# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
%YAML 1.2
---
$id: http://devicetree.org/schemas/bus/fsl,imx8qxp-pixel-link-msi-bus.yaml#
$schema: http://devicetree.org/meta-schemas/core.yaml#

title: Freescale i.MX8qxp Pixel Link Medium Speed Interconnect (MSI) Bus

maintainers:
  - Liu Ying <victor.liu@nxp.com>

description: |
  i.MX8qxp pixel link MSI bus is used to control settings of PHYs, I/Os
  sitting together with the PHYs.  It is not the same as the MSI bus coming
  from i.MX8 System Controller Unit (SCU) which is used to control power,
  clock and reset through the i.MX8 Distributed Slave System Controller (DSC).

  i.MX8qxp pixel link MSI bus is a simple memory-mapped bus. Two input clocks,
  that is, MSI clock and AHB clock, need to be enabled so that peripherals
  connected to the bus can be accessed. Also, the bus is part of a power
  domain. The power domain needs to be enabled before the peripherals can
  be accessed.

  Peripherals in i.MX8qm/qxp imaging, LVDS, MIPI DSI and HDMI TX subsystems,
  like I2C controller, PWM controller, MIPI DSI controller and Control and
  Status Registers (CSR) module, are accessed through the bus.

  The i.MX System Controller Firmware (SCFW) owns and uses the i.MX8qm/qxp
  pixel link MSI bus controller and does not allow SCFW user to control it.
  So, the controller's registers cannot be accessed by SCFW user. Hence,
  the interrupts generated by the controller don't make any sense from SCFW
  user's point of view.

allOf:
  - $ref: simple-pm-bus.yaml#

# We need a select here so we don't match all nodes with 'simple-pm-bus'.
select:
  properties:
    compatible:
      contains:
        enum:
          - fsl,imx8qxp-display-pixel-link-msi-bus
          - fsl,imx8qm-display-pixel-link-msi-bus
  required:
    - compatible

properties:
  compatible:
    items:
      - enum:
          - fsl,imx8qxp-display-pixel-link-msi-bus
          - fsl,imx8qm-display-pixel-link-msi-bus
      - const: simple-pm-bus

  reg:
    maxItems: 1

  interrupts:
    maxItems: 1

  clocks:
    items:
      - description: master gated clock from system
      - description: AHB clock

  clock-names:
    items:
      - const: msi
      - const: ahb

patternProperties:
  "^.*@[0-9a-f]+$":
    description: Devices attached to the bus
    type: object

    required:
      - reg

required:
  - compatible
  - reg
  - clocks
  - clock-names
  - power-domains

unevaluatedProperties: false

examples:
  - |
    #include <dt-bindings/clock/imx8-lpcg.h>
    #include <dt-bindings/firmware/imx/rsrc.h>
    bus@56200000 {
        compatible = "fsl,imx8qxp-display-pixel-link-msi-bus", "simple-pm-bus";
        reg = <0x56200000 0x20000>;
        #address-cells = <1>;
        #size-cells = <1>;
        interrupt-parent = <&dc0_irqsteer>;
        interrupts = <320>;
        ranges;
        clocks = <&dc0_disp_ctrl_link_mst0_lpcg IMX_LPCG_CLK_4>,
                 <&dc0_disp_ctrl_link_mst0_lpcg IMX_LPCG_CLK_4>;
        clock-names = "msi", "ahb";
        power-domains = <&pd IMX_SC_R_DC_0>;

        syscon@56221000 {
            compatible = "fsl,imx8qxp-mipi-lvds-csr", "syscon", "simple-mfd";
            reg = <0x56221000 0x1000>;
            clocks = <&mipi_lvds_0_di_mipi_lvds_regs_lpcg IMX_LPCG_CLK_4>;
            clock-names = "ipg";

            pxl2dpi {
                compatible = "fsl,imx8qxp-pxl2dpi";
                fsl,sc-resource = <IMX_SC_R_MIPI_0>;
                power-domains = <&pd IMX_SC_R_MIPI_0>;

                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;

                    port@0 {
                        #address-cells = <1>;
                        #size-cells = <0>;
                        reg = <0>;

                        mipi_lvds_0_pxl2dpi_dc0_pixel_link0: endpoint@0 {
                            reg = <0>;
                            remote-endpoint = <&dc0_pixel_link0_mipi_lvds_0_pxl2dpi>;
                        };

                        mipi_lvds_0_pxl2dpi_dc0_pixel_link1: endpoint@1 {
                            reg = <1>;
                            remote-endpoint = <&dc0_pixel_link1_mipi_lvds_0_pxl2dpi>;
                        };
                    };

                    port@1 {
                        #address-cells = <1>;
                        #size-cells = <0>;
                        reg = <1>;

                        mipi_lvds_0_pxl2dpi_mipi_lvds_0_ldb_ch0: endpoint@0 {
                            reg = <0>;
                            remote-endpoint = <&mipi_lvds_0_ldb_ch0_mipi_lvds_0_pxl2dpi>;
                        };

                        mipi_lvds_0_pxl2dpi_mipi_lvds_0_ldb_ch1: endpoint@1 {
                            reg = <1>;
                            remote-endpoint = <&mipi_lvds_0_ldb_ch1_mipi_lvds_0_pxl2dpi>;
                        };
                    };
                };
            };

            ldb {
                #address-cells = <1>;
                #size-cells = <0>;
                compatible = "fsl,imx8qxp-ldb";
                clocks = <&clk IMX_SC_R_LVDS_0 IMX_SC_PM_CLK_MISC2>,
                         <&clk IMX_SC_R_LVDS_0 IMX_SC_PM_CLK_BYPASS>;
                clock-names = "pixel", "bypass";
                power-domains = <&pd IMX_SC_R_LVDS_0>;

                channel@0 {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    reg = <0>;
                    phys = <&mipi_lvds_0_phy>;
                    phy-names = "lvds_phy";

                    port@0 {
                        reg = <0>;

                        mipi_lvds_0_ldb_ch0_mipi_lvds_0_pxl2dpi: endpoint {
                            remote-endpoint = <&mipi_lvds_0_pxl2dpi_mipi_lvds_0_ldb_ch0>;
                        };
                    };

                    port@1 {
                        reg = <1>;

                        /* ... */
                    };
                };

                channel@1 {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    reg = <1>;
                    phys = <&mipi_lvds_0_phy>;
                    phy-names = "lvds_phy";

                    port@0 {
                        reg = <0>;

                        mipi_lvds_0_ldb_ch1_mipi_lvds_0_pxl2dpi: endpoint {
                            remote-endpoint = <&mipi_lvds_0_pxl2dpi_mipi_lvds_0_ldb_ch1>;
                        };
                    };

                    port@1 {
                        reg = <1>;

                        /* ... */
                    };
                };
            };
        };

        clock-controller@56223004 {
            compatible = "fsl,imx8qxp-lpcg";
            reg = <0x56223004 0x4>;
            #clock-cells = <1>;
            clocks = <&mipi_lvds_0_ipg_clk>;
            clock-indices = <IMX_LPCG_CLK_4>;
            clock-output-names = "mipi_lvds_0_di_mipi_lvds_regs_lpcg_ipg_clk";
            power-domains = <&pd IMX_SC_R_MIPI_0>;
        };

        phy@56228300 {
            compatible = "fsl,imx8qxp-mipi-dphy";
            reg = <0x56228300 0x100>;
            clocks = <&clk IMX_SC_R_LVDS_0 IMX_SC_PM_CLK_PHY>;
            clock-names = "phy_ref";
            #phy-cells = <0>;
            fsl,syscon = <&mipi_lvds_0_csr>;
            power-domains = <&pd IMX_SC_R_MIPI_0>;
        };
    };
