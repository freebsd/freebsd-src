/*-
 *   BSD LICENSE
 *
 *   Copyright (c) 2025 Broadcom, All Rights Reserved.
 *   The term Broadcom refers to Broadcom Limited and/or its subsidiaries
 *
 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions
 *   are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>
__FBSDID("$FreeBSD$");

/*
 * Copyright(c) 2001-2025, Broadcom. All rights reserved. The
 * term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
 * Proprietary and Confidential Information.
 *
 * This source file is the property of Broadcom Corporation, and
 * may not be copied or distributed in any isomorphic form without
 * the prior written consent of Broadcom Corporation.
 *
 * DO NOT MODIFY!!! This file is automatically generated.
 */

#ifndef _HSI_STRUCT_DEF_H_
#define _HSI_STRUCT_DEF_H_

#if defined(HAVE_STDINT_H)
#include <stdint.h>
#endif

/* This is the HWRM command header. */
/* hwrm_cmd_hdr (size:128b/16B) */

typedef struct hwrm_cmd_hdr {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cmd_hdr_t, *phwrm_cmd_hdr_t;

/* This is the HWRM response header. */
/* hwrm_resp_hdr (size:64b/8B) */

typedef struct hwrm_resp_hdr {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
} hwrm_resp_hdr_t, *phwrm_resp_hdr_t;

/*
 * TLV encapsulated message. Use the TLV type field of the
 * TLV to determine the type of message encapsulated.
 */
#define CMD_DISCR_TLV_ENCAP UINT32_C(0x8000)
#define CMD_DISCR_LAST	CMD_DISCR_TLV_ENCAP


/* HWRM request message */
#define TLV_TYPE_HWRM_REQUEST			UINT32_C(0x1)
/* HWRM response message */
#define TLV_TYPE_HWRM_RESPONSE		UINT32_C(0x2)
/* RoCE slow path command */
#define TLV_TYPE_ROCE_SP_COMMAND		UINT32_C(0x3)
/* RoCE slow path command to query CC Gen1 support. */
#define TLV_TYPE_QUERY_ROCE_CC_GEN1		UINT32_C(0x4)
/* RoCE slow path command to modify CC Gen1 support. */
#define TLV_TYPE_MODIFY_ROCE_CC_GEN1		UINT32_C(0x5)
/* RoCE slow path command to query CC Gen2 support. */
#define TLV_TYPE_QUERY_ROCE_CC_GEN2		UINT32_C(0x6)
/* RoCE slow path command to modify CC Gen2 support. */
#define TLV_TYPE_MODIFY_ROCE_CC_GEN2		UINT32_C(0x7)
/* Engine CKV - The Alias key EC curve and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_ALIAS_ECC_PUBLIC_KEY UINT32_C(0x8001)
/* Engine CKV - Initialization vector. */
#define TLV_TYPE_ENGINE_CKV_IV		UINT32_C(0x8003)
/* Engine CKV - Authentication tag. */
#define TLV_TYPE_ENGINE_CKV_AUTH_TAG		UINT32_C(0x8004)
/* Engine CKV - The encrypted data. */
#define TLV_TYPE_ENGINE_CKV_CIPHERTEXT	UINT32_C(0x8005)
/* Engine CKV - Supported host_algorithms. */
#define TLV_TYPE_ENGINE_CKV_HOST_ALGORITHMS	UINT32_C(0x8006)
/* Engine CKV - The Host EC curve name and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_HOST_ECC_PUBLIC_KEY  UINT32_C(0x8007)
/* Engine CKV - The ECDSA signature. */
#define TLV_TYPE_ENGINE_CKV_ECDSA_SIGNATURE	UINT32_C(0x8008)
/* Engine CKV - The firmware EC curve name and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_FW_ECC_PUBLIC_KEY	UINT32_C(0x8009)
/* Engine CKV - Supported firmware algorithms. */
#define TLV_TYPE_ENGINE_CKV_FW_ALGORITHMS	UINT32_C(0x800a)
#define TLV_TYPE_LAST			TLV_TYPE_ENGINE_CKV_FW_ALGORITHMS


/* tlv (size:64b/8B) */

typedef struct tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define TLV_FLAGS_REQUIRED_LAST TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
} tlv_t, *ptlv_t;

/* Input */
/* input (size:128b/16B) */

typedef struct input {
	/*
	 * This value indicates what type of request this is. The format
	 * for the rest of the command is determined by this field.
	 */
	uint16_t	req_type;
	/*
	 * This value indicates the what completion ring the request will
	 * be optionally completed on. If the value is -1, then no
	 * CR completion will be generated. Any other value must be a
	 * valid CR ring_id value for this function.
	 */
	uint16_t	cmpl_ring;
	/* This value indicates the command sequence number. */
	uint16_t	seq_id;
	/*
	 * Target ID of this command.
	 *
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * This is the host address where the response will be written
	 * when the request is complete. This area must be 16B aligned
	 * and must be cleared to zero before the request is made.
	 */
	uint64_t	resp_addr;
} input_t, *pinput_t;

/* Output */
/* output (size:64b/8B) */

typedef struct output {
	/*
	 * Pass/Fail or error type
	 *
	 * Note: receiver to verify the in parameters, and fail the call
	 * with an error when appropriate
	 */
	uint16_t	error_code;
	/* This field returns the type of original request. */
	uint16_t	req_type;
	/* This field provides original sequence number of the command. */
	uint16_t	seq_id;
	/*
	 * This field is the length of the response in bytes. The
	 * last byte of the response is a valid flag that will read
	 * as '1' when the command has been completely written to
	 * memory.
	 */
	uint16_t	resp_len;
} output_t, *poutput_t;

/* Short Command Structure */
/* hwrm_short_input (size:128b/16B) */

typedef struct hwrm_short_input {
	/*
	 * This field indicates the type of request in the request buffer.
	 * The format for the rest of the command (request) is determined
	 * by this field.
	 */
	uint16_t	req_type;
	/*
	 * This field indicates a signature that is used to identify short
	 * form of the command listed here. This field shall be set to
	 * 17185 (0x4321).
	 */
	uint16_t	signature;
	/* Signature indicating this is a short form of HWRM command */
	#define HWRM_SHORT_INPUT_SIGNATURE_SHORT_CMD UINT32_C(0x4321)
	#define HWRM_SHORT_INPUT_SIGNATURE_LAST	HWRM_SHORT_INPUT_SIGNATURE_SHORT_CMD
	/* The target ID of the command */
	uint16_t	target_id;
	/* Default target_id (0x0) to maintain compatibility with old driver */
	#define HWRM_SHORT_INPUT_TARGET_ID_DEFAULT UINT32_C(0x0)
	/* Reserved for user-space HWRM interface */
	#define HWRM_SHORT_INPUT_TARGET_ID_TOOLS   UINT32_C(0xfffd)
	#define HWRM_SHORT_INPUT_TARGET_ID_LAST   HWRM_SHORT_INPUT_TARGET_ID_TOOLS
	/* This value indicates the length of the request. */
	uint16_t	size;
	/*
	 * This is the host address where the request was written.
	 * This area must be 16B aligned.
	 */
	uint64_t	req_addr;
} hwrm_short_input_t, *phwrm_short_input_t;

#define GET_HWRM_REQ_TYPE(x) \
	(((x) < 0x80) ? \
	((x) == 0x0 ? "HWRM_VER_GET": \
	((x) == 0xb ? "HWRM_FUNC_ECHO_RESPONSE": \
	((x) == 0xc ? "HWRM_ERROR_RECOVERY_QCFG": \
	((x) == 0xd ? "HWRM_FUNC_DRV_IF_CHANGE": \
	((x) == 0xe ? "HWRM_FUNC_BUF_UNRGTR": \
	((x) == 0xf ? "HWRM_FUNC_VF_CFG": \
	((x) == 0x10 ? "HWRM_RESERVED1": \
	((x) == 0x11 ? "HWRM_FUNC_RESET": \
	((x) == 0x12 ? "HWRM_FUNC_GETFID": \
	((x) == 0x13 ? "HWRM_FUNC_VF_ALLOC": \
	((x) == 0x14 ? "HWRM_FUNC_VF_FREE": \
	((x) == 0x15 ? "HWRM_FUNC_QCAPS": \
	((x) == 0x16 ? "HWRM_FUNC_QCFG": \
	((x) == 0x17 ? "HWRM_FUNC_CFG": \
	((x) == 0x18 ? "HWRM_FUNC_QSTATS": \
	((x) == 0x19 ? "HWRM_FUNC_CLR_STATS": \
	((x) == 0x1a ? "HWRM_FUNC_DRV_UNRGTR": \
	((x) == 0x1b ? "HWRM_FUNC_VF_RESC_FREE": \
	((x) == 0x1c ? "HWRM_FUNC_VF_VNIC_IDS_QUERY": \
	((x) == 0x1d ? "HWRM_FUNC_DRV_RGTR": \
	((x) == 0x1e ? "HWRM_FUNC_DRV_QVER": \
	((x) == 0x1f ? "HWRM_FUNC_BUF_RGTR": \
	((x) == 0x20 ? "HWRM_PORT_PHY_CFG": \
	((x) == 0x21 ? "HWRM_PORT_MAC_CFG": \
	((x) == 0x22 ? "HWRM_PORT_TS_QUERY": \
	((x) == 0x23 ? "HWRM_PORT_QSTATS": \
	((x) == 0x24 ? "HWRM_PORT_LPBK_QSTATS": \
	((x) == 0x25 ? "HWRM_PORT_CLR_STATS": \
	((x) == 0x26 ? "HWRM_PORT_LPBK_CLR_STATS": \
	((x) == 0x27 ? "HWRM_PORT_PHY_QCFG": \
	((x) == 0x28 ? "HWRM_PORT_MAC_QCFG": \
	((x) == 0x29 ? "HWRM_PORT_MAC_PTP_QCFG": \
	((x) == 0x2a ? "HWRM_PORT_PHY_QCAPS": \
	((x) == 0x2b ? "HWRM_PORT_PHY_I2C_WRITE": \
	((x) == 0x2c ? "HWRM_PORT_PHY_I2C_READ": \
	((x) == 0x2d ? "HWRM_PORT_LED_CFG": \
	((x) == 0x2e ? "HWRM_PORT_LED_QCFG": \
	((x) == 0x2f ? "HWRM_PORT_LED_QCAPS": \
	((x) == 0x30 ? "HWRM_QUEUE_QPORTCFG": \
	((x) == 0x31 ? "HWRM_QUEUE_QCFG": \
	((x) == 0x32 ? "HWRM_QUEUE_CFG": \
	((x) == 0x33 ? "HWRM_FUNC_VLAN_CFG": \
	((x) == 0x34 ? "HWRM_FUNC_VLAN_QCFG": \
	((x) == 0x35 ? "HWRM_QUEUE_PFCENABLE_QCFG": \
	((x) == 0x36 ? "HWRM_QUEUE_PFCENABLE_CFG": \
	((x) == 0x37 ? "HWRM_QUEUE_PRI2COS_QCFG": \
	((x) == 0x38 ? "HWRM_QUEUE_PRI2COS_CFG": \
	((x) == 0x39 ? "HWRM_QUEUE_COS2BW_QCFG": \
	((x) == 0x3a ? "HWRM_QUEUE_COS2BW_CFG": \
	((x) == 0x3b ? "HWRM_QUEUE_DSCP_QCAPS": \
	((x) == 0x3c ? "HWRM_QUEUE_DSCP2PRI_QCFG": \
	((x) == 0x3d ? "HWRM_QUEUE_DSCP2PRI_CFG": \
	((x) == 0x40 ? "HWRM_VNIC_ALLOC": \
	((x) == 0x41 ? "HWRM_VNIC_FREE": \
	((x) == 0x42 ? "HWRM_VNIC_CFG": \
	((x) == 0x43 ? "HWRM_VNIC_QCFG": \
	((x) == 0x44 ? "HWRM_VNIC_TPA_CFG": \
	((x) == 0x45 ? "HWRM_VNIC_TPA_QCFG": \
	((x) == 0x46 ? "HWRM_VNIC_RSS_CFG": \
	((x) == 0x47 ? "HWRM_VNIC_RSS_QCFG": \
	((x) == 0x48 ? "HWRM_VNIC_PLCMODES_CFG": \
	((x) == 0x49 ? "HWRM_VNIC_PLCMODES_QCFG": \
	((x) == 0x4a ? "HWRM_VNIC_QCAPS": \
	((x) == 0x4b ? "HWRM_VNIC_UPDATE": \
	((x) == 0x50 ? "HWRM_RING_ALLOC": \
	((x) == 0x51 ? "HWRM_RING_FREE": \
	((x) == 0x52 ? "HWRM_RING_CMPL_RING_QAGGINT_PARAMS": \
	((x) == 0x53 ? "HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS": \
	((x) == 0x54 ? "HWRM_RING_AGGINT_QCAPS": \
	((x) == 0x55 ? "HWRM_RING_SCHQ_ALLOC": \
	((x) == 0x56 ? "HWRM_RING_SCHQ_CFG": \
	((x) == 0x57 ? "HWRM_RING_SCHQ_FREE": \
	((x) == 0x5e ? "HWRM_RING_RESET": \
	((x) == 0x60 ? "HWRM_RING_GRP_ALLOC": \
	((x) == 0x61 ? "HWRM_RING_GRP_FREE": \
	((x) == 0x62 ? "HWRM_RING_CFG": \
	((x) == 0x63 ? "HWRM_RING_QCFG": \
	((x) == 0x64 ? "HWRM_RESERVED5": \
	((x) == 0x65 ? "HWRM_RESERVED6": \
	((x) == 0x70 ? "HWRM_VNIC_RSS_COS_LB_CTX_ALLOC": \
	((x) == 0x71 ? "HWRM_VNIC_RSS_COS_LB_CTX_FREE": \
	"Unknown decode" ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x100) ? \
	((x) == 0x80 ? "HWRM_QUEUE_MPLS_QCAPS": \
	((x) == 0x81 ? "HWRM_QUEUE_MPLSTC2PRI_QCFG": \
	((x) == 0x82 ? "HWRM_QUEUE_MPLSTC2PRI_CFG": \
	((x) == 0x83 ? "HWRM_QUEUE_VLANPRI_QCAPS": \
	((x) == 0x84 ? "HWRM_QUEUE_VLANPRI2PRI_QCFG": \
	((x) == 0x85 ? "HWRM_QUEUE_VLANPRI2PRI_CFG": \
	((x) == 0x86 ? "HWRM_QUEUE_GLOBAL_CFG": \
	((x) == 0x87 ? "HWRM_QUEUE_GLOBAL_QCFG": \
	((x) == 0x88 ? "HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG": \
	((x) == 0x89 ? "HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG": \
	((x) == 0x8a ? "HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG": \
	((x) == 0x8b ? "HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG": \
	((x) == 0x8c ? "HWRM_QUEUE_QCAPS": \
	((x) == 0x8d ? "HWRM_QUEUE_ADPTV_QOS_RX_TUNING_QCFG": \
	((x) == 0x8e ? "HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG": \
	((x) == 0x8f ? "HWRM_QUEUE_ADPTV_QOS_TX_TUNING_QCFG": \
	((x) == 0x90 ? "HWRM_CFA_L2_FILTER_ALLOC": \
	((x) == 0x91 ? "HWRM_CFA_L2_FILTER_FREE": \
	((x) == 0x92 ? "HWRM_CFA_L2_FILTER_CFG": \
	((x) == 0x93 ? "HWRM_CFA_L2_SET_RX_MASK": \
	((x) == 0x94 ? "HWRM_CFA_VLAN_ANTISPOOF_CFG": \
	((x) == 0x95 ? "HWRM_CFA_TUNNEL_FILTER_ALLOC": \
	((x) == 0x96 ? "HWRM_CFA_TUNNEL_FILTER_FREE": \
	((x) == 0x97 ? "HWRM_CFA_ENCAP_RECORD_ALLOC": \
	((x) == 0x98 ? "HWRM_CFA_ENCAP_RECORD_FREE": \
	((x) == 0x99 ? "HWRM_CFA_NTUPLE_FILTER_ALLOC": \
	((x) == 0x9a ? "HWRM_CFA_NTUPLE_FILTER_FREE": \
	((x) == 0x9b ? "HWRM_CFA_NTUPLE_FILTER_CFG": \
	((x) == 0x9c ? "HWRM_CFA_EM_FLOW_ALLOC": \
	((x) == 0x9d ? "HWRM_CFA_EM_FLOW_FREE": \
	((x) == 0x9e ? "HWRM_CFA_EM_FLOW_CFG": \
	((x) == 0xa0 ? "HWRM_TUNNEL_DST_PORT_QUERY": \
	((x) == 0xa1 ? "HWRM_TUNNEL_DST_PORT_ALLOC": \
	((x) == 0xa2 ? "HWRM_TUNNEL_DST_PORT_FREE": \
	((x) == 0xa3 ? "HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG": \
	((x) == 0xaf ? "HWRM_STAT_CTX_ENG_QUERY": \
	((x) == 0xb0 ? "HWRM_STAT_CTX_ALLOC": \
	((x) == 0xb1 ? "HWRM_STAT_CTX_FREE": \
	((x) == 0xb2 ? "HWRM_STAT_CTX_QUERY": \
	((x) == 0xb3 ? "HWRM_STAT_CTX_CLR_STATS": \
	((x) == 0xb4 ? "HWRM_PORT_QSTATS_EXT": \
	((x) == 0xb5 ? "HWRM_PORT_PHY_MDIO_WRITE": \
	((x) == 0xb6 ? "HWRM_PORT_PHY_MDIO_READ": \
	((x) == 0xb7 ? "HWRM_PORT_PHY_MDIO_BUS_ACQUIRE": \
	((x) == 0xb8 ? "HWRM_PORT_PHY_MDIO_BUS_RELEASE": \
	((x) == 0xb9 ? "HWRM_PORT_QSTATS_EXT_PFC_WD": \
	((x) == 0xba ? "HWRM_RESERVED7": \
	((x) == 0xbb ? "HWRM_PORT_TX_FIR_CFG": \
	((x) == 0xbc ? "HWRM_PORT_TX_FIR_QCFG": \
	((x) == 0xbd ? "HWRM_PORT_ECN_QSTATS": \
	((x) == 0xbe ? "HWRM_FW_LIVEPATCH_QUERY": \
	((x) == 0xbf ? "HWRM_FW_LIVEPATCH": \
	((x) == 0xc0 ? "HWRM_FW_RESET": \
	((x) == 0xc1 ? "HWRM_FW_QSTATUS": \
	((x) == 0xc2 ? "HWRM_FW_HEALTH_CHECK": \
	((x) == 0xc3 ? "HWRM_FW_SYNC": \
	((x) == 0xc4 ? "HWRM_FW_STATE_QCAPS": \
	((x) == 0xc5 ? "HWRM_FW_STATE_QUIESCE": \
	((x) == 0xc6 ? "HWRM_FW_STATE_BACKUP": \
	((x) == 0xc7 ? "HWRM_FW_STATE_RESTORE": \
	((x) == 0xc8 ? "HWRM_FW_SET_TIME": \
	((x) == 0xc9 ? "HWRM_FW_GET_TIME": \
	((x) == 0xca ? "HWRM_FW_SET_STRUCTURED_DATA": \
	((x) == 0xcb ? "HWRM_FW_GET_STRUCTURED_DATA": \
	((x) == 0xcc ? "HWRM_FW_IPC_MAILBOX": \
	((x) == 0xcd ? "HWRM_FW_ECN_CFG": \
	((x) == 0xce ? "HWRM_FW_ECN_QCFG": \
	((x) == 0xcf ? "HWRM_FW_SECURE_CFG": \
	((x) == 0xd0 ? "HWRM_EXEC_FWD_RESP": \
	((x) == 0xd1 ? "HWRM_REJECT_FWD_RESP": \
	((x) == 0xd2 ? "HWRM_FWD_RESP": \
	((x) == 0xd3 ? "HWRM_FWD_ASYNC_EVENT_CMPL": \
	((x) == 0xd4 ? "HWRM_OEM_CMD": \
	((x) == 0xd5 ? "HWRM_PORT_PRBS_TEST": \
	((x) == 0xd6 ? "HWRM_PORT_SFP_SIDEBAND_CFG": \
	((x) == 0xd7 ? "HWRM_PORT_SFP_SIDEBAND_QCFG": \
	((x) == 0xd8 ? "HWRM_FW_STATE_UNQUIESCE": \
	((x) == 0xd9 ? "HWRM_PORT_DSC_DUMP": \
	((x) == 0xda ? "HWRM_PORT_EP_TX_QCFG": \
	((x) == 0xdb ? "HWRM_PORT_EP_TX_CFG": \
	((x) == 0xdc ? "HWRM_PORT_CFG": \
	((x) == 0xdd ? "HWRM_PORT_QCFG": \
	((x) == 0xdf ? "HWRM_PORT_MAC_QCAPS": \
	((x) == 0xe0 ? "HWRM_TEMP_MONITOR_QUERY": \
	((x) == 0xe1 ? "HWRM_REG_POWER_QUERY": \
	((x) == 0xe2 ? "HWRM_CORE_FREQUENCY_QUERY": \
	((x) == 0xe3 ? "HWRM_REG_POWER_HISTOGRAM": \
	((x) == 0xf0 ? "HWRM_WOL_FILTER_ALLOC": \
	((x) == 0xf1 ? "HWRM_WOL_FILTER_FREE": \
	((x) == 0xf2 ? "HWRM_WOL_FILTER_QCFG": \
	((x) == 0xf3 ? "HWRM_WOL_REASON_QCFG": \
	((x) == 0xf4 ? "HWRM_CFA_METER_QCAPS": \
	((x) == 0xf5 ? "HWRM_CFA_METER_PROFILE_ALLOC": \
	((x) == 0xf6 ? "HWRM_CFA_METER_PROFILE_FREE": \
	((x) == 0xf7 ? "HWRM_CFA_METER_PROFILE_CFG": \
	((x) == 0xf8 ? "HWRM_CFA_METER_INSTANCE_ALLOC": \
	((x) == 0xf9 ? "HWRM_CFA_METER_INSTANCE_FREE": \
	((x) == 0xfa ? "HWRM_CFA_METER_INSTANCE_CFG": \
	((x) == 0xfd ? "HWRM_CFA_VFR_ALLOC": \
	((x) == 0xfe ? "HWRM_CFA_VFR_FREE": \
	"Unknown decode" )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x180) ? \
	((x) == 0x100 ? "HWRM_CFA_VF_PAIR_ALLOC": \
	((x) == 0x101 ? "HWRM_CFA_VF_PAIR_FREE": \
	((x) == 0x102 ? "HWRM_CFA_VF_PAIR_INFO": \
	((x) == 0x103 ? "HWRM_CFA_FLOW_ALLOC": \
	((x) == 0x104 ? "HWRM_CFA_FLOW_FREE": \
	((x) == 0x105 ? "HWRM_CFA_FLOW_FLUSH": \
	((x) == 0x106 ? "HWRM_CFA_FLOW_STATS": \
	((x) == 0x107 ? "HWRM_CFA_FLOW_INFO": \
	((x) == 0x108 ? "HWRM_CFA_DECAP_FILTER_ALLOC": \
	((x) == 0x109 ? "HWRM_CFA_DECAP_FILTER_FREE": \
	((x) == 0x10a ? "HWRM_CFA_VLAN_ANTISPOOF_QCFG": \
	((x) == 0x10b ? "HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC": \
	((x) == 0x10c ? "HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE": \
	((x) == 0x10d ? "HWRM_CFA_PAIR_ALLOC": \
	((x) == 0x10e ? "HWRM_CFA_PAIR_FREE": \
	((x) == 0x10f ? "HWRM_CFA_PAIR_INFO": \
	((x) == 0x110 ? "HWRM_FW_IPC_MSG": \
	((x) == 0x111 ? "HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO": \
	((x) == 0x112 ? "HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE": \
	((x) == 0x113 ? "HWRM_CFA_FLOW_AGING_TIMER_RESET": \
	((x) == 0x114 ? "HWRM_CFA_FLOW_AGING_CFG": \
	((x) == 0x115 ? "HWRM_CFA_FLOW_AGING_QCFG": \
	((x) == 0x116 ? "HWRM_CFA_FLOW_AGING_QCAPS": \
	((x) == 0x117 ? "HWRM_CFA_CTX_MEM_RGTR": \
	((x) == 0x118 ? "HWRM_CFA_CTX_MEM_UNRGTR": \
	((x) == 0x119 ? "HWRM_CFA_CTX_MEM_QCTX": \
	((x) == 0x11a ? "HWRM_CFA_CTX_MEM_QCAPS": \
	((x) == 0x11b ? "HWRM_CFA_COUNTER_QCAPS": \
	((x) == 0x11c ? "HWRM_CFA_COUNTER_CFG": \
	((x) == 0x11d ? "HWRM_CFA_COUNTER_QCFG": \
	((x) == 0x11e ? "HWRM_CFA_COUNTER_QSTATS": \
	((x) == 0x11f ? "HWRM_CFA_TCP_FLAG_PROCESS_QCFG": \
	((x) == 0x120 ? "HWRM_CFA_EEM_QCAPS": \
	((x) == 0x121 ? "HWRM_CFA_EEM_CFG": \
	((x) == 0x122 ? "HWRM_CFA_EEM_QCFG": \
	((x) == 0x123 ? "HWRM_CFA_EEM_OP": \
	((x) == 0x124 ? "HWRM_CFA_ADV_FLOW_MGNT_QCAPS": \
	((x) == 0x125 ? "HWRM_CFA_TFLIB": \
	((x) == 0x126 ? "HWRM_CFA_LAG_GROUP_MEMBER_RGTR": \
	((x) == 0x127 ? "HWRM_CFA_LAG_GROUP_MEMBER_UNRGTR": \
	((x) == 0x128 ? "HWRM_CFA_TLS_FILTER_ALLOC": \
	((x) == 0x129 ? "HWRM_CFA_TLS_FILTER_FREE": \
	((x) == 0x12a ? "HWRM_CFA_RELEASE_AFM_FUNC": \
	((x) == 0x12e ? "HWRM_ENGINE_CKV_STATUS": \
	((x) == 0x12f ? "HWRM_ENGINE_CKV_CKEK_ADD": \
	((x) == 0x130 ? "HWRM_ENGINE_CKV_CKEK_DELETE": \
	((x) == 0x131 ? "HWRM_ENGINE_CKV_KEY_ADD": \
	((x) == 0x132 ? "HWRM_ENGINE_CKV_KEY_DELETE": \
	((x) == 0x133 ? "HWRM_ENGINE_CKV_FLUSH": \
	((x) == 0x134 ? "HWRM_ENGINE_CKV_RNG_GET": \
	((x) == 0x135 ? "HWRM_ENGINE_CKV_KEY_GEN": \
	((x) == 0x136 ? "HWRM_ENGINE_CKV_KEY_LABEL_CFG": \
	((x) == 0x137 ? "HWRM_ENGINE_CKV_KEY_LABEL_QCFG": \
	((x) == 0x13c ? "HWRM_ENGINE_QG_CONFIG_QUERY": \
	((x) == 0x13d ? "HWRM_ENGINE_QG_QUERY": \
	((x) == 0x13e ? "HWRM_ENGINE_QG_METER_PROFILE_CONFIG_QUERY": \
	((x) == 0x13f ? "HWRM_ENGINE_QG_METER_PROFILE_QUERY": \
	((x) == 0x140 ? "HWRM_ENGINE_QG_METER_PROFILE_ALLOC": \
	((x) == 0x141 ? "HWRM_ENGINE_QG_METER_PROFILE_FREE": \
	((x) == 0x142 ? "HWRM_ENGINE_QG_METER_QUERY": \
	((x) == 0x143 ? "HWRM_ENGINE_QG_METER_BIND": \
	((x) == 0x144 ? "HWRM_ENGINE_QG_METER_UNBIND": \
	((x) == 0x145 ? "HWRM_ENGINE_QG_FUNC_BIND": \
	((x) == 0x146 ? "HWRM_ENGINE_SG_CONFIG_QUERY": \
	((x) == 0x147 ? "HWRM_ENGINE_SG_QUERY": \
	((x) == 0x148 ? "HWRM_ENGINE_SG_METER_QUERY": \
	((x) == 0x149 ? "HWRM_ENGINE_SG_METER_CONFIG": \
	((x) == 0x14a ? "HWRM_ENGINE_SG_QG_BIND": \
	((x) == 0x14b ? "HWRM_ENGINE_QG_SG_UNBIND": \
	((x) == 0x154 ? "HWRM_ENGINE_CONFIG_QUERY": \
	((x) == 0x155 ? "HWRM_ENGINE_STATS_CONFIG": \
	((x) == 0x156 ? "HWRM_ENGINE_STATS_CLEAR": \
	((x) == 0x157 ? "HWRM_ENGINE_STATS_QUERY": \
	((x) == 0x158 ? "HWRM_ENGINE_STATS_QUERY_CONTINUOUS_ERROR": \
	((x) == 0x15e ? "HWRM_ENGINE_RQ_ALLOC": \
	((x) == 0x15f ? "HWRM_ENGINE_RQ_FREE": \
	((x) == 0x160 ? "HWRM_ENGINE_CQ_ALLOC": \
	((x) == 0x161 ? "HWRM_ENGINE_CQ_FREE": \
	((x) == 0x162 ? "HWRM_ENGINE_NQ_ALLOC": \
	((x) == 0x163 ? "HWRM_ENGINE_NQ_FREE": \
	((x) == 0x164 ? "HWRM_ENGINE_ON_DIE_RQE_CREDITS": \
	((x) == 0x165 ? "HWRM_ENGINE_FUNC_QCFG": \
	"Unknown decode" )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x200) ? \
	((x) == 0x190 ? "HWRM_FUNC_RESOURCE_QCAPS": \
	((x) == 0x191 ? "HWRM_FUNC_VF_RESOURCE_CFG": \
	((x) == 0x192 ? "HWRM_FUNC_BACKING_STORE_QCAPS": \
	((x) == 0x193 ? "HWRM_FUNC_BACKING_STORE_CFG": \
	((x) == 0x194 ? "HWRM_FUNC_BACKING_STORE_QCFG": \
	((x) == 0x195 ? "HWRM_FUNC_VF_BW_CFG": \
	((x) == 0x196 ? "HWRM_FUNC_VF_BW_QCFG": \
	((x) == 0x197 ? "HWRM_FUNC_HOST_PF_IDS_QUERY": \
	((x) == 0x198 ? "HWRM_FUNC_QSTATS_EXT": \
	((x) == 0x199 ? "HWRM_STAT_EXT_CTX_QUERY": \
	((x) == 0x19a ? "HWRM_FUNC_SPD_CFG": \
	((x) == 0x19b ? "HWRM_FUNC_SPD_QCFG": \
	((x) == 0x19c ? "HWRM_FUNC_PTP_PIN_QCFG": \
	((x) == 0x19d ? "HWRM_FUNC_PTP_PIN_CFG": \
	((x) == 0x19e ? "HWRM_FUNC_PTP_CFG": \
	((x) == 0x19f ? "HWRM_FUNC_PTP_TS_QUERY": \
	((x) == 0x1a0 ? "HWRM_FUNC_PTP_EXT_CFG": \
	((x) == 0x1a1 ? "HWRM_FUNC_PTP_EXT_QCFG": \
	((x) == 0x1a2 ? "HWRM_FUNC_KEY_CTX_ALLOC": \
	((x) == 0x1a3 ? "HWRM_FUNC_BACKING_STORE_CFG_V2": \
	((x) == 0x1a4 ? "HWRM_FUNC_BACKING_STORE_QCFG_V2": \
	((x) == 0x1a5 ? "HWRM_FUNC_DBR_PACING_CFG": \
	((x) == 0x1a6 ? "HWRM_FUNC_DBR_PACING_QCFG": \
	((x) == 0x1a7 ? "HWRM_FUNC_DBR_PACING_BROADCAST_EVENT": \
	((x) == 0x1a8 ? "HWRM_FUNC_BACKING_STORE_QCAPS_V2": \
	((x) == 0x1a9 ? "HWRM_FUNC_DBR_PACING_NQLIST_QUERY": \
	((x) == 0x1aa ? "HWRM_FUNC_DBR_RECOVERY_COMPLETED": \
	((x) == 0x1ab ? "HWRM_FUNC_SYNCE_CFG": \
	((x) == 0x1ac ? "HWRM_FUNC_SYNCE_QCFG": \
	((x) == 0x1ad ? "HWRM_FUNC_KEY_CTX_FREE": \
	((x) == 0x1ae ? "HWRM_FUNC_LAG_MODE_CFG": \
	((x) == 0x1af ? "HWRM_FUNC_LAG_MODE_QCFG": \
	((x) == 0x1b0 ? "HWRM_FUNC_LAG_CREATE": \
	((x) == 0x1b1 ? "HWRM_FUNC_LAG_UPDATE": \
	((x) == 0x1b2 ? "HWRM_FUNC_LAG_FREE": \
	((x) == 0x1b3 ? "HWRM_FUNC_LAG_QCFG": \
	((x) == 0x1c2 ? "HWRM_FUNC_TIMEDTX_PACING_RATE_ADD": \
	((x) == 0x1c3 ? "HWRM_FUNC_TIMEDTX_PACING_RATE_DELETE": \
	((x) == 0x1c4 ? "HWRM_FUNC_TIMEDTX_PACING_RATE_QUERY": \
	"Unknown decode" ))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x280) ? \
	((x) == 0x200 ? "HWRM_SELFTEST_QLIST": \
	((x) == 0x201 ? "HWRM_SELFTEST_EXEC": \
	((x) == 0x202 ? "HWRM_SELFTEST_IRQ": \
	((x) == 0x203 ? "HWRM_SELFTEST_RETRIEVE_SERDES_DATA": \
	((x) == 0x204 ? "HWRM_PCIE_QSTATS": \
	((x) == 0x205 ? "HWRM_MFG_FRU_WRITE_CONTROL": \
	((x) == 0x206 ? "HWRM_MFG_TIMERS_QUERY": \
	((x) == 0x207 ? "HWRM_MFG_OTP_CFG": \
	((x) == 0x208 ? "HWRM_MFG_OTP_QCFG": \
	((x) == 0x209 ? "HWRM_MFG_HDMA_TEST": \
	((x) == 0x20a ? "HWRM_MFG_FRU_EEPROM_WRITE": \
	((x) == 0x20b ? "HWRM_MFG_FRU_EEPROM_READ": \
	((x) == 0x20c ? "HWRM_MFG_SOC_IMAGE": \
	((x) == 0x20d ? "HWRM_MFG_SOC_QSTATUS": \
	((x) == 0x20e ? "HWRM_MFG_PARAM_CRITICAL_DATA_FINALIZE": \
	((x) == 0x20f ? "HWRM_MFG_PARAM_CRITICAL_DATA_READ": \
	((x) == 0x210 ? "HWRM_MFG_PARAM_CRITICAL_DATA_HEALTH": \
	((x) == 0x211 ? "HWRM_MFG_PRVSN_EXPORT_CSR": \
	((x) == 0x212 ? "HWRM_MFG_PRVSN_IMPORT_CERT": \
	((x) == 0x213 ? "HWRM_MFG_PRVSN_GET_STATE": \
	((x) == 0x214 ? "HWRM_MFG_GET_NVM_MEASUREMENT": \
	((x) == 0x215 ? "HWRM_MFG_PSOC_QSTATUS": \
	((x) == 0x216 ? "HWRM_MFG_SELFTEST_QLIST": \
	((x) == 0x217 ? "HWRM_MFG_SELFTEST_EXEC": \
	((x) == 0x218 ? "HWRM_STAT_GENERIC_QSTATS": \
	((x) == 0x219 ? "HWRM_MFG_PRVSN_EXPORT_CERT": \
	((x) == 0x21a ? "HWRM_STAT_DB_ERROR_QSTATS": \
	((x) == 0x230 ? "HWRM_PORT_POE_CFG": \
	((x) == 0x231 ? "HWRM_PORT_POE_QCFG": \
	((x) == 0x258 ? "HWRM_UDCC_QCAPS": \
	((x) == 0x259 ? "HWRM_UDCC_CFG": \
	((x) == 0x25a ? "HWRM_UDCC_QCFG": \
	((x) == 0x25b ? "HWRM_UDCC_SESSION_CFG": \
	((x) == 0x25c ? "HWRM_UDCC_SESSION_QCFG": \
	((x) == 0x25d ? "HWRM_UDCC_SESSION_QUERY": \
	((x) == 0x25e ? "HWRM_UDCC_COMP_CFG": \
	((x) == 0x25f ? "HWRM_UDCC_COMP_QCFG": \
	((x) == 0x260 ? "HWRM_UDCC_COMP_QUERY": \
	((x) == 0x261 ? "HWRM_QUEUE_PFCWD_TIMEOUT_QCAPS": \
	((x) == 0x262 ? "HWRM_QUEUE_PFCWD_TIMEOUT_CFG": \
	((x) == 0x263 ? "HWRM_QUEUE_PFCWD_TIMEOUT_QCFG": \
	"Unknown decode" ))))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x300) ? \
	((x) == 0x2bc ? "HWRM_TF": \
	((x) == 0x2bd ? "HWRM_TF_VERSION_GET": \
	((x) == 0x2c6 ? "HWRM_TF_SESSION_OPEN": \
	((x) == 0x2c8 ? "HWRM_TF_SESSION_REGISTER": \
	((x) == 0x2c9 ? "HWRM_TF_SESSION_UNREGISTER": \
	((x) == 0x2ca ? "HWRM_TF_SESSION_CLOSE": \
	((x) == 0x2cb ? "HWRM_TF_SESSION_QCFG": \
	((x) == 0x2cc ? "HWRM_TF_SESSION_RESC_QCAPS": \
	((x) == 0x2cd ? "HWRM_TF_SESSION_RESC_ALLOC": \
	((x) == 0x2ce ? "HWRM_TF_SESSION_RESC_FREE": \
	((x) == 0x2cf ? "HWRM_TF_SESSION_RESC_FLUSH": \
	((x) == 0x2d0 ? "HWRM_TF_SESSION_RESC_INFO": \
	((x) == 0x2d1 ? "HWRM_TF_SESSION_HOTUP_STATE_SET": \
	((x) == 0x2d2 ? "HWRM_TF_SESSION_HOTUP_STATE_GET": \
	((x) == 0x2da ? "HWRM_TF_TBL_TYPE_GET": \
	((x) == 0x2db ? "HWRM_TF_TBL_TYPE_SET": \
	((x) == 0x2dc ? "HWRM_TF_TBL_TYPE_BULK_GET": \
	((x) == 0x2ea ? "HWRM_TF_EM_INSERT": \
	((x) == 0x2eb ? "HWRM_TF_EM_DELETE": \
	((x) == 0x2ec ? "HWRM_TF_EM_HASH_INSERT": \
	((x) == 0x2ed ? "HWRM_TF_EM_MOVE": \
	((x) == 0x2f8 ? "HWRM_TF_TCAM_SET": \
	((x) == 0x2f9 ? "HWRM_TF_TCAM_GET": \
	((x) == 0x2fa ? "HWRM_TF_TCAM_MOVE": \
	((x) == 0x2fb ? "HWRM_TF_TCAM_FREE": \
	((x) == 0x2fc ? "HWRM_TF_GLOBAL_CFG_SET": \
	((x) == 0x2fd ? "HWRM_TF_GLOBAL_CFG_GET": \
	((x) == 0x2fe ? "HWRM_TF_IF_TBL_SET": \
	((x) == 0x2ff ? "HWRM_TF_IF_TBL_GET": \
	"Unknown decode" ))))))))))))))))))))))))))))) : \
	(((x) < 0x380) ? \
	((x) == 0x300 ? "HWRM_TF_RESC_USAGE_SET": \
	((x) == 0x301 ? "HWRM_TF_RESC_USAGE_QUERY": \
	((x) == 0x302 ? "HWRM_TF_TBL_TYPE_ALLOC": \
	((x) == 0x303 ? "HWRM_TF_TBL_TYPE_FREE": \
	"Unknown decode" )))) : \
	(((x) < 0x400) ? \
	((x) == 0x380 ? "HWRM_TFC_TBL_SCOPE_QCAPS": \
	((x) == 0x381 ? "HWRM_TFC_TBL_SCOPE_ID_ALLOC": \
	((x) == 0x382 ? "HWRM_TFC_TBL_SCOPE_CONFIG": \
	((x) == 0x383 ? "HWRM_TFC_TBL_SCOPE_DECONFIG": \
	((x) == 0x384 ? "HWRM_TFC_TBL_SCOPE_FID_ADD": \
	((x) == 0x385 ? "HWRM_TFC_TBL_SCOPE_FID_REM": \
	((x) == 0x386 ? "HWRM_TFC_TBL_SCOPE_POOL_ALLOC": \
	((x) == 0x387 ? "HWRM_TFC_TBL_SCOPE_POOL_FREE": \
	((x) == 0x388 ? "HWRM_TFC_SESSION_ID_ALLOC": \
	((x) == 0x389 ? "HWRM_TFC_SESSION_FID_ADD": \
	((x) == 0x38a ? "HWRM_TFC_SESSION_FID_REM": \
	((x) == 0x38b ? "HWRM_TFC_IDENT_ALLOC": \
	((x) == 0x38c ? "HWRM_TFC_IDENT_FREE": \
	((x) == 0x38d ? "HWRM_TFC_IDX_TBL_ALLOC": \
	((x) == 0x38e ? "HWRM_TFC_IDX_TBL_ALLOC_SET": \
	((x) == 0x38f ? "HWRM_TFC_IDX_TBL_SET": \
	((x) == 0x390 ? "HWRM_TFC_IDX_TBL_GET": \
	((x) == 0x391 ? "HWRM_TFC_IDX_TBL_FREE": \
	((x) == 0x392 ? "HWRM_TFC_GLOBAL_ID_ALLOC": \
	((x) == 0x393 ? "HWRM_TFC_TCAM_SET": \
	((x) == 0x394 ? "HWRM_TFC_TCAM_GET": \
	((x) == 0x395 ? "HWRM_TFC_TCAM_ALLOC": \
	((x) == 0x396 ? "HWRM_TFC_TCAM_ALLOC_SET": \
	((x) == 0x397 ? "HWRM_TFC_TCAM_FREE": \
	((x) == 0x398 ? "HWRM_TFC_IF_TBL_SET": \
	((x) == 0x399 ? "HWRM_TFC_IF_TBL_GET": \
	((x) == 0x39a ? "HWRM_TFC_TBL_SCOPE_CONFIG_GET": \
	((x) == 0x39b ? "HWRM_TFC_RESC_USAGE_QUERY": \
	"Unknown decode" )))))))))))))))))))))))))))) : \
	(((x) < 0x480) ? \
	((x) == 0x400 ? "HWRM_SV": \
	"Unknown decode" ) : \
	(((x) < 0xff80) ? \
	((x) == 0xff0e ? "HWRM_DBG_SERDES_TEST": \
	((x) == 0xff0f ? "HWRM_DBG_LOG_BUFFER_FLUSH": \
	((x) == 0xff10 ? "HWRM_DBG_READ_DIRECT": \
	((x) == 0xff11 ? "HWRM_DBG_READ_INDIRECT": \
	((x) == 0xff12 ? "HWRM_DBG_WRITE_DIRECT": \
	((x) == 0xff13 ? "HWRM_DBG_WRITE_INDIRECT": \
	((x) == 0xff14 ? "HWRM_DBG_DUMP": \
	((x) == 0xff15 ? "HWRM_DBG_ERASE_NVM": \
	((x) == 0xff16 ? "HWRM_DBG_CFG": \
	((x) == 0xff17 ? "HWRM_DBG_COREDUMP_LIST": \
	((x) == 0xff18 ? "HWRM_DBG_COREDUMP_INITIATE": \
	((x) == 0xff19 ? "HWRM_DBG_COREDUMP_RETRIEVE": \
	((x) == 0xff1a ? "HWRM_DBG_FW_CLI": \
	((x) == 0xff1b ? "HWRM_DBG_I2C_CMD": \
	((x) == 0xff1c ? "HWRM_DBG_RING_INFO_GET": \
	((x) == 0xff1d ? "HWRM_DBG_CRASHDUMP_HEADER": \
	((x) == 0xff1e ? "HWRM_DBG_CRASHDUMP_ERASE": \
	((x) == 0xff1f ? "HWRM_DBG_DRV_TRACE": \
	((x) == 0xff20 ? "HWRM_DBG_QCAPS": \
	((x) == 0xff21 ? "HWRM_DBG_QCFG": \
	((x) == 0xff22 ? "HWRM_DBG_CRASHDUMP_MEDIUM_CFG": \
	((x) == 0xff23 ? "HWRM_DBG_USEQ_ALLOC": \
	((x) == 0xff24 ? "HWRM_DBG_USEQ_FREE": \
	((x) == 0xff25 ? "HWRM_DBG_USEQ_FLUSH": \
	((x) == 0xff26 ? "HWRM_DBG_USEQ_QCAPS": \
	((x) == 0xff27 ? "HWRM_DBG_USEQ_CW_CFG": \
	((x) == 0xff28 ? "HWRM_DBG_USEQ_SCHED_CFG": \
	((x) == 0xff29 ? "HWRM_DBG_USEQ_RUN": \
	((x) == 0xff2a ? "HWRM_DBG_USEQ_DELIVERY_REQ": \
	((x) == 0xff2b ? "HWRM_DBG_USEQ_RESP_HDR": \
	((x) == 0xff2c ? "HWRM_DBG_COREDUMP_CAPTURE": \
	((x) == 0xff2d ? "HWRM_DBG_PTRACE": \
	((x) == 0xff2e ? "HWRM_DBG_SIM_CABLE_STATE": \
	"Unknown decode" ))))))))))))))))))))))))))))))))) : \
	(((x) <= UINT16_MAX) ? \
	((x) == 0xffea ? "HWRM_NVM_GET_VPD_FIELD_INFO": \
	((x) == 0xffeb ? "HWRM_NVM_SET_VPD_FIELD_INFO": \
	((x) == 0xffec ? "HWRM_NVM_DEFRAG": \
	((x) == 0xffed ? "HWRM_NVM_REQ_ARBITRATION": \
	((x) == 0xffee ? "HWRM_NVM_FACTORY_DEFAULTS": \
	((x) == 0xffef ? "HWRM_NVM_VALIDATE_OPTION": \
	((x) == 0xfff0 ? "HWRM_NVM_FLUSH": \
	((x) == 0xfff1 ? "HWRM_NVM_GET_VARIABLE": \
	((x) == 0xfff2 ? "HWRM_NVM_SET_VARIABLE": \
	((x) == 0xfff3 ? "HWRM_NVM_INSTALL_UPDATE": \
	((x) == 0xfff4 ? "HWRM_NVM_MODIFY": \
	((x) == 0xfff5 ? "HWRM_NVM_VERIFY_UPDATE": \
	((x) == 0xfff6 ? "HWRM_NVM_GET_DEV_INFO": \
	((x) == 0xfff7 ? "HWRM_NVM_ERASE_DIR_ENTRY": \
	((x) == 0xfff8 ? "HWRM_NVM_MOD_DIR_ENTRY": \
	((x) == 0xfff9 ? "HWRM_NVM_FIND_DIR_ENTRY": \
	((x) == 0xfffa ? "HWRM_NVM_GET_DIR_ENTRIES": \
	((x) == 0xfffb ? "HWRM_NVM_GET_DIR_INFO": \
	((x) == 0xfffc ? "HWRM_NVM_RAW_DUMP": \
	((x) == 0xfffd ? "HWRM_NVM_READ": \
	((x) == 0xfffe ? "HWRM_NVM_WRITE": \
	((x) == 0xffff ? "HWRM_NVM_RAW_WRITE_BLK": \
	"Unknown decode" )))))))))))))))))))))) : \
	"Unknown decode" )))))))))))


/*
 * Command numbering
 * # NOTE - definitions already in hwrm_req_type, in hwrm_types.yaml
 * #	So only structure definition is provided here.
 */
/* cmd_nums (size:64b/8B) */

typedef struct cmd_nums {
	/*
	 * This version of the specification defines the commands listed in
	 * the table below. The following are general implementation
	 * requirements for these commands:
	 *
	 * # All commands listed below that are marked neither
	 * reserved nor experimental shall be implemented by the HWRM.
	 * # A HWRM client compliant to this specification should not use
	 * commands outside of the list below.
	 * # A HWRM client compliant to this specification should not use
	 * command numbers marked reserved below.
	 * # A command marked experimental below may not be implemented
	 * by the HWRM.
	 * # A command marked experimental may change in the
	 * future version of the HWRM specification.
	 * # A command not listed below may be implemented by the HWRM.
	 * The behavior of commands that are not listed below is outside
	 * the scope of this specification.
	 */
	uint16_t	req_type;
	#define HWRM_VER_GET				UINT32_C(0x0)
	#define HWRM_FUNC_ECHO_RESPONSE		UINT32_C(0xb)
	#define HWRM_ERROR_RECOVERY_QCFG		UINT32_C(0xc)
	#define HWRM_FUNC_DRV_IF_CHANGE		UINT32_C(0xd)
	#define HWRM_FUNC_BUF_UNRGTR			UINT32_C(0xe)
	#define HWRM_FUNC_VF_CFG			UINT32_C(0xf)
	/* Reserved for future use. */
	#define HWRM_RESERVED1				UINT32_C(0x10)
	#define HWRM_FUNC_RESET			UINT32_C(0x11)
	#define HWRM_FUNC_GETFID			UINT32_C(0x12)
	#define HWRM_FUNC_VF_ALLOC			UINT32_C(0x13)
	#define HWRM_FUNC_VF_FREE			UINT32_C(0x14)
	#define HWRM_FUNC_QCAPS			UINT32_C(0x15)
	#define HWRM_FUNC_QCFG				UINT32_C(0x16)
	#define HWRM_FUNC_CFG				UINT32_C(0x17)
	#define HWRM_FUNC_QSTATS			UINT32_C(0x18)
	#define HWRM_FUNC_CLR_STATS			UINT32_C(0x19)
	#define HWRM_FUNC_DRV_UNRGTR			UINT32_C(0x1a)
	#define HWRM_FUNC_VF_RESC_FREE			UINT32_C(0x1b)
	#define HWRM_FUNC_VF_VNIC_IDS_QUERY		UINT32_C(0x1c)
	#define HWRM_FUNC_DRV_RGTR			UINT32_C(0x1d)
	#define HWRM_FUNC_DRV_QVER			UINT32_C(0x1e)
	#define HWRM_FUNC_BUF_RGTR			UINT32_C(0x1f)
	#define HWRM_PORT_PHY_CFG			UINT32_C(0x20)
	#define HWRM_PORT_MAC_CFG			UINT32_C(0x21)
	/* Experimental */
	#define HWRM_PORT_TS_QUERY			UINT32_C(0x22)
	#define HWRM_PORT_QSTATS			UINT32_C(0x23)
	#define HWRM_PORT_LPBK_QSTATS			UINT32_C(0x24)
	/* Experimental */
	#define HWRM_PORT_CLR_STATS			UINT32_C(0x25)
	/* Experimental */
	#define HWRM_PORT_LPBK_CLR_STATS		UINT32_C(0x26)
	#define HWRM_PORT_PHY_QCFG			UINT32_C(0x27)
	#define HWRM_PORT_MAC_QCFG			UINT32_C(0x28)
	/* Experimental */
	#define HWRM_PORT_MAC_PTP_QCFG			UINT32_C(0x29)
	#define HWRM_PORT_PHY_QCAPS			UINT32_C(0x2a)
	#define HWRM_PORT_PHY_I2C_WRITE		UINT32_C(0x2b)
	#define HWRM_PORT_PHY_I2C_READ			UINT32_C(0x2c)
	#define HWRM_PORT_LED_CFG			UINT32_C(0x2d)
	#define HWRM_PORT_LED_QCFG			UINT32_C(0x2e)
	#define HWRM_PORT_LED_QCAPS			UINT32_C(0x2f)
	#define HWRM_QUEUE_QPORTCFG			UINT32_C(0x30)
	#define HWRM_QUEUE_QCFG			UINT32_C(0x31)
	#define HWRM_QUEUE_CFG				UINT32_C(0x32)
	#define HWRM_FUNC_VLAN_CFG			UINT32_C(0x33)
	#define HWRM_FUNC_VLAN_QCFG			UINT32_C(0x34)
	#define HWRM_QUEUE_PFCENABLE_QCFG		UINT32_C(0x35)
	#define HWRM_QUEUE_PFCENABLE_CFG		UINT32_C(0x36)
	#define HWRM_QUEUE_PRI2COS_QCFG		UINT32_C(0x37)
	#define HWRM_QUEUE_PRI2COS_CFG			UINT32_C(0x38)
	#define HWRM_QUEUE_COS2BW_QCFG			UINT32_C(0x39)
	#define HWRM_QUEUE_COS2BW_CFG			UINT32_C(0x3a)
	#define HWRM_QUEUE_DSCP_QCAPS			UINT32_C(0x3b)
	#define HWRM_QUEUE_DSCP2PRI_QCFG		UINT32_C(0x3c)
	#define HWRM_QUEUE_DSCP2PRI_CFG		UINT32_C(0x3d)
	#define HWRM_VNIC_ALLOC			UINT32_C(0x40)
	#define HWRM_VNIC_FREE				UINT32_C(0x41)
	#define HWRM_VNIC_CFG				UINT32_C(0x42)
	#define HWRM_VNIC_QCFG				UINT32_C(0x43)
	#define HWRM_VNIC_TPA_CFG			UINT32_C(0x44)
	/* Experimental */
	#define HWRM_VNIC_TPA_QCFG			UINT32_C(0x45)
	#define HWRM_VNIC_RSS_CFG			UINT32_C(0x46)
	#define HWRM_VNIC_RSS_QCFG			UINT32_C(0x47)
	#define HWRM_VNIC_PLCMODES_CFG			UINT32_C(0x48)
	#define HWRM_VNIC_PLCMODES_QCFG		UINT32_C(0x49)
	#define HWRM_VNIC_QCAPS			UINT32_C(0x4a)
	/* Updates specific fields in RX VNIC structure */
	#define HWRM_VNIC_UPDATE			UINT32_C(0x4b)
	#define HWRM_RING_ALLOC			UINT32_C(0x50)
	#define HWRM_RING_FREE				UINT32_C(0x51)
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS	UINT32_C(0x52)
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS	UINT32_C(0x53)
	#define HWRM_RING_AGGINT_QCAPS			UINT32_C(0x54)
	#define HWRM_RING_SCHQ_ALLOC			UINT32_C(0x55)
	#define HWRM_RING_SCHQ_CFG			UINT32_C(0x56)
	#define HWRM_RING_SCHQ_FREE			UINT32_C(0x57)
	#define HWRM_RING_RESET			UINT32_C(0x5e)
	#define HWRM_RING_GRP_ALLOC			UINT32_C(0x60)
	#define HWRM_RING_GRP_FREE			UINT32_C(0x61)
	#define HWRM_RING_CFG				UINT32_C(0x62)
	#define HWRM_RING_QCFG				UINT32_C(0x63)
	/* Reserved for future use. */
	#define HWRM_RESERVED5				UINT32_C(0x64)
	/* Reserved for future use. */
	#define HWRM_RESERVED6				UINT32_C(0x65)
	#define HWRM_VNIC_RSS_COS_LB_CTX_ALLOC		UINT32_C(0x70)
	#define HWRM_VNIC_RSS_COS_LB_CTX_FREE		UINT32_C(0x71)
	#define HWRM_QUEUE_MPLS_QCAPS			UINT32_C(0x80)
	#define HWRM_QUEUE_MPLSTC2PRI_QCFG		UINT32_C(0x81)
	#define HWRM_QUEUE_MPLSTC2PRI_CFG		UINT32_C(0x82)
	#define HWRM_QUEUE_VLANPRI_QCAPS		UINT32_C(0x83)
	#define HWRM_QUEUE_VLANPRI2PRI_QCFG		UINT32_C(0x84)
	#define HWRM_QUEUE_VLANPRI2PRI_CFG		UINT32_C(0x85)
	#define HWRM_QUEUE_GLOBAL_CFG			UINT32_C(0x86)
	#define HWRM_QUEUE_GLOBAL_QCFG			UINT32_C(0x87)
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG	UINT32_C(0x88)
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG	UINT32_C(0x89)
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG	UINT32_C(0x8a)
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG	UINT32_C(0x8b)
	#define HWRM_QUEUE_QCAPS			UINT32_C(0x8c)
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_QCFG	UINT32_C(0x8d)
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG	UINT32_C(0x8e)
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_QCFG	UINT32_C(0x8f)
	#define HWRM_CFA_L2_FILTER_ALLOC		UINT32_C(0x90)
	#define HWRM_CFA_L2_FILTER_FREE		UINT32_C(0x91)
	#define HWRM_CFA_L2_FILTER_CFG			UINT32_C(0x92)
	#define HWRM_CFA_L2_SET_RX_MASK		UINT32_C(0x93)
	#define HWRM_CFA_VLAN_ANTISPOOF_CFG		UINT32_C(0x94)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC		UINT32_C(0x95)
	#define HWRM_CFA_TUNNEL_FILTER_FREE		UINT32_C(0x96)
	/* Experimental */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC		UINT32_C(0x97)
	/* Experimental */
	#define HWRM_CFA_ENCAP_RECORD_FREE		UINT32_C(0x98)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC		UINT32_C(0x99)
	#define HWRM_CFA_NTUPLE_FILTER_FREE		UINT32_C(0x9a)
	#define HWRM_CFA_NTUPLE_FILTER_CFG		UINT32_C(0x9b)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_ALLOC			UINT32_C(0x9c)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_FREE			UINT32_C(0x9d)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_CFG			UINT32_C(0x9e)
	#define HWRM_TUNNEL_DST_PORT_QUERY		UINT32_C(0xa0)
	#define HWRM_TUNNEL_DST_PORT_ALLOC		UINT32_C(0xa1)
	#define HWRM_TUNNEL_DST_PORT_FREE		UINT32_C(0xa2)
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG	UINT32_C(0xa3)
	#define HWRM_STAT_CTX_ENG_QUERY		UINT32_C(0xaf)
	#define HWRM_STAT_CTX_ALLOC			UINT32_C(0xb0)
	#define HWRM_STAT_CTX_FREE			UINT32_C(0xb1)
	#define HWRM_STAT_CTX_QUERY			UINT32_C(0xb2)
	#define HWRM_STAT_CTX_CLR_STATS		UINT32_C(0xb3)
	#define HWRM_PORT_QSTATS_EXT			UINT32_C(0xb4)
	#define HWRM_PORT_PHY_MDIO_WRITE		UINT32_C(0xb5)
	#define HWRM_PORT_PHY_MDIO_READ		UINT32_C(0xb6)
	#define HWRM_PORT_PHY_MDIO_BUS_ACQUIRE		UINT32_C(0xb7)
	#define HWRM_PORT_PHY_MDIO_BUS_RELEASE		UINT32_C(0xb8)
	#define HWRM_PORT_QSTATS_EXT_PFC_WD		UINT32_C(0xb9)
	/* Reserved. */
	#define HWRM_RESERVED7				UINT32_C(0xba)
	#define HWRM_PORT_TX_FIR_CFG			UINT32_C(0xbb)
	#define HWRM_PORT_TX_FIR_QCFG			UINT32_C(0xbc)
	#define HWRM_PORT_ECN_QSTATS			UINT32_C(0xbd)
	#define HWRM_FW_LIVEPATCH_QUERY		UINT32_C(0xbe)
	#define HWRM_FW_LIVEPATCH			UINT32_C(0xbf)
	#define HWRM_FW_RESET				UINT32_C(0xc0)
	#define HWRM_FW_QSTATUS			UINT32_C(0xc1)
	#define HWRM_FW_HEALTH_CHECK			UINT32_C(0xc2)
	#define HWRM_FW_SYNC				UINT32_C(0xc3)
	#define HWRM_FW_STATE_QCAPS			UINT32_C(0xc4)
	#define HWRM_FW_STATE_QUIESCE			UINT32_C(0xc5)
	#define HWRM_FW_STATE_BACKUP			UINT32_C(0xc6)
	#define HWRM_FW_STATE_RESTORE			UINT32_C(0xc7)
	/* Experimental */
	#define HWRM_FW_SET_TIME			UINT32_C(0xc8)
	/* Experimental */
	#define HWRM_FW_GET_TIME			UINT32_C(0xc9)
	/* Experimental */
	#define HWRM_FW_SET_STRUCTURED_DATA		UINT32_C(0xca)
	/* Experimental */
	#define HWRM_FW_GET_STRUCTURED_DATA		UINT32_C(0xcb)
	/* Experimental */
	#define HWRM_FW_IPC_MAILBOX			UINT32_C(0xcc)
	#define HWRM_FW_ECN_CFG			UINT32_C(0xcd)
	#define HWRM_FW_ECN_QCFG			UINT32_C(0xce)
	#define HWRM_FW_SECURE_CFG			UINT32_C(0xcf)
	#define HWRM_EXEC_FWD_RESP			UINT32_C(0xd0)
	#define HWRM_REJECT_FWD_RESP			UINT32_C(0xd1)
	#define HWRM_FWD_RESP				UINT32_C(0xd2)
	#define HWRM_FWD_ASYNC_EVENT_CMPL		UINT32_C(0xd3)
	#define HWRM_OEM_CMD				UINT32_C(0xd4)
	/* Tells the fw to run PRBS test on a given port and lane. */
	#define HWRM_PORT_PRBS_TEST			UINT32_C(0xd5)
	#define HWRM_PORT_SFP_SIDEBAND_CFG		UINT32_C(0xd6)
	#define HWRM_PORT_SFP_SIDEBAND_QCFG		UINT32_C(0xd7)
	#define HWRM_FW_STATE_UNQUIESCE		UINT32_C(0xd8)
	/* Tells the fw to collect dsc dump on a given port and lane. */
	#define HWRM_PORT_DSC_DUMP			UINT32_C(0xd9)
	#define HWRM_PORT_EP_TX_QCFG			UINT32_C(0xda)
	#define HWRM_PORT_EP_TX_CFG			UINT32_C(0xdb)
	#define HWRM_PORT_CFG				UINT32_C(0xdc)
	#define HWRM_PORT_QCFG				UINT32_C(0xdd)
	/* Queries MAC capabilities for the specified port */
	#define HWRM_PORT_MAC_QCAPS			UINT32_C(0xdf)
	#define HWRM_TEMP_MONITOR_QUERY		UINT32_C(0xe0)
	#define HWRM_REG_POWER_QUERY			UINT32_C(0xe1)
	#define HWRM_CORE_FREQUENCY_QUERY		UINT32_C(0xe2)
	#define HWRM_REG_POWER_HISTOGRAM		UINT32_C(0xe3)
	#define HWRM_WOL_FILTER_ALLOC			UINT32_C(0xf0)
	#define HWRM_WOL_FILTER_FREE			UINT32_C(0xf1)
	#define HWRM_WOL_FILTER_QCFG			UINT32_C(0xf2)
	#define HWRM_WOL_REASON_QCFG			UINT32_C(0xf3)
	/* Experimental */
	#define HWRM_CFA_METER_QCAPS			UINT32_C(0xf4)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_ALLOC		UINT32_C(0xf5)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_FREE		UINT32_C(0xf6)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_CFG		UINT32_C(0xf7)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_ALLOC		UINT32_C(0xf8)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_FREE		UINT32_C(0xf9)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_CFG		UINT32_C(0xfa)
	/* Experimental */
	#define HWRM_CFA_VFR_ALLOC			UINT32_C(0xfd)
	/* Experimental */
	#define HWRM_CFA_VFR_FREE			UINT32_C(0xfe)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_ALLOC			UINT32_C(0x100)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_FREE			UINT32_C(0x101)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_INFO			UINT32_C(0x102)
	/* Experimental */
	#define HWRM_CFA_FLOW_ALLOC			UINT32_C(0x103)
	/* Experimental */
	#define HWRM_CFA_FLOW_FREE			UINT32_C(0x104)
	/* Experimental */
	#define HWRM_CFA_FLOW_FLUSH			UINT32_C(0x105)
	#define HWRM_CFA_FLOW_STATS			UINT32_C(0x106)
	#define HWRM_CFA_FLOW_INFO			UINT32_C(0x107)
	/* Experimental */
	#define HWRM_CFA_DECAP_FILTER_ALLOC		UINT32_C(0x108)
	/* Experimental */
	#define HWRM_CFA_DECAP_FILTER_FREE		UINT32_C(0x109)
	#define HWRM_CFA_VLAN_ANTISPOOF_QCFG		UINT32_C(0x10a)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC	UINT32_C(0x10b)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE	UINT32_C(0x10c)
	/* Experimental */
	#define HWRM_CFA_PAIR_ALLOC			UINT32_C(0x10d)
	/* Experimental */
	#define HWRM_CFA_PAIR_FREE			UINT32_C(0x10e)
	/* Experimental */
	#define HWRM_CFA_PAIR_INFO			UINT32_C(0x10f)
	/* Experimental */
	#define HWRM_FW_IPC_MSG			UINT32_C(0x110)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO	UINT32_C(0x111)
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE	UINT32_C(0x112)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_TIMER_RESET	UINT32_C(0x113)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_CFG		UINT32_C(0x114)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_QCFG		UINT32_C(0x115)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_QCAPS		UINT32_C(0x116)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_RGTR			UINT32_C(0x117)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_UNRGTR		UINT32_C(0x118)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_QCTX			UINT32_C(0x119)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_QCAPS			UINT32_C(0x11a)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QCAPS			UINT32_C(0x11b)
	/* Experimental */
	#define HWRM_CFA_COUNTER_CFG			UINT32_C(0x11c)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QCFG			UINT32_C(0x11d)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QSTATS		UINT32_C(0x11e)
	/* Experimental */
	#define HWRM_CFA_TCP_FLAG_PROCESS_QCFG		UINT32_C(0x11f)
	/* Experimental */
	#define HWRM_CFA_EEM_QCAPS			UINT32_C(0x120)
	/* Experimental */
	#define HWRM_CFA_EEM_CFG			UINT32_C(0x121)
	/* Experimental */
	#define HWRM_CFA_EEM_QCFG			UINT32_C(0x122)
	/* Experimental */
	#define HWRM_CFA_EEM_OP			UINT32_C(0x123)
	/* Experimental */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS		UINT32_C(0x124)
	/* Experimental - DEPRECATED */
	#define HWRM_CFA_TFLIB				UINT32_C(0x125)
	/* Experimental */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR		UINT32_C(0x126)
	/* Experimental */
	#define HWRM_CFA_LAG_GROUP_MEMBER_UNRGTR	UINT32_C(0x127)
	/* Experimental */
	#define HWRM_CFA_TLS_FILTER_ALLOC		UINT32_C(0x128)
	/* Experimental */
	#define HWRM_CFA_TLS_FILTER_FREE		UINT32_C(0x129)
	/* Release an AFM function for TF control */
	#define HWRM_CFA_RELEASE_AFM_FUNC		UINT32_C(0x12a)
	/*
	 * Engine CKV - Get the current allocation status of keys provisioned in
	 * the key vault.
	 */
	#define HWRM_ENGINE_CKV_STATUS			UINT32_C(0x12e)
	/* Engine CKV - Add a new CKEK used to encrypt keys. */
	#define HWRM_ENGINE_CKV_CKEK_ADD		UINT32_C(0x12f)
	/* Engine CKV - Delete a previously added CKEK. */
	#define HWRM_ENGINE_CKV_CKEK_DELETE		UINT32_C(0x130)
	/* Engine CKV - Add a new key to the key vault. */
	#define HWRM_ENGINE_CKV_KEY_ADD		UINT32_C(0x131)
	/* Engine CKV - Delete a key from the key vault. */
	#define HWRM_ENGINE_CKV_KEY_DELETE		UINT32_C(0x132)
	/* Engine CKV - Delete all keys from the key vault. */
	#define HWRM_ENGINE_CKV_FLUSH			UINT32_C(0x133)
	/* Engine CKV - Get random data. */
	#define HWRM_ENGINE_CKV_RNG_GET		UINT32_C(0x134)
	/* Engine CKV - Generate and encrypt a new AES key. */
	#define HWRM_ENGINE_CKV_KEY_GEN		UINT32_C(0x135)
	/* Engine CKV - Configure a label index with a label value. */
	#define HWRM_ENGINE_CKV_KEY_LABEL_CFG		UINT32_C(0x136)
	/* Engine CKV - Query a label */
	#define HWRM_ENGINE_CKV_KEY_LABEL_QCFG		UINT32_C(0x137)
	/* Engine - Query the available queue groups configuration. */
	#define HWRM_ENGINE_QG_CONFIG_QUERY		UINT32_C(0x13c)
	/* Engine - Query the queue groups assigned to a function. */
	#define HWRM_ENGINE_QG_QUERY			UINT32_C(0x13d)
	/* Engine - Query the available queue group meter profile configuration. */
	#define HWRM_ENGINE_QG_METER_PROFILE_CONFIG_QUERY UINT32_C(0x13e)
	/* Engine - Query the configuration of a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_QUERY	UINT32_C(0x13f)
	/* Engine - Allocate a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_ALLOC	UINT32_C(0x140)
	/* Engine - Free a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_FREE	UINT32_C(0x141)
	/* Engine - Query the meters assigned to a queue group. */
	#define HWRM_ENGINE_QG_METER_QUERY		UINT32_C(0x142)
	/* Engine - Bind a queue group meter profile to a queue group. */
	#define HWRM_ENGINE_QG_METER_BIND		UINT32_C(0x143)
	/* Engine - Unbind a queue group meter profile from a queue group. */
	#define HWRM_ENGINE_QG_METER_UNBIND		UINT32_C(0x144)
	/* Engine - Bind a queue group to a function. */
	#define HWRM_ENGINE_QG_FUNC_BIND		UINT32_C(0x145)
	/* Engine - Query the scheduling group configuration. */
	#define HWRM_ENGINE_SG_CONFIG_QUERY		UINT32_C(0x146)
	/* Engine - Query the queue groups assigned to a scheduling group. */
	#define HWRM_ENGINE_SG_QUERY			UINT32_C(0x147)
	/* Engine - Query the configuration of a scheduling group's meter profiles. */
	#define HWRM_ENGINE_SG_METER_QUERY		UINT32_C(0x148)
	/* Engine - Configure a scheduling group's meter profiles. */
	#define HWRM_ENGINE_SG_METER_CONFIG		UINT32_C(0x149)
	/* Engine - Bind a queue group to a scheduling group. */
	#define HWRM_ENGINE_SG_QG_BIND			UINT32_C(0x14a)
	/* Engine - Unbind a queue group from its scheduling group. */
	#define HWRM_ENGINE_QG_SG_UNBIND		UINT32_C(0x14b)
	/* Engine - Query the Engine configuration. */
	#define HWRM_ENGINE_CONFIG_QUERY		UINT32_C(0x154)
	/* Engine - Configure the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_CONFIG		UINT32_C(0x155)
	/* Engine - Clear the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_CLEAR		UINT32_C(0x156)
	/* Engine - Query the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_QUERY		UINT32_C(0x157)
	/*
	 * Engine - Query statistics counters for continuous errors from all CDDIP
	 * Engines.
	 */
	#define HWRM_ENGINE_STATS_QUERY_CONTINUOUS_ERROR  UINT32_C(0x158)
	/* Engine - Allocate an Engine RQ. */
	#define HWRM_ENGINE_RQ_ALLOC			UINT32_C(0x15e)
	/* Engine - Free an Engine RQ. */
	#define HWRM_ENGINE_RQ_FREE			UINT32_C(0x15f)
	/* Engine - Allocate an Engine CQ. */
	#define HWRM_ENGINE_CQ_ALLOC			UINT32_C(0x160)
	/* Engine - Free an Engine CQ. */
	#define HWRM_ENGINE_CQ_FREE			UINT32_C(0x161)
	/* Engine - Allocate an NQ. */
	#define HWRM_ENGINE_NQ_ALLOC			UINT32_C(0x162)
	/* Engine - Free an NQ. */
	#define HWRM_ENGINE_NQ_FREE			UINT32_C(0x163)
	/* Engine - Set the on-die RQE credit update location. */
	#define HWRM_ENGINE_ON_DIE_RQE_CREDITS		UINT32_C(0x164)
	/* Engine - Query the engine function configuration. */
	#define HWRM_ENGINE_FUNC_QCFG			UINT32_C(0x165)
	/* Experimental */
	#define HWRM_FUNC_RESOURCE_QCAPS		UINT32_C(0x190)
	/* Experimental */
	#define HWRM_FUNC_VF_RESOURCE_CFG		UINT32_C(0x191)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_QCAPS		UINT32_C(0x192)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_CFG		UINT32_C(0x193)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_QCFG		UINT32_C(0x194)
	/* Configures the BW of any VF */
	#define HWRM_FUNC_VF_BW_CFG			UINT32_C(0x195)
	/* Queries the BW of any VF */
	#define HWRM_FUNC_VF_BW_QCFG			UINT32_C(0x196)
	/* Queries pf ids belong to specified host(s) */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY		UINT32_C(0x197)
	/* Queries extended stats per function */
	#define HWRM_FUNC_QSTATS_EXT			UINT32_C(0x198)
	/* Queries extended statistics context */
	#define HWRM_STAT_EXT_CTX_QUERY		UINT32_C(0x199)
	/* Configure SoC packet DMA settings */
	#define HWRM_FUNC_SPD_CFG			UINT32_C(0x19a)
	/* Query SoC packet DMA settings */
	#define HWRM_FUNC_SPD_QCFG			UINT32_C(0x19b)
	/* PTP - Queries configuration of timesync IO pins. */
	#define HWRM_FUNC_PTP_PIN_QCFG			UINT32_C(0x19c)
	/* PTP - Configuration of timesync IO pins. */
	#define HWRM_FUNC_PTP_PIN_CFG			UINT32_C(0x19d)
	/* PTP - Configuration for disciplining PHC. */
	#define HWRM_FUNC_PTP_CFG			UINT32_C(0x19e)
	/* PTP - Queries for PHC timestamps. */
	#define HWRM_FUNC_PTP_TS_QUERY			UINT32_C(0x19f)
	/* PTP - Extended PTP configuration. */
	#define HWRM_FUNC_PTP_EXT_CFG			UINT32_C(0x1a0)
	/* PTP - Query extended PTP configuration. */
	#define HWRM_FUNC_PTP_EXT_QCFG			UINT32_C(0x1a1)
	/* The command is used to allocate KTLS or QUIC key contexts. */
	#define HWRM_FUNC_KEY_CTX_ALLOC		UINT32_C(0x1a2)
	/* The is the new API to configure backing stores. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2		UINT32_C(0x1a3)
	/* The is the new API to query backing store configurations. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2	UINT32_C(0x1a4)
	/* To support doorbell pacing configuration. */
	#define HWRM_FUNC_DBR_PACING_CFG		UINT32_C(0x1a5)
	/* To query doorbell pacing configuration. */
	#define HWRM_FUNC_DBR_PACING_QCFG		UINT32_C(0x1a6)
	/*
	 * To broadcast the doorbell event to the drivers to
	 * initiate pacing of doorbells.
	 */
	#define HWRM_FUNC_DBR_PACING_BROADCAST_EVENT	UINT32_C(0x1a7)
	/* The is the new API to query backing store capabilities. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2	UINT32_C(0x1a8)
	/* To query doorbell pacing NQ id list configuration. */
	#define HWRM_FUNC_DBR_PACING_NQLIST_QUERY	UINT32_C(0x1a9)
	/*
	 * To notify the firmware that recovery cycle has been
	 * completed by host function drivers.
	 */
	#define HWRM_FUNC_DBR_RECOVERY_COMPLETED	UINT32_C(0x1aa)
	/* Configures SyncE configurations. */
	#define HWRM_FUNC_SYNCE_CFG			UINT32_C(0x1ab)
	/* Queries SyncE configurations. */
	#define HWRM_FUNC_SYNCE_QCFG			UINT32_C(0x1ac)
	/* The command is used to deallocate KTLS or QUIC key contexts. */
	#define HWRM_FUNC_KEY_CTX_FREE			UINT32_C(0x1ad)
	/* The command is used to configure link aggr group mode. */
	#define HWRM_FUNC_LAG_MODE_CFG			UINT32_C(0x1ae)
	/* The command is used to query link aggr group mode. */
	#define HWRM_FUNC_LAG_MODE_QCFG		UINT32_C(0x1af)
	/* The command is used to create a link aggr group. */
	#define HWRM_FUNC_LAG_CREATE			UINT32_C(0x1b0)
	/* The command is used to update a link aggr group. */
	#define HWRM_FUNC_LAG_UPDATE			UINT32_C(0x1b1)
	/* The command is used to free a link aggr group. */
	#define HWRM_FUNC_LAG_FREE			UINT32_C(0x1b2)
	/* The command is used to query a link aggr group. */
	#define HWRM_FUNC_LAG_QCFG			UINT32_C(0x1b3)
	/* This command is use to add TimeTX packet pacing rate. */
	#define HWRM_FUNC_TIMEDTX_PACING_RATE_ADD	UINT32_C(0x1c2)
	/*
	 * This command is use to delete TimeTX packet pacing rate
	 * from the rate table.
	 */
	#define HWRM_FUNC_TIMEDTX_PACING_RATE_DELETE	UINT32_C(0x1c3)
	/*
	 * This command is used to retrieve all the TimeTX pacing rates
	 * from the rate table that have been added for the function.
	 */
	#define HWRM_FUNC_TIMEDTX_PACING_RATE_QUERY	UINT32_C(0x1c4)
	/* Experimental */
	#define HWRM_SELFTEST_QLIST			UINT32_C(0x200)
	/* Experimental */
	#define HWRM_SELFTEST_EXEC			UINT32_C(0x201)
	/* Experimental */
	#define HWRM_SELFTEST_IRQ			UINT32_C(0x202)
	/* Experimental (deprecated) */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA	UINT32_C(0x203)
	/* Experimental */
	#define HWRM_PCIE_QSTATS			UINT32_C(0x204)
	/* Experimental */
	#define HWRM_MFG_FRU_WRITE_CONTROL		UINT32_C(0x205)
	/* Returns the current value of a free running counter from the device. */
	#define HWRM_MFG_TIMERS_QUERY			UINT32_C(0x206)
	/* Experimental */
	#define HWRM_MFG_OTP_CFG			UINT32_C(0x207)
	/* Experimental */
	#define HWRM_MFG_OTP_QCFG			UINT32_C(0x208)
	/*
	 * Tells the fw to run the DMA read from the host and DMA write
	 * to the host test.
	 */
	#define HWRM_MFG_HDMA_TEST			UINT32_C(0x209)
	/* Tells the fw to program the fru memory */
	#define HWRM_MFG_FRU_EEPROM_WRITE		UINT32_C(0x20a)
	/* Tells the fw to read the fru memory */
	#define HWRM_MFG_FRU_EEPROM_READ		UINT32_C(0x20b)
	/* Used to provision SoC software images */
	#define HWRM_MFG_SOC_IMAGE			UINT32_C(0x20c)
	/* Retrieves the SoC status and image provisioning information */
	#define HWRM_MFG_SOC_QSTATUS			UINT32_C(0x20d)
	/* Tells the fw to finalize the critical data (store and lock it) */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_FINALIZE	UINT32_C(0x20e)
	/* Tells the fw to read the critical data */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_READ	UINT32_C(0x20f)
	/* Tells the fw to get the health of critical data */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_HEALTH	UINT32_C(0x210)
	/*
	 * The command is used for certificate provisioning to export a
	 * Certificate Signing Request (CSR) from the device.
	 */
	#define HWRM_MFG_PRVSN_EXPORT_CSR		UINT32_C(0x211)
	/*
	 * The command is used for certificate provisioning to import a
	 * CA-signed certificate chain to the device.
	 */
	#define HWRM_MFG_PRVSN_IMPORT_CERT		UINT32_C(0x212)
	/*
	 * The command is used for certificate provisioning to query the
	 * provisioned state.
	 */
	#define HWRM_MFG_PRVSN_GET_STATE		UINT32_C(0x213)
	/*
	 * The command is used to get the hash of the NVM configuration that is
	 * calculated during firmware boot.
	 */
	#define HWRM_MFG_GET_NVM_MEASUREMENT		UINT32_C(0x214)
	/* Retrieves the PSOC status and provisioning information. */
	#define HWRM_MFG_PSOC_QSTATUS			UINT32_C(0x215)
	/*
	 * This command allows manufacturing tool to determine which selftests
	 * are available to be run.
	 */
	#define HWRM_MFG_SELFTEST_QLIST		UINT32_C(0x216)
	/*
	 * This command allows manufacturing tool to request which selftests
	 * to run.
	 */
	#define HWRM_MFG_SELFTEST_EXEC			UINT32_C(0x217)
	/* Queries the generic stats */
	#define HWRM_STAT_GENERIC_QSTATS		UINT32_C(0x218)
	/*
	 * The command is used for certificate provisioning to export a
	 * certificate chain from the device.
	 */
	#define HWRM_MFG_PRVSN_EXPORT_CERT		UINT32_C(0x219)
	/* Query the statistics for doorbell drops due to various error conditions. */
	#define HWRM_STAT_DB_ERROR_QSTATS		UINT32_C(0x21a)
	/*
	 * The command is used to enable/disable the power on ethernet for
	 * a particular I/O expander port.
	 */
	#define HWRM_PORT_POE_CFG			UINT32_C(0x230)
	/*
	 * The command is used to query whether the power on ethernet
	 * is enabled/disabled for a particular I/O expander port.
	 */
	#define HWRM_PORT_POE_QCFG			UINT32_C(0x231)
	/*
	 * This command returns the capabilities related to User Defined
	 * Congestion Control on a function.
	 */
	#define HWRM_UDCC_QCAPS			UINT32_C(0x258)
	/* This command configures User Defined Congestion Control on a function. */
	#define HWRM_UDCC_CFG				UINT32_C(0x259)
	/*
	 * This command queries the configuration of User Defined Congestion
	 * Control on a function.
	 */
	#define HWRM_UDCC_QCFG				UINT32_C(0x25a)
	/* This command configures an existing UDCC session. */
	#define HWRM_UDCC_SESSION_CFG			UINT32_C(0x25b)
	/* This command queries the configuration of a UDCC session. */
	#define HWRM_UDCC_SESSION_QCFG			UINT32_C(0x25c)
	/* This command queries the UDCC session. */
	#define HWRM_UDCC_SESSION_QUERY		UINT32_C(0x25d)
	/* This command configures the computation unit. */
	#define HWRM_UDCC_COMP_CFG			UINT32_C(0x25e)
	/* This command queries the configuration of the computation unit. */
	#define HWRM_UDCC_COMP_QCFG			UINT32_C(0x25f)
	/* This command queries the status and statistics of the computation unit. */
	#define HWRM_UDCC_COMP_QUERY			UINT32_C(0x260)
	/*
	 * This command is used to query the pfc watchdog max configurable
	 * timeout value.
	 */
	#define HWRM_QUEUE_PFCWD_TIMEOUT_QCAPS		UINT32_C(0x261)
	/* This command is used to set the PFC watchdog timeout value. */
	#define HWRM_QUEUE_PFCWD_TIMEOUT_CFG		UINT32_C(0x262)
	/*
	 * This command is used to query the current configured pfc watchdog
	 * timeout value.
	 */
	#define HWRM_QUEUE_PFCWD_TIMEOUT_QCFG		UINT32_C(0x263)
	/* Experimental */
	#define HWRM_TF				UINT32_C(0x2bc)
	/* Experimental */
	#define HWRM_TF_VERSION_GET			UINT32_C(0x2bd)
	/* Experimental */
	#define HWRM_TF_SESSION_OPEN			UINT32_C(0x2c6)
	/* Experimental */
	#define HWRM_TF_SESSION_REGISTER		UINT32_C(0x2c8)
	/* Experimental */
	#define HWRM_TF_SESSION_UNREGISTER		UINT32_C(0x2c9)
	/* Experimental */
	#define HWRM_TF_SESSION_CLOSE			UINT32_C(0x2ca)
	/* Experimental */
	#define HWRM_TF_SESSION_QCFG			UINT32_C(0x2cb)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_QCAPS		UINT32_C(0x2cc)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_ALLOC		UINT32_C(0x2cd)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_FREE		UINT32_C(0x2ce)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_FLUSH		UINT32_C(0x2cf)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_INFO		UINT32_C(0x2d0)
	/* Experimental */
	#define HWRM_TF_SESSION_HOTUP_STATE_SET	UINT32_C(0x2d1)
	/* Experimental */
	#define HWRM_TF_SESSION_HOTUP_STATE_GET	UINT32_C(0x2d2)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_GET			UINT32_C(0x2da)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_SET			UINT32_C(0x2db)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_BULK_GET		UINT32_C(0x2dc)
	/* Experimental */
	#define HWRM_TF_EM_INSERT			UINT32_C(0x2ea)
	/* Experimental */
	#define HWRM_TF_EM_DELETE			UINT32_C(0x2eb)
	/* Experimental */
	#define HWRM_TF_EM_HASH_INSERT			UINT32_C(0x2ec)
	/* Experimental */
	#define HWRM_TF_EM_MOVE			UINT32_C(0x2ed)
	/* Experimental */
	#define HWRM_TF_TCAM_SET			UINT32_C(0x2f8)
	/* Experimental */
	#define HWRM_TF_TCAM_GET			UINT32_C(0x2f9)
	/* Experimental */
	#define HWRM_TF_TCAM_MOVE			UINT32_C(0x2fa)
	/* Experimental */
	#define HWRM_TF_TCAM_FREE			UINT32_C(0x2fb)
	/* Experimental */
	#define HWRM_TF_GLOBAL_CFG_SET			UINT32_C(0x2fc)
	/* Experimental */
	#define HWRM_TF_GLOBAL_CFG_GET			UINT32_C(0x2fd)
	/* Experimental */
	#define HWRM_TF_IF_TBL_SET			UINT32_C(0x2fe)
	/* Experimental */
	#define HWRM_TF_IF_TBL_GET			UINT32_C(0x2ff)
	/* Experimental */
	#define HWRM_TF_RESC_USAGE_SET			UINT32_C(0x300)
	/* Experimental */
	#define HWRM_TF_RESC_USAGE_QUERY		UINT32_C(0x301)
	/* Truflow command to allocate a table */
	#define HWRM_TF_TBL_TYPE_ALLOC			UINT32_C(0x302)
	/* Truflow command to free a table */
	#define HWRM_TF_TBL_TYPE_FREE			UINT32_C(0x303)
	/* TruFlow command to check firmware table scope capabilities. */
	#define HWRM_TFC_TBL_SCOPE_QCAPS		UINT32_C(0x380)
	/* TruFlow command to allocate a table scope ID and create the pools. */
	#define HWRM_TFC_TBL_SCOPE_ID_ALLOC		UINT32_C(0x381)
	/* TruFlow command to configure the table scope memory. */
	#define HWRM_TFC_TBL_SCOPE_CONFIG		UINT32_C(0x382)
	/* TruFlow command to deconfigure a table scope memory. */
	#define HWRM_TFC_TBL_SCOPE_DECONFIG		UINT32_C(0x383)
	/* TruFlow command to add a FID to a table scope. */
	#define HWRM_TFC_TBL_SCOPE_FID_ADD		UINT32_C(0x384)
	/* TruFlow command to remove a FID from a table scope. */
	#define HWRM_TFC_TBL_SCOPE_FID_REM		UINT32_C(0x385)
	/* DEPRECATED */
	#define HWRM_TFC_TBL_SCOPE_POOL_ALLOC		UINT32_C(0x386)
	/* DEPRECATED */
	#define HWRM_TFC_TBL_SCOPE_POOL_FREE		UINT32_C(0x387)
	/* Experimental */
	#define HWRM_TFC_SESSION_ID_ALLOC		UINT32_C(0x388)
	/* Experimental */
	#define HWRM_TFC_SESSION_FID_ADD		UINT32_C(0x389)
	/* Experimental */
	#define HWRM_TFC_SESSION_FID_REM		UINT32_C(0x38a)
	/* Experimental */
	#define HWRM_TFC_IDENT_ALLOC			UINT32_C(0x38b)
	/* Experimental */
	#define HWRM_TFC_IDENT_FREE			UINT32_C(0x38c)
	/* TruFlow command to allocate an index table entry */
	#define HWRM_TFC_IDX_TBL_ALLOC			UINT32_C(0x38d)
	/* TruFlow command to allocate and set an index table entry */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET		UINT32_C(0x38e)
	/* TruFlow command to set an index table entry */
	#define HWRM_TFC_IDX_TBL_SET			UINT32_C(0x38f)
	/* TruFlow command to get an index table entry */
	#define HWRM_TFC_IDX_TBL_GET			UINT32_C(0x390)
	/* TruFlow command to free an index table entry */
	#define HWRM_TFC_IDX_TBL_FREE			UINT32_C(0x391)
	/* TruFlow command to allocate resources for a global id. */
	#define HWRM_TFC_GLOBAL_ID_ALLOC		UINT32_C(0x392)
	/* TruFlow command to set TCAM entry. */
	#define HWRM_TFC_TCAM_SET			UINT32_C(0x393)
	/* TruFlow command to get TCAM entry. */
	#define HWRM_TFC_TCAM_GET			UINT32_C(0x394)
	/* TruFlow command to allocate a TCAM entry. */
	#define HWRM_TFC_TCAM_ALLOC			UINT32_C(0x395)
	/* TruFlow command allocate and set TCAM entry. */
	#define HWRM_TFC_TCAM_ALLOC_SET		UINT32_C(0x396)
	/* TruFlow command to free a TCAM entry. */
	#define HWRM_TFC_TCAM_FREE			UINT32_C(0x397)
	/* Truflow command to set an interface table entry */
	#define HWRM_TFC_IF_TBL_SET			UINT32_C(0x398)
	/* Truflow command to get an interface table entry */
	#define HWRM_TFC_IF_TBL_GET			UINT32_C(0x399)
	/* TruFlow command to get configured info about a table scope. */
	#define HWRM_TFC_TBL_SCOPE_CONFIG_GET		UINT32_C(0x39a)
	/* TruFlow command to query the resource usage state. */
	#define HWRM_TFC_RESC_USAGE_QUERY		UINT32_C(0x39b)
	/* Experimental */
	#define HWRM_SV				UINT32_C(0x400)
	/* Run a PCIe or Ethernet serdes test and retrieve test data. */
	#define HWRM_DBG_SERDES_TEST			UINT32_C(0xff0e)
	/* Flush any trace buffer data that has not been sent to the host. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH		UINT32_C(0xff0f)
	/* Experimental */
	#define HWRM_DBG_READ_DIRECT			UINT32_C(0xff10)
	/* Experimental */
	#define HWRM_DBG_READ_INDIRECT			UINT32_C(0xff11)
	/* Experimental */
	#define HWRM_DBG_WRITE_DIRECT			UINT32_C(0xff12)
	/* Experimental */
	#define HWRM_DBG_WRITE_INDIRECT		UINT32_C(0xff13)
	#define HWRM_DBG_DUMP				UINT32_C(0xff14)
	/* Experimental */
	#define HWRM_DBG_ERASE_NVM			UINT32_C(0xff15)
	/* Experimental */
	#define HWRM_DBG_CFG				UINT32_C(0xff16)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_LIST			UINT32_C(0xff17)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_INITIATE		UINT32_C(0xff18)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_RETRIEVE		UINT32_C(0xff19)
	/* Experimental */
	#define HWRM_DBG_FW_CLI			UINT32_C(0xff1a)
	/*  */
	#define HWRM_DBG_I2C_CMD			UINT32_C(0xff1b)
	/*  */
	#define HWRM_DBG_RING_INFO_GET			UINT32_C(0xff1c)
	/* Experimental */
	#define HWRM_DBG_CRASHDUMP_HEADER		UINT32_C(0xff1d)
	/* Experimental */
	#define HWRM_DBG_CRASHDUMP_ERASE		UINT32_C(0xff1e)
	/* Send driver debug information to firmware */
	#define HWRM_DBG_DRV_TRACE			UINT32_C(0xff1f)
	/* Query debug capabilities of firmware */
	#define HWRM_DBG_QCAPS				UINT32_C(0xff20)
	/* Retrieve debug settings of firmware */
	#define HWRM_DBG_QCFG				UINT32_C(0xff21)
	/* Set destination parameters for crashdump medium */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG		UINT32_C(0xff22)
	/* Experimental */
	#define HWRM_DBG_USEQ_ALLOC			UINT32_C(0xff23)
	/* Experimental */
	#define HWRM_DBG_USEQ_FREE			UINT32_C(0xff24)
	/* Experimental */
	#define HWRM_DBG_USEQ_FLUSH			UINT32_C(0xff25)
	/* Experimental */
	#define HWRM_DBG_USEQ_QCAPS			UINT32_C(0xff26)
	/* Experimental */
	#define HWRM_DBG_USEQ_CW_CFG			UINT32_C(0xff27)
	/* Experimental */
	#define HWRM_DBG_USEQ_SCHED_CFG		UINT32_C(0xff28)
	/* Experimental */
	#define HWRM_DBG_USEQ_RUN			UINT32_C(0xff29)
	/* Experimental */
	#define HWRM_DBG_USEQ_DELIVERY_REQ		UINT32_C(0xff2a)
	/* Experimental */
	#define HWRM_DBG_USEQ_RESP_HDR			UINT32_C(0xff2b)
	/*
	 * This command is used to request the firmware to store a coredump
	 * into Host memory previously specified with the
	 * HWRM_DBG_CRASHDUMP_MEDIUM_CFG API
	 */
	#define HWRM_DBG_COREDUMP_CAPTURE		UINT32_C(0xff2c)
	#define HWRM_DBG_PTRACE			UINT32_C(0xff2d)
	/*
	 * This command is used to request the firmware to simulate cable insert
	 * or removal.
	 */
	#define HWRM_DBG_SIM_CABLE_STATE		UINT32_C(0xff2e)
	#define HWRM_NVM_GET_VPD_FIELD_INFO		UINT32_C(0xffea)
	#define HWRM_NVM_SET_VPD_FIELD_INFO		UINT32_C(0xffeb)
	#define HWRM_NVM_DEFRAG			UINT32_C(0xffec)
	#define HWRM_NVM_REQ_ARBITRATION		UINT32_C(0xffed)
	/* Experimental */
	#define HWRM_NVM_FACTORY_DEFAULTS		UINT32_C(0xffee)
	#define HWRM_NVM_VALIDATE_OPTION		UINT32_C(0xffef)
	#define HWRM_NVM_FLUSH				UINT32_C(0xfff0)
	#define HWRM_NVM_GET_VARIABLE			UINT32_C(0xfff1)
	#define HWRM_NVM_SET_VARIABLE			UINT32_C(0xfff2)
	#define HWRM_NVM_INSTALL_UPDATE		UINT32_C(0xfff3)
	#define HWRM_NVM_MODIFY			UINT32_C(0xfff4)
	#define HWRM_NVM_VERIFY_UPDATE			UINT32_C(0xfff5)
	#define HWRM_NVM_GET_DEV_INFO			UINT32_C(0xfff6)
	#define HWRM_NVM_ERASE_DIR_ENTRY		UINT32_C(0xfff7)
	#define HWRM_NVM_MOD_DIR_ENTRY			UINT32_C(0xfff8)
	#define HWRM_NVM_FIND_DIR_ENTRY		UINT32_C(0xfff9)
	#define HWRM_NVM_GET_DIR_ENTRIES		UINT32_C(0xfffa)
	#define HWRM_NVM_GET_DIR_INFO			UINT32_C(0xfffb)
	#define HWRM_NVM_RAW_DUMP			UINT32_C(0xfffc)
	#define HWRM_NVM_READ				UINT32_C(0xfffd)
	#define HWRM_NVM_WRITE				UINT32_C(0xfffe)
	#define HWRM_NVM_RAW_WRITE_BLK			UINT32_C(0xffff)
	#define HWRM_LAST				HWRM_NVM_RAW_WRITE_BLK
	uint16_t	unused_0[3];
} cmd_nums_t, *pcmd_nums_t;

/* Return Codes */
/* ret_codes (size:64b/8B) */

typedef struct ret_codes {
	uint16_t	error_code;
	/* Request was successfully executed by the HWRM. */
	#define HWRM_ERR_CODE_SUCCESS			UINT32_C(0x0)
	/* The HWRM failed to execute the request. */
	#define HWRM_ERR_CODE_FAIL			UINT32_C(0x1)
	/*
	 * The request contains invalid argument(s) or input
	 * parameters.
	 */
	#define HWRM_ERR_CODE_INVALID_PARAMS		UINT32_C(0x2)
	/*
	 * The requester is not allowed to access the requested
	 * resource. This error code shall be provided in a
	 * response to a request to query or modify an existing
	 * resource that is not accessible by the requester.
	 */
	#define HWRM_ERR_CODE_RESOURCE_ACCESS_DENIED	UINT32_C(0x3)
	/*
	 * The HWRM is unable to allocate the requested resource.
	 * This code only applies to requests for HWRM resource
	 * allocations.
	 */
	#define HWRM_ERR_CODE_RESOURCE_ALLOC_ERROR	UINT32_C(0x4)
	/*
	 * Invalid combination of flags is specified in the
	 * request.
	 */
	#define HWRM_ERR_CODE_INVALID_FLAGS		UINT32_C(0x5)
	/*
	 * Invalid combination of enables fields is specified in
	 * the request.
	 */
	#define HWRM_ERR_CODE_INVALID_ENABLES		UINT32_C(0x6)
	/*
	 * Request contains a required TLV that is not supported by
	 * the installed version of firmware.
	 */
	#define HWRM_ERR_CODE_UNSUPPORTED_TLV		UINT32_C(0x7)
	/*
	 * No firmware buffer available to accept the request. Driver
	 * should retry the request.
	 */
	#define HWRM_ERR_CODE_NO_BUFFER			UINT32_C(0x8)
	/*
	 * This error code is only reported by firmware when some
	 * sub-option of a supported HWRM command is unsupported.
	 */
	#define HWRM_ERR_CODE_UNSUPPORTED_OPTION_ERR	UINT32_C(0x9)
	/*
	 * This error code is only reported by firmware when the specific
	 * request is not able to process when the HOT reset in progress.
	 */
	#define HWRM_ERR_CODE_HOT_RESET_PROGRESS	UINT32_C(0xa)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances are not capable of hot reset.
	 */
	#define HWRM_ERR_CODE_HOT_RESET_FAIL		UINT32_C(0xb)
	/*
	 * This error code is only reported by the firmware when during
	 * flow allocation when a request for a flow counter fails because
	 * the number of flow counters are exhausted.
	 */
	#define HWRM_ERR_CODE_NO_FLOW_COUNTER_DURING_ALLOC UINT32_C(0xc)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances requested to offloaded a flow but was unable to
	 * because the requested key's hash collides with the installed keys.
	 */
	#define HWRM_ERR_CODE_KEY_HASH_COLLISION	UINT32_C(0xd)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances requested to offloaded a flow but was unable to
	 * because the same key has already been installed.
	 */
	#define HWRM_ERR_CODE_KEY_ALREADY_EXISTS	UINT32_C(0xe)
	/*
	 * Generic HWRM execution error that represents an
	 * internal error.
	 */
	#define HWRM_ERR_CODE_HWRM_ERROR		UINT32_C(0xf)
	/*
	 * Firmware is unable to service the request at the present time.
	 * Caller may try again later.
	 */
	#define HWRM_ERR_CODE_BUSY			UINT32_C(0x10)
	/*
	 * This error code is reported by Firmware when an operation requested
	 * by the host is not allowed due to a secure lock violation.
	 */
	#define HWRM_ERR_CODE_RESOURCE_LOCKED		UINT32_C(0x11)
	/*
	 * This error code is reported by Firmware when an operation requested
	 * by a VF cannot be forwarded to the parent PF as required, either
	 * because the PF is down or otherwise doesn't have an appropriate
	 * async completion ring or associated forwarding buffers configured.
	 */
	#define HWRM_ERR_CODE_PF_UNAVAILABLE		UINT32_C(0x12)
	/*
	 * This error code is reported by Firmware when the specific entity
	 * requested by the host is not present or does not exist.
	 */
	#define HWRM_ERR_CODE_ENTITY_NOT_PRESENT	UINT32_C(0x13)
	/*
	 * This value indicates that the HWRM response is in TLV format and
	 * should be interpreted as one or more TLVs starting with the
	 * hwrm_resp_hdr TLV. This value is not an indication of any error
	 * by itself, just an indication that the response should be parsed
	 * as TLV and the actual error code will be in the hwrm_resp_hdr TLV.
	 */
	#define HWRM_ERR_CODE_TLV_ENCAPSULATED_RESPONSE	UINT32_C(0x8000)
	/* Unknown error */
	#define HWRM_ERR_CODE_UNKNOWN_ERR		UINT32_C(0xfffe)
	/* Unsupported or invalid command */
	#define HWRM_ERR_CODE_CMD_NOT_SUPPORTED		UINT32_C(0xffff)
	#define HWRM_ERR_CODE_LAST			HWRM_ERR_CODE_CMD_NOT_SUPPORTED
	uint16_t	unused_0[3];
} ret_codes_t, *pret_codes_t;

#define GET_HWRM_ERROR_CODE(x) \
	(((x) < 0x80) ? \
	((x) == 0x0 ? "SUCCESS": \
	((x) == 0x1 ? "FAIL": \
	((x) == 0x2 ? "INVALID_PARAMS": \
	((x) == 0x3 ? "RESOURCE_ACCESS_DENIED": \
	((x) == 0x4 ? "RESOURCE_ALLOC_ERROR": \
	((x) == 0x5 ? "INVALID_FLAGS": \
	((x) == 0x6 ? "INVALID_ENABLES": \
	((x) == 0x7 ? "UNSUPPORTED_TLV": \
	((x) == 0x8 ? "NO_BUFFER": \
	((x) == 0x9 ? "UNSUPPORTED_OPTION_ERR": \
	((x) == 0xa ? "HOT_RESET_PROGRESS": \
	((x) == 0xb ? "HOT_RESET_FAIL": \
	((x) == 0xc ? "NO_FLOW_COUNTER_DURING_ALLOC": \
	((x) == 0xd ? "KEY_HASH_COLLISION": \
	((x) == 0xe ? "KEY_ALREADY_EXISTS": \
	((x) == 0xf ? "HWRM_ERROR": \
	((x) == 0x10 ? "BUSY": \
	((x) == 0x11 ? "RESOURCE_LOCKED": \
	((x) == 0x12 ? "PF_UNAVAILABLE": \
	((x) == 0x13 ? "ENTITY_NOT_PRESENT": \
	"Unknown decode" )))))))))))))))))))) : \
	(((x) < 0x8080) ? \
	((x) == 0x8000 ? "TLV_ENCAPSULATED_RESPONSE": \
	"Unknown decode" ) : \
	(((x) <= UINT16_MAX) ? \
	((x) == 0xfffe ? "UNKNOWN_ERR": \
	((x) == 0xffff ? "CMD_NOT_SUPPORTED": \
	"Unknown decode" )) : \
	"Unknown decode" )))


/* Output */
/* hwrm_err_output (size:128b/16B) */

typedef struct hwrm_err_output {
	/*
	 * Pass/Fail or error type
	 *
	 * Note: receiver to verify the in parameters, and fail the call
	 * with an error when appropriate
	 */
	uint16_t	error_code;
	/* This field returns the type of original request. */
	uint16_t	req_type;
	/* This field provides original sequence number of the command. */
	uint16_t	seq_id;
	/*
	 * This field is the length of the response in bytes. The
	 * last byte of the response is a valid flag that will read
	 * as '1' when the command has been completely written to
	 * memory.
	 */
	uint16_t	resp_len;
	/* debug info for this error response. */
	uint32_t	opaque_0;
	/* debug info for this error response. */
	uint16_t	opaque_1;
	/*
	 * In the case of an error response, command specific error
	 * code is returned in this field.
	 */
	uint8_t	cmd_err;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_err_output_t, *phwrm_err_output_t;

/*
 * Following is the signature for HWRM message field that indicates not
 * applicable (All F's). Need to cast it the size of the field if needed.
 */
#define HWRM_NA_SIGNATURE ((uint32_t)(-1))
/*
 * This is reflecting the size of the PF mailbox and not the maximum
 * command size for any of the HWRM command structures. To determine
 * the maximum size of an HWRM command supported by the firmware, see
 * the max_ext_req_len field in the response of the HWRM_VER_GET command.
 */
#define HWRM_MAX_REQ_LEN 128
/* hwrm_cfa_flow_info */
#define HWRM_MAX_RESP_LEN 704
/* 7 bit indirection table index. */
#define HW_HASH_INDEX_SIZE 0x80
#define HW_HASH_KEY_SIZE 40
/* valid key for HWRM response */
#define HWRM_RESP_VALID_KEY 1
/* Reserved for BONO processor */
#define HWRM_TARGET_ID_BONO 0xFFF8
/* Reserved for KONG processor */
#define HWRM_TARGET_ID_KONG 0xFFF9
/* Reserved for APE processor */
#define HWRM_TARGET_ID_APE 0xFFFA
/*
 * This value will be used by tools for User-space HWRM Interface.
 * When tool execute any HWRM command with this target_id, firmware
 * will copy the response and/or data payload via register space instead
 * of DMAing it.
 */
#define HWRM_TARGET_ID_TOOLS 0xFFFD
#define HWRM_VERSION_MAJOR 1
#define HWRM_VERSION_MINOR 10
#define HWRM_VERSION_UPDATE 3
/* non-zero means beta version */
#define HWRM_VERSION_RSVD 61
#define HWRM_VERSION_STR "1.10.3.61"

/****************
 * hwrm_ver_get *
 ****************/


/* hwrm_ver_get_input (size:192b/24B) */

typedef struct hwrm_ver_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification.
	 */
	uint8_t	hwrm_intf_maj;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification.
	 * This can be due to addition or removal of functionality.
	 * HWRM interface specifications with the same major version
	 * but different minor versions are compatible.
	 */
	uint8_t	hwrm_intf_min;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * The interface update version is used to reflect minor
	 * changes or bug fixes to a released HWRM interface
	 * specification.
	 */
	uint8_t	hwrm_intf_upd;
	uint8_t	unused_0[5];
} hwrm_ver_get_input_t, *phwrm_ver_get_input_t;

/* hwrm_ver_get_output (size:1408b/176B) */

typedef struct hwrm_ver_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 1 in this field.
	 */
	uint8_t	hwrm_intf_maj_8b;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification.
	 * This can be due to addition or removal of functionality.
	 * HWRM interface specifications with the same major version
	 * but different minor versions are compatible.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint8_t	hwrm_intf_min_8b;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface update version is used to reflect minor
	 * changes or bug fixes to a released HWRM interface
	 * specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint8_t	hwrm_intf_upd_8b;
	uint8_t	hwrm_intf_rsvd_8b;
	/*
	 * This field represents the major version of HWRM firmware.
	 * A change in firmware major version represents a major
	 * firmware release.
	 */
	uint8_t	hwrm_fw_maj_8b;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint8_t	hwrm_fw_min_8b;
	/*
	 * This field represents the build version of HWRM firmware.
	 * A change in firmware build version represents bug fixes
	 * to a released firmware.
	 */
	uint8_t	hwrm_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version of the
	 * HWRM firmware.
	 */
	uint8_t	hwrm_fw_rsvd_8b;
	/*
	 * This field represents the major version of mgmt firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	mgmt_fw_maj_8b;
	/*
	 * This field represents the minor version of mgmt firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	mgmt_fw_min_8b;
	/*
	 * This field represents the build version of mgmt firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	mgmt_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	mgmt_fw_rsvd_8b;
	/*
	 * This field represents the major version of network
	 * control firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	netctrl_fw_maj_8b;
	/*
	 * This field represents the minor version of network
	 * control firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	netctrl_fw_min_8b;
	/*
	 * This field represents the build version of network
	 * control firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	netctrl_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	netctrl_fw_rsvd_8b;
	/*
	 * This field is used to indicate device's capabilities and
	 * configurations.
	 */
	uint32_t	dev_caps_cfg;
	/*
	 * If set to 1, then secure firmware update behavior
	 * is supported.
	 * If set to 0, then secure firmware update behavior is
	 * not supported.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SECURE_FW_UPD_SUPPORTED		UINT32_C(0x1)
	/*
	 * If set to 1, then firmware based DCBX agent is supported.
	 * If set to 0, then firmware based DCBX agent capability
	 * is not supported on this device.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FW_DCBX_AGENT_SUPPORTED		UINT32_C(0x2)
	/*
	 * If set to 1, then HWRM short command format is supported.
	 * If set to 0, then HWRM short command format is not supported.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SHORT_CMD_SUPPORTED			UINT32_C(0x4)
	/*
	 * If set to 1, then HWRM short command format is required.
	 * If set to 0, then HWRM short command format is not required.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SHORT_CMD_REQUIRED			UINT32_C(0x8)
	/*
	 * If set to 1, then the KONG host mailbox channel is supported.
	 * If set to 0, then the KONG host mailbox channel is not supported.
	 * By default, this flag should be 0 for older version of core
	 * firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_KONG_MB_CHNL_SUPPORTED		UINT32_C(0x10)
	/*
	 * If set to 1, then the 64bit flow handle is supported in addition
	 * to the legacy 16bit flow handle. If set to 0, then the 64bit flow
	 * handle is not supported. By default, this flag should be 0 for
	 * older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FLOW_HANDLE_64BIT_SUPPORTED		UINT32_C(0x20)
	/*
	 * If set to 1, then filter type can be provided in filter_alloc or
	 * filter_cfg filter types like L2 for l2 traffic and ROCE for roce &
	 * l2 traffic. If set to 0, then filter types not supported. By
	 * default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_L2_FILTER_TYPES_ROCE_OR_L2_SUPPORTED	UINT32_C(0x40)
	/*
	 * If set to 1, firmware is capable to support virtio vSwitch offload
	 * model. If set to 0, firmware can't supported virtio vSwitch
	 * offload model.
	 * By default, this flag should be 0 for older version of core
	 * firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_VIRTIO_VSWITCH_OFFLOAD_SUPPORTED	UINT32_C(0x80)
	/*
	 * If set to 1, firmware is capable to support trusted VF.
	 * If set to 0, firmware is not capable to support trusted VF.
	 * By default, this flag should be 0 for older version of core
	 * firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_TRUSTED_VF_SUPPORTED			UINT32_C(0x100)
	/*
	 * If set to 1, firmware is capable to support flow aging.
	 * If set to 0, firmware is not capable to support flow aging.
	 * By default, this flag should be 0 for older version of core
	 * firmware. (deprecated)
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FLOW_AGING_SUPPORTED			UINT32_C(0x200)
	/*
	 * If set to 1, firmware is capable to support advanced flow counters
	 * like, Meter drop counters and EEM counters.
	 * If set to 0, firmware is not capable to support advanced flow
	 * counters. By default, this flag should be 0 for older version of
	 * core firmware. (deprecated)
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_ADV_FLOW_COUNTERS_SUPPORTED		UINT32_C(0x400)
	/*
	 * If set to 1, the firmware is able to support the use of the CFA
	 * Extended Exact Match(EEM) feature.
	 * If set to 0, firmware is not capable to support the use of the
	 * CFA EEM feature.
	 * By default, this flag should be 0 for older version of core
	 * firmware. (deprecated)
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_EEM_SUPPORTED			UINT32_C(0x800)
	/*
	 * If set to 1, the firmware is able to support advance CFA flow
	 * management features reported in the HWRM_CFA_FLOW_MGNT_QCAPS.
	 * If set to 0, then the firmware doesn't support the advance CFA
	 * flow management features.
	 * By default, this flag should be 0 for older version of core
	 * firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_ADV_FLOW_MGNT_SUPPORTED		UINT32_C(0x1000)
	/*
	 * Deprecated and replaced with cfa_truflow_supported.
	 * If set to 1, the firmware is able to support TFLIB features.
	 * If set to 0, then the firmware doesn't support TFLIB features.
	 * By default, this flag should be 0 for older version of core
	 * firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_TFLIB_SUPPORTED			UINT32_C(0x2000)
	/*
	 * If set to 1, the firmware is able to support TruFlow features.
	 * If set to 0, then the firmware doesn't support TruFlow features.
	 * By default, this flag should be 0 for older version of
	 * core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_TRUFLOW_SUPPORTED			UINT32_C(0x4000)
	/*
	 * If set to 1, then firmware supports secure boot.
	 * If set to 0, then firmware doesn't support secure boot.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SECURE_BOOT_CAPABLE			UINT32_C(0x8000)
	/*
	 * If set to 1, then firmware is able to support the secure solution
	 * feature.
	 * If set to 0, then firmware does not support the secure solution
	 * feature.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SECURE_SOC_CAPABLE			UINT32_C(0x10000)
	/*
	 * This field represents the major version of RoCE firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	roce_fw_maj_8b;
	/*
	 * This field represents the minor version of RoCE firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	roce_fw_min_8b;
	/*
	 * This field represents the build version of RoCE firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	roce_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	roce_fw_rsvd_8b;
	/*
	 * This field represents the name of HWRM FW (ASCII chars
	 * with NULL at the end).
	 */
	char	hwrm_fw_name[16];
	/*
	 * This field represents the name of mgmt FW (ASCII chars
	 * with NULL at the end).
	 */
	char	mgmt_fw_name[16];
	/*
	 * This field represents the name of network control
	 * firmware (ASCII chars with NULL at the end).
	 */
	char	netctrl_fw_name[16];
	/* This field represents the active board package name. */
	char	active_pkg_name[16];
	/*
	 * This field represents the name of RoCE FW (ASCII chars
	 * with NULL at the end).
	 */
	char	roce_fw_name[16];
	/* This field returns the chip number. */
	uint16_t	chip_num;
	/* This field returns the revision of chip. */
	uint8_t	chip_rev;
	/* This field returns the chip metal number. */
	uint8_t	chip_metal;
	/* This field returns the bond id of the chip. */
	uint8_t	chip_bond_id;
	/*
	 * This value indicates the type of platform used for chip
	 * implementation.
	 */
	uint8_t	chip_platform_type;
	/* ASIC */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_ASIC	UINT32_C(0x0)
	/* FPGA platform of the chip. */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_FPGA	UINT32_C(0x1)
	/* Palladium platform of the chip. */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_PALLADIUM UINT32_C(0x2)
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_LAST	HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_PALLADIUM
	/*
	 * This field returns the maximum value of request window that
	 * is supported by the HWRM. The request window is mapped
	 * into device address space using MMIO.
	 */
	uint16_t	max_req_win_len;
	/*
	 * This field returns the maximum value of response buffer in
	 * bytes.
	 */
	uint16_t	max_resp_len;
	/*
	 * This field returns the default request timeout value in
	 * milliseconds.
	 */
	uint16_t	def_req_timeout;
	/*
	 * This field will indicate if any subsystems is not fully
	 * initialized.
	 */
	uint8_t	flags;
	/*
	 * If set to 1, it will indicate to host drivers that firmware is
	 * not ready to start full blown HWRM commands. Host drivers should
	 * re-try HWRM_VER_GET with some timeout period. The timeout period
	 * can be selected up to 5 seconds. Host drivers should also check
	 * for dev_not_rdy_backing_store to identify if flag is set due to
	 * backing store not been available.
	 * For Example, PCIe hot-plug:
	 *	Hot plug timing is system dependent. It generally takes up to
	 *	600 milliseconds for firmware to clear DEV_NOT_RDY flag.
	 * If set to 0, device is ready to accept all HWRM commands.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_DEV_NOT_RDY		UINT32_C(0x1)
	/*
	 * If set to 1, external version present.
	 * If set to 0, external version not present.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_EXT_VER_AVAIL		UINT32_C(0x2)
	/*
	 * Firmware sets this flag along with dev_not_rdy flag to indicate
	 * host drivers that it has not completed resource initialization
	 * required for data path operations. Host drivers should not send
	 * any HWRM command that requires data path resources. Firmware will
	 * fail those commands with HWRM_ERR_CODE_BUSY. Host drivers can
	 * retry those commands once both the flags are cleared.
	 * If this flag and dev_not_rdy flag are set to 0, device is ready
	 * to accept all HWRM commands.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_DEV_NOT_RDY_BACKING_STORE	UINT32_C(0x4)
	uint8_t	unused_0[2];
	/*
	 * For backward compatibility this field must be set to 1.
	 * Older drivers might look for this field to be 1 before
	 * processing the message.
	 */
	uint8_t	always_1;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification. A HWRM implementation that is
	 * compliant with this specification shall provide value of 1
	 * in this field.
	 */
	uint16_t	hwrm_intf_major;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification. This can be due to addition or
	 * removal of functionality. HWRM interface specifications
	 * with the same major version but different minor versions are
	 * compatible. A HWRM implementation that is compliant with
	 * this specification shall provide value of 2 in this field.
	 */
	uint16_t	hwrm_intf_minor;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the HWRM implementation. The
	 * interface update version is used to reflect minor changes or
	 * bug fixes to a released HWRM interface specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint16_t	hwrm_intf_build;
	/*
	 * This field represents the patch version of HWRM interface
	 * specification supported by the HWRM implementation.
	 */
	uint16_t	hwrm_intf_patch;
	/*
	 * This field represents the major version of HWRM firmware.
	 * A change in firmware major version represents a major
	 * firmware release.
	 */
	uint16_t	hwrm_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint16_t	hwrm_fw_minor;
	/*
	 * This field represents the build version of HWRM firmware.
	 * A change in firmware build version represents bug fixes to
	 * a released firmware.
	 */
	uint16_t	hwrm_fw_build;
	/*
	 * This field is a reserved field.
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major,minor,update) version
	 * of the HWRM firmware.
	 */
	uint16_t	hwrm_fw_patch;
	/*
	 * This field represents the major version of mgmt firmware.
	 * A change in major version represents a major release.
	 */
	uint16_t	mgmt_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint16_t	mgmt_fw_minor;
	/*
	 * This field represents the build version of mgmt firmware.
	 * A change in update version represents bug fixes.
	 */
	uint16_t	mgmt_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version.
	 */
	uint16_t	mgmt_fw_patch;
	/*
	 * This field represents the major version of network control
	 * firmware. A change in major version represents
	 * a major release.
	 */
	uint16_t	netctrl_fw_major;
	/*
	 * This field represents the minor version of network control
	 * firmware. A change in minor version represents significant
	 * functionality changes.
	 */
	uint16_t	netctrl_fw_minor;
	/*
	 * This field represents the build version of network control
	 * firmware. A change in update version represents bug fixes.
	 */
	uint16_t	netctrl_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint16_t	netctrl_fw_patch;
	/*
	 * This field represents the major version of RoCE firmware.
	 * A change in major version represents a major release.
	 */
	uint16_t	roce_fw_major;
	/*
	 * This field represents the minor version of RoCE firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint16_t	roce_fw_minor;
	/*
	 * This field represents the build version of RoCE firmware.
	 * A change in update version represents bug fixes.
	 */
	uint16_t	roce_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint16_t	roce_fw_patch;
	/*
	 * This field returns the maximum extended request length acceptable
	 * by the device which allows requests greater than mailbox size when
	 * used with the short cmd request format.
	 */
	uint16_t	max_ext_req_len;
	/*
	 * This field returns the maximum request timeout value in seconds.
	 * For backward compatibility, a value of zero should be interpreted
	 * as the default value of 40 seconds. Drivers should always honor the
	 * maximum timeout, but are permitted to warn if a longer duration than
	 * this default is advertised. Values larger than 40 seconds should
	 * only be used as a stopgap measure to address a device limitation or
	 * for the purposes of test and debugging. The long term goal is for
	 * firmware to significantly reduce this value in the passage of time.
	 */
	uint16_t	max_req_timeout;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ver_get_output_t, *phwrm_ver_get_output_t;

/* cfa_bds_read_cmd_data_msg (size:128b/16B) */

typedef struct cfa_bds_read_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is read command. From 32 to 128B can be read from a table
	 * using this command.
	 */
	#define CFA_BDS_READ_CMD_DATA_MSG_OPCODE_READ UINT32_C(0x0)
	#define CFA_BDS_READ_CMD_DATA_MSG_OPCODE_LAST CFA_BDS_READ_CMD_DATA_MSG_OPCODE_READ
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
		#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_EM	UINT32_C(0x1)
		#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_LAST   CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_READ_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_READ_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 * this command is read from. The bottom two bits of this value must be
	 * zero. The size of the write is controlled by the data_size field.
	 */
	uint64_t	host_address;
} cfa_bds_read_cmd_data_msg_t, *pcfa_bds_read_cmd_data_msg_t;

/* cfa_bds_write_cmd_data_msg (size:1152b/144B) */

typedef struct cfa_bds_write_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is write command. From 32 to 128B can be written to a table
	 * using this command.
	 */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_WRITE UINT32_C(0x1)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_LAST CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_WRITE
	/* This value selects the table type to be acted upon. */
	uint8_t	write_thru_table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
		#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_EM	UINT32_C(0x1)
		#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_LAST   CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_EM
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_WRITE_THRU	UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	uint32_t	unused0;
	uint32_t	unused1;
	/*
	 * This is the data to be written. Data length is determined by the
	 * data_size field. The bd_cnt in the encapsulating BD must also be set
	 * correctly to ensure that the BD is processed correctly and the full
	 * WRITE_CMD message is extracted from the BD.
	 */
	uint32_t	dta[32];
} cfa_bds_write_cmd_data_msg_t, *pcfa_bds_write_cmd_data_msg_t;

/* cfa_bds_read_clr_cmd_data_msg (size:256b/32B) */

typedef struct cfa_bds_read_clr_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is read-clear command. 32B can be read from a table and
	 * a 16b mask can be used to clear specific 16b units after the
	 * read as an atomic operation.
	 */
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_READ_CLR UINT32_C(0x2)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_READ_CLR
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
		#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_EM	UINT32_C(0x1)
		#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_LAST   CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed.
	 * Always set the value to 1.
	 */
	uint8_t	data_size;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 * this command is read from. The bottom two bits of this value must be
	 * zero. The size of the write is controlled by the data_size field.
	 */
	uint64_t	host_address;
	/*
	 * This is active high clear mask for the 32B of data that this command
	 * can read. Bit 0 of the field will clear bits 15:0 of the first word
	 * of data read when set to '1'.
	 */
	uint16_t	clear_mask;
	uint16_t	unused0[3];
	uint16_t	unused1[4];
} cfa_bds_read_clr_cmd_data_msg_t, *pcfa_bds_read_clr_cmd_data_msg_t;

/* cfa_bds_em_insert_cmd_data_msg (size:1152b/144B) */

typedef struct cfa_bds_em_insert_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * An exact match table insert will be attempted into the table.
	 * If there is a free location in the bucket, the payload will
	 * be written to the bucket.
	 */
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_EM_INSERT UINT32_C(0x3)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_EM_INSERT
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	uint8_t	write_thru;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_UNUSED_MASK	UINT32_C(0xf)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_UNUSED_SFT	0
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_WRITE_THRU	UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
	/*
	 * This is the Exact Match Lookup Record. Data length is determined by
	 * the data_size field. The bd_cnt in the encapsulating BD must also be
	 */
	uint32_t	dta[32];
} cfa_bds_em_insert_cmd_data_msg_t, *pcfa_bds_em_insert_cmd_data_msg_t;

/* cfa_bds_em_delete_cmd_data_msg (size:256b/32B) */

typedef struct cfa_bds_em_delete_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/* An exact match table delete will be attempted. */
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_EM_DELETE UINT32_C(0x4)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_EM_DELETE
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	uint8_t	write_thru;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_UNUSED_MASK	UINT32_C(0xf)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_UNUSED_SFT	0
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_WRITE_THRU	UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	uint32_t	unused0;
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
	/*
	 * This is the Exact Match Lookup Record. Data length is determined by
	 * the data_size field. The bd_cnt in the encapsulating BD must also be
	 */
	uint64_t	dta;
	uint64_t	unused1;
} cfa_bds_em_delete_cmd_data_msg_t, *pcfa_bds_em_delete_cmd_data_msg_t;

/* cfa_bds_invalidate_cmd_data_msg (size:128b/16B) */

typedef struct cfa_bds_invalidate_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * The specified table area will be invalidated. If it is needed.
	 * again, it will be read from the backing store.
	 */
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_INVALIDATE UINT32_C(0x5)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_INVALIDATE
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
		#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_EM	UINT32_C(0x1)
		#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_LAST   CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/* This value specifies the number of cache lines to invalidate. */
	uint8_t	data_size;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	uint64_t	unused;
} cfa_bds_invalidate_cmd_data_msg_t, *pcfa_bds_invalidate_cmd_data_msg_t;

/* cfa_bds_event_collect_cmd_data_msg (size:128b/16B) */

typedef struct cfa_bds_event_collect_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/* Reads notification messages from the Host Notification Queue. */
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_EVENT_COLLECT UINT32_C(0x6)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_EVENT_COLLECT
	uint8_t	unused0;
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_DATA_SIZE_SFT 0
	uint32_t	unused1;
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
} cfa_bds_event_collect_cmd_data_msg_t, *pcfa_bds_event_collect_cmd_data_msg_t;

/* ce_bds_add_data_msg (size:576b/72B) */

typedef struct ce_bds_add_data_msg {
	uint32_t	version_algorithm_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_ADD_DATA_MSG_OPCODE_MASK		UINT32_C(0xf)
	#define CE_BDS_ADD_DATA_MSG_OPCODE_SFT		0
	/*
	 * This is the add command. Using this opcode, Host Driver can add
	 * information required for kTLS processing. The information is
	 * updated in the CFCK context.
	 */
		#define CE_BDS_ADD_DATA_MSG_OPCODE_ADD		UINT32_C(0x1)
		#define CE_BDS_ADD_DATA_MSG_OPCODE_LAST		CE_BDS_ADD_DATA_MSG_OPCODE_ADD
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_ADD_DATA_MSG_KID_MASK		UINT32_C(0xfffff0)
	#define CE_BDS_ADD_DATA_MSG_KID_SFT		4
	/*
	 * Currently only two algorithms are supported, AES_GCM_128 and
	 * AES_GCM_256. Additional bits for future growth.
	 */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_MASK		UINT32_C(0xf000000)
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_SFT		24
	/* AES_GCM_128 Algorithm */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_AES_GCM_128	UINT32_C(0x1000000)
	/* AES_GCM_256 Algorithm */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_AES_GCM_256	UINT32_C(0x2000000)
	/*
	 * Version number of TLS connection. HW will provide registers that
	 * converts the 4b encoded version number to 16b of actual version
	 * number in the TLS Header. This field is initialized/updated by
	 * this "KTLS crypto add" mid-path command.
	 */
	#define CE_BDS_ADD_DATA_MSG_VERSION_MASK		UINT32_C(0xf0000000)
	#define CE_BDS_ADD_DATA_MSG_VERSION_SFT		28
	/* TLS1.2 Version */
		#define CE_BDS_ADD_DATA_MSG__TLS1_2			(UINT32_C(0x0) << 28)
	/* TLS1.3 Version */
		#define CE_BDS_ADD_DATA_MSG__TLS1_3			(UINT32_C(0x1) << 28)
		#define CE_BDS_ADD_DATA_MSG__LAST			CE_BDS_ADD_DATA_MSG__TLS1_3
	uint8_t	ctx_kind;
	/* This field selects the context kind for the request. */
	#define CE_BDS_ADD_DATA_MSG_CTX_KIND_MASK UINT32_C(0x1f)
	#define CE_BDS_ADD_DATA_MSG_CTX_KIND_SFT  0
	/* Crypto key transmit context */
		#define CE_BDS_ADD_DATA_MSG_CTX_KIND_CK_TX  UINT32_C(0x11)
	/* Crypto key receive context */
		#define CE_BDS_ADD_DATA_MSG_CTX_KIND_CK_RX  UINT32_C(0x12)
		#define CE_BDS_ADD_DATA_MSG_CTX_KIND_LAST  CE_BDS_ADD_DATA_MSG_CTX_KIND_CK_RX
	uint8_t	unused0[3];
	/*
	 * Salt is part of the nonce that is used as the Initial Vector (IV) in
	 * AES-GCM cipher suites. These are exchanged as part of the handshake
	 * process and is either the client_write_iv (when the client is
	 * sending) or server_write_iv (when the server is sending). In
	 * TLS1.2, 4B of Salt is concatenated with 8B of explicit_nonce to
	 * generate the 12B of IV. In TLS1.3, 8B of TLS record sequence number
	 * is zero padded to 12B and then xor'ed with the 4B of salt to generate
	 * the 12B of IV. This value is initialized by this mid-path command.
	 */
	uint8_t	salt[4];
	uint8_t	unused1[4];
	/*
	 * This field keeps track of the TCP sequence number that is expected as
	 * the first byte in the next TCP packet. This field is calculated by HW
	 * using the output of the parser. The field is initialized as part of
	 * the Mid-path BD download/update of a kTLS connection. For every TCP
	 * packet processed, TCE HW will update the value to Current packet TCP
	 * sequence number + Current packet TCP Payload Length.
	 */
	uint32_t	pkt_tcp_seq_num;
	/*
	 * This field maintains the TCP sequence number of the first byte in the
	 * header of the active TLS record. This field is initialized as part of
	 * the Mid-path BD download/update of a kTLS connection. For every
	 * record that is processed, TCE HW copies the value from the
	 * next_tls_header_tcp_seq_num field.
	 */
	uint32_t	tls_header_tcp_seq_num;
	/*
	 * This is sequence number for the TLS record in a particular session.
	 * In TLS1.2, record sequence number is part of the Associated Data (AD)
	 * in the AEAD algorithm. In TLS1.3, record sequence number is part of
	 * the Initial Vector (IV). The field is initialized as part of the
	 * mid-path BD download/update of a kTLS connection. TCE HW increments
	 * the field after that for every record processed as it parses the TCP
	 * packet.
	 */
	uint64_t	record_seq_num;
	/*
	 * Key used for encrypting or decrypting TLS records. The Key is
	 * exchanged during the hand-shake protocol by the client-server and
	 * provided to HW through this mid-path BD.
	 */
	uint8_t	session_key[32];
	/*
	 * Additional IV that is exchanged as part of sessions setup between
	 * the two end points. This field is used for TLS1.3 only.
	 */
	uint8_t	addl_iv[8];
} ce_bds_add_data_msg_t, *pce_bds_add_data_msg_t;

/* ce_bds_delete_data_msg (size:32b/4B) */

typedef struct ce_bds_delete_data_msg {
	uint32_t	kid_opcode_ctx_kind;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_DELETE_DATA_MSG_OPCODE_MASK	UINT32_C(0xf)
	#define CE_BDS_DELETE_DATA_MSG_OPCODE_SFT	0
	/*
	 * This is the delete command. Using this opcode, the host Driver
	 * can remove a key context from the CFCK. If context is deleted
	 * and packets with the same KID come through the pipeline, the
	 * following actions are taken. For transmit packets, no crypto
	 * operation will be performed, payload will be zero'ed out. For
	 * receive packets, no crypto operation will be performed,
	 * payload will be unmodified.
	 */
		#define CE_BDS_DELETE_DATA_MSG_OPCODE_DELETE	UINT32_C(0x2)
		#define CE_BDS_DELETE_DATA_MSG_OPCODE_LAST	CE_BDS_DELETE_DATA_MSG_OPCODE_DELETE
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_DELETE_DATA_MSG_KID_MASK	UINT32_C(0xfffff0)
	#define CE_BDS_DELETE_DATA_MSG_KID_SFT	4
	/* This field selects the context kind for the request. */
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_MASK   UINT32_C(0x1f000000)
	#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_SFT	24
	/* Crypto Key Transmit Context. */
		#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_CK_TX	(UINT32_C(0x11) << 24)
	/* Crypto Key Receive Context. */
		#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_CK_RX	(UINT32_C(0x12) << 24)
	/* QUIC Key Transmit Context. */
		#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_QUIC_TX  (UINT32_C(0x14) << 24)
	/* QUIC Key Receive Context. */
		#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_QUIC_RX  (UINT32_C(0x15) << 24)
		#define CE_BDS_DELETE_DATA_MSG_CTX_KIND_LAST	CE_BDS_DELETE_DATA_MSG_CTX_KIND_QUIC_RX
} ce_bds_delete_data_msg_t, *pce_bds_delete_data_msg_t;

/* ce_bds_resync_resp_ack_msg (size:128b/16B) */

typedef struct ce_bds_resync_resp_ack_msg {
	uint32_t	resync_status_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_MASK	UINT32_C(0xf)
	#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_SFT	0
	/*
	 * This command is used by the driver as a response to the resync
	 * request sent by the crypto engine.
	 */
		#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_RESYNC	UINT32_C(0x3)
		#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_LAST	CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_RESYNC
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_KID_MASK	UINT32_C(0xfffff0)
	#define CE_BDS_RESYNC_RESP_ACK_MSG_KID_SFT	4
	/*
	 * This field indicates if the resync request resulted in a success or
	 * a failure.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS	UINT32_C(0x1000000)
	/*
	 * An ACK indicates that the driver was able to find the TLS record
	 * associated with TCP sequence number provided by the HW
	 */
		#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_ACK   (UINT32_C(0x0) << 24)
		#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_LAST CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_ACK
	/*
	 * This field is the echo of the TCP sequence number provided in the
	 * resync request by the HW. If HW sent multiple resync requests, it
	 * only tracks the latest TCP sequence number. When the response from
	 * the Driver doesn't match the latest request, HW will drop the resync
	 * response.
	 */
	uint32_t	resync_record_tcp_seq_num;
	/*
	 * This field indicates the TLS record sequence number associated with
	 * the resync request. HW will take this number and add the delta records
	 * it has found since sending the resync request, update the context and
	 * resume decrypting records.
	 */
	uint64_t	resync_record_seq_num;
} ce_bds_resync_resp_ack_msg_t, *pce_bds_resync_resp_ack_msg_t;

/* ce_bds_resync_resp_nack_msg (size:64b/8B) */

typedef struct ce_bds_resync_resp_nack_msg {
	uint32_t	resync_status_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_MASK	UINT32_C(0xf)
	#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_SFT	0
	/*
	 * This command is used by the driver as a response to the resync
	 * request sent by the crypto engine.
	 */
		#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_RESYNC	UINT32_C(0x3)
		#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_LAST	CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_RESYNC
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_KID_MASK	UINT32_C(0xfffff0)
	#define CE_BDS_RESYNC_RESP_NACK_MSG_KID_SFT	4
	/*
	 * This field indicates if the resync request resulted in a success or
	 * a failure.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS	UINT32_C(0x1000000)
	/*
	 * An NAK indicates that the driver wasn't able to find the TLS
	 * record associated with TCP sequence number provided by the HW
	 */
		#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_NACK  (UINT32_C(0x1) << 24)
		#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_LAST CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_NACK
	/*
	 * This field is the echo of the TCP sequence number provided in the
	 * resync request by the HW. If HW sent multiple resync requests, it
	 * only tracks the latest TCP sequence number. When the response from
	 * the Driver doesn't match the latest request, HW will drop the resync
	 * response.
	 */
	uint32_t	resync_record_tcp_seq_num;
} ce_bds_resync_resp_nack_msg_t, *pce_bds_resync_resp_nack_msg_t;

/* crypto_presync_bd_cmd (size:256b/32B) */

typedef struct crypto_presync_bd_cmd {
	uint8_t	flags;
	/*
	 * Typically, presync BDs are used for packet retransmissions. Source
	 * port sends all the packets in order over the network to destination
	 * port and packets get dropped in the network. The destination port
	 * will request retransmission of dropped packets and source port
	 * driver will send presync BD to setup the transmitter appropriately.
	 * It will provide the start and end TCP sequence number of the data to
	 * be transmitted. HW keeps two sets of context variable, one for in
	 * order traffic and one for retransmission traffic. HW is designed to
	 * transmit everything posted in the presync BD and return to in order
	 * mode after that. No inorder context variables are updated in the
	 * process. There is a special case where packets can be dropped
	 * between the TCP stack and Device Driver (Berkeley Packet Filter for
	 * ex) and HW still needs to transmit rest of the traffic. In this
	 * mode, driver will send a presync BD as if it is a retransmission but
	 * at the end of the transmission, the in order variables need to be
	 * updated. This flag is used by driver to indicate that in order
	 * variables needs to be updated at the end of completing the task
	 * associated with the presync BD.
	 */
	#define CRYPTO_PRESYNC_BD_CMD_FLAGS_UPDATE_IN_ORDER_VAR	UINT32_C(0x1)
	/*
	 * When packet with an authentication TAG is lost in the network,
	 * During retransmission Device driver will post the entire record for
	 * the hardware to recalculate the TAG. Hardware is set to retransmit
	 * only portions of the record, it does so by looking at the Header
	 * TCP Sequence Number and Start TCP Sequence Number. However, there
	 * is a case where the header packet gets dropped in the stack for ex
	 * BPF packet filter and it is impossible for the Hardware to
	 * determine if this is a case of full replay for only the TAG
	 * generation.
	 */
	#define CRYPTO_PRESYNC_BD_CMD_FLAGS_FULL_REPLAY_RETRAN	UINT32_C(0x2)
	uint8_t	unused0;
	uint16_t	unused1;
	/*
	 * This field maintains the TCP sequence number of the first byte in the
	 * Header of the active TLS record. This field is set to 0 during
	 * mid-path BD updates, but is set to correct value when a presync BD is
	 * detected. For every record that is processed, the value from the
	 * next_tls_header_tcp_seq_num field is copied.
	 */
	uint32_t	header_tcp_seq_num;
	/*
	 * When a retransmitted packet has a TLS authentication TAG present and
	 * the data spans multiple TCP Packets, HW is required to read the entire
	 * record to recalculate the TAG but only transmit what is required. This
	 * field is the start TCP sequence number of the packet(s) that need to
	 * be re-transmitted. This field is initialized to 0 during Mid-path BD
	 * add command and initialized to value provided by the driver when
	 * Pre-sync BD is detected. This field is never updated unless another
	 * Pre-sync BD signaling a new retransmission is scheduled.
	 */
	uint32_t	start_tcp_seq_num;
	/*
	 * When a retransmitted packet has a TLS authentication TAG present and
	 * the data spans multiple TCP Packets, HW is required to read the
	 * entire record to recalculate the TAG but only transmit what is
	 * required. This field is the end TCP sequence number of the packet(s)
	 * that need to be re-transmitted. This field is initialized to 0 during
	 * Mid-path BD add command and initialized to value provided by the
	 * driver when Pre-sync BD is detected. This field is never updated
	 * unless another Pre-sync BD signaling a new retransmission is
	 * scheduled.
	 */
	uint32_t	end_tcp_seq_num;
	/*
	 * For TLS1.2, an explicit nonce is used as part of the IV (concatenated
	 * with the SALT). For retrans packets, this field is extracted from the
	 * TLS record, field right after the TLS Header and stored in the
	 * context. This field needs to be stored in context as TCP segmentation
	 * could have split the field into multiple TCP packets. This value is
	 * initialized to 0 when presync BD is detected by taking the value from
	 * the first TLS header. When subsequent TLS Headers are detected, the
	 * value is extracted from packet.
	 */
	uint8_t	explicit_nonce[8];
	/*
	 * This is sequence number for the TLS record in a particular session. In
	 * TLS1.2, record sequence number is part of the Associated Data (AD) in
	 * the AEAD algorithm. In TLS1.3, record sequence number is part of the
	 * Initial Vector (IV). The field is initialized to 0 during Mid-path BD
	 * download. Is initialized to correct value when a pre-sync BD is
	 * detected. TCE HW increments the field after that for every record
	 * processed as it parses the TCP packet. Subsequent pre-sync BDs
	 * delivering more retransmission instruction will also update this
	 * field.
	 */
	uint64_t	record_seq_num;
} crypto_presync_bd_cmd_t, *pcrypto_presync_bd_cmd_t;

/* ce_bds_quic_add_data_msg (size:832b/104B) */

typedef struct ce_bds_quic_add_data_msg {
	uint32_t	ver_algo_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_MASK	UINT32_C(0xf)
	#define CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_SFT	0
	/*
	 * This is the add command. Using this opcode, Host Driver can add
	 * information required for QUIC processing. The information is
	 * updated in the CFCK context.
	 */
		#define CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_ADD		UINT32_C(0x1)
		#define CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_LAST	CE_BDS_QUIC_ADD_DATA_MSG_OPCODE_ADD
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated QUIC offloaded connection.
	 */
	#define CE_BDS_QUIC_ADD_DATA_MSG_KID_MASK		UINT32_C(0xfffff0)
	#define CE_BDS_QUIC_ADD_DATA_MSG_KID_SFT		4
	/* Algorithm used for encryption and decryption. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_MASK	UINT32_C(0xf000000)
	#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_SFT	24
	/* AES_GCM_128 Algorithm. */
		#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_AES_GCM_128  (UINT32_C(0x1) << 24)
	/* AES_GCM_256 Algorithm. */
		#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_AES_GCM_256  (UINT32_C(0x2) << 24)
	/* Chacha20 Algorithm. */
		#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_CHACHA20	(UINT32_C(0x3) << 24)
		#define CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_LAST	CE_BDS_QUIC_ADD_DATA_MSG_ALGORITHM_CHACHA20
	/* Version number of QUIC connection. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_VERSION_MASK	UINT32_C(0xf0000000)
	#define CE_BDS_QUIC_ADD_DATA_MSG_VERSION_SFT	28
	/* TLS1.2 Version */
		#define CE_BDS_QUIC_ADD_DATA_MSG__TLS1_2		(UINT32_C(0x0) << 28)
	/* TLS1.3 Version */
		#define CE_BDS_QUIC_ADD_DATA_MSG__TLS1_3		(UINT32_C(0x1) << 28)
	/* DTLS1.2 Version */
		#define CE_BDS_QUIC_ADD_DATA_MSG__DTLS1_2		(UINT32_C(0x2) << 28)
	/* DTLS1.2 for RoCE Version */
		#define CE_BDS_QUIC_ADD_DATA_MSG__DTLS1_2_ROCE	(UINT32_C(0x3) << 28)
	/* QUIC Version */
		#define CE_BDS_QUIC_ADD_DATA_MSG__QUIC		(UINT32_C(0x4) << 28)
		#define CE_BDS_QUIC_ADD_DATA_MSG__LAST		CE_BDS_QUIC_ADD_DATA_MSG__QUIC
	uint32_t	ctx_kind_dcid_width_key_phase;
	/* Key phase. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_KEY_PHASE	UINT32_C(0x1)
	/* Destination connection ID width. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_DCID_WIDTH_MASK UINT32_C(0x3e)
	#define CE_BDS_QUIC_ADD_DATA_MSG_DCID_WIDTH_SFT  1
	/* This field selects the context kind for the request. */
	#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_MASK   UINT32_C(0x7c0)
	#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_SFT	6
	/* QUIC key transmit context */
		#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_QUIC_TX  (UINT32_C(0x14) << 6)
	/* QUIC key receive context */
		#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_QUIC_RX  (UINT32_C(0x15) << 6)
		#define CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_LAST	CE_BDS_QUIC_ADD_DATA_MSG_CTX_KIND_QUIC_RX
	uint64_t	unused_0;
	/*
	 * Least-significant 64 bits (of 96) of additional IV that is
	 * exchanged as part of sessions setup between the two end
	 * points for QUIC operations.
	 */
	uint8_t	quic_iv_lo[8];
	/*
	 * Most-significant 32 bits (of 96) of additional IV that is
	 * exchanged as part of sessions setup between the two end
	 * points for QUIC operations.
	 */
	uint8_t	quic_iv_hi[4];
	uint32_t	unused_1;
	/*
	 * Key used for encrypting or decrypting records. The Key is exchanged
	 * as part of sessions setup between the two end points through this
	 * mid-path BD.
	 */
	uint8_t	session_key[32];
	/* Header protection key. */
	uint8_t	hp_key[32];
	/* Packet number associated with the QUIC connection. */
	uint64_t	pkt_number;
} ce_bds_quic_add_data_msg_t, *pce_bds_quic_add_data_msg_t;

/* bd_base (size:64b/8B) */

typedef struct bd_base {
	uint8_t	type;
	/* This value identifies the type of buffer descriptor. */
	#define BD_BASE_TYPE_MASK		UINT32_C(0x3f)
	#define BD_BASE_TYPE_SFT		0
	/*
	 * Indicates that this BD is 16B long and is used for
	 * normal L2 packet transmission.
	 */
		#define BD_BASE_TYPE_TX_BD_SHORT	UINT32_C(0x0)
	/*
	 * Indicates that this BD is 1BB long and is an empty
	 * TX BD. Not valid for use by the driver.
	 */
		#define BD_BASE_TYPE_TX_BD_EMPTY	UINT32_C(0x1)
	/*
	 * Indicates that this BD is 16B long and is an RX Producer
	 * (i.e. empty) buffer descriptor.
	 */
		#define BD_BASE_TYPE_RX_PROD_PKT	UINT32_C(0x4)
	/*
	 * Indicates that this BD is 16B long and is an RX
	 * Producer Buffer BD.
	 */
		#define BD_BASE_TYPE_RX_PROD_BFR	UINT32_C(0x5)
	/*
	 * Indicates that this BD is 16B long and is an
	 * RX Producer Assembly Buffer Descriptor.
	 */
		#define BD_BASE_TYPE_RX_PROD_AGG	UINT32_C(0x6)
	/*
	 * Indicates that this BD is used to issue a command to one of
	 * the mid-path destinations.
	 */
		#define BD_BASE_TYPE_TX_BD_MP_CMD	UINT32_C(0x8)
	/*
	 * Indicates that this BD is used to issue a cryptographic pre-
	 * sync command through the fast path and destined for TCE.
	 */
		#define BD_BASE_TYPE_TX_BD_PRESYNC_CMD  UINT32_C(0x9)
	/*
	 * Indicates a timed transmit BD. This is a 16b BD that is inserted
	 * into a packet BD chain immediately after the first BD. It is used
	 * to control the flow in a timed transmit operation.
	 */
		#define BD_BASE_TYPE_TX_BD_TIMEDTX	UINT32_C(0xa)
	/*
	 * Indicates that this BD is 32B long and is used for
	 * normal L2 packet transmission.
	 */
		#define BD_BASE_TYPE_TX_BD_LONG	UINT32_C(0x10)
	/*
	 * Indicates that this BD is 32B long and is used for
	 * L2 packet transmission for small packets that require
	 * low latency.
	 */
		#define BD_BASE_TYPE_TX_BD_LONG_INLINE  UINT32_C(0x11)
		#define BD_BASE_TYPE_LAST		BD_BASE_TYPE_TX_BD_LONG_INLINE
	uint8_t	unused_1[7];
} bd_base_t, *pbd_base_t;

/* tx_bd_short (size:128b/16B) */

typedef struct tx_bd_short {
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_SHORT_TYPE_MASK		UINT32_C(0x3f)
	#define TX_BD_SHORT_TYPE_SFT		0
	/*
	 * Indicates that this BD is 16B long and is used for
	 * normal L2 packet transmission.
	 */
		#define TX_BD_SHORT_TYPE_TX_BD_SHORT	UINT32_C(0x0)
		#define TX_BD_SHORT_TYPE_LAST		TX_BD_SHORT_TYPE_TX_BD_SHORT
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_BD_SHORT_FLAGS_SFT		6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_SHORT_FLAGS_PACKET_END	UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in it's
	 * processing.
	 * If this bit
	 * is set to 0, then the packet will be completed normally.
	 *
	 * This bit must be valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_NO_CMPL	UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet.
	 * A value of 1 indicates that this BD is the only BD (and that
	 * it is a short BD). A value
	 * of 3 indicates either 3 short BDs or 1 long BD and one short
	 * BD in the packet. A value of 0 indicates
	 * that there are 32 BD locations in the packet (the maximum).
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define TX_BD_SHORT_FLAGS_BD_CNT_SFT	8
	/*
	 * This value is a hint for the length of the entire packet.
	 * It is used by the chip to optimize internal processing.
	 *
	 * The packet will be dropped if the hint is too short.
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_LHINT_MASK	UINT32_C(0x6000)
	#define TX_BD_SHORT_FLAGS_LHINT_SFT	13
	/* indicates packet length < 512B */
		#define TX_BD_SHORT_FLAGS_LHINT_LT512	(UINT32_C(0x0) << 13)
	/* indicates 512 <= packet length < 1KB */
		#define TX_BD_SHORT_FLAGS_LHINT_LT1K	(UINT32_C(0x1) << 13)
	/* indicates 1KB <= packet length < 2KB */
		#define TX_BD_SHORT_FLAGS_LHINT_LT2K	(UINT32_C(0x2) << 13)
	/* indicates packet length >= 2KB */
		#define TX_BD_SHORT_FLAGS_LHINT_GTE2K	(UINT32_C(0x3) << 13)
		#define TX_BD_SHORT_FLAGS_LHINT_LAST	TX_BD_SHORT_FLAGS_LHINT_GTE2K
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_COAL_NOW	UINT32_C(0x8000)
	/*
	 * This is the length of the host physical buffer this BD describes
	 * in bytes.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD.
	 *
	 * This field must be valid on the first BD of a packet. If completion
	 * coalescing is enabled on the TX ring, it is suggested that the driver
	 * populate the opaque field to indicate the specific TX ring with which
	 * the completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address for the portion of the packet
	 * described by this TX BD.
	 *
	 * This value must be valid on all BDs of a packet.
	 */
	uint64_t	addr;
} tx_bd_short_t, *ptx_bd_short_t;

/* tx_bd_long (size:128b/16B) */

typedef struct tx_bd_long {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/*
	 * This value indicates the type of buffer descriptor.
	 * packet.
	 */
	#define TX_BD_LONG_TYPE_MASK		UINT32_C(0x3f)
	#define TX_BD_LONG_TYPE_SFT		0
	/*
	 * Indicates that this BD is 32B long and is used for
	 * normal L2 packet transmission.
	 */
		#define TX_BD_LONG_TYPE_TX_BD_LONG	UINT32_C(0x10)
		#define TX_BD_LONG_TYPE_LAST		TX_BD_LONG_TYPE_TX_BD_LONG
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	#define TX_BD_LONG_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_BD_LONG_FLAGS_SFT		6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_LONG_FLAGS_PACKET_END	UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in it's
	 * processing.
	 * If this bit
	 * is set to 0, then the packet will be completed normally.
	 *
	 * This bit must be valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_NO_CMPL	UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet.
	 * A value of 1 indicates that this BD is the only BD (and that
	 * it is a short BD). A value
	 * of 3 indicates either 3 short BDs or 1 long BD and one short
	 * BD in the packet. A value of 0 indicates
	 * that there are 32 BD locations in the packet (the maximum).
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define TX_BD_LONG_FLAGS_BD_CNT_SFT	8
	/*
	 * This value is a hint for the length of the entire packet.
	 * It is used by the chip to optimize internal processing.
	 *
	 * The packet will be dropped if the hint is too short.
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_LHINT_MASK	UINT32_C(0x6000)
	#define TX_BD_LONG_FLAGS_LHINT_SFT	13
	/* indicates packet length < 512B */
		#define TX_BD_LONG_FLAGS_LHINT_LT512	(UINT32_C(0x0) << 13)
	/* indicates 512 <= packet length < 1KB */
		#define TX_BD_LONG_FLAGS_LHINT_LT1K	(UINT32_C(0x1) << 13)
	/* indicates 1KB <= packet length < 2KB */
		#define TX_BD_LONG_FLAGS_LHINT_LT2K	(UINT32_C(0x2) << 13)
	/* indicates packet length >= 2KB */
		#define TX_BD_LONG_FLAGS_LHINT_GTE2K	(UINT32_C(0x3) << 13)
		#define TX_BD_LONG_FLAGS_LHINT_LAST	TX_BD_LONG_FLAGS_LHINT_GTE2K
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_COAL_NOW	UINT32_C(0x8000)
	/*
	 * This is the length of the host physical buffer this BD describes
	 * in bytes.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is passed through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD.
	 *
	 * This field must be valid on the first BD of a packet. If completion
	 * coalescing is enabled on the TX ring, it is suggested that the driver
	 * populate the opaque field to indicate the specific TX ring with which
	 * the completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address for the portion of the packet
	 * described by this TX BD.
	 *
	 * This value must be valid on all BDs of a packet.
	 */
	uint64_t	addr;
} tx_bd_long_t, *ptx_bd_long_t;

/* Last 16 bytes of tx_bd_long. */
/* tx_bd_long_hi (size:128b/16B) */

typedef struct tx_bd_long_hi {
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor. The flag is ignored if the LSO flag is set.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define TX_BD_LONG_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * This bit, in conjunction with the stamp_1step bit, controls whether
	 * a TX packet timestamp is collected and the type of timestamp that
	 * is collected.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Enumerations of the concatenation { stamp, stamp_1step } are
	 * as follows:
	 *
	 * - 2'b00: ts_none - no timestamp
	 * - 2'b01: ts_ptp_1step - 1-step PTP
	 * - 2'b10: ts_2cmpl - 2-step PTP timestamp or PA timestamp
	 * - 2'b11: ts_rsvd - reserved, same behavior as ts_none
	 * For the ts_2cmpl enumeration, an additional completion is returned.
	 * This additional completion may carry a 2-step PTP timestamp or a PA
	 * timestamp, depending on parsing of the transmitted packet.
	 */
	#define TX_BD_LONG_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor.
	 *
	 * For outer UDP checksum, global outer UDP checksum TE_NIC register
	 * needs to be enabled. If the global outer UDP checksum TE_NIC
	 * register bit is set, outer UDP checksum will be calculated for
	 * the following cases:
	 * 1. Packets with tcp_udp_chksum flag set to offload checksum for
	 * inner packet AND the inner packet is TCP/UDP. If the inner packet
	 * is ICMP for example (non-TCP/UDP), even if the tcp_udp_chksum is
	 * set, the outer UDP checksum will not be calculated.
	 * 2. Packets with lso flag set which implies inner TCP checksum
	 * calculation as part of LSO operation.
	 */
	#define TX_BD_LONG_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to 1, the device will treat this packet with LSO(Large
	 * Send Offload) processing for both normal or encapsulated
	 * packets, which is a form of TCP segmentation. When this bit
	 * is 1, the hdr_size and mss fields must be valid. The driver
	 * doesn't need to set ot_ip_chksum, t_ip_chksum, ip_chksum, and
	 * tcp_udp_chksum flags since the controller will replace the
	 * appropriate checksum fields for segmented packets.
	 *
	 * When this bit is 1, the hdr_size and mss fields must be valid.
	 */
	#define TX_BD_LONG_LFLAGS_LSO		UINT32_C(0x20)
	/*
	 * If set to zero when LSO is '1', then the IPID will be treated
	 * as a 16b number and will be wrapped if it exceeds a value of
	 * 0xffff.
	 *
	 * If set to one when LSO is '1', then the IPID will be treated
	 * as a 15b number and will be wrapped if it exceeds a value of
	 * 0x7fff.
	 */
	#define TX_BD_LONG_LFLAGS_IPID_FMT	UINT32_C(0x40)
	/*
	 * If set to zero when LSO is '1', then the IPID of the tunnel
	 * IP header will not be modified during LSO operations.
	 *
	 * If set to one when LSO is '1', then the IPID of the tunnel
	 * IP header will be incremented for each subsequent segment of an
	 * LSO operation.
	 *
	 * The flag is ignored if the LSO packet is a normal (non-tunneled)
	 * TCP packet.
	 */
	#define TX_BD_LONG_LFLAGS_T_IPID		UINT32_C(0x80)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define TX_BD_LONG_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define TX_BD_LONG_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * If set to '1', then the timestamp from the BD is used. If cleared
	 * to 0, then TWE provides the timestamp.
	 */
	/*
	 * The BD timestamp feature cannot be enabled concurrently with
	 * cryptography (KTLS), thus lflags.bd_ts_en and lflags.crypto_en
	 * shall never both be set in a BD.
	 */
	#define TX_BD_LONG_LFLAGS_BD_TS_EN	UINT32_C(0x400)
	/*
	 * If set to '1', this operation will cause a trace capture in each
	 * block it passes through.
	 */
	#define TX_BD_LONG_LFLAGS_DEBUG_TRACE	UINT32_C(0x800)
	/*
	 * This bit, in conjunction with the stamp bit, controls whether a
	 * TX packet timestamp is collected and the type of timestamp that
	 * is collected.
	 *
	 * See the stamp field for a description of the valid combinations of
	 * stamp and stamp_1step.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_STAMP_1STEP	UINT32_C(0x1000)
	/*
	 * If set to '1', the controller replaces the Outer-tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header of the
	 * packet associated with this descriptor. For outer UDP checksum, it
	 * will be the following behavior for all cases independent of
	 * settings of inner LSO and checksum offload BD flags.
	 * If outer UDP checksum is 0, then do not update it.
	 * If outer UDP checksum is non zero, then the hardware should
	 * compute and update it.
	 */
	#define TX_BD_LONG_LFLAGS_OT_IP_CHKSUM	UINT32_C(0x2000)
	/*
	 * If set to zero when LSO is '1', then the IPID of the Outer-tunnel
	 * IP header will not be modified during LSO operations. If set to one
	 * when LSO is '1', then the IPID of the Outer-tunnel IP header will
	 * be incremented for each subsequent segment of an LSO operation. The
	 * flag is ignored if the LSO packet is a normal (non-tunneled) TCP
	 * packet.
	 */
	#define TX_BD_LONG_LFLAGS_OT_IPID		UINT32_C(0x4000)
	/*
	 * If set to '1', When set to 1, KTLS encryption will be enabled for
	 * the packet.
	 */
	/*
	 * The BD timestamp feature cannot be enabled concurrently with
	 * cryptography (KTLS), thus lflags.bd_ts_en and lflags.crypto_en
	 * shall never both be set in a BD.
	 */
	#define TX_BD_LONG_LFLAGS_CRYPTO_EN	UINT32_C(0x8000)
	uint16_t	kid_or_ts_low_hdr_size;
	/*
	 * When LSO is '1', this field must contain the offset of the
	 * TCP payload from the beginning of the packet in as
	 * 16b words. In case of encapsulated/tunneling packet, this field
	 * contains the offset of the inner TCP payload from beginning of the
	 * packet as 16-bit words.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_HDR_SIZE_MASK	UINT32_C(0x1ff)
	#define TX_BD_LONG_HDR_SIZE_SFT	0
	/*
	 * If lflags.bd_ts_en is 1, this is the lower 7 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, this is the lower 7 bits of
	 * the 20-bit KID.
	 */
	/*
	 * The KID value of all-ones is reserved for non-KTLS packets, which
	 * only implies that this value must not be used when filling this
	 * field for crypto packets.
	 */
	#define TX_BD_LONG_KID_OR_TS_LOW_MASK UINT32_C(0xfe00)
	#define TX_BD_LONG_KID_OR_TS_LOW_SFT 9
	uint32_t	kid_or_ts_high_mss;
	/*
	 * This is the MSS value that will be used to do the LSO processing.
	 * The value is the length in bytes of the TCP payload for each
	 * segment generated by the LSO operation.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_MSS_MASK	UINT32_C(0x7fff)
	#define TX_BD_LONG_MSS_SFT		0
	/*
	 * If lflags.bd_ts_en is 1, this is the upper 17 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, the least significant 13 bits
	 * of this field contain the upper 13 bits of the 20-bit KID.
	 */
	/*
	 * The KID value of all-ones is reserved for non-KTLS packets, which
	 * only implies that this value must not be used when filling this
	 * field for crypto packets.
	 */
	#define TX_BD_LONG_KID_OR_TS_HIGH_MASK UINT32_C(0xffff8000)
	#define TX_BD_LONG_KID_OR_TS_HIGH_SFT 15
	/*
	 * This value selects bits 25:16 of the CFA action to perform on the
	 * packet. See the cfa_action field for more information.
	 */
	uint16_t	cfa_action_high;
	#define TX_BD_LONG_CFA_ACTION_HIGH_MASK UINT32_C(0x3ff)
	#define TX_BD_LONG_CFA_ACTION_HIGH_SFT 0
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define TX_BD_LONG_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define TX_BD_LONG_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define TX_BD_LONG_CFA_META_VLAN_DE		UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define TX_BD_LONG_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define TX_BD_LONG_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define TX_BD_LONG_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID88A8	(UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID8100	(UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9100	(UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9200	(UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9300	(UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPIDCFG	(UINT32_C(0x5) << 16)
		#define TX_BD_LONG_CFA_META_VLAN_TPID_LAST	TX_BD_LONG_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define TX_BD_LONG_CFA_META_VLAN_RESERVED_MASK   UINT32_C(0xff80000)
	#define TX_BD_LONG_CFA_META_VLAN_RESERVED_SFT	19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_CFA_META_KEY_MASK		UINT32_C(0xf0000000)
	#define TX_BD_LONG_CFA_META_KEY_SFT		28
	/* No editing */
		#define TX_BD_LONG_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define TX_BD_LONG_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
	/*
	 * Provide metadata
	 * - Wh+/SR - this option is not supported.
	 * - Thor - cfa_meta[15:0] is used for metadata output if en_bd_meta
	 *   is set in the Lookup Table.
	 * - SR2 - {4'd0, cfa_meta[27:0]} is used for metadata output if
	 *   en_bd_meta is set in the Lookup Table.
	 */
		#define TX_BD_LONG_CFA_META_KEY_METADATA_TRANSFER  (UINT32_C(0x2) << 28)
		#define TX_BD_LONG_CFA_META_KEY_LAST		TX_BD_LONG_CFA_META_KEY_METADATA_TRANSFER
} tx_bd_long_hi_t, *ptx_bd_long_hi_t;

/*
 * This structure is used to inform the NIC of packet data that needs to
 * be transmitted with additional processing that requires extra data
 * such as VLAN insertion plus attached inline data.
 * This BD type may be used to improve latency for small packets needing
 * the additional extended features supported by long BDs.
 */
/* tx_bd_long_inline (size:256b/32B) */

typedef struct tx_bd_long_inline {
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_LONG_INLINE_TYPE_MASK		UINT32_C(0x3f)
	#define TX_BD_LONG_INLINE_TYPE_SFT		0
	/*
	 * This type of BD is 32B long and is used for inline L2 packet
	 * transmission.
	 */
		#define TX_BD_LONG_INLINE_TYPE_TX_BD_LONG_INLINE  UINT32_C(0x11)
		#define TX_BD_LONG_INLINE_TYPE_LAST		TX_BD_LONG_INLINE_TYPE_TX_BD_LONG_INLINE
	/*
	 * All bits in this field may be set on the first BD of a packet.
	 * Only the packet_end bit may be set in non-first BDs.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_MASK		UINT32_C(0xffc0)
	#define TX_BD_LONG_INLINE_FLAGS_SFT		6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_PACKET_END	UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in its processing.
	 * If this bit is set to 0, then the packet will be completed
	 * normally.
	 *
	 * This bit may be set only on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_NO_CMPL	UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet, including the BD and inline
	 * data.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define TX_BD_LONG_INLINE_FLAGS_BD_CNT_SFT	8
	/* This field is deprecated. */
	#define TX_BD_LONG_INLINE_FLAGS_LHINT_MASK	UINT32_C(0x6000)
	#define TX_BD_LONG_INLINE_FLAGS_LHINT_SFT	13
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_COAL_NOW	UINT32_C(0x8000)
	/*
	 * This is the length of the inline data, not including BD length, in
	 * bytes.
	 * The maximum value is 480.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	/*
	 * A fatal error will be generated if the value of this field
	 * does not correspond with the value of flags.bd_cnt. For example, if
	 * this field carries a value of 20, then bd_cnt must equal 4.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is passed through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD. This field must be valid on the first BD of a packet.
	 * If completion coalescing is enabled on the TX ring, it is suggested
	 * that the driver populate the opaque field to indicate the specific
	 * TX ring with which the completion is associated, then utilize the
	 * opaque and sq_cons_idx fields in the coalesced completion record to
	 * determine the specific packets that are to be completed on that ring.
	 *
	 * This field must be valid on the first BD of a packet.
	 */
	uint32_t	opaque;
	uint64_t	unused1;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet is ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor. The flag is ignored if the LSO flag is set.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC for 2-step time sync. This
	 * bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, the controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor. The hardware
	 * updates an outer UDP checksum if it is non-zero.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * This bit must be 0 for BDs of this type. LSO is not supported with
	 * inline BDs.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_LSO		UINT32_C(0x20)
	/* Since LSO is not supported with inline BDs, this bit is not used. */
	#define TX_BD_LONG_INLINE_LFLAGS_IPID_FMT	UINT32_C(0x40)
	/* Since LSO is not supported with inline BDs, this bit is not used. */
	#define TX_BD_LONG_INLINE_LFLAGS_T_IPID		UINT32_C(0x80)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * If set to '1', then the timestamp from the BD is used. If cleared
	 * to 0, then TWE provides the timestamp.
	 */
	/*
	 * The BD timestamp feature cannot be enabled concurrently with
	 * cryptography (KTLS), thus lflags.bd_ts_en and lflags.crypto_en
	 * shall never both be set in a BD.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_BD_TS_EN	UINT32_C(0x400)
	/*
	 * If set to '1', this operation will cause a trace capture in each
	 * block it passes through.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_DEBUG_TRACE	UINT32_C(0x800)
	/*
	 * If set to '1', the device will record the time at which the packet
	 * was actually transmitted at the TX MAC for 1-step time sync. This
	 * bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_STAMP_1STEP	UINT32_C(0x1000)
	/*
	 * If set to '1', the controller replaces the Outer-tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header of the
	 * packet associated with this descriptor. For outer UDP checksum, it
	 * will be the following behavior for all cases independent of settings
	 * of inner LSO and checksum offload BD flags. If outer UDP checksum
	 * is 0, then do not update it. If outer UDP checksum is non zero, then
	 * the hardware should compute and update it.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_OT_IP_CHKSUM	UINT32_C(0x2000)
	/*
	 * If set to zero when LSO is '1', then the IPID of the Outer-tunnel IP
	 * header will not be modified during LSO operations. If set to one
	 * when LSO is '1', then the IPID of the Outer-tunnel IP header will be
	 * incremented for each subsequent segment of an LSO operation. The
	 * flag is ignored if the LSO packet is a normal (non-tunneled) TCP
	 * packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_OT_IPID		UINT32_C(0x4000)
	/*
	 * If set to '1', When set to 1, KTLS encryption will be enabled for
	 * the packet.
	 */
	/*
	 * The BD timestamp feature cannot be enabled concurrently with
	 * cryptography (KTLS), thus lflags.bd_ts_en and lflags.crypto_en
	 * shall never both be set in a BD.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_CRYPTO_EN	UINT32_C(0x8000)
	uint8_t	unused2;
	uint8_t	kid_or_ts_low;
	#define TX_BD_LONG_INLINE_UNUSED		UINT32_C(0x1)
	/*
	 * If lflags.bd_ts_en is 1, this is the lower 7 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, this is the lower 7 bits of
	 * the 20-bit KID.
	 */
	/*
	 * The KID value of all-ones is reserved for non-KTLS packets, which
	 * only implies that this value must not be used when filling this
	 * field for crypto packets.
	 */
	#define TX_BD_LONG_INLINE_KID_OR_TS_LOW_MASK UINT32_C(0xfe)
	#define TX_BD_LONG_INLINE_KID_OR_TS_LOW_SFT 1
	uint32_t	kid_or_ts_high;
	#define TX_BD_LONG_INLINE_UNUSED_MASK	UINT32_C(0x7fff)
	#define TX_BD_LONG_INLINE_UNUSED_SFT	0
	/*
	 * If lflags.bd_ts_en is 1, this is the upper 17 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, the least significant 13 bits
	 * of this field contain the upper 13 bits of the 20-bit KID.
	 */
	/*
	 * The KID value of all-ones is reserved for non-KTLS packets, which
	 * only implies that this value must not be used when filling this
	 * field for crypto packets.
	 */
	#define TX_BD_LONG_INLINE_KID_OR_TS_HIGH_MASK UINT32_C(0xffff8000)
	#define TX_BD_LONG_INLINE_KID_OR_TS_HIGH_SFT 15
	/*
	 * This value selects bits 25:16 of the CFA action to perform on the
	 * packet. See the cfa_action field for more information.
	 */
	uint16_t	cfa_action_high;
	#define TX_BD_LONG_INLINE_CFA_ACTION_HIGH_MASK UINT32_C(0x3ff)
	#define TX_BD_LONG_INLINE_CFA_ACTION_HIGH_SFT 0
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key = 1, this is the VLAN tag VID value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_VID_SFT	0
	/* When key = 1, this is the VLAN tag DE value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_DE		UINT32_C(0x1000)
	/* When key = 1, this is the VLAN tag PRI value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_PRI_SFT	13
	/* When key = 1, this is the VLAN tag TPID select value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID88A8	(UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID8100	(UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9100	(UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9200	(UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9300	(UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPIDCFG	(UINT32_C(0x5) << 16)
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_LAST	TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPIDCFG
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_RESERVED_MASK   UINT32_C(0xff80000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_RESERVED_SFT	19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_CFA_META_KEY_MASK		UINT32_C(0xf0000000)
	#define TX_BD_LONG_INLINE_CFA_META_KEY_SFT		28
	/* No editing */
		#define TX_BD_LONG_INLINE_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define TX_BD_LONG_INLINE_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
	/*
	 * Provide metadata
	 * - Wh+/SR - this option is not supported.
	 * - Thor - cfa_meta[15:0] is used for metadata output if en_bd_meta
	 *   is set in the Lookup Table.
	 * - SR2 - {4'd0, cfa_meta[27:0]} is used for metadata output if
	 *   en_bd_meta is set in the Lookup Table.
	 */
		#define TX_BD_LONG_INLINE_CFA_META_KEY_METADATA_TRANSFER  (UINT32_C(0x2) << 28)
		#define TX_BD_LONG_INLINE_CFA_META_KEY_LAST		TX_BD_LONG_INLINE_CFA_META_KEY_METADATA_TRANSFER
} tx_bd_long_inline_t, *ptx_bd_long_inline_t;

/* tx_bd_empty (size:128b/16B) */

typedef struct tx_bd_empty {
	/* This value identifies the type of buffer descriptor. */
	uint8_t	type;
	#define TX_BD_EMPTY_TYPE_MASK	UINT32_C(0x3f)
	#define TX_BD_EMPTY_TYPE_SFT	0
	/*
	 * Indicates that this BD is 1BB long and is an empty
	 * TX BD. Not valid for use by the driver.
	 */
		#define TX_BD_EMPTY_TYPE_TX_BD_EMPTY  UINT32_C(0x1)
		#define TX_BD_EMPTY_TYPE_LAST	TX_BD_EMPTY_TYPE_TX_BD_EMPTY
	uint8_t	unused_1[3];
	uint8_t	unused_2;
	uint8_t	unused_3[3];
	uint8_t	unused_4[8];
} tx_bd_empty_t, *ptx_bd_empty_t;

/* tx_bd_mp_cmd (size:128b/16B) */

typedef struct tx_bd_mp_cmd {
	/* Unless otherwise stated, sub-fields of this field are always valid. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_MP_CMD_TYPE_MASK	UINT32_C(0x3f)
	#define TX_BD_MP_CMD_TYPE_SFT	0
	/*
	 * Indicates that this BD is used to issue a command to one of
	 * the mid-path destinations.
	 */
		#define TX_BD_MP_CMD_TYPE_TX_BD_MP_CMD  UINT32_C(0x8)
		#define TX_BD_MP_CMD_TYPE_LAST	TX_BD_MP_CMD_TYPE_TX_BD_MP_CMD
	#define TX_BD_MP_CMD_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_BD_MP_CMD_FLAGS_SFT	6
	/*  */
	#define TX_BD_MP_CMD_FLAGS_UNUSED_MASK UINT32_C(0xc0)
	#define TX_BD_MP_CMD_FLAGS_UNUSED_SFT  6
	/*
	 * This value indicates the number of 16B BD locations (slots)
	 * consumed in the ring by this mid-path command BD, including the
	 * BD header and the command field.
	 */
	#define TX_BD_MP_CMD_FLAGS_BD_CNT_MASK UINT32_C(0x1f00)
	#define TX_BD_MP_CMD_FLAGS_BD_CNT_SFT  8
	/*
	 * This value defines the length of command field in bytes. The maximum
	 * value shall be 496.
	 */
	/*
	 * Note that a fatal error will be generated if the value of this field
	 * does not correspond with the value of flags.bd_cnt. For example, if
	 * this field carries a value of 20, then bd_cnt must equal 3.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * Tx mid-path command.
	 */
	uint32_t	opaque;
	uint64_t	unused1;
} tx_bd_mp_cmd_t, *ptx_bd_mp_cmd_t;

/* tx_bd_presync_cmd (size:128b/16B) */

typedef struct tx_bd_presync_cmd {
	/* Unless otherwise stated, sub-fields of this field are always valid. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_PRESYNC_CMD_TYPE_MASK		UINT32_C(0x3f)
	#define TX_BD_PRESYNC_CMD_TYPE_SFT		0
	/*
	 * Indicates that this BD is used to issue a cryptographic pre-
	 * sync command through the fast path and destined for TCE.
	 */
		#define TX_BD_PRESYNC_CMD_TYPE_TX_BD_PRESYNC_CMD  UINT32_C(0x9)
		#define TX_BD_PRESYNC_CMD_TYPE_LAST		TX_BD_PRESYNC_CMD_TYPE_TX_BD_PRESYNC_CMD
	#define TX_BD_PRESYNC_CMD_FLAGS_MASK		UINT32_C(0xffc0)
	#define TX_BD_PRESYNC_CMD_FLAGS_SFT		6
	/*  */
	#define TX_BD_PRESYNC_CMD_FLAGS_UNUSED_MASK	UINT32_C(0xc0)
	#define TX_BD_PRESYNC_CMD_FLAGS_UNUSED_SFT	6
	/*
	 * This value indicates the number of 16B BD locations (slots)
	 * consumed in the ring by this pre-sync command BD, including the
	 * BD header and the command field.
	 */
	#define TX_BD_PRESYNC_CMD_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define TX_BD_PRESYNC_CMD_FLAGS_BD_CNT_SFT	8
	/*
	 * This value defines the length of command field in bytes. The maximum
	 * value shall be 496.
	 */
	/*
	 * Note that a fatal error will be generated if the value of this field
	 * does not correspond with the value of flags.bd_cnt. For example, if
	 * this field carries a value of 20, then bd_cnt must equal 3.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to TCE and can be used for
	 * debug.
	 */
	uint32_t	opaque;
	/*
	 * This field is the Crypto Context ID to which the retransmit packet is
	 * applied. The KID references the context fields used by the
	 * associated kTLS offloaded connection.
	 */
	uint32_t	kid;
	/*
	 * The KID value of all-ones is reserved for non-KTLS packets, which
	 * only implies that this value must not be used when filling this
	 * field for crypto packets.
	 */
	#define TX_BD_PRESYNC_CMD_KID_VAL_MASK UINT32_C(0xfffff)
	#define TX_BD_PRESYNC_CMD_KID_VAL_SFT 0
	uint32_t	unused_1;
} tx_bd_presync_cmd_t, *ptx_bd_presync_cmd_t;

/*
 * This structure is used to send additional information for transmitting
 * packets using timed transmit scheduling. It must only to be applied as
 * the second BD of a BD chain that represents a packet. Any subsequent
 * BDs will follow the timed transmit BD.
 */
/* tx_bd_timedtx (size:128b/16B) */

typedef struct tx_bd_timedtx {
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_TIMEDTX_TYPE_MASK	UINT32_C(0x3f)
	#define TX_BD_TIMEDTX_TYPE_SFT		0
	/*
	 * Indicates a timed transmit BD. This is a 16b BD that is inserted
	 * into a packet BD chain immediately after the first BD. It is used
	 * to control the flow in a timed transmit operation.
	 */
		#define TX_BD_TIMEDTX_TYPE_TX_BD_TIMEDTX	UINT32_C(0xa)
		#define TX_BD_TIMEDTX_TYPE_LAST		TX_BD_TIMEDTX_TYPE_TX_BD_TIMEDTX
	/* Unless otherwise stated, sub-fields of this field are always valid. */
	#define TX_BD_TIMEDTX_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_BD_TIMEDTX_FLAGS_SFT	6
	/*
	 * This value identifies the kind of buffer timed transmit mode that
	 * is to be enabled for the packet.
	 */
	#define TX_BD_TIMEDTX_FLAGS_KIND_MASK	UINT32_C(0x1c0)
	#define TX_BD_TIMEDTX_FLAGS_KIND_SFT	6
	/*
	 * This timed transmit mode indicates that the packet will be
	 * scheduled and send immediately (or as soon as possible), once
	 * it is scheduled in the transmitter.
	 * Note: This mode is similar to regular (non-timed transmit)
	 * operation. Its main purpose is to cancel pace mode timed
	 * transmit.
	 */
		#define TX_BD_TIMEDTX_FLAGS_KIND_ASAP	(UINT32_C(0x0) << 6)
	/*
	 * This timed transmit mode is used to schedule transmission of
	 * the packet no earlier than the time given in the tx_time
	 * field of the BD.
	 * Note: In case subsequent packets don't include a timed transmit
	 * BD, they will be scheduled subsequently for transmission
	 * without any timed transmit constraint.
	 */
		#define TX_BD_TIMEDTX_FLAGS_KIND_SO_TXTIME   (UINT32_C(0x1) << 6)
	/*
	 * This timed transmit mode is used to enable rate control for the
	 * flow (QP) at a rate as defined by the rate field of this BD.
	 * Note: In case subsequent, adjacent packets on the same flow
	 * don't include a timed transmit BD, they will continue to be
	 * paced by the transmitter at the same rate as given in this BD.
	 */
		#define TX_BD_TIMEDTX_FLAGS_KIND_PACE	(UINT32_C(0x2) << 6)
		#define TX_BD_TIMEDTX_FLAGS_KIND_LAST	TX_BD_TIMEDTX_FLAGS_KIND_PACE
	/*
	 * This field exists in all Tx BDs. It doesn't apply to this particular
	 * BD type since the BD never represents an SGL or inline data; i.e. it
	 * is only a command. This field must be zero.
	 */
	/*
	 * Note that if this field is not zero, a fatal length error will be
	 * generated as it will be included in the aggregate of SGE lengths for
	 * the packet.
	 */
	uint16_t	len;
	/*
	 * This field represents the rate of the flow (QP) in terms of KB/s.
	 * This applies to pace mode timed transmit.
	 */
	uint32_t	rate;
	/*
	 * Applying this rate to a QP will result in this and all subsequent
	 * packets of the flow being paced at the given rate, until such time
	 * that the timed transmit mode is either changed or the rate is
	 * updated in a future packet on the flow.
	 * This field is applicable only if flags.kind is pace.
	 */
	#define TX_BD_TIMEDTX_RATE_VAL_MASK UINT32_C(0x1ffffff)
	#define TX_BD_TIMEDTX_RATE_VAL_SFT 0
	/*
	 * This field represents the nano-second time to transmit the
	 * corresponding packet using SO_TXTIME mode of timed transmit.
	 * This field is applicable only if flags.kind is so_txtime.
	 */
	uint64_t	tx_time;
} tx_bd_timedtx_t, *ptx_bd_timedtx_t;

/* rx_prod_pkt_bd (size:128b/16B) */

typedef struct rx_prod_pkt_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_PKT_BD_TYPE_MASK	UINT32_C(0x3f)
	#define RX_PROD_PKT_BD_TYPE_SFT	0
	/*
	 * Indicates that this BD is 16B long and is an RX Producer
	 * (i.e. empty) buffer descriptor.
	 */
		#define RX_PROD_PKT_BD_TYPE_RX_PROD_PKT	UINT32_C(0x4)
		#define RX_PROD_PKT_BD_TYPE_LAST	RX_PROD_PKT_BD_TYPE_RX_PROD_PKT
	#define RX_PROD_PKT_BD_FLAGS_MASK	UINT32_C(0xffc0)
	#define RX_PROD_PKT_BD_FLAGS_SFT	6
	/*
	 * If set to 1, the packet will be placed at the address plus
	 * 2B. The 2 Bytes of padding will be written as zero.
	 */
	/*
	 * This is intended to be used when the host buffer is
	 * cache-line aligned to produce packets that are easy to
	 * parse in host memory while still allowing writes to be cache
	 * line aligned.
	 */
	#define RX_PROD_PKT_BD_FLAGS_SOP_PAD	UINT32_C(0x40)
	/*
	 * If set to 1, the packet write will be padded out to the
	 * nearest cache-line with zero value padding.
	 */
	/*
	 * If receive buffers start/end on cache-line boundaries, this
	 * feature will ensure that all data writes on the PCI bus
	 * start/end on cache line boundaries.
	 */
	#define RX_PROD_PKT_BD_FLAGS_EOP_PAD	UINT32_C(0x80)
	/*
	 * This field has been deprecated. There can be no additional
	 * BDs for this packet from this ring.
	 *
	 * Old definition:
	 * This value is the number of additional buffers in the ring that
	 * describe the buffer space to be consumed for this packet.
	 * If the value is zero, then the packet must fit within the
	 * space described by this BD. If this value is 1 or more, it
	 * indicates how many additional "buffer" BDs are in the ring
	 * immediately following this BD to be used for the same
	 * network packet. Even if the packet to be placed does not need
	 * all the additional buffers, they will be consumed anyway.
	 */
	#define RX_PROD_PKT_BD_FLAGS_BUFFERS_MASK UINT32_C(0x300)
	#define RX_PROD_PKT_BD_FLAGS_BUFFERS_SFT  8
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	/*
	 * While this is a Byte resolution value, it is often advantageous
	 * to ensure that the buffers provided end on a host cache line.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * receive buffer set.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	/*
	 * While this is a Byte resolution value, it is often advantageous
	 * to ensure that the buffers provide start on a host cache line.
	 */
	uint64_t	addr;
} rx_prod_pkt_bd_t, *prx_prod_pkt_bd_t;

/* rx_prod_bfr_bd (size:128b/16B) */

typedef struct rx_prod_bfr_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_BFR_BD_TYPE_MASK	UINT32_C(0x3f)
	#define RX_PROD_BFR_BD_TYPE_SFT	0
	/*
	 * Indicates that this BD is 16B long and is an RX
	 * Producer Buffer BD.
	 */
		#define RX_PROD_BFR_BD_TYPE_RX_PROD_BFR  UINT32_C(0x5)
		#define RX_PROD_BFR_BD_TYPE_LAST	RX_PROD_BFR_BD_TYPE_RX_PROD_BFR
	#define RX_PROD_BFR_BD_FLAGS_MASK	UINT32_C(0xffc0)
	#define RX_PROD_BFR_BD_FLAGS_SFT	6
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	/*
	 * While this is a Byte resolution value, it is often advantageous
	 * to ensure that the buffers provided end on a host cache line.
	 */
	uint16_t	len;
	/* This field is not used. */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	/*
	 * While this is a Byte resolution value, it is often advantageous
	 * to ensure that the buffers provide start on a host cache line.
	 */
	uint64_t	addr;
} rx_prod_bfr_bd_t, *prx_prod_bfr_bd_t;

/* rx_prod_agg_bd (size:128b/16B) */

typedef struct rx_prod_agg_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_AGG_BD_TYPE_MASK	UINT32_C(0x3f)
	#define RX_PROD_AGG_BD_TYPE_SFT	0
	/*
	 * Indicates that this BD is 16B long and is an
	 * RX Producer Assembly Buffer Descriptor.
	 */
		#define RX_PROD_AGG_BD_TYPE_RX_PROD_AGG	UINT32_C(0x6)
		#define RX_PROD_AGG_BD_TYPE_LAST	RX_PROD_AGG_BD_TYPE_RX_PROD_AGG
	#define RX_PROD_AGG_BD_FLAGS_MASK	UINT32_C(0xffc0)
	#define RX_PROD_AGG_BD_FLAGS_SFT	6
	/*
	 * If set to 1, the packet write will be padded out to the
	 * nearest cache-line with zero value padding.
	 */
	/*
	 * If receive buffers start/end on cache-line boundaries, this
	 * feature will ensure that all data writes on the PCI bus
	 * end on cache line boundaries.
	 */
	#define RX_PROD_AGG_BD_FLAGS_EOP_PAD	UINT32_C(0x40)
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	/*
	 * While this is a Byte resolution value, it is often advantageous
	 * to ensure that the buffers provided end on a host cache line.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * receive assembly buffer.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	/*
	 * While this is a Byte resolution value, it is often advantageous
	 * to ensure that the buffers provide start on a host cache line.
	 */
	uint64_t	addr;
} rx_prod_agg_bd_t, *prx_prod_agg_bd_t;

/* cfa_cmpls_cmp_data_msg (size:128b/16B) */

typedef struct cfa_cmpls_cmp_data_msg {
	uint32_t	mp_client_dma_length_opcode_status_type;
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	/*
	 * This field indicates the exact type of the completion. By
	 * convention, the LSB identifies the length of the record in 16B
	 * units. Even values indicate 16B records. Odd values indicate 32B
	 * records.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_TYPE_MASK		UINT32_C(0x3f)
	#define CFA_CMPLS_CMP_DATA_MSG_TYPE_SFT		0
	/* Mid Path Short Completion with length = 16B. */
		#define CFA_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT	UINT32_C(0x1e)
		#define CFA_CMPLS_CMP_DATA_MSG_TYPE_LAST		CFA_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT
	/* This value indicates the status for the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_MASK		UINT32_C(0x3c0)
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_SFT		6
	/* Completed without error. */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_OK		(UINT32_C(0x0) << 6)
	/* Indicates an unsupported CFA opcode in the command. */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_UNSPRT_ERR	(UINT32_C(0x1) << 6)
	/*
	 * Indicates a CFA command formatting error. This error can occur on
	 * any of the supported CFA commands.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_FMT_ERR		(UINT32_C(0x2) << 6)
	/*
	 * Indicates an SVIF-Table scope error. This error can occur on any
	 * of the supported CFA commands.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_SCOPE_ERR	(UINT32_C(0x3) << 6)
	/*
	 * Indicates that the table_index is either outside of the
	 * table_scope range set by its EM_SIZE or, for EM Insert, it is in
	 * the static bucket range. This error can occur on EM Insert
	 * commands. It can also occur on Read, Read Clear, Write, and
	 * Invalidate commands if the table_type is EM.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_ADDR_ERR		(UINT32_C(0x4) << 6)
	/*
	 * Cache operation responded with an error. This error can occur on
	 * Read, Read Clear, Write, EM Insert, and EM Delete commands.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_CACHE_ERR	(UINT32_C(0x5) << 6)
	/*
	 * Indicates failure on EM Insert or EM Delete Command. Hash index
	 * and hash msb are returned in table_index and hash_msb fields.
	 * Dma_length is set to 1 if the bucket is also returned (as dma
	 * data).
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_EM_FAIL		(UINT32_C(0x6) << 6)
	/*
	 * Indicates no notifications were available on an Event Collection
	 * command.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_EVENT_COLLECT_FAIL  (UINT32_C(0x7) << 6)
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_LAST		CFA_CMPLS_CMP_DATA_MSG_STATUS_EVENT_COLLECT_FAIL
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED0_MASK		UINT32_C(0xc00)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED0_SFT		10
	/* This is the opcode from the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_MASK		UINT32_C(0xff000)
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_SFT		12
	/*
	 * This is read command. From 32 to 128B can be read from a table
	 * using this command.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_READ		(UINT32_C(0x0) << 12)
	/*
	 * This is write command. From 32 to 128B can be written to a table
	 * using this command.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_WRITE		(UINT32_C(0x1) << 12)
	/*
	 * This is read-clear command. 32B can be read from a table and a 16b
	 * mask can be used to clear specific 16b units after the read as an
	 * atomic operation.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_READ_CLR		(UINT32_C(0x2) << 12)
	/*
	 * An exact match table insert will be attempted into the table. If
	 * there is a free location in the bucket, the payload will be
	 * written to the bucket.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EM_INSERT	(UINT32_C(0x3) << 12)
	/* An exact match table delete will be attempted. */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EM_DELETE	(UINT32_C(0x4) << 12)
	/*
	 * The specified table area will be invalidated. If it is needed
	 * again, it will be read from the backing store.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_INVALIDATE	(UINT32_C(0x5) << 12)
	/* Reads notification messages from the Host Notification Queue. */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EVENT_COLLECT	(UINT32_C(0x6) << 12)
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_LAST		CFA_CMPLS_CMP_DATA_MSG_OPCODE_EVENT_COLLECT
	/*
	 * This field indicates the length of the DMA that accompanies the
	 * completion. Specified in units of DWords (32b). Valid values are
	 * between 0 and 128. A value of zero indicates that there is no DMA
	 * that accompanies the completion.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_DMA_LENGTH_MASK	UINT32_C(0xff00000)
	#define CFA_CMPLS_CMP_DATA_MSG_DMA_LENGTH_SFT	20
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_MASK	UINT32_C(0xf0000000)
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_SFT		28
	/* TX configurable flow processing block. */
		#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_TE_CFA	(UINT32_C(0x2) << 28)
	/* RX configurable flow processing block. */
		#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_RE_CFA	(UINT32_C(0x3) << 28)
		#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_LAST		CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_RE_CFA
	/*
	 * This is a copy of the opaque field from the mid path BD of this
	 * command.
	 */
	uint32_t	opaque;
	uint16_t	hash_msb_v;
	/*
	 * This value is written by the NIC such that it will be different for
	 * each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_V		UINT32_C(0x1)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED1_MASK UINT32_C(0xe)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED1_SFT  1
	/*
	 * This is the upper 12b of the hash, returned on Exact Match
	 * Insertion/Deletion Commands.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_HASH_MSB_MASK UINT32_C(0xfff0)
	#define CFA_CMPLS_CMP_DATA_MSG_HASH_MSB_SFT 4
	/* This is the table type from the command. */
	uint8_t	table_type;
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED2_MASK	UINT32_C(0xf)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED2_SFT	0
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf0)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_SFT   4
	/* This command acts on the action table of the specified scope. */
		#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_ACTION  (UINT32_C(0x0) << 4)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_EM	(UINT32_C(0x1) << 4)
		#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_LAST   CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_EM
	uint8_t	table_scope;
	/* This is the table scope from the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_SCOPE_SFT 0
	uint32_t	table_index;
	/*
	 * This is the table index from the command (if it exists). However, if
	 * an Exact Match Insertion/Deletion command failed, then this is the
	 * table index of the calculated static hash bucket.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_INDEX_SFT 0
} cfa_cmpls_cmp_data_msg_t, *pcfa_cmpls_cmp_data_msg_t;

/* CFA Mid-Path 32B DMA Message */
/* cfa_dma32b_data_msg (size:256b/32B) */

typedef struct cfa_dma32b_data_msg {
	/* DMA data value. */
	uint32_t	dta[8];
} cfa_dma32b_data_msg_t, *pcfa_dma32b_data_msg_t;

/* CFA Mid-Path 64B DMA Message */
/* cfa_dma64b_data_msg (size:512b/64B) */

typedef struct cfa_dma64b_data_msg {
	/* DMA data value. */
	uint32_t	dta[16];
} cfa_dma64b_data_msg_t, *pcfa_dma64b_data_msg_t;

/* CFA Mid-Path 96B DMA Message */
/* cfa_dma96b_data_msg (size:768b/96B) */

typedef struct cfa_dma96b_data_msg {
	/* DMA data value. */
	uint32_t	dta[24];
} cfa_dma96b_data_msg_t, *pcfa_dma96b_data_msg_t;

/* CFA Mid-Path 128B DMA Message */
/* cfa_dma128b_data_msg (size:1024b/128B) */

typedef struct cfa_dma128b_data_msg {
	/* DMA data value. */
	uint32_t	dta[32];
} cfa_dma128b_data_msg_t, *pcfa_dma128b_data_msg_t;

/* ce_cmpls_cmp_data_msg (size:128b/16B) */

typedef struct ce_cmpls_cmp_data_msg {
	uint16_t	client_subtype_type;
	/*
	 * This field indicates the exact type of the completion. By
	 * convention, the LSB identifies the length of the record in 16B
	 * units. Even values indicate 16B records. Odd values indicate 32B
	 * records.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_TYPE_MASK	UINT32_C(0x3f)
	#define CE_CMPLS_CMP_DATA_MSG_TYPE_SFT	0
	/* Completion of a Mid Path Command. Length = 16B */
		#define CE_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT  UINT32_C(0x1e)
		#define CE_CMPLS_CMP_DATA_MSG_TYPE_LAST	CE_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED0_MASK	UINT32_C(0xc0)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED0_SFT	6
	/*
	 * This value indicates the CE sub-type operation that is being
	 * completed.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_MASK	UINT32_C(0xf00)
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_SFT	8
	/* Completion Response for a Solicited Command. */
		#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_SOLICITED	(UINT32_C(0x0) << 8)
	/* Error Completion (Unsolicited). */
		#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_ERR	(UINT32_C(0x1) << 8)
	/* Re-Sync Completion (Unsolicited) */
		#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_RESYNC	(UINT32_C(0x2) << 8)
		#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_LAST	CE_CMPLS_CMP_DATA_MSG_SUBTYPE_RESYNC
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_MASK	UINT32_C(0xf000)
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_SFT	12
	/* TX crypto engine block. */
		#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_TCE	(UINT32_C(0x0) << 12)
	/* RX crypto engine block. */
		#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_RCE	(UINT32_C(0x1) << 12)
		#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_LAST	CE_CMPLS_CMP_DATA_MSG_MP_CLIENT_RCE
	uint16_t	status;
	/* This value indicates the status for the command. */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_MASK	UINT32_C(0xf)
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_SFT	0
	/* Completed without error. */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_OK	UINT32_C(0x0)
	/* CFCK load error. */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_CTX_LD_ERR   UINT32_C(0x1)
	/* FID check error. */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_FID_CHK_ERR  UINT32_C(0x2)
	/* Context kind / MP version mismatch error. */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_CTX_VER_ERR  UINT32_C(0x3)
	/* Unsupported Destination Connection ID Length. */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_DST_ID_ERR   UINT32_C(0x4)
	/*
	 * Invalid MP Command [anything other than ADD or DELETE
	 * triggers this for QUIC].
	 */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_MP_CMD_ERR   UINT32_C(0x5)
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_LAST	CE_CMPLS_CMP_DATA_MSG_STATUS_MP_CMD_ERR
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED1_MASK	UINT32_C(0xfff0)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED1_SFT	4
	/*
	 * This is a copy of the opaque field from the mid path BD of this
	 * command.
	 */
	uint32_t	opaque;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_V	UINT32_C(0x1)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED2_MASK UINT32_C(0xfffffffe)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED2_SFT 1
	uint32_t	kid;
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_KID_MASK	UINT32_C(0xfffff)
	#define CE_CMPLS_CMP_DATA_MSG_KID_SFT	0
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED3_MASK UINT32_C(0xfff00000)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED3_SFT 20
} ce_cmpls_cmp_data_msg_t, *pce_cmpls_cmp_data_msg_t;

/* cmpl_base (size:128b/16B) */

typedef struct cmpl_base {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CMPL_BASE_TYPE_MASK		UINT32_C(0x3f)
	#define CMPL_BASE_TYPE_SFT		0
	/*
	 * TX L2 completion:
	 * Completion of TX packet. Length = 16B
	 */
		#define CMPL_BASE_TYPE_TX_L2		UINT32_C(0x0)
	/*
	 * NO-OP completion:
	 * Completion of NO-OP. Length = 16B
	 */
		#define CMPL_BASE_TYPE_NO_OP		UINT32_C(0x1)
	/*
	 * TX L2 coalesced completion:
	 * Completion of coalesced TX packet. Length = 16B
	 */
		#define CMPL_BASE_TYPE_TX_L2_COAL	UINT32_C(0x2)
	/*
	 * TX L2 Packet Timestamp completion:
	 * Completion of an L2 Packet Timestamp Packet. Length = 16B
	 */
		#define CMPL_BASE_TYPE_TX_L2_PKT_TS	UINT32_C(0x4)
	/*
	 * RX L2 TPA Start V2 Completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_TPA_START completion used
	 * in SR2 and later chips.
	 */
		#define CMPL_BASE_TYPE_RX_TPA_START_V2   UINT32_C(0xd)
	/*
	 * RX L2 V2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_L2 completion used in SR2
	 * and later chips.
	 */
		#define CMPL_BASE_TYPE_RX_L2_V2	UINT32_C(0xf)
	/*
	 * RX L2 completion:
	 * This is the compressed version of Rx Completion for performance
	 * applications. Length = 16B
	 */
		#define CMPL_BASE_TYPE_RX_L2_COMPRESS	UINT32_C(0x10)
	/*
	 * RX L2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 */
		#define CMPL_BASE_TYPE_RX_L2		UINT32_C(0x11)
	/*
	 * RX Aggregation Buffer completion:
	 * Completion of an L2 aggregation buffer in support of
	 * TPA, HDS, or Jumbo packet completion. Length = 16B
	 */
		#define CMPL_BASE_TYPE_RX_AGG		UINT32_C(0x12)
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
		#define CMPL_BASE_TYPE_RX_TPA_START	UINT32_C(0x13)
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
		#define CMPL_BASE_TYPE_RX_TPA_END	UINT32_C(0x15)
	/*
	 * RX TPA Aggregation Buffer Completion:
	 * Completion of an L2 aggregation buffer in support of TPA packet
	 * completion.
	 * Length = 16B
	 */
		#define CMPL_BASE_TYPE_RX_TPA_AGG	UINT32_C(0x16)
	/*
	 * RX L2 completion: Completion of and L2 RX packet.
	 * Length = 32B
	 */
		#define CMPL_BASE_TYPE_RX_L2_V3	UINT32_C(0x17)
	/*
	 * RX L2 TPA Start completion: Completion at the beginning of a TPA
	 * operation.
	 * Length = 32B
	 */
		#define CMPL_BASE_TYPE_RX_TPA_START_V3   UINT32_C(0x19)
	/*
	 * Statistics Ejection Completion:
	 * Completion of statistics data ejection buffer.
	 * Length = 16B
	 */
		#define CMPL_BASE_TYPE_STAT_EJECT	UINT32_C(0x1a)
	/*
	 * VEE Flush Completion:
	 * This completion is inserted manually by
	 * the Primate and processed by the VEE hardware to ensure that
	 * all completions on a VEE function have been processed by the
	 * VEE hardware before FLR process is completed.
	 */
		#define CMPL_BASE_TYPE_VEE_FLUSH	UINT32_C(0x1c)
	/*
	 * Mid Path Short Completion :
	 * Completion of a Mid Path Command. Length = 16B
	 */
		#define CMPL_BASE_TYPE_MID_PATH_SHORT	UINT32_C(0x1e)
	/*
	 * Mid Path Long Completion :
	 * Completion of a Mid Path Command. Length = 32B
	 */
		#define CMPL_BASE_TYPE_MID_PATH_LONG	UINT32_C(0x1f)
	/*
	 * HWRM Command Completion:
	 * Completion of an HWRM command.
	 */
		#define CMPL_BASE_TYPE_HWRM_DONE	UINT32_C(0x20)
	/* Forwarded HWRM Request */
		#define CMPL_BASE_TYPE_HWRM_FWD_REQ	UINT32_C(0x22)
	/* Forwarded HWRM Response */
		#define CMPL_BASE_TYPE_HWRM_FWD_RESP	UINT32_C(0x24)
	/* HWRM Asynchronous Event Information */
		#define CMPL_BASE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
	/* CQ Notification */
		#define CMPL_BASE_TYPE_CQ_NOTIFICATION   UINT32_C(0x30)
	/* SRQ Threshold Event */
		#define CMPL_BASE_TYPE_SRQ_EVENT	UINT32_C(0x32)
	/* DBQ Threshold Event */
		#define CMPL_BASE_TYPE_DBQ_EVENT	UINT32_C(0x34)
	/* QP Async Notification */
		#define CMPL_BASE_TYPE_QP_EVENT	UINT32_C(0x38)
	/* Function Async Notification */
		#define CMPL_BASE_TYPE_FUNC_EVENT	UINT32_C(0x3a)
		#define CMPL_BASE_TYPE_LAST		CMPL_BASE_TYPE_FUNC_EVENT
	/* info1 is 16 b */
	uint16_t	info1;
	/* info2 is 32 b */
	uint32_t	info2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint32_t	info3_v;
	#define CMPL_BASE_V	UINT32_C(0x1)
	#define CMPL_BASE_INFO3_MASK UINT32_C(0xfffffffe)
	#define CMPL_BASE_INFO3_SFT 1
	/* info4 is 32 b */
	uint32_t	info4;
} cmpl_base_t, *pcmpl_base_t;

/* tx_cmpl (size:128b/16B) */

typedef struct tx_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define TX_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define TX_CMPL_TYPE_SFT	0
	/*
	 * TX L2 completion:
	 * Completion of TX packet. Length = 16B
	 */
		#define TX_CMPL_TYPE_TX_L2	UINT32_C(0x0)
		#define TX_CMPL_TYPE_LAST	TX_CMPL_TYPE_TX_L2
	#define TX_CMPL_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_CMPL_FLAGS_SFT	6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define TX_CMPL_FLAGS_ERROR	UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push acceleration data provided
	 * by the driver. When this bit is '0', it indicates that the
	 * packet had not push acceleration data written or was executed
	 * as a normal packet even though push data was provided.
	 */
	#define TX_CMPL_FLAGS_PUSH	UINT32_C(0x80)
	/* unused1 is 16 b */
	uint16_t	unused_0;
	/*
	 * This is a copy of the opaque field from the first TX BD of this
	 * transmitted packet. Note that, if the packet was described by a short
	 * CSO or short CSO inline BD, then the 16-bit opaque field from the
	 * short CSO BD will appear in the bottom 16 bits of this field.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_V				UINT32_C(0x1)
	#define TX_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define TX_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem
	 * with the BDs for the packet.
	 */
	#define TX_CMPL_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define TX_CMPL_ERRORS_BUFFER_ERROR_SFT		1
	/* No error */
		#define TX_CMPL_ERRORS_BUFFER_ERROR_NO_ERROR	(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define TX_CMPL_ERRORS_BUFFER_ERROR_BAD_FMT	(UINT32_C(0x2) << 1)
		#define TX_CMPL_ERRORS_BUFFER_ERROR_LAST		TX_CMPL_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * When this bit is '1', it indicates that the length of
	 * the packet was zero. No packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_ZERO_LENGTH_PKT		UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the packet
	 * was longer than the programmed limit in TDI. No
	 * packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_EXCESSIVE_BD_LENGTH	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the
	 * BDs associated with this packet generated a PCI error.
	 * This probably means the address was not valid.
	 */
	#define TX_CMPL_ERRORS_DMA_ERROR			UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet was longer
	 * than indicated by the hint. No packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_HINT_TOO_SHORT		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was
	 * dropped due to Poison TLP error on one or more of the
	 * TLPs in the PXP completion.
	 */
	#define TX_CMPL_ERRORS_POISON_TLP_ERROR		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to a transient internal error in TDC. The packet or LSO can
	 * be retried and may transmit successfully on a subsequent attempt.
	 */
	#define TX_CMPL_ERRORS_INTERNAL_ERROR		UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a timestamp
	 * for a PTP completion, in which case the timestamp_hi and
	 * timestamp_lo fields are invalid. When this bit is '0' for a PTP
	 * completion, the timestamp_hi and timestamp_lo fields are valid.
	 * RJRN will copy the value of this bit into the field of the same
	 * name in all TX completions, regardless of whether such completions
	 * are PTP completions or other TX completions.
	 */
	#define TX_CMPL_ERRORS_TIMESTAMP_INVALID_ERROR	UINT32_C(0x400)
	/* unused2 is 16 b */
	uint16_t	unused_1;
	/* unused3 is 32 b */
	uint32_t	unused_2;
} tx_cmpl_t, *ptx_cmpl_t;

/* tx_cmpl_coal (size:128b/16B) */

typedef struct tx_cmpl_coal {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define TX_CMPL_COAL_TYPE_MASK	UINT32_C(0x3f)
	#define TX_CMPL_COAL_TYPE_SFT	0
	/*
	 * TX L2 coalesced completion:
	 * Completion of TX packet. Length = 16B
	 */
		#define TX_CMPL_COAL_TYPE_TX_L2_COAL   UINT32_C(0x2)
		#define TX_CMPL_COAL_TYPE_LAST	TX_CMPL_COAL_TYPE_TX_L2_COAL
	#define TX_CMPL_COAL_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_CMPL_COAL_FLAGS_SFT	6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define TX_CMPL_COAL_FLAGS_ERROR	UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push acceleration data provided
	 * by the driver. When this bit is '0', it indicates that the
	 * packet had not push acceleration data written or was executed
	 * as a normal packet even though push data was provided.
	 */
	#define TX_CMPL_COAL_FLAGS_PUSH	UINT32_C(0x80)
	/* unused1 is 16 b */
	uint16_t	unused_0;
	/*
	 * This is a copy of the opaque field from the first TX BD of the packet
	 * which corresponds with the reported sq_cons_idx. Note that, with
	 * coalesced completions, completions are generated for only some of the
	 * packets. The driver will see the opaque field for only those packets.
	 * Note that, if the packet was described by a short CSO or short CSO
	 * inline BD, then the 16-bit opaque field from the short CSO BD will
	 * appear in the bottom 16 bits of this field. For TX rings with
	 * completion coalescing enabled (which would use the coalesced
	 * completion record), it is suggested that the driver populate the
	 * opaque field to indicate the specific TX ring with which the
	 * completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_COAL_V				UINT32_C(0x1)
	#define TX_CMPL_COAL_ERRORS_MASK			UINT32_C(0xfffe)
	#define TX_CMPL_COAL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem
	 * with the BDs for the packet.
	 */
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_SFT		1
	/* No error */
		#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_NO_ERROR	(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_BAD_FMT	(UINT32_C(0x2) << 1)
		#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_LAST		TX_CMPL_COAL_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * When this bit is '1', it indicates that the length of
	 * the packet was zero. No packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_ZERO_LENGTH_PKT		UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the packet
	 * was longer than the programmed limit in TDI. No
	 * packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_EXCESSIVE_BD_LENGTH	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the
	 * BDs associated with this packet generated a PCI error.
	 * This probably means the address was not valid.
	 */
	#define TX_CMPL_COAL_ERRORS_DMA_ERROR			UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet was longer
	 * than indicated by the hint. No packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_HINT_TOO_SHORT		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was
	 * dropped due to Poison TLP error on one or more of the
	 * TLPs in the PXP completion.
	 */
	#define TX_CMPL_COAL_ERRORS_POISON_TLP_ERROR		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to a transient internal error in TDC. The packet or LSO can
	 * be retried and may transmit successfully on a subsequent attempt.
	 */
	#define TX_CMPL_COAL_ERRORS_INTERNAL_ERROR		UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a a timestamp
	 * for a PTP completion, in which case the timestamp_hi and
	 * timestamp_lo fields are invalid. When this bit is '0' for a PTP
	 * completion, the timestamp_hi and timestamp_lo fields are valid.
	 * RJRN will copy the value of this bit into the field of the same
	 * name in all TX completions, regardless of whether such
	 * completions are PTP completions or other TX completions.
	 */
	#define TX_CMPL_COAL_ERRORS_TIMESTAMP_INVALID_ERROR	UINT32_C(0x400)
	/* unused2 is 16 b */
	uint16_t	unused_1;
	uint32_t	sq_cons_idx;
	/*
	 * This value is SQ index for the start of the packet following the
	 * last completed packet.
	 */
	#define TX_CMPL_COAL_SQ_CONS_IDX_MASK UINT32_C(0xffffff)
	#define TX_CMPL_COAL_SQ_CONS_IDX_SFT 0
} tx_cmpl_coal_t, *ptx_cmpl_coal_t;

/* tx_cmpl_packet_timestamp (size:128b/16B) */

typedef struct tx_cmpl_packet_timestamp {
	uint16_t	ts_sub_ns_flags_type;
	/*
	 * This field indicates the exact type of the completion. By
	 * convention, the LSB identifies the length of the record in 16B
	 * units. Even values indicate 16B records. Odd values indicate
	 * 32B records.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_TYPE_MASK		UINT32_C(0x3f)
	#define TX_CMPL_PACKET_TIMESTAMP_TYPE_SFT		0
	/*
	 * TX L2 Packet Timestamp completion:
	 * Completion of an L2 Packet Timestamp Packet. Length = 16B
	 */
		#define TX_CMPL_PACKET_TIMESTAMP_TYPE_TX_L2_PKT_TS	UINT32_C(0x4)
		#define TX_CMPL_PACKET_TIMESTAMP_TYPE_LAST		TX_CMPL_PACKET_TIMESTAMP_TYPE_TX_L2_PKT_TS
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_MASK		UINT32_C(0xfc0)
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_SFT		6
	/*
	 * When this bit is '1', it indicates a packet that has an error
	 * of some type. Type of error is indicated in error_flags.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_ERROR		UINT32_C(0x40)
	/*
	 * This field indicates the TX packet timestamp type that is
	 * represented by a TX Packet Timestamp Completion. Note that
	 * this field is invalid if the timestamp_invalid_error flag
	 * is set.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE	UINT32_C(0x80)
	/* The packet timestamp came from PM. */
		#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE_TS_PM	(UINT32_C(0x0) << 7)
	/* The packet timestamp came from PA. */
		#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE_TS_PA	(UINT32_C(0x1) << 7)
		#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE_LAST	TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_TYPE_TS_PA
	/*
	 * This flag indicates that the timestamp should have come from PM,
	 * but came instead from PA because all PM timestamp resources were
	 * in use. This can occur in the following circumstances:
	 * 1. The BD specified ts_2cmpl_auto and the packet was a PTP packet
	 *	but PA could not request a PM timestamp
	 * 2. The BD specified ts_2cmpl_pm, but PA could not request a PM
	 *	timestamp
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_FLAGS_TS_FALLBACK	UINT32_C(0x100)
	/*
	 * For 2-step PTP timestamps, bits[3:0] of this field represent the
	 * sub-nanosecond portion of the packet timestamp, returned from PM
	 * for 2-step PTP timestamps. For PA timestamps, this field also
	 * represents the sub-nanosecond portion of the packet timestamp;
	 * however, due to synchronization uncertainties, the accuracy of
	 * PA timestamps is limited to approximately +/- 4 ns. Therefore
	 * this field is of dubious value for PA timestamps.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_TS_SUB_NS_MASK	UINT32_C(0xf000)
	#define TX_CMPL_PACKET_TIMESTAMP_TS_SUB_NS_SFT	12
	/*
	 * This is bits [47:32] of the nanoseconds portion of the packet
	 * timestamp, returned from PM for 2-step PTP timestamps or from
	 * PA for PA timestamps. This field is in units of 2^32 ns.
	 */
	uint16_t	ts_ns_mid;
	/*
	 * This is a copy of the opaque field from the first TX BD of this
	 * transmitted packet. Note that, if the packet was described by a
	 * short CSO or short CSO inline BD, then the 16-bit opaque field
	 * from the short CSO BD will appear in the bottom 16 bits of this
	 * field.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_V				UINT32_C(0x1)
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_MASK			UINT32_C(0xfffe)
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_SFT			1
	/*
	 * This field was previously used to indicate fatal errors, which
	 * now result in aborting and bringing down the ring. This field
	 * is deprecated.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_SFT		1
	/* No error. */
		#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_NO_ERROR	(UINT32_C(0x0) << 1)
	/* Deprecated. */
		#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_BAD_FMT	(UINT32_C(0x2) << 1)
		#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_LAST		TX_CMPL_PACKET_TIMESTAMP_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * This error is fatal and results in aborting and bringing down the
	 * ring, thus is deprecated.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_ZERO_LENGTH_PKT		UINT32_C(0x10)
	/*
	 * This error is fatal and results in aborting and bringing down the
	 * ring, thus is deprecated.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_EXCESSIVE_BD_LENGTH	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the BDs
	 * associated with this packet generated a PCI error when accessing
	 * header/payload data from host memory. It most likely indicates
	 * that the address was not valid. Note that this bit has no meaning
	 * for the timestamp completion and will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_DMA_ERROR			UINT32_C(0x40)
	/*
	 * This error is fatal and results in aborting and bringing down the
	 * ring, thus is deprecated.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_HINT_TOO_SHORT		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to Poison TLP error on one or more of the TLPs in one or more
	 * of the associated PXP completion(s) when accessing header/payload
	 * data from host memory. Note that this bit has no meaning for the
	 * timestamp completion, and will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_POISON_TLP_ERROR		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to a transient internal error in TDC. The packet or LSO can
	 * be retried and may transmit successfully on a subsequent attempt.
	 * Note that this bit has no meaning for the timestamp completion
	 * and will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_INTERNAL_ERROR		UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a timestamp
	 * for a timestamp completion, in which case the ts_ns and ts_sub_ns
	 * fields are invalid. When this bit is '0' in a timestamp
	 * completion record, the ts_sub_ns, ts_ns_lo, and ts_ns_mid fields
	 * are valid. Note that this bit has meaning only for the timestamp
	 * completion. For types other than the timestamp completion, this
	 * bit will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_TIMESTAMP_INVALID_ERROR	UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates that a Timed Transmit
	 * SO-TXTIME packet violated the max_ttx_overtime constraint i.e.,
	 * the time the packet was processed for transmission in TWE was
	 * later than the time given by (TimedTx_BD.tx_time +
	 * max_ttx_overtime) and as result, the packet was dropped.
	 * Note that max_ttx_overtime is a global configuration in TWE.
	 * Note that this bit has no meaning in a timestamp completion,
	 * and will always be '0'.
	 */
	#define TX_CMPL_PACKET_TIMESTAMP_ERRORS_TTX_OVERTIME_ERROR	UINT32_C(0x800)
	/* unused2 is 16 b */
	uint16_t	unused_2;
	/*
	 * This is bits [31:0] of the nanoseconds portion of the packet
	 * timestamp, returned from PM for 2-step PTP timestamp or from
	 * PA for PA timestamps. This field is in units of ns.
	 */
	uint32_t	ts_ns_lo;
} tx_cmpl_packet_timestamp_t, *ptx_cmpl_packet_timestamp_t;

/* rx_pkt_cmpl (size:128b/16B) */

typedef struct rx_pkt_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_PKT_CMPL_TYPE_SFT			0
	/*
	 * RX L2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 */
		#define RX_PKT_CMPL_TYPE_RX_L2			UINT32_C(0x11)
		#define RX_PKT_CMPL_TYPE_LAST			RX_PKT_CMPL_TYPE_RX_L2
	#define RX_PKT_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_PKT_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Normal:
	 * Packet was placed using normal algorithm.
	 */
		#define RX_PKT_CMPL_FLAGS_PLACEMENT_NORMAL		(UINT32_C(0x0) << 7)
	/*
	 * Jumbo:
	 * Packet was placed using jumbo algorithm.
	 */
		#define RX_PKT_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_PKT_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
		#define RX_PKT_CMPL_FLAGS_PLACEMENT_LAST		RX_PKT_CMPL_FLAGS_PLACEMENT_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory.
	 */
	#define RX_PKT_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_PKT_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_NOT_KNOWN		(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_IP			(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 12)
	/*
	 * PTP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP	(UINT32_C(0x8) << 12)
	/*
	 * PTP packet w/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 12)
		#define RX_PKT_CMPL_FLAGS_ITYPE_LAST		RX_PKT_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_CMPL_V1	UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_CMPL_AGG_BUFS_MASK UINT32_C(0x3e)
	#define RX_PKT_CMPL_AGG_BUFS_SFT 1
	/* unused1 is 2 b */
	#define RX_PKT_CMPL_UNUSED1_MASK UINT32_C(0xc0)
	#define RX_PKT_CMPL_UNUSED1_SFT  6
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * Note that 4-tuples values listed below are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 */
	#define RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_0 UINT32_C(0x0)
	/*
	 * The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 */
	#define RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_1 UINT32_C(0x1)
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_2 UINT32_C(0x2)
	/*
	 * The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_3 UINT32_C(0x3)
	#define RX_PKT_CMPL_RSS_HASH_TYPE_LAST  RX_PKT_CMPL_RSS_HASH_TYPE_ENUM_3
	/*
	 * This value indicates the offset in bytes from the beginning of the
	 * packet where the inner payload starts. This value is valid for TCP,
	 * UDP, FCoE, and RoCE packets.
	 *
	 * A value of zero indicates that header is 256B into the packet.
	 */
	uint8_t	payload_offset;
	/* unused2 is 8 b */
	uint8_t	unused1;
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} rx_pkt_cmpl_t, *prx_pkt_cmpl_t;

/* Last 16 bytes of rx_pkt_cmpl. */
/* rx_pkt_cmpl_hi (size:128b/16B) */

typedef struct rx_pkt_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the ip_cs_error field indicates if there
	 * was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the l4_cs_error field
	 * indicates if there was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the t_ip_cs_error field indicates if there
	 * was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the t_l4_cs_error field
	 * indicates if there was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_SFT		4
	/* No metadata information. Value is zero. */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_VLAN		(UINT32_C(0x1) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset, inner_l2_offset, inner_l3_offset and
	 * inner_l4_size.
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[17:9] contains the inner_l2_offset.
	 * - metadata[26:18] contains the inner_l3_offset.
	 * - metadata[31:27] contains the inner_l4_size.
	 */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_LAST		RX_PKT_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_CMPL_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * The combination of this value and meta_format indicated what
	 * format the metadata field is.
	 */
	#define RX_PKT_CMPL_FLAGS2_EXT_META_FORMAT_MASK	UINT32_C(0xc00)
	#define RX_PKT_CMPL_FLAGS2_EXT_META_FORMAT_SFT	10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_PKT_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_CMPL_METADATA_VID_SFT  0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_PKT_CMPL_METADATA_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_PKT_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_CMPL_METADATA_PRI_SFT  13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define RX_PKT_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_PKT_CMPL_METADATA_TPID_SFT 16
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_CMPL_V2					UINT32_C(0x1)
	#define RX_PKT_CMPL_ERRORS_MASK				UINT32_C(0xfffe)
	#define RX_PKT_CMPL_ERRORS_SFT				1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_SFT		1
	/* No buffer error */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Packet did not fit into packet buffer provided.
	 * For regular placement, this means the packet did not fit
	 * in the buffer provided. For HDS and jumbo placement, this
	 * means that the packet could not be placed into 7 physical
	 * buffers or less.
	 */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT		(UINT32_C(0x1) << 1)
	/*
	 * Not On Chip:
	 * All BDs needed for the packet were not on-chip when
	 * the packet arrived.
	 */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_FLUSH		(UINT32_C(0x5) << 1)
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_LAST		RX_PKT_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This indicates that there was an error in the IP header
	 * checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_IP_CS_ERROR			UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP
	 * or ICMP checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_L4_CS_ERROR			UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel
	 * IP header checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_T_IP_CS_ERROR			UINT32_C(0x40)
	/*
	 * This indicates that there was an error in the tunnel
	 * UDP checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_T_L4_CS_ERROR			UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_CMPL_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_SFT			9
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6
	 * in the tunnel header.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the
	 * tunnel header. Valid for
	 * IPv4.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the PPPoE header length for a tunnel PPPoE
	 * packet.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6
	 * tunnel packet packets.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel UDP header length for a tunnel
	 * UDP packet that is not fragmented.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 9)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0) in the tunnel header. Valid
	 * for IPv4, and IPv6.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x6) << 9)
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_LAST			RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR		(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL   (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_LAST			RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	uint32_t	reorder;
	/*
	 * This value holds the reordering sequence number for the packet.
	 * If the reordering sequence is not valid, then this value is zero.
	 * The reordering domain for the packet is in the bottom 8 to 10b of
	 * the rss_hash value. The bottom 20b of this value contain the
	 * ordering domain value for the packet.
	 */
	#define RX_PKT_CMPL_REORDER_MASK UINT32_C(0xffffff)
	#define RX_PKT_CMPL_REORDER_SFT 0
} rx_pkt_cmpl_hi_t, *prx_pkt_cmpl_hi_t;

/* rx_pkt_v2_cmpl (size:128b/16B) */

typedef struct rx_pkt_v2_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_V2_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_PKT_V2_CMPL_TYPE_SFT			0
	/*
	 * RX L2 V2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_L2 completion used in SR2
	 * and later chips.
	 */
		#define RX_PKT_V2_CMPL_TYPE_RX_L2_V2			UINT32_C(0xf)
		#define RX_PKT_V2_CMPL_TYPE_LAST			RX_PKT_V2_CMPL_TYPE_RX_L2_V2
	#define RX_PKT_V2_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_PKT_V2_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Normal:
	 * Packet was placed using normal algorithm.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_NORMAL		(UINT32_C(0x0) << 7)
	/*
	 * Jumbo:
	 * Packet was placed using jumbo algorithm.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * Truncation:
	 * Packet was placed using truncation algorithm. The
	 * placed (truncated) length is indicated in the payload_offset
	 * field. The original length is indicated in the len field.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_TRUNCATION	(UINT32_C(0x3) << 7)
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_LAST		RX_PKT_V2_CMPL_FLAGS_PLACEMENT_TRUNCATION
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_V2_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_NOT_KNOWN		(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_IP			(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 12)
	/*
	 * PTP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP	(UINT32_C(0x8) << 12)
	/*
	 * PTP packet w/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 12)
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_LAST		RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V2_CMPL_V1	UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_V2_CMPL_AGG_BUFS_MASK UINT32_C(0x3e)
	#define RX_PKT_V2_CMPL_AGG_BUFS_SFT 1
	/* unused1 is 2 b */
	#define RX_PKT_V2_CMPL_UNUSED1_MASK UINT32_C(0xc0)
	#define RX_PKT_V2_CMPL_UNUSED1_SFT  6
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * Note that 4-tuples values listed below are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 */
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_0 UINT32_C(0x0)
	/*
	 * The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 */
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_1 UINT32_C(0x1)
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_2 UINT32_C(0x2)
	/*
	 * The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_3 UINT32_C(0x3)
	#define RX_PKT_V2_CMPL_RSS_HASH_TYPE_LAST  RX_PKT_V2_CMPL_RSS_HASH_TYPE_ENUM_3
	uint16_t	metadata1_payload_offset;
	/*
	 * This is data from the CFA as indicated by the meta_format field.
	 * If truncation placement is not used, this value indicates the offset
	 * in bytes from the beginning of the packet where the inner payload
	 * starts. This value is valid for TCP, UDP, FCoE, and RoCE packets. If
	 * truncation placement is used, this value represents the placed
	 * (truncated) length of the packet.
	 */
	#define RX_PKT_V2_CMPL_PAYLOAD_OFFSET_MASK	UINT32_C(0x1ff)
	#define RX_PKT_V2_CMPL_PAYLOAD_OFFSET_SFT	0
	/* This is data from the CFA as indicated by the meta_format field. */
	#define RX_PKT_V2_CMPL_METADATA1_MASK		UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_METADATA1_SFT		12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_MASK	UINT32_C(0x7000)
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_SFT	12
	/* 0x88a8 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 12)
	/* 0x8100 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 12)
	/* 0x9100 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 12)
	/* 0x9200 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 12)
	/* 0x9300 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 12)
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_LAST	RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_PKT_V2_CMPL_METADATA1_VALID		UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC. When vee_cmpl_mode
	 * is set in VNIC context, this is the lower 32b of the host address
	 * from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} rx_pkt_v2_cmpl_t, *prx_pkt_v2_cmpl_t;

/* Last 16 bytes of RX Packet V2 Completion Record */
/* rx_pkt_v2_cmpl_hi (size:128b/16B) */

typedef struct rx_pkt_v2_cmpl_hi {
	uint32_t	flags2;
	/*
	 * When this bit is '0', the cs_ok field has the following definition:-
	 * ip_cs_ok[2:0] = The number of header groups with a valid IP checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. -
	 * l4_cs_ok[5:3] = The number of header groups with a valid L4 checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. When this
	 * bit is '1', the cs_ok field has the following definition: -
	 * hdr_cnt[2:0] = The number of header groups that were parsed by the
	 * chip and passed in the delivered packet. - ip_cs_all_ok[3] =This bit
	 * will be '1' if all the parsed header groups with an IP checksum are
	 * valid. - l4_cs_all_ok[4] = This bit will be '1' if all the parsed
	 * header groups with an L4 checksum are valid.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_ALL_OK_MODE		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_SFT		4
	/* There is no metadata information. Values are zero. */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_LAST		RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_OK_MASK		UINT32_C(0xfc00)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_OK_SFT		10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V2_CMPL_HI_V2					UINT32_C(0x1)
	#define RX_PKT_V2_CMPL_HI_ERRORS_MASK				UINT32_C(0xfffe)
	#define RX_PKT_V2_CMPL_HI_ERRORS_SFT				1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_SFT		1
	/* No buffer error */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_NO_BUFFER		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit: Packet did not fit into packet buffer provided.
	 * For regular placement, this means the packet did not fit in
	 * the buffer provided. For HDS and jumbo placement, this means
	 * that the packet could not be placed into 8 physical buffers
	 * (if fixed-size buffers are used), or that the packet could
	 * not be placed in the number of physical buffers configured
	 * for the VNIC (if variable-size buffers are used)
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_DID_NOT_FIT		(UINT32_C(0x1) << 1)
	/*
	 * Not On Chip: All BDs needed for the packet were not on-chip
	 * when the packet arrived. For regular placement, this error is
	 * not valid. For HDS and jumbo placement, this means that not
	 * enough agg BDs were posted to place the packet.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_NOT_ON_CHIP		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_BAD_FORMAT		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH		(UINT32_C(0x5) << 1)
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_LAST		RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This indicates that there was an error in the outer tunnel
	 * portion of the packet when this field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_MASK		UINT32_C(0x70)
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_SFT		4
	/*
	 * No additional error occurred on the outer tunnel portion
	 * of the packet or the packet does not have a outer tunnel.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 4)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the outer tunnel header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_VERSION	(UINT32_C(0x1) << 4)
	/*
	 * Indicates that header length is out of range in the outer
	 * tunnel header. Valid for IPv4.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 4)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the outer tunnel l3 header length. Valid for IPv4, or
	 * IPv6 outer tunnel packets.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_IP_TOTAL_ERROR	(UINT32_C(0x3) << 4)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the outer tunnel UDP header length for a outer
	 * tunnel UDP packet that is not fragmented.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_UDP_TOTAL_ERROR	(UINT32_C(0x4) << 4)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have
	 * failed (e.g. TTL = 0) in the outer tunnel header. Valid for
	 * IPv4, and IPv6.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_TTL	(UINT32_C(0x5) << 4)
	/*
	 * Indicates that the IP checksum failed its check in the outer
	 * tunnel header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_IP_CS_ERROR	(UINT32_C(0x6) << 4)
	/*
	 * Indicates that the L4 checksum failed its check in the outer
	 * tunnel header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L4_CS_ERROR	(UINT32_C(0x7) << 4)
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_LAST		RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L4_CS_ERROR
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel portion
	 * of the packet when this field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_SFT			9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet or the packet does not have a tunnel.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the tunnel
	 * header. Valid for IPv4.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 tunnel
	 * packet packets.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that the physical packet is shorter than that claimed
	 * by the tunnel UDP header length for a tunnel UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have failed
	 * (e.g. TTL = 0) in the tunnel header. Valid for IPv4, and IPv6.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x5) << 9)
	/*
	 * Indicates that the IP checksum failed its check in the tunnel
	 * header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_CS_ERROR		(UINT32_C(0x6) << 9)
	/*
	 * Indicates that the L4 checksum failed its check in the tunnel
	 * header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR		(UINT32_C(0x7) << 9)
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_LAST			RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR		(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL   (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
	/*
	 * Indicates that the IP checksum failed its check in the
	 * inner header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_IP_CS_ERROR		(UINT32_C(0x9) << 12)
	/*
	 * Indicates that the L4 checksum failed its check in the
	 * inner header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_CS_ERROR		(UINT32_C(0xa) << 12)
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_LAST			RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_CS_ERROR
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_V2_CMPL_HI_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_V2_CMPL_HI_METADATA0_PRI_SFT 13
	/*
	 * The timestamp field contains the 32b timestamp for the packet from
	 * the MAC.
	 */
	uint32_t	timestamp;
} rx_pkt_v2_cmpl_hi_t, *prx_pkt_v2_cmpl_hi_t;

/* rx_pkt_v3_cmpl (size:128b/16B) */

typedef struct rx_pkt_v3_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_V3_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_PKT_V3_CMPL_TYPE_SFT			0
	/*
	 * RX L2 V3 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_L2 completion used in Thor2
	 * and later chips.
	 */
		#define RX_PKT_V3_CMPL_TYPE_RX_L2_V3			UINT32_C(0x17)
		#define RX_PKT_V3_CMPL_TYPE_LAST			RX_PKT_V3_CMPL_TYPE_RX_L2_V3
	#define RX_PKT_V3_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_PKT_V3_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Normal:
	 * Packet was placed using normal algorithm.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_NORMAL		(UINT32_C(0x0) << 7)
	/*
	 * Jumbo:
	 * Packet was placed using jumbo algorithm.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * Truncation:
	 * Packet was placed using truncation algorithm. The
	 * placed (truncated) length is indicated in the payload_offset
	 * field. The original length is indicated in the len field.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_TRUNCATION	(UINT32_C(0x3) << 7)
		#define RX_PKT_V3_CMPL_FLAGS_PLACEMENT_LAST		RX_PKT_V3_CMPL_FLAGS_PLACEMENT_TRUNCATION
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_V3_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_PKT_V3_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_NOT_KNOWN		(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_IP			(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 12)
	/*
	 * PTP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP	(UINT32_C(0x8) << 12)
	/*
	 * PTP packet w/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet and that a timestamp was taken for the packet.
	 * The 4b sub-nanosecond portion of the timestamp is in
	 * the payload_offset field.
	 */
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 12)
		#define RX_PKT_V3_CMPL_FLAGS_ITYPE_LAST		RX_PKT_V3_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint16_t	rss_hash_type_agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V3_CMPL_V1		UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_V3_CMPL_AGG_BUFS_MASK	UINT32_C(0x3e)
	#define RX_PKT_V3_CMPL_AGG_BUFS_SFT	1
	/* unused1 is 1 b */
	#define RX_PKT_V3_CMPL_UNUSED1		UINT32_C(0x40)
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * Note that 4-tuples values listed below are applicable
	 * for layer 4 protocols supported and enabled for RSS in the
	 * hardware, HWRM firmware, and drivers. For example, if RSS hash
	 * is supported and enabled for TCP traffic only, then the values of
	 * tuple_extract_op corresponding to 4-tuples are only valid for
	 * TCP traffic.
	 */
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_MASK   UINT32_C(0xff80)
	#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_SFT	7
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * inner IP and TCP or UDP headers.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_0   (UINT32_C(0x0) << 7)
	/*
	 * The RSS hash was computed over source IP address and
	 * destination IP address of inner IP header.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_1   (UINT32_C(0x1) << 7)
	/*
	 * The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_2   (UINT32_C(0x2) << 7)
	/*
	 * The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_3   (UINT32_C(0x3) << 7)
	/*
	 * The RSS hash was computed over source IP address of the inner
	 * IP header.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_4   (UINT32_C(0x4) << 7)
	/*
	 * The RSS hash was computed over destination IP address of the
	 * inner IP header.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_5   (UINT32_C(0x5) << 7)
	/*
	 * The RSS hash was computed over source IP address of the outer
	 * IP header.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_6   (UINT32_C(0x6) << 7)
	/*
	 * The RSS hash was computed over destination IP address of the
	 * outer IP header.
	 * Note: For non-tunneled packets, this value is not applicable.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_7   (UINT32_C(0x7) << 7)
	/*
	 * The RSS hash was computed over source IP address, destination
	 * IP address, and flow label of the inner IP header.
	 * Note: For packets without an inner IPv6 header, this value is not
	 * this value is not applicable.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_8   (UINT32_C(0x8) << 7)
	/*
	 * The RSS hash was computed over the flow label of the inner
	 * IP header.
	 * Note: For packets without an inner IPv6 header, this value
	 * is not applicable.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_9   (UINT32_C(0x9) << 7)
	/*
	 * The RSS hash was computed over source IP address, destination
	 * IP address, and flow label of the outer IP header.
	 * Note: For packets without an outer IPv6 header, this value is not
	 * applicable.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_10  (UINT32_C(0xa) << 7)
	/*
	 * The RSS hash was computed over the flow label of the outer
	 * IP header.
	 * Note: For packets without an outer IPv6 header, this value
	 * is not applicable.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_11  (UINT32_C(0xb) << 7)
	/* The RSS hash was computed over tunnel context and tunnel ID field. */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_12  (UINT32_C(0xc) << 7)
	/*
	 * The RSS hash was computed over tunnel source IP address, tunnel
	 * destination IP address, and tunnel ID field.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_13  (UINT32_C(0xd) << 7)
	/*
	 * The RSS hash was computed over tunnel source IP address, tunnel
	 * destination IP address, tunnel context, and tunnel ID field.
	 */
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_14  (UINT32_C(0xe) << 7)
		#define RX_PKT_V3_CMPL_RSS_HASH_TYPE_LAST	RX_PKT_V3_CMPL_RSS_HASH_TYPE_ENUM_14
	uint16_t	metadata1_payload_offset;
	/*
	 * If truncation placement is not used, this value indicates the offset
	 * in bytes from the beginning of the packet where the inner payload
	 * starts. This value is valid for TCP, UDP, FCoE, and RoCE packets.
	 * For PTP packets with timestamp (as indicated by the flags_itype
	 * field), this field contains the 4b sub-nanosecond portion of the
	 * timestamp.
	 *
	 * If truncation placement is used, this value represents the placed
	 * (truncated) length of the packet.
	 */
	#define RX_PKT_V3_CMPL_PAYLOAD_OFFSET_MASK	UINT32_C(0x1ff)
	#define RX_PKT_V3_CMPL_PAYLOAD_OFFSET_SFT	0
	/* This is data from the CFA as indicated by the meta_format field. */
	#define RX_PKT_V3_CMPL_METADATA1_MASK		UINT32_C(0xf000)
	#define RX_PKT_V3_CMPL_METADATA1_SFT		12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_MASK	UINT32_C(0x7000)
	#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_SFT	12
	/* 0x88a8 */
		#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 12)
	/* 0x8100 */
		#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 12)
	/* 0x9100 */
		#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 12)
	/* 0x9200 */
		#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 12)
	/* 0x9300 */
		#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
		#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 12)
		#define RX_PKT_V3_CMPL_METADATA1_TPID_SEL_LAST	RX_PKT_V3_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_PKT_V3_CMPL_METADATA1_VALID		UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC. When hairpin_en
	 * is set in VNIC context, this is the lower 32b of the host address
	 * from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} rx_pkt_v3_cmpl_t, *prx_pkt_v3_cmpl_t;

/* Last 16 bytes of RX Packet V3 Completion Record */
/* rx_pkt_v3_cmpl_hi (size:128b/16B) */

typedef struct rx_pkt_v3_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the inner
	 * packet and that the ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was calculated
	 * for the inner packet and that the l4_cs_error field indicates if
	 * there was an error.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the tunnel
	 * header and that the t_ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was calculated for the tunnel
	 * packet and that the t_l4_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_SFT		4
	/* There is no metadata information. Values are zero. */
		#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
		#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_LAST		RX_PKT_V3_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE		UINT32_C(0x400)
	/* Indicates that the Tunnel IP type was IPv4 */
		#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE_IPV4		(UINT32_C(0x0) << 10)
	/* Indicates that the Tunnel IP type was IPv6 */
		#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE_IPV6		(UINT32_C(0x1) << 10)
		#define RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE_LAST		RX_PKT_V3_CMPL_HI_FLAGS2_T_IP_TYPE_IPV6
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define RX_PKT_V3_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_PKT_V3_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V3_CMPL_HI_V2					UINT32_C(0x1)
	#define RX_PKT_V3_CMPL_HI_ERRORS_MASK				UINT32_C(0xfffe)
	#define RX_PKT_V3_CMPL_HI_ERRORS_SFT				1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_SFT		1
	/* No buffer error */
		#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_NO_BUFFER		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit: Packet did not fit into packet buffer provided.
	 * For regular placement, this means the packet did not fit in
	 * the buffer provided. For HDS and jumbo placement, this means
	 * that the packet could not be placed into 8 physical buffers.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_DID_NOT_FIT		(UINT32_C(0x1) << 1)
	/*
	 * Not On Chip: All BDs needed for the packet were not on-chip
	 * when the packet arrived. For regular placement, this error is
	 * not valid. For HDS and jumbo placement, this means that not
	 * enough agg BDs were posted to place the packet.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_NOT_ON_CHIP		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_BAD_FORMAT		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH		(UINT32_C(0x5) << 1)
		#define RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_LAST		RX_PKT_V3_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH
	/* This indicates that there was an error in the IP header checksum. */
	#define RX_PKT_V3_CMPL_HI_ERRORS_IP_CS_ERROR			UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP or ICMP
	 * checksum.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_L4_CS_ERROR			UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel IP header
	 * checksum.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_IP_CS_ERROR			UINT32_C(0x40)
	/* This indicates that there was an error in the tunnel UDP checksum. */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_L4_CS_ERROR			UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel portion
	 * of the packet when this field is non-zero.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_SFT			9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet or the packet does not have a tunnel.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the tunnel
	 * header. Valid for IPv4.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 tunnel
	 * packet packets.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that the physical packet is shorter than that claimed
	 * by the tunnel UDP header length for a tunnel UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have failed
	 * (e.g. TTL = 0) in the tunnel header. Valid for IPv4, and IPv6.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x5) << 9)
	/*
	 * Indicates that the physical packet is shorter than that claimed
	 * by the tunnel header length. Valid for GTPv1-U packets.
	 * header.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_TOTAL_ERROR		(UINT32_C(0x6) << 9)
		#define RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_LAST			RX_PKT_V3_CMPL_HI_ERRORS_T_PKT_ERROR_T_TOTAL_ERROR
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR		(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL   (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
		#define RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_LAST			RX_PKT_V3_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_PKT_V3_CMPL_HI_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_V3_CMPL_HI_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_PKT_V3_CMPL_HI_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_PKT_V3_CMPL_HI_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_V3_CMPL_HI_METADATA0_PRI_SFT 13
	/*
	 * The timestamp field contains the 32b timestamp for the packet from
	 * the MAC.
	 *
	 * When hairpin_en is set in VNIC context, this is the upper 32b of the
	 * host address from the first BD used to place the packet.
	 */
	uint32_t	timestamp;
} rx_pkt_v3_cmpl_hi_t, *prx_pkt_v3_cmpl_hi_t;

/* rx_pkt_compress_cmpl (size:128b/16B) */

typedef struct rx_pkt_compress_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_COMPRESS_CMPL_TYPE_MASK		UINT32_C(0x3f)
	#define RX_PKT_COMPRESS_CMPL_TYPE_SFT			0
	/*
	 * RX L2 completion:
	 * This is the compressed version of Rx Completion for performance
	 * applications. Length = 16B
	 * This version of the completion record is used in Thor2 and later
	 * chips.
	 */
		#define RX_PKT_COMPRESS_CMPL_TYPE_RX_L2_COMPRESS	UINT32_C(0x10)
		#define RX_PKT_COMPRESS_CMPL_TYPE_LAST			RX_PKT_COMPRESS_CMPL_TYPE_RX_L2_COMPRESS
	#define RX_PKT_COMPRESS_CMPL_FLAGS_MASK		UINT32_C(0xffc0)
	#define RX_PKT_COMPRESS_CMPL_FLAGS_SFT		6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ERROR		UINT32_C(0x40)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE		UINT32_C(0x100)
	/* Indicates that the Tunnel IP type was IPv4 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE_IPV4	(UINT32_C(0x0) << 8)
	/* Indicates that the Tunnel IP type was IPv6 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE_IPV6	(UINT32_C(0x1) << 8)
		#define RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE_LAST	RX_PKT_COMPRESS_CMPL_FLAGS_T_IP_TYPE_IPV6
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_IP_TYPE		UINT32_C(0x200)
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_NOT_KNOWN	(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_IP		(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 12)
	/*
	 * PTP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP   (UINT32_C(0x8) << 12)
	/*
	 * PTP packet w/timestamp:
	 * Indicates that the packet was recognized as a PTP
	 * packet and that a timestamp was taken for the packet.
	 * The 4b sub-nanosecond portion of the timestamp is in
	 * the payload_offset field.
	 */
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 12)
		#define RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_LAST		RX_PKT_COMPRESS_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC. When hairpin_en
	 * is set in VNIC context, this is the lower 32b of the host address
	 * from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
	uint16_t	metadata1_cs_error_calc_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_COMPRESS_CMPL_V1				UINT32_C(0x1)
	/* unused is 3 b */
	#define RX_PKT_COMPRESS_CMPL_UNUSED_MASK			UINT32_C(0xe)
	#define RX_PKT_COMPRESS_CMPL_UNUSED_SFT			1
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_MASK		UINT32_C(0xff0)
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_SFT		4
	/* This indicates that there was an error in the IP header checksum. */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_IP_CS_ERROR	UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP or ICMP
	 * checksum.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_L4_CS_ERROR	UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel IP header
	 * checksum.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_T_IP_CS_ERROR	UINT32_C(0x40)
	/* This indicates that there was an error in the tunnel UDP checksum. */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_T_L4_CS_ERROR	UINT32_C(0x80)
	/*
	 * This indicates that the ip checksum was calculated for the inner
	 * packet and that the ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_IP_CS_CALC	UINT32_C(0x100)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was calculated
	 * for the inner packet and that the l4_cs_error field indicates if
	 * there was an error.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_L4_CS_CALC	UINT32_C(0x200)
	/*
	 * This indicates that the ip checksum was calculated for the tunnel
	 * header and that the t_ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_T_IP_CS_CALC	UINT32_C(0x400)
	/*
	 * This indicates that the UDP checksum was calculated for the tunnel
	 * packet and that the t_l4_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_PKT_COMPRESS_CMPL_CS_ERROR_CALC_T_L4_CS_CALC	UINT32_C(0x800)
	/* This is data from the CFA as indicated by the meta_format field. */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_MASK		UINT32_C(0xf000)
	#define RX_PKT_COMPRESS_CMPL_METADATA1_SFT		12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_MASK	UINT32_C(0x7000)
	#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_SFT	12
	/* 0x88a8 */
		#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID88A8	(UINT32_C(0x0) << 12)
	/* 0x8100 */
		#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID8100	(UINT32_C(0x1) << 12)
	/* 0x9100 */
		#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID9100	(UINT32_C(0x2) << 12)
	/* 0x9200 */
		#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID9200	(UINT32_C(0x3) << 12)
	/* 0x9300 */
		#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPID9300	(UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
		#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 12)
		#define RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_LAST	RX_PKT_COMPRESS_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_PKT_COMPRESS_CMPL_METADATA1_VALID		UINT32_C(0x8000)
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	vlanc_tcid;
	/* When meta_format!=0, this value is the VLAN VID. */
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_VID_SFT 0
	/* When meta_format!=0, this value is the VLAN DE. */
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_DE	UINT32_C(0x1000)
	/* When meta_format!=0, this value is the VLAN PRI. */
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_COMPRESS_CMPL_VLANC_TCID_PRI_SFT 13
	uint32_t	errors_agg_bufs_opaque;
	/* Lower 16bits of the Opaque field provided in the Rx BD. */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_OPAQUE_MASK				UINT32_C(0xffff)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_OPAQUE_SFT				0
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_AGG_BUFS_MASK				UINT32_C(0x1f0000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_AGG_BUFS_SFT				16
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_MASK				UINT32_C(0x1fe00000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_SFT				21
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_MASK			UINT32_C(0x1e00000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_SFT			21
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 21)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 21)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 21)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 21)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 21)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR		(UINT32_C(0x5) << 21)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 21)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL   (UINT32_C(0x7) << 21)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 21)
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_LAST			RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/*
	 * This indicates that there was an error in the tunnel portion
	 * of the packet when this field is non-zero.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe000000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_SFT			25
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet or the packet does not have a tunnel.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 25)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 25)
	/*
	 * Indicates that header length is out of range in the tunnel
	 * header. Valid for IPv4.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 25)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 tunnel
	 * packet packets.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x3) << 25)
	/*
	 * Indicates that the physical packet is shorter than that claimed
	 * by the tunnel UDP header length for a tunnel UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x4) << 25)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have failed
	 * (e.g. TTL = 0) in the tunnel header. Valid for IPv4, and IPv6.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x5) << 25)
	/*
	 * Indicates that the IP checksum failed its check in the tunnel
	 * header.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_IP_CS_ERROR		(UINT32_C(0x6) << 25)
	/*
	 * Indicates that the L4 checksum failed its check in the tunnel
	 * header.
	 */
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR		(UINT32_C(0x7) << 25)
		#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_LAST			RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_ERRORS_CRC_ERROR			UINT32_C(0x10000000)
	/* unused1 is 3 b */
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_UNUSED1_MASK				UINT32_C(0xe0000000)
	#define RX_PKT_COMPRESS_CMPL_ERRORS_AGG_BUFS_OPAQUE_UNUSED1_SFT				29
} rx_pkt_compress_cmpl_t, *prx_pkt_compress_cmpl_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_cmpl (size:128b/16B) */

typedef struct rx_tpa_start_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_START_CMPL_TYPE_MASK		UINT32_C(0x3f)
	#define RX_TPA_START_CMPL_TYPE_SFT		0
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
		#define RX_TPA_START_CMPL_TYPE_RX_TPA_START	UINT32_C(0x13)
		#define RX_TPA_START_CMPL_TYPE_LAST		RX_TPA_START_CMPL_TYPE_RX_TPA_START
	#define RX_TPA_START_CMPL_FLAGS_MASK		UINT32_C(0xffc0)
	#define RX_TPA_START_CMPL_FLAGS_SFT		6
	/* This bit will always be '0' for TPA start completions. */
	#define RX_TPA_START_CMPL_FLAGS_ERROR		UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_MASK	UINT32_C(0x380)
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_SFT	7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_JUMBO	(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_HDS	(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_JUMBO   (UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_LAST	RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_START_CMPL_FLAGS_RSS_VALID	UINT32_C(0x400)
	/* unused is 1 b */
	#define RX_TPA_START_CMPL_FLAGS_UNUSED		UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_START_CMPL_FLAGS_ITYPE_MASK	UINT32_C(0xf000)
	#define RX_TPA_START_CMPL_FLAGS_ITYPE_SFT	12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
		#define RX_TPA_START_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
		#define RX_TPA_START_CMPL_FLAGS_ITYPE_LAST	RX_TPA_START_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_START_CMPL_LAST RX_TPA_START_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/* unused2 is 9 b */
	#define RX_TPA_START_CMPL_UNUSED2_MASK UINT32_C(0x1ff)
	#define RX_TPA_START_CMPL_UNUSED2_SFT 0
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_START_CMPL_AGG_ID_MASK UINT32_C(0xfe00)
	#define RX_TPA_START_CMPL_AGG_ID_SFT  9
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} rx_tpa_start_cmpl_t, *prx_tpa_start_cmpl_t;

/*
 * Last 16 bytes of rx_tpa_start_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_start_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_IP_CS_CALC	UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the sum passed
	 * for all segments included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_L4_CS_CALC	UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_T_IP_CS_CALC	UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the sum passed for
	 * all segments included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_T_L4_CS_CALC	UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_MASK UINT32_C(0xf0)
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_SFT  4
	/* No metadata information. Value is zero. */
		#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_NONE   (UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
		#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN   (UINT32_C(0x1) << 4)
		#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_LAST  RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_IP_TYPE	UINT32_C(0x100)
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_TPA_START_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_START_CMPL_METADATA_VID_SFT  0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_TPA_START_CMPL_METADATA_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_TPA_START_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_START_CMPL_METADATA_PRI_SFT  13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define RX_TPA_START_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_TPA_START_CMPL_METADATA_TPID_SFT 16
	uint16_t	v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_CMPL_V2	UINT32_C(0x1)
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	uint32_t	inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset;
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the outer L3 header. If there is no outer L3 header, then this
	 * value is zero.
	 */
	#define RX_TPA_START_CMPL_OUTER_L3_OFFSET_MASK UINT32_C(0x1ff)
	#define RX_TPA_START_CMPL_OUTER_L3_OFFSET_SFT 0
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L2 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L2_OFFSET_MASK UINT32_C(0x3fe00)
	#define RX_TPA_START_CMPL_INNER_L2_OFFSET_SFT 9
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L3 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L3_OFFSET_MASK UINT32_C(0x7fc0000)
	#define RX_TPA_START_CMPL_INNER_L3_OFFSET_SFT 18
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L4_SIZE_MASK  UINT32_C(0xf8000000)
	#define RX_TPA_START_CMPL_INNER_L4_SIZE_SFT   27
} rx_tpa_start_cmpl_hi_t, *prx_tpa_start_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 * RX L2 TPA Start V2 Completion Record (32 bytes split to 2 16-byte
 * struct)
 */
/* rx_tpa_start_v2_cmpl (size:128b/16B) */

typedef struct rx_tpa_start_v2_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_START_V2_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_START_V2_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA Start V2 Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 * This is the new version of the RX_TPA_START completion used
	 * in SR2 and later chips.
	 */
		#define RX_TPA_START_V2_CMPL_TYPE_RX_TPA_START_V2		UINT32_C(0xd)
		#define RX_TPA_START_V2_CMPL_TYPE_LAST			RX_TPA_START_V2_CMPL_TYPE_RX_TPA_START_V2
	#define RX_TPA_START_V2_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_START_V2_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an error
	 * of some type. Type of error is indicated in error_flags.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * IOC/Jumbo:
	 * Packet will be placed using In-Order Completion/Jumbo where
	 * the first packet of the aggregation is placed using Jumbo
	 * Placement. Subsequent packets will be placed such that each
	 * packet starts at the beginning of an aggregation buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_JUMBO	(UINT32_C(0x4) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_HDS	(UINT32_C(0x7) << 7)
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_START_V2_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement. It
	 * starts at the first 32B boundary after the end of the header for
	 * HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
		#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_LAST		RX_TPA_START_V2_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to. If the VNIC is configured to not use an Rx BD for
	 * the TPA Start completion, then this is a copy of the opaque field
	 * from the first BD used to place the TPA Start packet.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V2_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_START_V2_CMPL_LAST RX_TPA_START_V2_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_START_V2_CMPL_AGG_ID_MASK		UINT32_C(0xfff)
	#define RX_TPA_START_V2_CMPL_AGG_ID_SFT		0
	#define RX_TPA_START_V2_CMPL_METADATA1_MASK		UINT32_C(0xf000)
	#define RX_TPA_START_V2_CMPL_METADATA1_SFT		12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_MASK	UINT32_C(0x7000)
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_SFT	12
	/* 0x88a8 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 12)
	/* 0x8100 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 12)
	/* 0x9100 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 12)
	/* 0x9200 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 12)
	/* 0x9300 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 12)
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_LAST	RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_TPA_START_V2_CMPL_METADATA1_VALID		UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 * When vee_cmpl_mode is set in VNIC context, this is the lower
	 * 32b of the host address from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} rx_tpa_start_v2_cmpl_t, *prx_tpa_start_v2_cmpl_t;

/*
 * Last 16 bytes of RX L2 TPA Start V2 Completion Record
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_v2_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_start_v2_cmpl_hi {
	uint32_t	flags2;
	/* This indicates that the aggregation was done using GRO rules. */
	#define RX_TPA_START_V2_CMPL_FLAGS2_AGG_GRO			UINT32_C(0x4)
	/*
	 * When this bit is '0', the cs_ok field has the following definition:-
	 * ip_cs_ok[2:0] = The number of header groups with a valid IP checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. -
	 * l4_cs_ok[5:3] = The number of header groups with a valid L4 checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. When this
	 * bit is '1', the cs_ok field has the following definition: -
	 * hdr_cnt[2:0] = The number of header groups that were parsed by the
	 * chip and passed in the delivered packet. - ip_cs_all_ok[3] =This bit
	 * will be '1' if all the parsed header groups with an IP checksum are
	 * valid. - l4_cs_all_ok[4] = This bit will be '1' if all the parsed
	 * header groups with an L4 checksum are valid.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_ALL_OK_MODE		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_SFT		4
	/* There is no metadata information. Values are zero. */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_LAST		RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet in the aggregation.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 * CS status for TPA packets is always valid. This means that "all_ok"
	 * status will always be set. The ok count status will be set
	 * appropriately for the packet header, such that all existing CS
	 * values are ok.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_OK_MASK		UINT32_C(0xfc00)
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_OK_SFT		10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set. For TPA Start completions,
	 * the complete checksum is calculated for the first packet in the
	 * aggregation only.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V2_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_START_V2_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define RX_TPA_START_V2_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packetThe packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Packet did not fit into packet buffer provided. This means
	 * that the TPA Start packet was too big to be placed into the
	 * per-packet maximum number of physical buffers configured for
	 * the VNIC, or that it was too big to be placed into the
	 * per-aggregation maximum number of physical buffers configured
	 * for the VNIC. This error only occurs when the VNIC is
	 * configured for variable size receive buffers.
	 */
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT   (UINT32_C(0x1) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT	(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format != 0, this value is the VLAN VID. */
	#define RX_TPA_START_V2_CMPL_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_START_V2_CMPL_METADATA0_VID_SFT 0
	/* When meta_format != 0, this value is the VLAN DE. */
	#define RX_TPA_START_V2_CMPL_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format != 0, this value is the VLAN PRI. */
	#define RX_TPA_START_V2_CMPL_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_START_V2_CMPL_METADATA0_PRI_SFT 13
	/*
	 * This field contains the outer_l3_offset, inner_l2_offset,
	 * inner_l3_offset, and inner_l4_size.
	 *
	 * hdr_offsets[8:0] contains the outer_l3_offset.
	 * hdr_offsets[17:9] contains the inner_l2_offset.
	 * hdr_offsets[26:18] contains the inner_l3_offset.
	 * hdr_offsets[31:27] contains the inner_l4_size.
	 */
	uint32_t	hdr_offsets;
} rx_tpa_start_v2_cmpl_hi_t, *prx_tpa_start_v2_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 * RX L2 TPA Start V3 Completion Record (32 bytes split to 2 16-byte
 * struct)
 */
/* rx_tpa_start_v3_cmpl (size:128b/16B) */

typedef struct rx_tpa_start_v3_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_START_V3_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_START_V3_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA Start V3 completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 * This is the new version of the RX_TPA_START completion used
	 * in Thor2 and later chips.
	 */
		#define RX_TPA_START_V3_CMPL_TYPE_RX_TPA_START_V3		UINT32_C(0x19)
		#define RX_TPA_START_V3_CMPL_TYPE_LAST			RX_TPA_START_V3_CMPL_TYPE_RX_TPA_START_V3
	#define RX_TPA_START_V3_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_START_V3_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an error
	 * of some type. Type of error is indicated in error_flags.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * IOC/Jumbo:
	 * Packet will be placed using In-Order Completion/Jumbo where
	 * the first packet of the aggregation is placed using Jumbo
	 * Placement. Subsequent packets will be placed such that each
	 * packet starts at the beginning of an aggregation buffer.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_IOC_JUMBO	(UINT32_C(0x4) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_IOC_HDS	(UINT32_C(0x7) << 7)
		#define RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_START_V3_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_START_V3_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement. It
	 * starts at the first 32B boundary after the end of the header for
	 * HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_START_V3_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
		#define RX_TPA_START_V3_CMPL_FLAGS_ITYPE_LAST		RX_TPA_START_V3_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to. If the VNIC is configured to not use an Rx BD for
	 * the TPA Start completion, then this is a copy of the opaque field
	 * from the first BD used to place the TPA Start packet.
	 */
	uint32_t	opaque;
	uint16_t	rss_hash_type_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V3_CMPL_V1		UINT32_C(0x1)
	/* unused1 is 6 b. */
	#define RX_TPA_START_V3_CMPL_UNUSED1_MASK	UINT32_C(0x7e)
	#define RX_TPA_START_V3_CMPL_UNUSED1_SFT	1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers.
	 * * 1: The RSS hash was computed over source IP address and
	 * destination IP address of inner IP header.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 4: The RSS hash was computed over source IP address of the inner
	 * IP header.
	 * * 5: The RSS hash was computed over destination IP address of the
	 * inner IP header.
	 * * 6: The RSS hash was computed over source IP address of the outer
	 * IP header. Note: For non-tunneled packets, this value is not
	 * applicable
	 * * 7: The RSS hash was computed over destination IP address of the
	 * outer IP header.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 8: The RSS hash was computed over source IP address, destination
	 * IP address, and flow label of the inner IP header.
	 * Note: For packets without an inner IPv6 header, this value is not
	 * applicable.
	 * * 9: The RSS hash was computed over the flow label of the inner
	 * IP header.
	 * Note: For packets without an inner IPv6 header, this value
	 * is not applicable.
	 * * 10: The RSS hash was computed over source IP address, destination
	 * IP address, and flow label of the outer IP header.
	 * Note: For packets without an outer IPv6 header, this value is not
	 * applicable.
	 * * 11: The RSS hash was computed over the flow label of the outer
	 * IP header. Note: For packets without an outer IPv6 header, this
	 * value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported
	 * and enabled for TCP traffic only, then the values of
	 * tuple_extract_op corresponding to 4-tuples are only valid for TCP
	 * traffic
	 */
	#define RX_TPA_START_V3_CMPL_RSS_HASH_TYPE_MASK UINT32_C(0xff80)
	#define RX_TPA_START_V3_CMPL_RSS_HASH_TYPE_SFT 7
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_START_V3_CMPL_AGG_ID_MASK		UINT32_C(0xfff)
	#define RX_TPA_START_V3_CMPL_AGG_ID_SFT		0
	#define RX_TPA_START_V3_CMPL_METADATA1_MASK		UINT32_C(0xf000)
	#define RX_TPA_START_V3_CMPL_METADATA1_SFT		12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_MASK	UINT32_C(0x7000)
	#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_SFT	12
	/* 0x88a8 */
		#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 12)
	/* 0x8100 */
		#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 12)
	/* 0x9100 */
		#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 12)
	/* 0x9200 */
		#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 12)
	/* 0x9300 */
		#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
		#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 12)
		#define RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_LAST	RX_TPA_START_V3_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_TPA_START_V3_CMPL_METADATA1_VALID		UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 * When vee_cmpl_mode is set in VNIC context, this is the lower
	 * 32b of the host address from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} rx_tpa_start_v3_cmpl_t, *prx_tpa_start_v3_cmpl_t;

/*
 * Last 16 bytes of RX L2 TPA Start V3 Completion Record
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_v3_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_start_v3_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the inner
	 * packet and that the ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was calculated
	 * for the inner packet and that the l4_cs_error field indicates if
	 * there was an error.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the tunnel
	 * header and that the t_ip_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was calculated for the tunnel
	 * packet and that the t_l4_cs_error field indicates if there was an
	 * error.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_SFT		4
	/* There is no metadata information. Values are zero. */
		#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_LAST		RX_TPA_START_V3_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE		UINT32_C(0x400)
	/* Indicates that the Tunnel IP type was IPv4 */
		#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE_IPV4		(UINT32_C(0x0) << 10)
	/* Indicates that the Tunnel IP type was IPv6 */
		#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE_IPV6		(UINT32_C(0x1) << 10)
		#define RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE_LAST		RX_TPA_START_V3_CMPL_FLAGS2_T_IP_TYPE_IPV6
	/* This indicates that the aggregation was done using GRO rules. */
	#define RX_TPA_START_V3_CMPL_FLAGS2_AGG_GRO			UINT32_C(0x800)
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set. For TPA Start completions,
	 * the complete checksum is calculated for the first packet in the
	 * aggregation only.
	 */
	#define RX_TPA_START_V3_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_TPA_START_V3_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V3_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_START_V3_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define RX_TPA_START_V3_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packetThe packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Packet did not fit into packet buffer provided. This means
	 * that the TPA Start packet was too big to be placed into the
	 * per-packet maximum number of physical buffers configured for
	 * the VNIC, or that it was too big to be placed into the
	 * per-aggregation maximum number of physical buffers configured
	 * for the VNIC. This error only occurs when the VNIC is
	 * configured for variable size receive buffers.
	 */
		#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT   (UINT32_C(0x1) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT	(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_START_V3_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format != 0, this value is the VLAN VID. */
	#define RX_TPA_START_V3_CMPL_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_START_V3_CMPL_METADATA0_VID_SFT 0
	/* When meta_format != 0, this value is the VLAN DE. */
	#define RX_TPA_START_V3_CMPL_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format != 0, this value is the VLAN PRI. */
	#define RX_TPA_START_V3_CMPL_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_START_V3_CMPL_METADATA0_PRI_SFT 13
	/*
	 * This field contains the outer_l3_offset, inner_l2_offset,
	 * inner_l3_offset, and inner_l4_size.
	 *
	 * hdr_offsets[8:0] contains the outer_l3_offset.
	 * hdr_offsets[17:9] contains the inner_l2_offset.
	 * hdr_offsets[26:18] contains the inner_l3_offset.
	 * hdr_offsets[31:27] contains the inner_l4_size.
	 */
	uint32_t	hdr_offsets;
} rx_tpa_start_v3_cmpl_hi_t, *prx_tpa_start_v3_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_end_cmpl (size:128b/16B) */

typedef struct rx_tpa_end_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_END_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_END_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
		#define RX_TPA_END_CMPL_TYPE_RX_TPA_END		UINT32_C(0x15)
		#define RX_TPA_END_CMPL_TYPE_LAST			RX_TPA_END_CMPL_TYPE_RX_TPA_END
	#define RX_TPA_END_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_END_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_TPA_END_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * IOC/Jumbo:
	 * Packet will be placed using In-Order Completion/Jumbo where
	 * the first packet of the aggregation is placed using Jumbo
	 * Placement. Subsequent packets will be placed such that each
	 * packet starts at the beginning of an aggregation buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_JUMBO	(UINT32_C(0x4) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_HDS	(UINT32_C(0x7) << 7)
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* When set, this bit indicates that the timestamp field is valid. */
	#define RX_TPA_END_CMPL_FLAGS_TIMESTAMP_VALID	UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 * - 2 TCP Packet
	 *	Indicates that the packet was IP and TCP. This indicates
	 *	that the ip_cs field is valid and that the tcp_udp_cs
	 *	field is valid and contains the TCP checksum.
	 *	This also indicates that the payload_offset field is valid.
	 */
	#define RX_TPA_END_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_END_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * This value is zero for TPA End completions.
	 * There is no data in the buffer that corresponds to the opaque
	 * value in this completion.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_END_CMPL_V1	UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this aggregation
	 * packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided in the aggregation start completion.
	 */
	#define RX_TPA_END_CMPL_AGG_BUFS_MASK UINT32_C(0x7e)
	#define RX_TPA_END_CMPL_AGG_BUFS_SFT 1
	/* This value is the number of segments in the TPA operation. */
	uint8_t	tpa_segs;
	/*
	 * This value indicates the offset in bytes from the beginning of the
	 * packet where the inner payload starts. This value is valid for TCP,
	 * UDP, FCoE, and RoCE packets.
	 *
	 * A value of zero indicates an offset of 256 bytes.
	 */
	uint8_t	payload_offset;
	uint8_t	agg_id;
	/* unused2 is 1 b */
	#define RX_TPA_END_CMPL_UNUSED2	UINT32_C(0x1)
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_END_CMPL_AGG_ID_MASK UINT32_C(0xfe)
	#define RX_TPA_END_CMPL_AGG_ID_SFT  1
	/*
	 * For non-GRO packets, this value is the
	 * timestamp delta between earliest and latest timestamp values for
	 * TPA packet. If packets were not time stamped, then delta will be
	 * zero.
	 *
	 * For GRO packets, this field is zero except for the following
	 * sub-fields.
	 * - tsdelta[31]
	 *	Timestamp present indication. When '0', no Timestamp
	 *	option is in the packet. When '1', then a Timestamp
	 *	option is present in the packet.
	 */
	uint32_t	tsdelta;
} rx_tpa_end_cmpl_t, *prx_tpa_end_cmpl_t;

/*
 * Last 16 bytes of rx_tpa_end_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_end_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_end_cmpl_hi {
	uint32_t	tpa_dup_acks;
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	#define RX_TPA_END_CMPL_TPA_DUP_ACKS_MASK UINT32_C(0xf)
	#define RX_TPA_END_CMPL_TPA_DUP_ACKS_SFT 0
	/*
	 * This value is the valid when TPA completion is active. It
	 * indicates the length of the longest segment of the TPA operation
	 * for LRO mode and the length of the first segment in GRO mode.
	 *
	 * This value may be used by GRO software to re-construct the original
	 * packet stream from the TPA packet. This is the length of all
	 * but the last segment for GRO. In LRO mode this value may be used
	 * to indicate MSS size to the stack.
	 */
	uint16_t	tpa_seg_len;
	/*
	 * The lower 16b of the timestamp of the last packet added to the
	 * aggregation. Only valid when flags.timestamp_valid is set.
	 */
	uint16_t	timestamp_lower;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_END_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_END_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define RX_TPA_END_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/*
	 * This error occurs when there is a fatal HW problem in
	 * the chip only. It indicates that there were not
	 * BDs on chip but that there was adequate reservation.
	 * provided by the TPA block.
	 */
		#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP   (UINT32_C(0x2) << 1)
	/*
	 * This error occurs when TPA block was not configured to
	 * reserve adequate BDs for TPA operations on this RX
	 * ring. All data for the TPA operation was not placed.
	 *
	 * This error can also be generated when the number of
	 * segments is not programmed correctly in TPA and the
	 * 33 total aggregation buffers allowed for the TPA
	 * operation has been exceeded.
	 */
		#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR	(UINT32_C(0x4) << 1)
		#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR
	/*
	 * The upper 16b of the timestamp of the last packet added to the
	 * aggregation. Only valid when flags.timestamp_valid is set.
	 */
	uint16_t	timestamp_upper;
	/*
	 * This is the opaque value that was completed for the TPA start
	 * completion that corresponds to this TPA end completion.
	 */
	uint32_t	start_opaque;
} rx_tpa_end_cmpl_hi_t, *prx_tpa_end_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_start_cmpl (size:128b/16B) */

typedef struct rx_tpa_v2_start_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_START_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_V2_START_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
		#define RX_TPA_V2_START_CMPL_TYPE_RX_TPA_START		UINT32_C(0x13)
		#define RX_TPA_V2_START_CMPL_TYPE_LAST			RX_TPA_V2_START_CMPL_TYPE_RX_TPA_START
	#define RX_TPA_V2_START_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_V2_START_CMPL_FLAGS_SFT			6
	/* This bit will always be '0' for TPA start completions. */
	#define RX_TPA_V2_START_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_V2_START_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * For devices that support timestamps, when this bit is cleared the
	 * `inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset`
	 * field contains the 32b timestamp for
	 * the packet from the MAC. When this bit is set, the
	 * `inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset`
	 * field contains the outer_l3_offset, inner_l2_offset,
	 * inner_l3_offset, and inner_l4_size.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_TIMESTAMP_FLD_FORMAT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
		#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_LAST		RX_TPA_V2_START_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_START_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_V2_START_CMPL_LAST RX_TPA_V2_START_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} rx_tpa_v2_start_cmpl_t, *prx_tpa_v2_start_cmpl_t;

/*
 * Last 16 bytes of rx_tpa_v2_start_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_start_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_v2_start_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the sum passed
	 * for all segments included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the sum passed for
	 * all segments included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_SFT		4
	/* No metadata information. Value is zero. */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_VLAN		(UINT32_C(0x1) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. Zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset, inner_l2_offset, inner_l3_offset and
	 * inner_l4_size.
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[17:9] contains the inner_l2_offset.
	 * - metadata[26:18] contains the inner_l3_offset.
	 * - metadata[31:27] contains the inner_l4_size.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_LAST		RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * The combination of this value and meta_format indicated what
	 * format the metadata field is.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_EXT_META_FORMAT_MASK	UINT32_C(0xc00)
	#define RX_TPA_V2_START_CMPL_FLAGS2_EXT_META_FORMAT_SFT	10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set. For TPA Start completions,
	 * the complete checksum is calculated for the first packet in the
	 * aggregation only.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN VID. */
	#define RX_TPA_V2_START_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_V2_START_CMPL_METADATA_VID_SFT  0
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN DE. */
	#define RX_TPA_V2_START_CMPL_METADATA_DE	UINT32_C(0x1000)
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN PRI. */
	#define RX_TPA_V2_START_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_V2_START_CMPL_METADATA_PRI_SFT  13
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN TPID. */
	#define RX_TPA_V2_START_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_TPA_V2_START_CMPL_METADATA_TPID_SFT 16
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_START_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_V2_START_CMPL_ERRORS_MASK		UINT32_C(0xfffe)
	#define RX_TPA_V2_START_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT   (UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	/*
	 * For devices that support timestamps this field is overridden
	 * with the timestamp value. When `flags.timestamp_fld_format` is
	 * cleared, this field contains the 32b timestamp for the packet from the
	 * MAC.
	 *
	 * When `flags.timestamp_fld_format` is set, this field contains the
	 * outer_l3_offset, inner_l2_offset, inner_l3_offset, and inner_l4_size
	 * as defined below.
	 */
	uint32_t	inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset;
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the outer L3 header. If there is no outer L3 header, then this
	 * value is zero.
	 */
	#define RX_TPA_V2_START_CMPL_OUTER_L3_OFFSET_MASK UINT32_C(0x1ff)
	#define RX_TPA_V2_START_CMPL_OUTER_L3_OFFSET_SFT 0
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L2 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L2_OFFSET_MASK UINT32_C(0x3fe00)
	#define RX_TPA_V2_START_CMPL_INNER_L2_OFFSET_SFT 9
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L3 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L3_OFFSET_MASK UINT32_C(0x7fc0000)
	#define RX_TPA_V2_START_CMPL_INNER_L3_OFFSET_SFT 18
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L4_SIZE_MASK  UINT32_C(0xf8000000)
	#define RX_TPA_V2_START_CMPL_INNER_L4_SIZE_SFT   27
} rx_tpa_v2_start_cmpl_hi_t, *prx_tpa_v2_start_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_end_cmpl (size:128b/16B) */

typedef struct rx_tpa_v2_end_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_END_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_V2_END_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
		#define RX_TPA_V2_END_CMPL_TYPE_RX_TPA_END		UINT32_C(0x15)
		#define RX_TPA_V2_END_CMPL_TYPE_LAST			RX_TPA_V2_END_CMPL_TYPE_RX_TPA_END
	#define RX_TPA_V2_END_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_V2_END_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_IOC_HDS	(UINT32_C(0x7) << 7)
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* unused is 1 b */
	#define RX_TPA_V2_END_CMPL_FLAGS_UNUSED			UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 * - 2 TCP Packet
	 *	Indicates that the packet was IP and TCP. This indicates
	 *	that the ip_cs field is valid and that the tcp_udp_cs
	 *	field is valid and contains the TCP checksum.
	 *	This also indicates that the payload_offset field is valid.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_V2_END_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * This value is zero for TPA End completions.
	 * There is no data in the buffer that corresponds to the opaque
	 * value in this completion.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_END_CMPL_V1	UINT32_C(0x1)
	/* This value is the number of segments in the TPA operation. */
	uint8_t	tpa_segs;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * For non-GRO packets, this value is the
	 * timestamp delta between earliest and latest timestamp values for
	 * TPA packet. If packets were not time stamped, then delta will be
	 * zero.
	 *
	 * For GRO packets, this field is zero except for the following
	 * sub-fields.
	 * - tsdelta[31]
	 *	Timestamp present indication. When '0', no Timestamp
	 *	option is in the packet. When '1', then a Timestamp
	 *	option is present in the packet.
	 */
	uint32_t	tsdelta;
} rx_tpa_v2_end_cmpl_t, *prx_tpa_v2_end_cmpl_t;

/*
 * Last 16 bytes of rx_tpa_v2_end_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_end_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_v2_end_cmpl_hi {
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	uint16_t	tpa_dup_acks;
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	#define RX_TPA_V2_END_CMPL_TPA_DUP_ACKS_MASK UINT32_C(0xf)
	#define RX_TPA_V2_END_CMPL_TPA_DUP_ACKS_SFT 0
	/*
	 * This value indicated the offset in bytes from the beginning of
	 * the packet where the inner payload starts. This value is valid
	 * for TCP, UDP, FCoE and RoCE packets
	 */
	uint8_t	payload_offset;
	/*
	 * The value is the total number of aggregation buffers that were
	 * used in the TPA operation. All TPA aggregation buffer completions
	 * precede the TPA End completion. If the value is zero, then the
	 * aggregation is completely contained in the buffer space provided
	 * in the aggregation start completion.
	 * Note that the field is simply provided as a cross check.
	 */
	uint8_t	tpa_agg_bufs;
	/*
	 * This value is the valid when TPA completion is active. It
	 * indicates the length of the longest segment of the TPA operation
	 * for LRO mode and the length of the first segment in GRO mode.
	 *
	 * This value may be used by GRO software to re-construct the original
	 * packet stream from the TPA packet. This is the length of all
	 * but the last segment for GRO. In LRO mode this value may be used
	 * to indicate MSS size to the stack.
	 */
	uint16_t	tpa_seg_len;
	uint16_t	unused_1;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_END_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_V2_END_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define RX_TPA_V2_END_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * This error occurs when there is a fatal HW problem in
	 * the chip only. It indicates that there were not
	 * BDs on chip but that there was adequate reservation.
	 * provided by the TPA block.
	 */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP   (UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT	(UINT32_C(0x3) << 1)
	/*
	 * This error occurs when TPA block was not configured to
	 * reserve adequate BDs for TPA operations on this RX
	 * ring. All data for the TPA operation was not placed.
	 *
	 * This error can also be generated when the number of
	 * segments is not programmed correctly in TPA and the
	 * 33 total aggregation buffers allowed for the TPA
	 * operation has been exceeded.
	 */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR	(UINT32_C(0x4) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	uint16_t	unused_2;
	/*
	 * This is the opaque value that was completed for the TPA start
	 * completion that corresponds to this TPA end completion.
	 */
	uint32_t	start_opaque;
} rx_tpa_v2_end_cmpl_hi_t, *prx_tpa_v2_end_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_abuf_cmpl (size:128b/16B) */

typedef struct rx_tpa_v2_abuf_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_ABUF_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define RX_TPA_V2_ABUF_CMPL_TYPE_SFT	0
	/*
	 * RX TPA Aggregation Buffer completion:
	 * Completion of an L2 aggregation buffer in support of
	 * TPA packet completion. Length = 16B
	 */
		#define RX_TPA_V2_ABUF_CMPL_TYPE_RX_TPA_AGG  UINT32_C(0x16)
		#define RX_TPA_V2_ABUF_CMPL_TYPE_LAST	RX_TPA_V2_ABUF_CMPL_TYPE_RX_TPA_AGG
	/*
	 * This is the length of the data for the packet stored in this
	 * aggregation buffer identified by the opaque value. This does not
	 * include the length of any
	 * data placed in other aggregation BDs or in the packet or buffer
	 * BDs. This length does not include any space added due to
	 * hdr_offset register during HDS placement mode.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this aggregation
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint16_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_ABUF_CMPL_V	UINT32_C(0x1)
	/*
	 * This is the aggregation ID that the completion is associated with. Use
	 * this number to correlate the TPA agg completion with the TPA start
	 * completion and the TPA end completion.
	 */
	uint16_t	agg_id;
	uint32_t	unused_1;
} rx_tpa_v2_abuf_cmpl_t, *prx_tpa_v2_abuf_cmpl_t;

/* rx_abuf_cmpl (size:128b/16B) */

typedef struct rx_abuf_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_ABUF_CMPL_TYPE_MASK  UINT32_C(0x3f)
	#define RX_ABUF_CMPL_TYPE_SFT   0
	/*
	 * RX Aggregation Buffer completion:
	 * Completion of an L2 aggregation buffer in support of
	 * TPA, HDS, or Jumbo packet completion. Length = 16B
	 */
		#define RX_ABUF_CMPL_TYPE_RX_AGG  UINT32_C(0x12)
		#define RX_ABUF_CMPL_TYPE_LAST   RX_ABUF_CMPL_TYPE_RX_AGG
	/*
	 * This is the length of the data for the packet stored in this
	 * aggregation buffer identified by the opaque value. This does not
	 * include the length of any
	 * data placed in other aggregation BDs or in the packet or buffer
	 * BDs. This length does not include any space added due to
	 * hdr_offset register during HDS placement mode.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this aggregation
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_ABUF_CMPL_V	UINT32_C(0x1)
	/* unused3 is 32 b */
	uint32_t	unused_2;
} rx_abuf_cmpl_t, *prx_abuf_cmpl_t;

/* VEE FLUSH Completion Record (16 bytes) */
/* vee_flush (size:128b/16B) */

typedef struct vee_flush {
	uint32_t	downstream_path_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define VEE_FLUSH_TYPE_MASK	UINT32_C(0x3f)
	#define VEE_FLUSH_TYPE_SFT		0
	/*
	 * VEE Flush Completion:
	 * This completion is inserted manually by the Primate and processed
	 * by the VEE hardware to ensure that all completions on a VEE
	 * function have been processed by the VEE hardware before FLR
	 * process is completed.
	 */
		#define VEE_FLUSH_TYPE_VEE_FLUSH	UINT32_C(0x1c)
		#define VEE_FLUSH_TYPE_LAST		VEE_FLUSH_TYPE_VEE_FLUSH
	/* downstream_path is 1 b */
	#define VEE_FLUSH_DOWNSTREAM_PATH	UINT32_C(0x40)
	/* This completion is associated with VEE Transmit */
		#define VEE_FLUSH_DOWNSTREAM_PATH_TX	(UINT32_C(0x0) << 6)
	/* This completion is associated with VEE Receive */
		#define VEE_FLUSH_DOWNSTREAM_PATH_RX	(UINT32_C(0x1) << 6)
		#define VEE_FLUSH_DOWNSTREAM_PATH_LAST VEE_FLUSH_DOWNSTREAM_PATH_RX
	/*
	 * This is an opaque value that is passed through the completion
	 * to the VEE handler SW and is used to indicate what VEE VQ or
	 * function has completed FLR processing.
	 */
	uint32_t	opaque;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define VEE_FLUSH_V	UINT32_C(0x1)
	/* unused3 is 32 b */
	uint32_t	unused_3;
} vee_flush_t, *pvee_flush_t;

/* eject_cmpl (size:128b/16B) */

typedef struct eject_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define EJECT_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define EJECT_CMPL_TYPE_SFT	0
	/*
	 * Statistics Ejection Completion:
	 * Completion of statistics data ejection buffer.
	 * Length = 16B
	 */
		#define EJECT_CMPL_TYPE_STAT_EJECT   UINT32_C(0x1a)
		#define EJECT_CMPL_TYPE_LAST	EJECT_CMPL_TYPE_STAT_EJECT
	#define EJECT_CMPL_FLAGS_MASK	UINT32_C(0xffc0)
	#define EJECT_CMPL_FLAGS_SFT	6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define EJECT_CMPL_FLAGS_ERROR	UINT32_C(0x40)
	/*
	 * This is the length of the statistics data stored in this
	 * buffer.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this ejection
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint16_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define EJECT_CMPL_V				UINT32_C(0x1)
	#define EJECT_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define EJECT_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for statistics ejection. The statistics ejection should
	 * be treated as invalid
	 */
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Statistics did not fit into aggregation buffer provided.
	 */
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT   (UINT32_C(0x1) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT	(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_LAST	EJECT_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	/* unused3 is 32 b */
	uint32_t	unused_2;
} eject_cmpl_t, *peject_cmpl_t;

/* hwrm_cmpl (size:128b/16B) */

typedef struct hwrm_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define HWRM_CMPL_TYPE_SFT	0
	/*
	 * HWRM Command Completion:
	 * Completion of an HWRM command.
	 */
		#define HWRM_CMPL_TYPE_HWRM_DONE  UINT32_C(0x20)
		#define HWRM_CMPL_TYPE_LAST	HWRM_CMPL_TYPE_HWRM_DONE
	/* This is the sequence_id of the HWRM command that has completed. */
	uint16_t	sequence_id;
	/* unused2 is 32 b */
	uint32_t	unused_1;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_CMPL_V	UINT32_C(0x1)
	/* unused4 is 32 b */
	uint32_t	unused_3;
} hwrm_cmpl_t, *phwrm_cmpl_t;

/* hwrm_fwd_req_cmpl (size:128b/16B) */

typedef struct hwrm_fwd_req_cmpl {
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	uint16_t	req_len_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_FWD_REQ_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define HWRM_FWD_REQ_CMPL_TYPE_SFT	0
	/* Forwarded HWRM Request */
		#define HWRM_FWD_REQ_CMPL_TYPE_HWRM_FWD_REQ  UINT32_C(0x22)
		#define HWRM_FWD_REQ_CMPL_TYPE_LAST	HWRM_FWD_REQ_CMPL_TYPE_HWRM_FWD_REQ
	/* Length of forwarded request in bytes. */
	#define HWRM_FWD_REQ_CMPL_REQ_LEN_MASK	UINT32_C(0xffc0)
	#define HWRM_FWD_REQ_CMPL_REQ_LEN_SFT	6
	/*
	 * Source ID of this request.
	 * Typically used in forwarding requests and responses.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	source_id;
	/* unused1 is 32 b */
	uint32_t	unused0;
	/* Address of forwarded request. */
	uint64_t	req_buf_addr_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_FWD_REQ_CMPL_V		UINT32_C(0x1)
	/* Address of forwarded request. */
	#define HWRM_FWD_REQ_CMPL_REQ_BUF_ADDR_MASK UINT32_C(0xfffffffe)
	#define HWRM_FWD_REQ_CMPL_REQ_BUF_ADDR_SFT 1
} hwrm_fwd_req_cmpl_t, *phwrm_fwd_req_cmpl_t;

/* hwrm_fwd_resp_cmpl (size:128b/16B) */

typedef struct hwrm_fwd_resp_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_FWD_RESP_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define HWRM_FWD_RESP_CMPL_TYPE_SFT	0
	/* Forwarded HWRM Response */
		#define HWRM_FWD_RESP_CMPL_TYPE_HWRM_FWD_RESP  UINT32_C(0x24)
		#define HWRM_FWD_RESP_CMPL_TYPE_LAST	HWRM_FWD_RESP_CMPL_TYPE_HWRM_FWD_RESP
	/*
	 * Source ID of this response.
	 * Typically used in forwarding requests and responses.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	source_id;
	/* Length of forwarded response in bytes. */
	uint16_t	resp_len;
	/* unused2 is 16 b */
	uint16_t	unused_1;
	/* Address of forwarded request. */
	uint64_t	resp_buf_addr_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_FWD_RESP_CMPL_V		UINT32_C(0x1)
	/* Address of forwarded request. */
	#define HWRM_FWD_RESP_CMPL_RESP_BUF_ADDR_MASK UINT32_C(0xfffffffe)
	#define HWRM_FWD_RESP_CMPL_RESP_BUF_ADDR_SFT 1
} hwrm_fwd_resp_cmpl_t, *phwrm_fwd_resp_cmpl_t;

/* hwrm_async_event_cmpl (size:128b/16B) */

typedef struct hwrm_async_event_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link status changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_STATUS_CHANGE		UINT32_C(0x0)
	/* Link MTU changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_MTU_CHANGE		UINT32_C(0x1)
	/* Link speed changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CHANGE		UINT32_C(0x2)
	/* DCB Configuration changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DCB_CONFIG_CHANGE		UINT32_C(0x3)
	/* Port connection not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PORT_CONN_NOT_ALLOWED	UINT32_C(0x4)
	/* Link speed configuration was not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED	UINT32_C(0x5)
	/* Link speed configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_CHANGE	UINT32_C(0x6)
	/* Port PHY configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PORT_PHY_CFG_CHANGE		UINT32_C(0x7)
	/* Reset notification to clients */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_RESET_NOTIFY			UINT32_C(0x8)
	/* Master function selection event */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_ERROR_RECOVERY		UINT32_C(0x9)
	/*
	 * An event signifying that a ring has been disabled by
	 * hw due to error.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_RING_MONITOR_MSG		UINT32_C(0xa)
	/* Function driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_DRVR_UNLOAD		UINT32_C(0x10)
	/* Function driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_DRVR_LOAD		UINT32_C(0x11)
	/* Function FLR related processing has completed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_FLR_PROC_CMPLT		UINT32_C(0x12)
	/* PF driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_UNLOAD		UINT32_C(0x20)
	/* PF driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_LOAD			UINT32_C(0x21)
	/* VF Function Level Reset (FLR) */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_FLR			UINT32_C(0x30)
	/* VF MAC Address Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_MAC_ADDR_CHANGE		UINT32_C(0x31)
	/* PF-VF communication channel status change. */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_VF_COMM_STATUS_CHANGE	UINT32_C(0x32)
	/* VF Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_CFG_CHANGE		UINT32_C(0x33)
	/* LLFC/PFC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LLFC_PFC_CHANGE		UINT32_C(0x34)
	/* Default VNIC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEFAULT_VNIC_CHANGE		UINT32_C(0x35)
	/* HW flow aged */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HW_FLOW_AGED			UINT32_C(0x36)
	/*
	 * A debug notification being posted to the driver. These
	 * notifications are purely for diagnostic purpose and should not be
	 * used for functional purpose. The driver is not supposed to act
	 * on these messages except to log/record it.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEBUG_NOTIFICATION		UINT32_C(0x37)
	/*
	 * An EEM flow cached memory flush for all flows request event being
	 * posted to the PF driver.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CACHE_FLUSH_REQ		UINT32_C(0x38)
	/*
	 * An EEM flow cache memory flush completion event being posted to the
	 * firmware by the PF driver. This is indication that host EEM flush
	 * has completed by the PF.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CACHE_FLUSH_DONE		UINT32_C(0x39)
	/*
	 * A tcp flag action change event being posted to the PF or trusted VF
	 * driver by the firmware. The PF or trusted VF driver should query
	 * the firmware for the new TCP flag action update after receiving
	 * this async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TCP_FLAG_ACTION_CHANGE	UINT32_C(0x3a)
	/*
	 * An EEM flow active event being posted to the PF or trusted VF driver
	 * by the firmware. The PF or trusted VF driver should update the
	 * flow's aging timer after receiving this async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_FLOW_ACTIVE		UINT32_C(0x3b)
	/*
	 * A eem cfg change event being posted to the trusted VF driver by the
	 * firmware if the parent PF EEM configuration changed.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CFG_CHANGE		UINT32_C(0x3c)
	/*
	 * Deprecated.
	 * TFLIB unique default VNIC Configuration Change
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TFLIB_DEFAULT_VNIC_CHANGE	UINT32_C(0x3d)
	/*
	 * Deprecated.
	 * TFLIB unique link status changed
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TFLIB_LINK_STATUS_CHANGE	UINT32_C(0x3e)
	/*
	 * An event signifying completion for HWRM_FW_STATE_QUIESCE
	 * (completion, timeout, or error)
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_QUIESCE_DONE			UINT32_C(0x3f)
	/*
	 * An event signifying a HWRM command is in progress and its
	 * response will be deferred. This event is used on crypto controllers
	 * only.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEFERRED_RESPONSE		UINT32_C(0x40)
	/*
	 * An event signifying that a PFC WatchDog configuration
	 * has changed on any port / cos.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE	UINT32_C(0x41)
	/*
	 * An echo request from the firmware. An echo response is expected by
	 * the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_ECHO_REQUEST			UINT32_C(0x42)
	/*
	 * An event from firmware indicating who has been selected as the
	 * PHC Master or secondary. Also indicates the last time a failover
	 * happens. Event will also be sent when PHC rolls over.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PHC_UPDATE			UINT32_C(0x43)
	/*
	 * An event from firmware showing the last PPS timestamp that has been
	 * latched.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PPS_TIMESTAMP		UINT32_C(0x44)
	/*
	 * An event from firmware indicating that an error has occurred.
	 * The driver should log the event so that an administrator can be
	 * aware that a problem has occurred that may need attention.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_ERROR_REPORT			UINT32_C(0x45)
	/*
	 * An event from firmware indicating that the programmed pacing
	 * threshold for the doorbell global FIFO has been crossed. The driver
	 * needs to take appropriate action to pace the doorbells when this
	 * event is received from the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DOORBELL_PACING_THRESHOLD	UINT32_C(0x46)
	/*
	 * An event from firmware indicating that the RSS capabilities have
	 * changed.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_RSS_CHANGE			UINT32_C(0x47)
	/*
	 * An event from firmware indicating that list of nq ids used for
	 * doorbell pacing DBQ event notification has been updated. The driver
	 * needs to take appropriate action and retrieve the new list when this
	 * event is received from the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DOORBELL_PACING_NQ_UPDATE	UINT32_C(0x48)
	/*
	 * An event from firmware indicating that hardware ran into an error
	 * while trying to read the host based doorbell copy region. The driver
	 * needs to take the appropriate action and maintain the corresponding
	 * doorbell copy region.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HW_DOORBELL_RECOVERY_READ_ERROR UINT32_C(0x49)
	/*
	 * An event from firmware indicating that the XID partition was not
	 * allocated/freed by the FW successfully for the request that is
	 * encapsulated in the HWRM_EXEC_FWD_RESP by the PF driver for VF.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_CTX_ERROR			UINT32_C(0x4a)
	/*
	 * A UDCC session has been modified in the FW. The session_id can be
	 * used by the driver to retrieve information related to the UDCC
	 * session.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_UDCC_SESSION_CHANGE		UINT32_C(0x4b)
	/*
	 * Used to notify the host that the firmware has DMA-ed additional
	 * debug data to the host buffer. This is effectively a producer index
	 * update. The host driver can utilize this information to determine
	 * how much of its host buffer has been populated by the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DBG_BUF_PRODUCER		UINT32_C(0x4c)
	/*
	 * Memory mapping between GPA and HPA has been configured for
	 * a peer device. Inform driver to pick up the new mapping.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PEER_MMAP_CHANGE		UINT32_C(0x4d)
	/*
	 * Used to notify representor endpoint in the driver about pair creation
	 * in the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_REPRESENTOR_PAIR_CHANGE	UINT32_C(0x4e)
	/*
	 * VF statistics context change. Informs PF driver that a VF
	 * statistics context has either been allocated or freed.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_STAT_CHANGE		UINT32_C(0x4f)
	/*
	 * coredump collection into host DMA address. Informs PF driver that
	 * the coredump has been captured.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HOST_COREDUMP		UINT32_C(0x50)
	/* Maximum Registrable event id. */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_MAX_RGTR_EVENT_ID		UINT32_C(0x51)
	/*
	 * A trace log message. This contains firmware trace logs string
	 * embedded in the asynchronous message. This is an experimental
	 * event, not meant for production use at this time.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FW_TRACE_MSG			UINT32_C(0xfe)
	/* HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HWRM_ERROR			UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HWRM_ERROR
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_t, *phwrm_async_event_cmpl_t;

#define GET_EVENT_ID(x) \
	(((x) < 0x80) ? \
	((x) == 0x0 ? "LINK_STATUS_CHANGE": \
	((x) == 0x1 ? "LINK_MTU_CHANGE": \
	((x) == 0x2 ? "LINK_SPEED_CHANGE": \
	((x) == 0x3 ? "DCB_CONFIG_CHANGE": \
	((x) == 0x4 ? "PORT_CONN_NOT_ALLOWED": \
	((x) == 0x5 ? "LINK_SPEED_CFG_NOT_ALLOWED": \
	((x) == 0x6 ? "LINK_SPEED_CFG_CHANGE": \
	((x) == 0x7 ? "PORT_PHY_CFG_CHANGE": \
	((x) == 0x8 ? "RESET_NOTIFY": \
	((x) == 0x9 ? "ERROR_RECOVERY": \
	((x) == 0xa ? "RING_MONITOR_MSG": \
	((x) == 0x10 ? "FUNC_DRVR_UNLOAD": \
	((x) == 0x11 ? "FUNC_DRVR_LOAD": \
	((x) == 0x12 ? "FUNC_FLR_PROC_CMPLT": \
	((x) == 0x20 ? "PF_DRVR_UNLOAD": \
	((x) == 0x21 ? "PF_DRVR_LOAD": \
	((x) == 0x30 ? "VF_FLR": \
	((x) == 0x31 ? "VF_MAC_ADDR_CHANGE": \
	((x) == 0x32 ? "PF_VF_COMM_STATUS_CHANGE": \
	((x) == 0x33 ? "VF_CFG_CHANGE": \
	((x) == 0x34 ? "LLFC_PFC_CHANGE": \
	((x) == 0x35 ? "DEFAULT_VNIC_CHANGE": \
	((x) == 0x36 ? "HW_FLOW_AGED": \
	((x) == 0x37 ? "DEBUG_NOTIFICATION": \
	((x) == 0x38 ? "EEM_CACHE_FLUSH_REQ": \
	((x) == 0x39 ? "EEM_CACHE_FLUSH_DONE": \
	((x) == 0x3a ? "TCP_FLAG_ACTION_CHANGE": \
	((x) == 0x3b ? "EEM_FLOW_ACTIVE": \
	((x) == 0x3c ? "EEM_CFG_CHANGE": \
	((x) == 0x3d ? "TFLIB_DEFAULT_VNIC_CHANGE": \
	((x) == 0x3e ? "TFLIB_LINK_STATUS_CHANGE": \
	((x) == 0x3f ? "QUIESCE_DONE": \
	((x) == 0x40 ? "DEFERRED_RESPONSE": \
	((x) == 0x41 ? "PFC_WATCHDOG_CFG_CHANGE": \
	((x) == 0x42 ? "ECHO_REQUEST": \
	((x) == 0x43 ? "PHC_UPDATE": \
	((x) == 0x44 ? "PPS_TIMESTAMP": \
	((x) == 0x45 ? "ERROR_REPORT": \
	((x) == 0x46 ? "DOORBELL_PACING_THRESHOLD": \
	((x) == 0x47 ? "RSS_CHANGE": \
	((x) == 0x48 ? "DOORBELL_PACING_NQ_UPDATE": \
	((x) == 0x49 ? "HW_DOORBELL_RECOVERY_READ_ERROR": \
	((x) == 0x4a ? "CTX_ERROR": \
	((x) == 0x4b ? "UDCC_SESSION_CHANGE": \
	((x) == 0x4c ? "DBG_BUF_PRODUCER": \
	((x) == 0x4d ? "PEER_MMAP_CHANGE": \
	((x) == 0x4e ? "REPRESENTOR_PAIR_CHANGE": \
	((x) == 0x4f ? "VF_STAT_CHANGE": \
	((x) == 0x50 ? "HOST_COREDUMP": \
	((x) == 0x51 ? "MAX_RGTR_EVENT_ID": \
	"Unknown decode" )))))))))))))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x100) ? \
	((x) == 0xfe ? "FW_TRACE_MSG": \
	((x) == 0xff ? "HWRM_ERROR": \
	"Unknown decode" )) : \
	"Unknown decode" ))


/* hwrm_async_event_cmpl_link_status_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_status_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link status changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LINK_STATUS_CHANGE UINT32_C(0x0)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LINK_STATUS_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates link status change */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE	UINT32_C(0x1)
	/*
	 * If this bit set to 0, then it indicates that the link
	 * was up and it went down.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_DOWN  UINT32_C(0x0)
	/*
	 * If this bit is set to 1, then it indicates that the link
	 * was down and it went up.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_UP	UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_LAST HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_UP
	/* Indicates the physical port this link status change occur */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_MASK	UINT32_C(0xe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_SFT	1
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_ID_MASK	UINT32_C(0xffff0)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_ID_SFT	4
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PF_ID_MASK	UINT32_C(0xff00000)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PF_ID_SFT	20
} hwrm_async_event_cmpl_link_status_change_t, *phwrm_async_event_cmpl_link_status_change_t;

/* hwrm_async_event_cmpl_link_mtu_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_mtu_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link MTU changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LINK_MTU_CHANGE UINT32_C(0x1)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LINK_MTU_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* The new MTU of the link in bytes. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_DATA1_NEW_MTU_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_DATA1_NEW_MTU_SFT 0
} hwrm_async_event_cmpl_link_mtu_change_t, *phwrm_async_event_cmpl_link_mtu_change_t;

/* hwrm_async_event_cmpl_link_speed_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_speed_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LINK_SPEED_CHANGE UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LINK_SPEED_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * When this bit is '1', the link was forced to the
	 * force_link_speed value.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_FORCE			UINT32_C(0x1)
	/* The new link speed in 100 Mbps units. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_MASK UINT32_C(0xfffe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_SFT  1
	/* 100Mb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100MB  (UINT32_C(0x1) << 1)
	/* 1Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_1GB	(UINT32_C(0xa) << 1)
	/* 2Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_2GB	(UINT32_C(0x14) << 1)
	/* 25Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_2_5GB  (UINT32_C(0x19) << 1)
	/* 10Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_10GB   (UINT32_C(0x64) << 1)
	/* 20Mb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_20GB   (UINT32_C(0xc8) << 1)
	/* 25Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_25GB   (UINT32_C(0xfa) << 1)
	/* 40Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_40GB   (UINT32_C(0x190) << 1)
	/* 50Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_50GB   (UINT32_C(0x1f4) << 1)
	/* 100Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100GB  (UINT32_C(0x3e8) << 1)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_LAST  HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100GB
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_PORT_ID_MASK		UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_PORT_ID_SFT		16
} hwrm_async_event_cmpl_link_speed_change_t, *phwrm_async_event_cmpl_link_speed_change_t;

/* hwrm_async_event_cmpl_dcb_config_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_dcb_config_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* DCB Configuration changed */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_DCB_CONFIG_CHANGE UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_DCB_CONFIG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/* ETS configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_ETS	UINT32_C(0x1)
	/* PFC configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_PFC	UINT32_C(0x2)
	/* APP configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_APP	UINT32_C(0x4)
	/* DSCP configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_DSCP	UINT32_C(0x8)
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_PORT_ID_MASK		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_PORT_ID_SFT		0
	/* Priority recommended for RoCE traffic */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_MASK UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_SFT 16
	/* none is 255 */
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_NONE  (UINT32_C(0xff) << 16)
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_LAST HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_NONE
	/* Priority recommended for L2 traffic */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_MASK  UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_SFT   24
	/* none is 255 */
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_NONE	(UINT32_C(0xff) << 24)
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_LAST   HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_NONE
} hwrm_async_event_cmpl_dcb_config_change_t, *phwrm_async_event_cmpl_dcb_config_change_t;

/* hwrm_async_event_cmpl_port_conn_not_allowed (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_port_conn_not_allowed {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Port connection not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_PORT_CONN_NOT_ALLOWED UINT32_C(0x4)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_PORT_CONN_NOT_ALLOWED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_SFT		0
	/*
	 * This value indicates the current port level enforcement policy
	 * for the optics module when there is an optical module mismatch
	 * and port is not connected.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_MASK	UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_SFT	16
	/* No enforcement */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_NONE	(UINT32_C(0x0) << 16)
	/* Disable Transmit side Laser. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_DISABLETX   (UINT32_C(0x1) << 16)
	/* Raise a warning message. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_WARNINGMSG  (UINT32_C(0x2) << 16)
	/* Power down the module. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_PWRDOWN	(UINT32_C(0x3) << 16)
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_LAST	HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_PWRDOWN
} hwrm_async_event_cmpl_port_conn_not_allowed_t, *phwrm_async_event_cmpl_port_conn_not_allowed_t;

/* hwrm_async_event_cmpl_link_speed_cfg_not_allowed (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_speed_cfg_not_allowed {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed configuration was not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED UINT32_C(0x5)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_DATA1_PORT_ID_SFT 0
} hwrm_async_event_cmpl_link_speed_cfg_not_allowed_t, *phwrm_async_event_cmpl_link_speed_cfg_not_allowed_t;

/* hwrm_async_event_cmpl_link_speed_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_speed_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LINK_SPEED_CFG_CHANGE UINT32_C(0x6)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LINK_SPEED_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK			UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT			0
	/*
	 * If set to 1, it indicates that the supported link speeds
	 * configuration on the port has changed.
	 * If set to 0, then there is no change in supported link speeds
	 * configuration.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_SUPPORTED_LINK_SPEEDS_CHANGE	UINT32_C(0x10000)
	/*
	 * If set to 1, it indicates that the link speed configuration
	 * on the port has become illegal or invalid.
	 * If set to 0, then the link speed configuration on the port is
	 * legal or valid.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_ILLEGAL_LINK_SPEED_CFG	UINT32_C(0x20000)
} hwrm_async_event_cmpl_link_speed_cfg_change_t, *phwrm_async_event_cmpl_link_speed_cfg_change_t;

/* hwrm_async_event_cmpl_port_phy_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_port_phy_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Port PHY configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_PORT_PHY_CFG_CHANGE UINT32_C(0x7)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_PORT_PHY_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * This value indicates the current status of the optics module on
	 * this port. the same information can be found in the module_status
	 * field of the HWRM_PORT_PHY_QCFG response
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_MASK	UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_SFT	0
	/* Module is inserted and accepted */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_NONE	UINT32_C(0x0)
	/* Module is rejected and transmit side Laser is disabled. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_DISABLETX	UINT32_C(0x1)
	/* Module mismatch warning. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_MISMATCH	UINT32_C(0x2)
	/* Module is rejected and powered down. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_PWRDOWN	UINT32_C(0x3)
	/* Module is not inserted. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_NOTINSERTED	UINT32_C(0x4)
	/* Module is powered down because of over current fault. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_CURRENTFAULT   UINT32_C(0x5)
	/* Module is overheated. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_OVERHEATED	UINT32_C(0x6)
	/* Module status is not applicable. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_NOTAPPLICABLE  UINT32_C(0xff)
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_LAST	HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA2_MODULE_STATUS_NOTAPPLICABLE
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK	UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT	0
	/*
	 * If set to 1, it indicates that the FEC
	 * configuration on the port has changed.
	 * If set to 0, then there is no change in FEC configuration.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_FEC_CFG_CHANGE	UINT32_C(0x10000)
	/*
	 * If set to 1, it indicates that the EEE configuration
	 * on the port has changed.
	 * If set to 0, then there is no change in EEE configuration
	 * on the port.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_EEE_CFG_CHANGE	UINT32_C(0x20000)
	/*
	 * If set to 1, it indicates that the pause configuration
	 * on the PHY has changed.
	 * If set to 0, then there is no change in the pause
	 * configuration on the PHY.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PAUSE_CFG_CHANGE	UINT32_C(0x40000)
} hwrm_async_event_cmpl_port_phy_cfg_change_t, *phwrm_async_event_cmpl_port_phy_cfg_change_t;

/* hwrm_async_event_cmpl_reset_notify (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_reset_notify {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notify clients of imminent reset. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_RESET_NOTIFY UINT32_C(0x8)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_RESET_NOTIFY
	/* Event specific data. The data is for internal debug use only. */
	uint32_t	event_data2;
	/*
	 * These bits indicate the status as being reported by the firmware.
	 * This value is exactly the same as status code in fw_status register.
	 * If the status code is equal to 0x8000, then the reset is initiated
	 * by the Host using the FW_RESET command when the FW is in a healthy
	 * state. If the status code is not equal to 0x8000, then the reset is
	 * initiated by the FW to recover from the error or FATAL state.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA2_FW_STATUS_CODE_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA2_FW_STATUS_CODE_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_OPAQUE_SFT 1
	/*
	 * 8-lsb timestamp (100-msec resolution)
	 * The Minimum time required for the Firmware readiness after sending
	 * this notification to the driver instances.
	 */
	uint8_t	timestamp_lo;
	/*
	 * 16-lsb timestamp (100-msec resolution)
	 * The Maximum Firmware Reset bail out value in the order of 100
	 * milliseconds. The driver instances will use this value to reinitiate
	 * the registration process again if the core firmware didn't set the
	 * state bit.
	 */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates driver action requested */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_SFT		0
	/*
	 * If set to 1, it indicates that the l2 client should
	 * stop sending in band traffic to Nitro.
	 * if set to 0, there is no change in L2 client behavior.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_STOP_TX_QUEUE	UINT32_C(0x1)
	/*
	 * If set to 1, it indicates that the L2 client should
	 * bring down the interface.
	 * If set to 0, then there is no change in L2 client behavior.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_IFDOWN	UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_LAST		HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_IFDOWN
	/* Indicates reason for reset. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_MASK			UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_SFT			8
	/* A management client has requested reset. */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_MANAGEMENT_RESET_REQUEST  (UINT32_C(0x1) << 8)
	/* A fatal firmware exception has occurred. */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_EXCEPTION_FATAL	(UINT32_C(0x2) << 8)
	/* A non-fatal firmware exception has occurred. */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_EXCEPTION_NON_FATAL	(UINT32_C(0x3) << 8)
	/* Fast reset */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FAST_RESET		(UINT32_C(0x4) << 8)
	/*
	 * Reset was a result of a firmware activation. That is, the
	 * fw_activation flag was set in a FW_RESET operation.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_ACTIVATION		(UINT32_C(0x5) << 8)
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_LAST			HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_ACTIVATION
	/*
	 * Minimum time before driver should attempt access - units 100ms
	 * ticks.
	 * Range 0-65535
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DELAY_IN_100MS_TICKS_MASK	UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DELAY_IN_100MS_TICKS_SFT		16
} hwrm_async_event_cmpl_reset_notify_t, *phwrm_async_event_cmpl_reset_notify_t;

/* hwrm_async_event_cmpl_error_recovery (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_recovery {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message can be used for selecting or
	 * deselecting master function for error recovery,
	 * and to communicate to all the functions whether error recovery
	 * was enabled/disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_ERROR_RECOVERY UINT32_C(0x9)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_ERROR_RECOVERY
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates driver action requested */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_SFT		0
	/*
	 * If set to 1, this function is selected as Master function.
	 * This function has responsibility to do 'chip reset' when it
	 * detects a fatal error. If set to 0, master function functionality
	 * is disabled on this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_MASTER_FUNC	UINT32_C(0x1)
	/*
	 * If set to 1, error recovery is enabled.
	 * If set to 0, error recovery is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_RECOVERY_ENABLED	UINT32_C(0x2)
} hwrm_async_event_cmpl_error_recovery_t, *phwrm_async_event_cmpl_error_recovery_t;

/* hwrm_async_event_cmpl_ring_monitor_msg (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_ring_monitor_msg {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Ring Monitor Message. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_RING_MONITOR_MSG UINT32_C(0xa)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_RING_MONITOR_MSG
	/* Event specific data */
	uint32_t	event_data2;
	/* Type of Ring disabled. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_SFT 0
	/* tx ring disabled. */
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_TX	UINT32_C(0x0)
	/* rx ring disabled. */
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_RX	UINT32_C(0x1)
	/* cmpl ring disabled. */
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_CMPL  UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_LAST HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_CMPL
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/*
	 * Event specific data. If ring_type_disabled indicates a tx, rx or cmpl
	 * then this field will indicate the ring id.
	 */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_ring_monitor_msg_t, *phwrm_async_event_cmpl_ring_monitor_msg_t;

/* hwrm_async_event_cmpl_func_drvr_unload (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_func_drvr_unload {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_FUNC_DRVR_UNLOAD UINT32_C(0x10)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_FUNC_DRVR_UNLOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_SFT 0
} hwrm_async_event_cmpl_func_drvr_unload_t, *phwrm_async_event_cmpl_func_drvr_unload_t;

/* hwrm_async_event_cmpl_func_drvr_load (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_func_drvr_load {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_FUNC_DRVR_LOAD UINT32_C(0x11)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_FUNC_DRVR_LOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_DATA1_FUNC_ID_SFT 0
} hwrm_async_event_cmpl_func_drvr_load_t, *phwrm_async_event_cmpl_func_drvr_load_t;

/* hwrm_async_event_cmpl_func_flr_proc_cmplt (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_func_flr_proc_cmplt {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function FLR related processing has completed */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_FUNC_FLR_PROC_CMPLT UINT32_C(0x12)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_FUNC_FLR_PROC_CMPLT
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_DATA1_FUNC_ID_SFT 0
} hwrm_async_event_cmpl_func_flr_proc_cmplt_t, *phwrm_async_event_cmpl_func_flr_proc_cmplt_t;

/* hwrm_async_event_cmpl_pf_drvr_unload (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pf_drvr_unload {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_PF_DRVR_UNLOAD UINT32_C(0x20)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_PF_DRVR_UNLOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PF ID */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_SFT 0
	/* Indicates the physical port this pf belongs to */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_PORT_MASK   UINT32_C(0x70000)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_PORT_SFT	16
} hwrm_async_event_cmpl_pf_drvr_unload_t, *phwrm_async_event_cmpl_pf_drvr_unload_t;

/* hwrm_async_event_cmpl_pf_drvr_load (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pf_drvr_load {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_PF_DRVR_LOAD UINT32_C(0x21)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_PF_DRVR_LOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PF ID */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_FUNC_ID_SFT 0
	/* Indicates the physical port this pf belongs to */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_PORT_MASK   UINT32_C(0x70000)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_PORT_SFT	16
} hwrm_async_event_cmpl_pf_drvr_load_t, *phwrm_async_event_cmpl_pf_drvr_load_t;

/* hwrm_async_event_cmpl_vf_flr (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_vf_flr {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF Function Level Reset (FLR) */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_VF_FLR UINT32_C(0x30)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_LAST  HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_VF_FLR
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* VF ID */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_VF_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_VF_ID_SFT 0
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_PF_ID_MASK UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_PF_ID_SFT 16
} hwrm_async_event_cmpl_vf_flr_t, *phwrm_async_event_cmpl_vf_flr_t;

/* hwrm_async_event_cmpl_vf_mac_addr_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_vf_mac_addr_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF MAC Address Change */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_VF_MAC_ADDR_CHANGE UINT32_C(0x31)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_VF_MAC_ADDR_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* VF ID */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_DATA1_VF_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_DATA1_VF_ID_SFT 0
} hwrm_async_event_cmpl_vf_mac_addr_change_t, *phwrm_async_event_cmpl_vf_mac_addr_change_t;

/* hwrm_async_event_cmpl_pf_vf_comm_status_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pf_vf_comm_status_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF-VF communication channel status change. */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_PF_VF_COMM_STATUS_CHANGE UINT32_C(0x32)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_PF_VF_COMM_STATUS_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * If this bit is set to 1, then it indicates that the PF-VF
	 * communication was lost and it is established.
	 * If this bit set to 0, then it indicates that the PF-VF
	 * communication was established and it is lost.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_DATA1_COMM_ESTABLISHED	UINT32_C(0x1)
} hwrm_async_event_cmpl_pf_vf_comm_status_change_t, *phwrm_async_event_cmpl_pf_vf_comm_status_change_t;

/* hwrm_async_event_cmpl_vf_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_vf_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_VF_CFG_CHANGE UINT32_C(0x33)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_VF_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * This value indicates the VF ID of the VF whose configuration
	 * is changing if this async. event is sent to the parent PF.
	 * The firmware supports sending this to the parent PF if the
	 * `hwrm_func_qcaps.vf_cfg_async_for_pf_supported` value is 1.
	 * This value is undefined when the async. event is sent to the
	 * VF.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA2_VF_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA2_VF_ID_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/*
	 * Each flag provided in this field indicates a specific VF
	 * configuration change. At least one of these flags shall be set to 1
	 * when an asynchronous event completion of this type is provided
	 * by the HWRM.
	 */
	uint32_t	event_data1;
	/*
	 * If this bit is set to 1, then the value of MTU
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_MTU_CHANGE		UINT32_C(0x1)
	/*
	 * If this bit is set to 1, then the value of MRU
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_MRU_CHANGE		UINT32_C(0x2)
	/*
	 * If this bit is set to 1, then the value of default MAC
	 * address was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_DFLT_MAC_ADDR_CHANGE	UINT32_C(0x4)
	/*
	 * If this bit is set to 1, then the value of default VLAN
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_DFLT_VLAN_CHANGE	UINT32_C(0x8)
	/*
	 * If this bit is set to 1, then the value of trusted VF enable
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_TRUSTED_VF_CFG_CHANGE	UINT32_C(0x10)
	/*
	 * If this bit is set to 1, then the control of VF was relinquished
	 * back to the firmware flow manager following the function takeover
	 * by TruFlow.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_TF_OWNERSHIP_RELEASE	UINT32_C(0x20)
} hwrm_async_event_cmpl_vf_cfg_change_t, *phwrm_async_event_cmpl_vf_cfg_change_t;

/* hwrm_async_event_cmpl_llfc_pfc_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_llfc_pfc_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* unused1 is 10 b */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_UNUSED1_MASK	UINT32_C(0xffc0)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_UNUSED1_SFT	6
	/* Identifiers of events. */
	uint16_t	event_id;
	/* LLFC/PFC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LLFC_PFC_CHANGE UINT32_C(0x34)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LLFC_PFC_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates llfc pfc status change */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_MASK UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_SFT 0
	/*
	 * If this field set to 1, then it indicates that llfc is
	 * enabled.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_LLFC  UINT32_C(0x1)
	/*
	 * If this field is set to 2, then it indicates that pfc
	 * is enabled.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_PFC   UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_LAST HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_PFC
	/* Indicates the physical port this llfc pfc change occur */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_MASK	UINT32_C(0x1c)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_SFT	2
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_ID_MASK UINT32_C(0x1fffe0)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_ID_SFT  5
} hwrm_async_event_cmpl_llfc_pfc_change_t, *phwrm_async_event_cmpl_llfc_pfc_change_t;

/* hwrm_async_event_cmpl_default_vnic_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_default_vnic_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* unused1 is 10 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_UNUSED1_MASK	UINT32_C(0xffc0)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_UNUSED1_SFT	6
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a default vnic allocation or free */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_ALLOC_FREE_NOTIFICATION UINT32_C(0x35)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_ALLOC_FREE_NOTIFICATION
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates default vnic configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_MASK	UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_SFT	0
	/*
	 * If this field is set to 1, then it indicates that
	 * a default VNIC has been allocate.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_ALLOC  UINT32_C(0x1)
	/*
	 * If this field is set to 2, then it indicates that
	 * a default VNIC has been freed.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_FREE   UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_LAST	HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_FREE
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_PF_ID_MASK		UINT32_C(0x3fc)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_PF_ID_SFT			2
	/* Indicates the virtual function this event occurred on */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_VF_ID_MASK		UINT32_C(0x3fffc00)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_VF_ID_SFT			10
} hwrm_async_event_cmpl_default_vnic_change_t, *phwrm_async_event_cmpl_default_vnic_change_t;

/* hwrm_async_event_cmpl_hw_flow_aged (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_hw_flow_aged {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a hw flow aged */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_HW_FLOW_AGED UINT32_C(0x36)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_HW_FLOW_AGED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates flow ID this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_ID_MASK	UINT32_C(0x7fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_ID_SFT	0
	/* Indicates flow direction this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION	UINT32_C(0x80000000)
	/*
	 * If this bit set to 0, then it indicates that the aged
	 * event was rx flow.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_RX	(UINT32_C(0x0) << 31)
	/*
	 * If this bit is set to 1, then it indicates that the aged
	 * event was tx flow.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_TX	(UINT32_C(0x1) << 31)
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_LAST HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_TX
} hwrm_async_event_cmpl_hw_flow_aged_t, *phwrm_async_event_cmpl_hw_flow_aged_t;

/* hwrm_async_event_cmpl_eem_cache_flush_req (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_eem_cache_flush_req {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a eem_cache_flush request */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_EEM_CACHE_FLUSH_REQ UINT32_C(0x38)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_EEM_CACHE_FLUSH_REQ
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_eem_cache_flush_req_t, *phwrm_async_event_cmpl_eem_cache_flush_req_t;

/* hwrm_async_event_cmpl_eem_cache_flush_done (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_eem_cache_flush_done {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * Notification of a host eem_cache_flush has completed. This event
	 * is generated by the host driver.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_EEM_CACHE_FLUSH_DONE UINT32_C(0x39)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_EEM_CACHE_FLUSH_DONE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates function ID that this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_DATA1_FID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_DATA1_FID_SFT 0
} hwrm_async_event_cmpl_eem_cache_flush_done_t, *phwrm_async_event_cmpl_eem_cache_flush_done_t;

/* hwrm_async_event_cmpl_tcp_flag_action_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_tcp_flag_action_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of tcp flag action change */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_TCP_FLAG_ACTION_CHANGE UINT32_C(0x3a)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_TCP_FLAG_ACTION_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_tcp_flag_action_change_t, *phwrm_async_event_cmpl_tcp_flag_action_change_t;

/* hwrm_async_event_cmpl_eem_flow_active (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_eem_flow_active {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of an active eem flow */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_EEM_FLOW_ACTIVE UINT32_C(0x3b)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_EEM_FLOW_ACTIVE
	/* Event specific data */
	uint32_t	event_data2;
	/* Indicates the 2nd global id this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_GLOBAL_ID_2_MASK   UINT32_C(0x3fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_GLOBAL_ID_2_SFT	0
	/*
	 * Indicates flow direction of the flow identified by
	 * the global_id_2.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION	UINT32_C(0x40000000)
	/* If this bit is set to 0, then it indicates that this rx flow. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_RX	(UINT32_C(0x0) << 30)
	/* If this bit is set to 1, then it indicates that this tx flow. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_TX	(UINT32_C(0x1) << 30)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_LAST HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_TX
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the 1st global id this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_GLOBAL_ID_1_MASK   UINT32_C(0x3fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_GLOBAL_ID_1_SFT	0
	/*
	 * Indicates flow direction of the flow identified by the
	 * global_id_1.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION	UINT32_C(0x40000000)
	/* If this bit is set to 0, then it indicates that this is rx flow. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_RX	(UINT32_C(0x0) << 30)
	/* If this bit is set to 1, then it indicates that this is tx flow. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_TX	(UINT32_C(0x1) << 30)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_LAST HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_TX
	/*
	 * Indicates EEM flow aging mode this event occurred on. If
	 * this bit is set to 0, the event_data1 is the EEM global
	 * ID. If this bit is set to 1, the event_data1 is the number
	 * of global ID in the context memory.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE		UINT32_C(0x80000000)
	/* EEM flow aging mode 0. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_0		(UINT32_C(0x0) << 31)
	/* EEM flow aging mode 1. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_1		(UINT32_C(0x1) << 31)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_LAST	HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_1
} hwrm_async_event_cmpl_eem_flow_active_t, *phwrm_async_event_cmpl_eem_flow_active_t;

/* hwrm_async_event_cmpl_eem_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_eem_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of EEM configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_EEM_CFG_CHANGE UINT32_C(0x3c)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_EEM_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * Value of 1 to indicate EEM TX configuration is enabled. Value of
	 * 0 to indicate the EEM TX configuration is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_DATA1_EEM_TX_ENABLE	UINT32_C(0x1)
	/*
	 * Value of 1 to indicate EEM RX configuration is enabled. Value of 0
	 * to indicate the EEM RX configuration is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_DATA1_EEM_RX_ENABLE	UINT32_C(0x2)
} hwrm_async_event_cmpl_eem_cfg_change_t, *phwrm_async_event_cmpl_eem_cfg_change_t;

/* hwrm_async_event_cmpl_quiesce_done (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_quiesce_done {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* An event signifying completion of HWRM_FW_STATE_QUIESCE */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_QUIESCE_DONE UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_QUIESCE_DONE
	/* Event specific data */
	uint32_t	event_data2;
	/* Status of HWRM_FW_STATE_QUIESCE completion */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_SFT		0
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE
	 * completed successfully.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_SUCCESS		UINT32_C(0x0)
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE timed
	 * out.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_TIMEOUT		UINT32_C(0x1)
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE
	 * encountered an error.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_ERROR		UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_LAST		HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_ERROR
	/* opaque is 8 b */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_OPAQUE_MASK			UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_OPAQUE_SFT			8
	/*
	 * Additional information about internal hardware state related to
	 * idle/quiesce state. QUIESCE may succeed per quiesce_status
	 * regardless of idle_state_flags. If QUIESCE fails, the host may
	 * inspect idle_state_flags to determine whether a retry is warranted.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_MASK		UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_SFT		16
	/*
	 * Failure to quiesce is caused by host not updating the NQ consumer
	 * index.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_INCOMPLETE_NQ	UINT32_C(0x10000)
	/* Flag 1 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_1	UINT32_C(0x20000)
	/* Flag 2 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_2	UINT32_C(0x40000)
	/* Flag 3 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_3	UINT32_C(0x80000)
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Time stamp for error event */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA1_TIMESTAMP	UINT32_C(0x1)
} hwrm_async_event_cmpl_quiesce_done_t, *phwrm_async_event_cmpl_quiesce_done_t;

/* hwrm_async_event_cmpl_deferred_response (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_deferred_response {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * An event signifying a HWRM command is in progress and its
	 * response will be deferred
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_DEFERRED_RESPONSE UINT32_C(0x40)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_DEFERRED_RESPONSE
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * The PF's mailbox is clear to issue another command.
	 * A command with this seq_id is still in progress
	 * and will return a regular HWRM completion when done.
	 * 'event_data1' field, if non-zero, contains the estimated
	 * execution time for the command.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_DATA2_SEQ_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_DATA2_SEQ_ID_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Estimated remaining time of command execution in ms (if not zero) */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_deferred_response_t, *phwrm_async_event_cmpl_deferred_response_t;

/* hwrm_async_event_cmpl_pfc_watchdog_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pfc_watchdog_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PFC watchdog configuration change for given port/cos */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE UINT32_C(0x41)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * 1 in bit position X indicates PFC watchdog should
	 * be on for COSX
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_SFT		0
	/* 1 means PFC WD for COS0 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS0	UINT32_C(0x1)
	/* 1 means PFC WD for COS1 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS1	UINT32_C(0x2)
	/* 1 means PFC WD for COS2 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS2	UINT32_C(0x4)
	/* 1 means PFC WD for COS3 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS3	UINT32_C(0x8)
	/* 1 means PFC WD for COS4 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS4	UINT32_C(0x10)
	/* 1 means PFC WD for COS5 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS5	UINT32_C(0x20)
	/* 1 means PFC WD for COS6 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS6	UINT32_C(0x40)
	/* 1 means PFC WD for COS7 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS7	UINT32_C(0x80)
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK		UINT32_C(0xffff00)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT		8
} hwrm_async_event_cmpl_pfc_watchdog_cfg_change_t, *phwrm_async_event_cmpl_pfc_watchdog_cfg_change_t;

/* hwrm_async_event_cmpl_echo_request (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_echo_request {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * An echo request from the firmware. An echo response is expected by
	 * the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_ECHO_REQUEST UINT32_C(0x42)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_ECHO_REQUEST
	/* Event specific data that should be provided in the echo response */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data that should be provided in the echo response */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_echo_request_t, *phwrm_async_event_cmpl_echo_request_t;

/* hwrm_async_event_cmpl_phc_update (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_phc_update {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async event is used to notify driver of changes
	 * in PHC master. Only one master function can configure
	 * PHC.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_ID_PHC_UPDATE UINT32_C(0x43)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_ID_PHC_UPDATE
	/* Event specific data */
	uint32_t	event_data2;
	/* This field provides the current master function. */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA2_PHC_MASTER_FID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA2_PHC_MASTER_FID_SFT 0
	/* This field provides the current secondary function. */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA2_PHC_SEC_FID_MASK   UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA2_PHC_SEC_FID_SFT	16
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates to the driver the type of PHC event. */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_MASK	UINT32_C(0xf)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_SFT	0
	/*
	 * Indicates PHC Master selection event. The master fid is
	 * specified in event_data2.phc_master_fid.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_MASTER	UINT32_C(0x1)
	/*
	 * Indicates PHC Secondary selection event. The secondary fid is
	 * specified in event_data2.phc_sec_fid.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_SECONDARY   UINT32_C(0x2)
	/*
	 * Indicates PHC failover event. Failover happens from
	 * event_data2.phc_master_fid to event_data2.phc_sec_fid.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_FAILOVER	UINT32_C(0x3)
	/*
	 * Indicates that the 64bit Real time clock upper 16bits
	 * have been updated due to PHC rollover. The updated
	 * upper 16bits is in event_data1.phc_time_msb
	 */
		#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_RTC_UPDATE  UINT32_C(0x4)
		#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_LAST	HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_RTC_UPDATE
	/*
	 * This field provides the upper 16bits of the 64bit real
	 * time clock.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_PHC_TIME_MSB_MASK   UINT32_C(0xffff0)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_PHC_TIME_MSB_SFT	4
} hwrm_async_event_cmpl_phc_update_t, *phwrm_async_event_cmpl_phc_update_t;

/* hwrm_async_event_cmpl_pps_timestamp (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pps_timestamp {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message can be used to inform
	 * driver of the latest PPS timestamp that has been latched.
	 * When driver enables PPS event, Firmware will generate
	 * PPS timestamps every second, Firmware informs driver
	 * of this timestamp through the async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_PPS_TIMESTAMP UINT32_C(0x44)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_PPS_TIMESTAMP
	/* Event specific data */
	uint32_t	event_data2;
	/* Indicates the PPS event type */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE		UINT32_C(0x1)
	/* This is an internal event. */
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_INTERNAL	UINT32_C(0x0)
	/* This is an external event. */
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_EXTERNAL	UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_LAST	HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_EXTERNAL
	/*
	 * Indicates the pin number on which the event is
	 * received.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PIN_NUMBER_MASK	UINT32_C(0xe)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PIN_NUMBER_SFT	1
	/*
	 * Contains bits[47:32] of the upper PPS timestamp.
	 * Lower 32 bits are in event_data1. Together they
	 * provide the 48 bit PPS timestamp.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PPS_TIMESTAMP_UPPER_MASK UINT32_C(0xffff0)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PPS_TIMESTAMP_UPPER_SFT 4
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Contains the lower 32 bits of the PPS timestamp. */
	uint32_t	event_data1;
	/* Contains the lower 32 bit PPS timestamp */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA1_PPS_TIMESTAMP_LOWER_MASK UINT32_C(0xffffffff)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA1_PPS_TIMESTAMP_LOWER_SFT 0
} hwrm_async_event_cmpl_pps_timestamp_t, *phwrm_async_event_cmpl_pps_timestamp_t;

/* hwrm_async_event_cmpl_error_report (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_report {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_ID_ERROR_REPORT UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * Indicates the type of error being reported. See section on Error
	 * Report event error_types for details on each error.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_DATA1_ERROR_TYPE_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_EVENT_DATA1_ERROR_TYPE_SFT 0
} hwrm_async_event_cmpl_error_report_t, *phwrm_async_event_cmpl_error_report_t;

/* hwrm_async_event_cmpl_doorbell_pacing_threshold (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_doorbell_pacing_threshold {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the driver
	 * that the programmable pacing threshold for the doorbell FIFO is
	 * reached. The driver will take appropriate action to pace the
	 * doorbells when this async event is received from the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_EVENT_ID_DOORBELL_PACING_THRESHOLD UINT32_C(0x46)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_EVENT_ID_DOORBELL_PACING_THRESHOLD
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_THRESHOLD_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_doorbell_pacing_threshold_t, *phwrm_async_event_cmpl_doorbell_pacing_threshold_t;

/* hwrm_async_event_cmpl_rss_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_rss_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the driver
	 * that the RSS capabilities have changed. The driver will need
	 * to query hwrm_vnic_qcaps.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_EVENT_ID_RSS_CHANGE UINT32_C(0x47)
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_EVENT_ID_RSS_CHANGE
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_RSS_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_rss_change_t, *phwrm_async_event_cmpl_rss_change_t;

/* hwrm_async_event_cmpl_doorbell_pacing_nq_update (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_doorbell_pacing_nq_update {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * An event from firmware indicating that list of nq ids used for
	 * doorbell pacing DBQ event notification has been updated. The driver
	 * needs to take appropriate action and retrieve the new list when this
	 * event is received from the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_EVENT_ID_DOORBELL_PACING_NQ_UPDATE UINT32_C(0x48)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_EVENT_ID_DOORBELL_PACING_NQ_UPDATE
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DOORBELL_PACING_NQ_UPDATE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_doorbell_pacing_nq_update_t, *phwrm_async_event_cmpl_doorbell_pacing_nq_update_t;

/* hwrm_async_event_cmpl_hw_doorbell_recovery_read_error (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_hw_doorbell_recovery_read_error {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the driver
	 * that hardware ran into an error while trying to read the host
	 * based doorbell copy region. The driver will take the appropriate
	 * action to maintain the corresponding functions doorbell copy
	 * region in the correct format.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_ID_HW_DOORBELL_RECOVERY_READ_ERROR UINT32_C(0x49)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_ID_HW_DOORBELL_RECOVERY_READ_ERROR
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * Indicates that there is an error while reading the doorbell copy
	 * regions.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_MASK	UINT32_C(0xf)
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_SFT	0
	/*
	 * If set to 1, indicates that there is an error while reading the
	 * SQ doorbell copy region for this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_SQ_ERR	UINT32_C(0x1)
	/*
	 * If set to 1, indicates that there is an error while reading the
	 * RQ doorbell copy region for this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_RQ_ERR	UINT32_C(0x2)
	/*
	 * If set to 1, indicates that there is an error while reading the
	 * SRQ doorbell copy region for this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_SRQ_ERR	UINT32_C(0x4)
	/*
	 * If set to 1, indicates that there is an error while reading the
	 * CQ doorbell copy region for this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_DOORBELL_RECOVERY_READ_ERROR_EVENT_DATA1_READ_ERROR_FLAGS_CQ_ERR	UINT32_C(0x8)
} hwrm_async_event_cmpl_hw_doorbell_recovery_read_error_t, *phwrm_async_event_cmpl_hw_doorbell_recovery_read_error_t;

/* hwrm_async_event_cmpl_ctx_error (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_ctx_error {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the PF driver
	 * that firmware fails to allocate/free the contexts requested. This
	 * message is only valid in the XID partition scheme. Given the start
	 * xid and the number of contexts in error, the PF driver will figure
	 * out the corresponding XID partition(s) in error.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_ID_CTX_ERROR UINT32_C(0x4a)
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_ID_CTX_ERROR
	/* Event specific data */
	uint32_t	event_data2;
	/* Context operation code */
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_CTX_OP_CODE	UINT32_C(0x1)
	/* Context alloc failure */
		#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_CTX_OP_CODE_ALLOC  UINT32_C(0x0)
	/* Context free failure */
		#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_CTX_OP_CODE_FREE   UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_CTX_OP_CODE_LAST  HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_CTX_OP_CODE_FREE
	/* Number of contexts in error */
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_NUM_CTXS_MASK	UINT32_C(0xfffe)
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_NUM_CTXS_SFT	1
	/* Function ID which the XID partitions are associated with */
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_FID_MASK	UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA2_FID_SFT	16
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Starting XID that has error */
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA1_START_XID_MASK UINT32_C(0xffffffff)
	#define HWRM_ASYNC_EVENT_CMPL_CTX_ERROR_EVENT_DATA1_START_XID_SFT 0
} hwrm_async_event_cmpl_ctx_error_t, *phwrm_async_event_cmpl_ctx_error_t;

/* hwrm_async_event_udcc_session_change (size:128b/16B) */

typedef struct hwrm_async_event_udcc_session_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the PF driver
	 * that firmware has modified a UDCC session.
	 */
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_ID_UDCC_SESSION_CHANGE UINT32_C(0x4b)
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_ID_UDCC_SESSION_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/* UDCC Session id operation code */
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_DATA2_SESSION_ID_OP_CODE_MASK   UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_DATA2_SESSION_ID_OP_CODE_SFT	0
	/* session_id has been created */
		#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_DATA2_SESSION_ID_OP_CODE_CREATED  UINT32_C(0x0)
	/* session_id has been freed */
		#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_DATA2_SESSION_ID_OP_CODE_FREED	UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_DATA2_SESSION_ID_OP_CODE_LAST	HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_DATA2_SESSION_ID_OP_CODE_FREED
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* UDCC session id which was modified */
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_DATA1_UDCC_SESSION_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_UDCC_SESSION_CHANGE_EVENT_DATA1_UDCC_SESSION_ID_SFT 0
} hwrm_async_event_udcc_session_change_t, *phwrm_async_event_udcc_session_change_t;

/* hwrm_async_event_representor_pair_change (size:128b/16B) */

typedef struct hwrm_async_event_representor_pair_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the driver
	 * that firmware has modified a representor pair.
	 */
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_ID_REPRESENTOR_PAIR_CHANGE UINT32_C(0x4e)
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_ID_REPRESENTOR_PAIR_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/* Representor pair operation code */
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_PAIR_OP_CODE_MASK   UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_PAIR_OP_CODE_SFT	0
	/* pair has been created */
		#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_PAIR_OP_CODE_CREATED  UINT32_C(0x0)
	/* pair has been deleted */
		#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_PAIR_OP_CODE_DELETED  UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_PAIR_OP_CODE_LAST	HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_PAIR_OP_CODE_DELETED
	/* DSCP insert operation code */
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_DSCP_OP_CODE_MASK   UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_DSCP_OP_CODE_SFT	8
	/* allow dscp modification */
		#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_DSCP_OP_CODE_MODIFY   (UINT32_C(0x0) << 8)
	/* skip dscp modification */
		#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_DSCP_OP_CODE_IGNORE   (UINT32_C(0x1) << 8)
		#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_DSCP_OP_CODE_LAST	HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA2_DSCP_OP_CODE_IGNORE
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Representor endpoint fid which was modified */
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA1_PAIR_EP_FID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA1_PAIR_EP_FID_SFT  0
	/* Representor uplink fid which was modified */
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA1_PAIR_REP_FID_MASK UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_REPRESENTOR_PAIR_CHANGE_EVENT_DATA1_PAIR_REP_FID_SFT 16
} hwrm_async_event_representor_pair_change_t, *phwrm_async_event_representor_pair_change_t;

/* hwrm_async_event_cmpl_dbg_buf_producer (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_dbg_buf_producer {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * Used to notify the host that the firmware has DMA-ed additional
	 * debug data to the host buffer. This is effectively a producer index
	 * update. The host driver can utilize this information to determine
	 * how much of its host buffer has been populated by the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_ID_DBG_BUF_PRODUCER UINT32_C(0x4c)
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_ID_DBG_BUF_PRODUCER
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * Specifies the current host buffer offset. Data up to this offset
	 * has been populated by the firmware. For example, if the firmware
	 * has DMA-ed 8192 bytes to the host buffer, then this field has a
	 * value of 8192. This field rolls over to zero once the firmware
	 * writes the last page of the host buffer
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA2_CURRENT_BUFFER_OFFSET_MASK UINT32_C(0xffffffff)
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA2_CURRENT_BUFFER_OFFSET_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Type of trace buffer that has been updated. */
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_MASK	UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_SFT		0
	/* SRT trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_SRT_TRACE	UINT32_C(0x0)
	/* SRT2 trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_SRT2_TRACE	UINT32_C(0x1)
	/* CRT trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_CRT_TRACE	UINT32_C(0x2)
	/* CRT2 trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_CRT2_TRACE	UINT32_C(0x3)
	/* RIGP0 trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_RIGP0_TRACE	UINT32_C(0x4)
	/* L2 HWRM trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_L2_HWRM_TRACE	UINT32_C(0x5)
	/* RoCE HWRM trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_ROCE_HWRM_TRACE  UINT32_C(0x6)
	/* Context Accelerator CPU 0 trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_CA0_TRACE	UINT32_C(0x7)
	/* Context Accelerator CPU 1 trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_CA1_TRACE	UINT32_C(0x8)
	/* Context Accelerator CPU 2 trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_CA2_TRACE	UINT32_C(0x9)
	/* RIGP1 trace. */
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_RIGP1_TRACE	UINT32_C(0xa)
		#define HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DBG_BUF_PRODUCER_EVENT_DATA1_TYPE_RIGP1_TRACE
} hwrm_async_event_cmpl_dbg_buf_producer_t, *phwrm_async_event_cmpl_dbg_buf_producer_t;

/* hwrm_async_event_cmpl_peer_mmap_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_peer_mmap_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform the driver
	 * that the memory mapping for a peer device is set. The driver
	 * will need to query using get_structured_data.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_EVENT_ID_PEER_MMAP_CHANGE UINT32_C(0x4d)
	#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_EVENT_ID_PEER_MMAP_CHANGE
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PEER_MMAP_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_peer_mmap_change_t, *phwrm_async_event_cmpl_peer_mmap_change_t;

/* hwrm_async_event_cmpl_fw_trace_msg (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_fw_trace_msg {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Firmware trace log message */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_FW_TRACE_MSG UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_FW_TRACE_MSG
	/* Trace byte 0 to 3 */
	uint32_t	event_data2;
	/* Trace byte0 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE0_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE0_SFT 0
	/* Trace byte1 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE1_MASK UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE1_SFT 8
	/* Trace byte2 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE2_MASK UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE2_SFT 16
	/* Trace byte3 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE3_MASK UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE3_SFT 24
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_OPAQUE_SFT 1
	/* Trace flags */
	uint8_t	timestamp_lo;
	/* Indicates if the string is partial or complete. */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING		UINT32_C(0x1)
	/* Complete string */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_COMPLETE	UINT32_C(0x0)
	/* Partial string */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_PARTIAL	UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_LAST	HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_PARTIAL
	/* Indicates the firmware that sent the trace message. */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE	UINT32_C(0x2)
	/* Primary firmware */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_PRIMARY	(UINT32_C(0x0) << 1)
	/* Secondary firmware */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_SECONDARY  (UINT32_C(0x1) << 1)
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_LAST	HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_SECONDARY
	/* Trace byte 4 to 5 */
	uint16_t	timestamp_hi;
	/* Trace byte4 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE4_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE4_SFT 0
	/* Trace byte5 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE5_MASK UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE5_SFT 8
	/* Trace byte 6 to 9 */
	uint32_t	event_data1;
	/* Trace byte6 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE6_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE6_SFT 0
	/* Trace byte7 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE7_MASK UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE7_SFT 8
	/* Trace byte8 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE8_MASK UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE8_SFT 16
	/* Trace byte9 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE9_MASK UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE9_SFT 24
} hwrm_async_event_cmpl_fw_trace_msg_t, *phwrm_async_event_cmpl_fw_trace_msg_t;

/* hwrm_async_event_cmpl_hwrm_error (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_hwrm_error {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_HWRM_ERROR UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_HWRM_ERROR
	/* Event specific data */
	uint32_t	event_data2;
	/* Severity of HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_MASK	UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_SFT	0
	/* Warning */
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_WARNING   UINT32_C(0x0)
	/* Non-fatal Error */
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_NONFATAL  UINT32_C(0x1)
	/* Fatal Error */
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_FATAL	UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_LAST	HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_FATAL
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Time stamp for error event */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA1_TIMESTAMP	UINT32_C(0x1)
} hwrm_async_event_cmpl_hwrm_error_t, *phwrm_async_event_cmpl_hwrm_error_t;

/* hwrm_async_event_cmpl_error_report_base (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_report_base {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_ID_ERROR_REPORT UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_MASK			UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_SFT			0
	/* Reserved */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_RESERVED			UINT32_C(0x0)
	/*
	 * The NIC was subjected to an extended pause storm which caused it
	 * to disable flow control in order to avoid stalling the Tx path.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_PAUSE_STORM		UINT32_C(0x1)
	/*
	 * The NIC received an interrupt storm on a TSIO pin being used as
	 * PPS_IN which caused it to disable the interrupt. The signal
	 * should be fixed to be a proper 1 PPS signal before re-enabling
	 * it. The pin number on which this signal was received is stored
	 * in event_data2 as pin_id.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_INVALID_SIGNAL		UINT32_C(0x2)
	/*
	 * There was a low level error with an NVM write or erase.
	 * See nvm_err_type for more details.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_NVM			UINT32_C(0x3)
	/*
	 * This indicates doorbell drop threshold was hit. When this
	 * threshold is crossed, it indicates one or more doorbells for
	 * the function were dropped by hardware.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_DOORBELL_DROP_THRESHOLD	UINT32_C(0x4)
	/*
	 * Indicates the NIC's temperature has crossed one of the thermal
	 * thresholds.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_THERMAL_THRESHOLD		UINT32_C(0x5)
	/*
	 * Speed change not supported with dual rate transceivers
	 * on this board.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_DUAL_DATA_RATE_NOT_SUPPORTED  UINT32_C(0x6)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_LAST			HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_DUAL_DATA_RATE_NOT_SUPPORTED
} hwrm_async_event_cmpl_error_report_base_t, *phwrm_async_event_cmpl_error_report_base_t;

#define GET_ERROR_REPORT_TYPE(x) \
	(((x) < 0x80) ? \
	((x) == 0x0 ? "RESERVED": \
	((x) == 0x1 ? "PAUSE_STORM": \
	((x) == 0x2 ? "INVALID_SIGNAL": \
	((x) == 0x3 ? "NVM": \
	((x) == 0x4 ? "DOORBELL_DROP_THRESHOLD": \
	((x) == 0x5 ? "THERMAL_THRESHOLD": \
	((x) == 0x6 ? "DUAL_DATA_RATE_NOT_SUPPORTED": \
	"Unknown decode" ))))))) : \
	"Unknown decode" )


/* hwrm_async_event_cmpl_error_report_pause_storm (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_report_pause_storm {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_ID_ERROR_REPORT UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_MASK	UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_SFT	0
	/*
	 * The NIC was subjected to an extended pause storm which caused it
	 * to disable flow control in order to avoid stalling the Tx path.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_PAUSE_STORM  UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_PAUSE_STORM_EVENT_DATA1_ERROR_TYPE_PAUSE_STORM
} hwrm_async_event_cmpl_error_report_pause_storm_t, *phwrm_async_event_cmpl_error_report_pause_storm_t;

/* hwrm_async_event_cmpl_error_report_invalid_signal (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_report_invalid_signal {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_ID_ERROR_REPORT UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	/* Indicates the TSIO pin on which invalid signal is detected. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA2_PIN_ID_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA2_PIN_ID_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_MASK	UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_SFT	0
	/*
	 * The NIC received an interrupt storm on a TSIO pin being used as
	 * PPS_IN which caused it to disable the interrupt. The signal
	 * should be fixed to be a proper 1 PPS signal before re-enabling
	 * it. The pin number on which this signal was received is stored
	 * in event_data2 as pin_id.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_INVALID_SIGNAL  UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_INVALID_SIGNAL_EVENT_DATA1_ERROR_TYPE_INVALID_SIGNAL
} hwrm_async_event_cmpl_error_report_invalid_signal_t, *phwrm_async_event_cmpl_error_report_invalid_signal_t;

/* hwrm_async_event_cmpl_error_report_nvm (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_report_nvm {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_ID_ERROR_REPORT UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	/* Indicates the address where error was detected */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA2_ERR_ADDR_MASK UINT32_C(0xffffffff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA2_ERR_ADDR_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_MASK	UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_SFT	0
	/*
	 * There was a low level error with an NVM operation.
	 * See nvm_err_type for more details.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_NVM_ERROR  UINT32_C(0x3)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_ERROR_TYPE_NVM_ERROR
	/* The specific type of NVM error */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_MASK   UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_SFT	8
	/*
	 * There was a low level error with an NVM write operation.
	 * Verification of written data did not match.
	 * event_data2 will be the failing address.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_WRITE	(UINT32_C(0x1) << 8)
	/*
	 * There was a low level error with an NVM erase operation.
	 * All the bits were not erased.
	 * event_data2 will be the failing address.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_ERASE	(UINT32_C(0x2) << 8)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_NVM_EVENT_DATA1_NVM_ERR_TYPE_ERASE
} hwrm_async_event_cmpl_error_report_nvm_t, *phwrm_async_event_cmpl_error_report_nvm_t;

/* hwrm_async_event_cmpl_error_report_doorbell_drop_threshold (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_report_doorbell_drop_threshold {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_ID_ERROR_REPORT UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_SFT			0
	/*
	 * This indicates doorbell drop threshold was hit. When this
	 * threshold is crossed, it indicates one or more doorbells for
	 * the function were dropped by hardware.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_DOORBELL_DROP_THRESHOLD  UINT32_C(0x4)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_LAST			HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_ERROR_TYPE_DOORBELL_DROP_THRESHOLD
	/*
	 * The epoch value to be sent from firmware to the driver to track
	 * a doorbell recovery cycle.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_EPOCH_MASK			UINT32_C(0xffffff00)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DOORBELL_DROP_THRESHOLD_EVENT_DATA1_EPOCH_SFT			8
} hwrm_async_event_cmpl_error_report_doorbell_drop_threshold_t, *phwrm_async_event_cmpl_error_report_doorbell_drop_threshold_t;

/* hwrm_async_event_cmpl_error_report_thermal (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_report_thermal {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_ID_ERROR_REPORT UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	/* Current temperature. In Celsius */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA2_CURRENT_TEMP_MASK  UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA2_CURRENT_TEMP_SFT   0
	/*
	 * The temperature setting of the threshold that was just crossed.
	 * In Celsius
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA2_THRESHOLD_TEMP_MASK UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA2_THRESHOLD_TEMP_SFT 8
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_MASK	UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_SFT	0
	/*
	 * There was thermal event. The type will be specified in the
	 * field threshold_type. event_data2 will contain the current
	 * temperature and the configured value for the threshold that
	 * was just crossed. The threshold values are lower thresholds,
	 * so the event will trigger with an active flag when the
	 * temperature is on an increasing trajectory.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_THERMAL_EVENT   UINT32_C(0x5)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_ERROR_TYPE_THERMAL_EVENT
	/* The specific type of thermal threshold error */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_MASK	UINT32_C(0x700)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_SFT	8
	/* Warning thermal threshold was crossed */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_WARN	(UINT32_C(0x0) << 8)
	/* Critical thermal threshold was crossed */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_CRITICAL	(UINT32_C(0x1) << 8)
	/* Fatal thermal threshold was crossed */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_FATAL	(UINT32_C(0x2) << 8)
	/*
	 * Thermal shutdown threshold was crossed and a shutdown is
	 * imminent. This event will not occur if self shutdown
	 * is disabled.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_SHUTDOWN	(UINT32_C(0x3) << 8)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_THRESHOLD_TYPE_SHUTDOWN
	/*
	 * Indicates if the thermal crossing occurs while the temperature is
	 * increasing or decreasing.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR	UINT32_C(0x800)
	/* Threshold is crossed while the temperature is falling. */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR_DECREASING  (UINT32_C(0x0) << 11)
	/* Threshold is crossed while the temperature is rising. */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR_INCREASING  (UINT32_C(0x1) << 11)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_THERMAL_EVENT_DATA1_TRANSITION_DIR_INCREASING
} hwrm_async_event_cmpl_error_report_thermal_t, *phwrm_async_event_cmpl_error_report_thermal_t;

/* hwrm_async_event_cmpl_error_report_dual_data_rate_not_supported (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_report_dual_data_rate_not_supported {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message is used to inform
	 * the driver that an error has occurred which may need
	 * the attention of the administrator.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_EVENT_ID_ERROR_REPORT UINT32_C(0x45)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_EVENT_ID_ERROR_REPORT
	/* Event specific data. */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the type of error being reported. */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_EVENT_DATA1_ERROR_TYPE_MASK			UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_EVENT_DATA1_ERROR_TYPE_SFT			0
	/*
	 * Speed change not supported with dual rate transceivers
	 * on this board.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_EVENT_DATA1_ERROR_TYPE_DUAL_DATA_RATE_NOT_SUPPORTED  UINT32_C(0x6)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_EVENT_DATA1_ERROR_TYPE_LAST			HWRM_ASYNC_EVENT_CMPL_ERROR_REPORT_DUAL_DATA_RATE_NOT_SUPPORTED_EVENT_DATA1_ERROR_TYPE_DUAL_DATA_RATE_NOT_SUPPORTED
} hwrm_async_event_cmpl_error_report_dual_data_rate_not_supported_t, *phwrm_async_event_cmpl_error_report_dual_data_rate_not_supported_t;

/* hwrm_async_event_cmpl_vf_stat_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_vf_stat_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * VF statistics context change. Informs PF driver that a VF
	 * statistics context has either been allocated or freed.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_ID_VF_STAT_CHANGE UINT32_C(0x4f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_ID_VF_STAT_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * VF ID that allocated the stats context. This is zero-based and
	 * relative to each PF.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_DATA2_VF_ID_MASK		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_DATA2_VF_ID_SFT		0
	/*
	 * A value of zero signals to the PF driver that it can free the host
	 * buffer associated with the statistics context.
	 * A non-zero values signals to the PF driver that it should allocate
	 * a host buffer for the statistics context and inform the firmware
	 * via HWRM_STAT_CTX_ALLOC. The PF driver must provide the sequence id
	 * in the corresponding HWRM_STAT_CTX_ALLOC request so that firmware
	 * can correlate it to the VF statistics context.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_DATA2_ACTION_SEQUENCE_ID_MASK UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_DATA2_ACTION_SEQUENCE_ID_SFT 16
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* VF statistics context identifier */
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_DATA1_STAT_CTX_ID_MASK UINT32_C(0xffffffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_STAT_CHANGE_EVENT_DATA1_STAT_CTX_ID_SFT 0
} hwrm_async_event_cmpl_vf_stat_change_t, *phwrm_async_event_cmpl_vf_stat_change_t;

/* hwrm_async_event_cmpl_host_coredump (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_host_coredump {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * coredump collection into host DMA address. Informs PF driver that
	 * the coredump has been captured.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_EVENT_ID_HOST_COREDUMP UINT32_C(0x50)
	#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_EVENT_ID_HOST_COREDUMP
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HOST_COREDUMP_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_host_coredump_t, *phwrm_async_event_cmpl_host_coredump_t;

/* metadata_base_msg (size:64b/8B) */

typedef struct metadata_base_msg {
	uint16_t	md_type_link;
	/* This field classifies the data present in the meta-data. */
	#define METADATA_BASE_MSG_MD_TYPE_MASK	UINT32_C(0x1f)
	#define METADATA_BASE_MSG_MD_TYPE_SFT	0
	/* Meta data fields are not valid */
		#define METADATA_BASE_MSG_MD_TYPE_NONE	UINT32_C(0x0)
	/*
	 * This setting is used when packets are coming in-order. Depending on
	 * the state of the receive context, the meta-data will carry
	 * different information.
	 */
		#define METADATA_BASE_MSG_MD_TYPE_TLS_INSYNC  UINT32_C(0x1)
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
		#define METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC  UINT32_C(0x2)
	/* This setting is used for QUIC packets. */
		#define METADATA_BASE_MSG_MD_TYPE_QUIC	UINT32_C(0x3)
	/*
	 * This setting is used for crypto packets with an unsupported
	 * protocol.
	 */
		#define METADATA_BASE_MSG_MD_TYPE_ILLEGAL	UINT32_C(0x1f)
		#define METADATA_BASE_MSG_MD_TYPE_LAST	METADATA_BASE_MSG_MD_TYPE_ILLEGAL
	/*
	 * This field indicates where the next metadata block starts, relative
	 * to the current metadata block. It is the offset to the next metadata
	 * header, counted in 16B units. A value of zero indicates that there is
	 * no additional metadata, and that the current metadata block is the
	 * last one.
	 */
	#define METADATA_BASE_MSG_LINK_MASK	UINT32_C(0x1e0)
	#define METADATA_BASE_MSG_LINK_SFT	5
	uint16_t	unused0;
	uint32_t	unused1;
} metadata_base_msg_t, *pmetadata_base_msg_t;

/* tls_metadata_base_msg (size:64b/8B) */

typedef struct tls_metadata_base_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_BASE_MSG_MD_TYPE_MASK				UINT32_C(0x1f)
	#define TLS_METADATA_BASE_MSG_MD_TYPE_SFT				0
	/*
	 * This setting is used when packets are coming in-order. Depending
	 * on the state of the receive context, the meta-data will carry
	 * different information.
	 */
		#define TLS_METADATA_BASE_MSG_MD_TYPE_TLS_INSYNC				UINT32_C(0x1)
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
		#define TLS_METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC				UINT32_C(0x2)
		#define TLS_METADATA_BASE_MSG_MD_TYPE_LAST				TLS_METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_BASE_MSG_LINK_MASK					UINT32_C(0x1e0)
	#define TLS_METADATA_BASE_MSG_LINK_SFT					5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_BASE_MSG_FLAGS_MASK				UINT32_C(0x1fffe00)
	#define TLS_METADATA_BASE_MSG_FLAGS_SFT					9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_DECRYPTED				UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_MASK				UINT32_C(0xc00)
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_SFT				10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_NOT_VALID			(UINT32_C(0x0) << 10)
	/*
	 * This enumeration indicates that this pkt contains the record's
	 * tag and this pkt was received ooo, the partial_ghash field
	 * contains the ghash.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_CUR_REC				(UINT32_C(0x1) << 10)
	/*
	 * This enumeration indicates that the current record's tag wasn't
	 * seen and the chip is moving on to the next record, the
	 * partial_ghash field contains the ghash.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_PRIOR_REC			(UINT32_C(0x2) << 10)
		#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_LAST				TLS_METADATA_BASE_MSG_FLAGS_GHASH_PRIOR_REC
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_MASK			UINT32_C(0x3000)
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_SFT			12
	/*
	 * This enumeration is set when HW was not able to authenticate a
	 * TAG.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_NOT_CHECKED		(UINT32_C(0x0) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and every tag is valid.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_SUCCESS		(UINT32_C(0x1) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and at least one of the tag is invalid. The entire packet
	 * is sent decrypted to the host.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE		(UINT32_C(0x2) << 12)
		#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_LAST			TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_HEADER_FLDS_VALID			UINT32_C(0x4000)
	/*
	 * A value of 1 indicates that the packet experienced a context load
	 * error. In this case, the packet is sent to the host without the
	 * header or payload decrypted and the context is not updated.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_CTX_LOAD_ERR				UINT32_C(0x8000)
	/* This field indicates the packet operation state. */
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_MASK		UINT32_C(0x70000)
	#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_SFT		16
	/* Packet is in order. */
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_IN_ORDER		(UINT32_C(0x0) << 16)
	/* Packet is out of order, no header loss. */
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_OUT_OF_ORDER	(UINT32_C(0x1) << 16)
	/* Packet is header search (out of order with header loss). */
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_HEADER_SEARCH	(UINT32_C(0x2) << 16)
	/* Packet is resync (resync record ongoing). */
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC		(UINT32_C(0x3) << 16)
	/*
	 * Packet is resync wait (resync record completes, waiting for
	 * result).
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT	(UINT32_C(0x4) << 16)
	/*
	 * Packet is resync wait for partial tag (waiting for resync record
	 * tag).
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT_PARTIAL   (UINT32_C(0x5) << 16)
	/* Packet is resync success (got resync record success). */
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS	(UINT32_C(0x6) << 16)
	/*
	 * Packet is resync success wait (got midpath ACK, waiting for
	 * resync record success).
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT   (UINT32_C(0x7) << 16)
		#define TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_LAST		TLS_METADATA_BASE_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_BASE_MSG_KID_LO_MASK				UINT32_C(0xfe000000)
	#define TLS_METADATA_BASE_MSG_KID_LO_SFT				25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_BASE_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_BASE_MSG_KID_HI_SFT 0
	uint16_t	unused0;
} tls_metadata_base_msg_t, *ptls_metadata_base_msg_t;

/* tls_metadata_insync_msg (size:192b/24B) */

typedef struct tls_metadata_insync_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_INSYNC_MSG_MD_TYPE_MASK				UINT32_C(0x1f)
	#define TLS_METADATA_INSYNC_MSG_MD_TYPE_SFT				0
	/*
	 * This setting is used when packets are coming in-order. Depending on
	 * the state of the receive context, the meta-data will carry
	 * different information.
	 */
		#define TLS_METADATA_INSYNC_MSG_MD_TYPE_TLS_INSYNC				UINT32_C(0x1)
		#define TLS_METADATA_INSYNC_MSG_MD_TYPE_LAST				TLS_METADATA_INSYNC_MSG_MD_TYPE_TLS_INSYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_INSYNC_MSG_LINK_MASK					UINT32_C(0x1e0)
	#define TLS_METADATA_INSYNC_MSG_LINK_SFT					5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_MASK				UINT32_C(0x1fffe00)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_SFT					9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_DECRYPTED				UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_MASK				UINT32_C(0xc00)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_SFT				10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_NOT_VALID			(UINT32_C(0x0) << 10)
	/*
	 * This enumeration indicates that this pkt contains the record's
	 * tag and this pkt was received ooo, the partial_ghash field
	 * contains the ghash.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_CUR_REC				(UINT32_C(0x1) << 10)
	/*
	 * This enumeration indicates that the current record's tag wasn't
	 * seen and the chip is moving on to the next record, the
	 * partial_ghash field contains the ghash.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_PRIOR_REC			(UINT32_C(0x2) << 10)
		#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_LAST				TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_PRIOR_REC
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_MASK			UINT32_C(0x3000)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_SFT			12
	/*
	 * This enumeration is set when HW was not able to authenticate a
	 * TAG.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_NOT_CHECKED		(UINT32_C(0x0) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and every tag is valid.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_SUCCESS		(UINT32_C(0x1) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and at least one of the tag is invalid. The entire packet
	 * is sent decrypted to the host.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE		(UINT32_C(0x2) << 12)
		#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_LAST			TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_HEADER_FLDS_VALID			UINT32_C(0x4000)
	/*
	 * A value of 1 indicates that the packet experienced a context load
	 * error. In this case, the packet is sent to the host without the
	 * header or payload decrypted and the context is not updated.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_CTX_LOAD_ERR				UINT32_C(0x8000)
	/* This field indicates the packet operation state. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_MASK		UINT32_C(0x70000)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_SFT		16
	/* Packet is in order. */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_IN_ORDER		(UINT32_C(0x0) << 16)
	/* Packet is out of order, no header loss. */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_OUT_OF_ORDER	(UINT32_C(0x1) << 16)
	/* Packet is header search (out of order with header loss). */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_HEADER_SEARCH	(UINT32_C(0x2) << 16)
	/* Packet is resync (resync record ongoing). */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC		(UINT32_C(0x3) << 16)
	/*
	 * Packet is resync wait (resync record completes, waiting for
	 * result).
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT	(UINT32_C(0x4) << 16)
	/*
	 * Packet is resync wait for partial tag (waiting for resync record
	 * tag).
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT_PARTIAL   (UINT32_C(0x5) << 16)
	/* Packet is resync success (got resync record success). */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS	(UINT32_C(0x6) << 16)
	/*
	 * Packet is resync success wait (got midpath ACK, waiting for
	 * resync record success).
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT   (UINT32_C(0x7) << 16)
		#define TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_LAST		TLS_METADATA_INSYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_INSYNC_MSG_KID_LO_MASK				UINT32_C(0xfe000000)
	#define TLS_METADATA_INSYNC_MSG_KID_LO_SFT				25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_INSYNC_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_INSYNC_MSG_KID_HI_SFT 0
	/*
	 * This field is only valid when md_type is set to tls_insync. This
	 * field indicates the offset within the current TCP packet where the
	 * TLS header starts. If there are multiple TLS headers in the packet,
	 * this provides the offset of the last TLS header.
	 *
	 * The field is calculated by subtracting TCP sequence number of the
	 * first byte of the TCP payload of the packet from the TCP sequence
	 * number of the last TLS header in the packet.
	 */
	uint16_t	tls_header_offset;
	/*
	 * This is the sequence Number of the record that was processed by the HW.
	 * If there are multiple records in a packet, this would be the sequence
	 * number of the last record.
	 */
	uint64_t	record_seq_num;
	/*
	 * This field contains cumulative partial GHASH value of all the packets
	 * decrypted by the HW associated with a TLS record. This field is valid
	 * on when packets belonging to have arrived out-of-order and HW could
	 * not decrypt every packet and authenticate the record. Partial GHASH is
	 * only sent out with packet having the TAG field.
	 */
	uint8_t	partial_ghash[8];
} tls_metadata_insync_msg_t, *ptls_metadata_insync_msg_t;

/* tls_metadata_resync_msg (size:256b/32B) */

typedef struct tls_metadata_resync_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_RESYNC_MSG_MD_TYPE_MASK				UINT32_C(0x1f)
	#define TLS_METADATA_RESYNC_MSG_MD_TYPE_SFT				0
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
		#define TLS_METADATA_RESYNC_MSG_MD_TYPE_TLS_RESYNC				UINT32_C(0x2)
		#define TLS_METADATA_RESYNC_MSG_MD_TYPE_LAST				TLS_METADATA_RESYNC_MSG_MD_TYPE_TLS_RESYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_RESYNC_MSG_LINK_MASK					UINT32_C(0x1e0)
	#define TLS_METADATA_RESYNC_MSG_LINK_SFT					5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_MASK				UINT32_C(0x1fffe00)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_SFT					9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_DECRYPTED				UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_MASK				UINT32_C(0xc00)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_SFT				10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_NOT_VALID			(UINT32_C(0x0) << 10)
		#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_LAST				TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_NOT_VALID
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_MASK			UINT32_C(0x3000)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_SFT			12
	/*
	 * This enumeration is set when HW was not able to authenticate a
	 * TAG.
	 */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_NOT_CHECKED		(UINT32_C(0x0) << 12)
		#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_LAST			TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_NOT_CHECKED
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_HEADER_FLDS_VALID			UINT32_C(0x4000)
	/*
	 * A value of 1 indicates that the packet experienced a context load
	 * error. In this case, the packet is sent to the host without the
	 * header or payload decrypted and the context is not updated.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_CTX_LOAD_ERR				UINT32_C(0x8000)
	/* This field indicates the packet operation state. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_MASK		UINT32_C(0x70000)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_SFT		16
	/* Packet is in order. */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_IN_ORDER		(UINT32_C(0x0) << 16)
	/* Packet is out of order, no header loss. */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_OUT_OF_ORDER	(UINT32_C(0x1) << 16)
	/* Packet is header search (out of order with header loss). */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_HEADER_SEARCH	(UINT32_C(0x2) << 16)
	/* Packet is resync (resync record ongoing). */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC		(UINT32_C(0x3) << 16)
	/*
	 * Packet is resync wait (resync record completes, waiting for
	 * result).
	 */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT	(UINT32_C(0x4) << 16)
	/*
	 * Packet is resync wait for partial tag (waiting for resync record
	 * tag).
	 */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_WAIT_PARTIAL   (UINT32_C(0x5) << 16)
	/* Packet is resync success (got resync record success). */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS	(UINT32_C(0x6) << 16)
	/*
	 * Packet is resync success wait (got midpath ACK, waiting for
	 * resync record success).
	 */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT   (UINT32_C(0x7) << 16)
		#define TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_LAST		TLS_METADATA_RESYNC_MSG_FLAGS_PKT_OPERATION_STATE_RESYNC_SUCCESS_WAIT
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_RESYNC_MSG_KID_LO_MASK				UINT32_C(0xfe000000)
	#define TLS_METADATA_RESYNC_MSG_KID_LO_SFT				25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_RESYNC_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_RESYNC_MSG_KID_HI_SFT 0
	/* This field is unused in this context. */
	uint16_t	metadata_0;
	/*
	 * This field indicates the TCP sequence number of the TLS record that HW
	 * is requesting a resync on from the Driver. HW will keep a count of the
	 * TLS records it found after this record (delta_records). Driver will
	 * provide the TLS Record Sequence Number associated with the record. HW
	 * will add the delta_records to the Record Sequence Number provided by
	 * the driver and get back on sync.
	 */
	uint32_t	resync_record_tcp_seq_num;
	uint32_t	unused0;
	/* This field is unused in this context. */
	uint64_t	metadata_2;
	/* This field is unused in this context. */
	uint64_t	metadata_3;
} tls_metadata_resync_msg_t, *ptls_metadata_resync_msg_t;

/* tx_doorbell (size:32b/4B) */

typedef struct tx_doorbell {
	uint32_t	key_idx;
	/*
	 * BD Index of next BD that will be used to transmit data
	 * on the TX ring mapped to this door bell. NIC may
	 * read and process all BDs up to, but not including this
	 * index.
	 */
	#define TX_DOORBELL_IDX_MASK UINT32_C(0xffffff)
	#define TX_DOORBELL_IDX_SFT 0
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested. This value is '0' for TX
	 * door bell operations.
	 */
	#define TX_DOORBELL_KEY_MASK UINT32_C(0xf0000000)
	#define TX_DOORBELL_KEY_SFT 28
	/* TX Operation */
		#define TX_DOORBELL_KEY_TX	(UINT32_C(0x0) << 28)
		#define TX_DOORBELL_KEY_LAST TX_DOORBELL_KEY_TX
} tx_doorbell_t, *ptx_doorbell_t;

/* rx_doorbell (size:32b/4B) */

typedef struct rx_doorbell {
	uint32_t	key_idx;
	/*
	 * BD Index of next BD that will be used for an empty receive
	 * buffer on the RX ring mapped to this door bell. NIC may
	 * read and process all BDs up to, but not including this
	 * index.
	 */
	#define RX_DOORBELL_IDX_MASK UINT32_C(0xffffff)
	#define RX_DOORBELL_IDX_SFT 0
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested. This value is '1' for RX
	 * door bell operations.
	 */
	#define RX_DOORBELL_KEY_MASK UINT32_C(0xf0000000)
	#define RX_DOORBELL_KEY_SFT 28
	/* RX Operation */
		#define RX_DOORBELL_KEY_RX	(UINT32_C(0x1) << 28)
		#define RX_DOORBELL_KEY_LAST RX_DOORBELL_KEY_RX
} rx_doorbell_t, *prx_doorbell_t;

/* cmpl_doorbell (size:32b/4B) */

typedef struct cmpl_doorbell {
	uint32_t	key_mask_valid_idx;
	/*
	 * BD Index of the most recently handed completion record
	 * on the completion ring mapped to this door bell.
	 * NIC may
	 * write this location again with a new completion.
	 */
	#define CMPL_DOORBELL_IDX_MASK	UINT32_C(0xffffff)
	#define CMPL_DOORBELL_IDX_SFT	0
	/*
	 * This indicates if the BDIDX value is valid for this
	 * update when it is '1'. When it is '0', the BDIDX
	 * value should be ignored.
	 */
	#define CMPL_DOORBELL_IDX_VALID	UINT32_C(0x4000000)
	/*
	 * This bit indicates the new interrupt mask state for the
	 * interrupt associated with the BDIDX. A '1', means the
	 * interrupt is to be masked. A '0' indicates the interrupt
	 * is to be unmasked.
	 */
	#define CMPL_DOORBELL_MASK	UINT32_C(0x8000000)
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested. This value is '2' for CMP
	 * door bell operations.
	 */
	#define CMPL_DOORBELL_KEY_MASK	UINT32_C(0xf0000000)
	#define CMPL_DOORBELL_KEY_SFT	28
	/* Completion Operation */
		#define CMPL_DOORBELL_KEY_CMPL	(UINT32_C(0x2) << 28)
		#define CMPL_DOORBELL_KEY_LAST	CMPL_DOORBELL_KEY_CMPL
} cmpl_doorbell_t, *pcmpl_doorbell_t;

/* status_doorbell (size:32b/4B) */

typedef struct status_doorbell {
	uint32_t	key_idx;
	/*
	 * BD Index of the status record for which space is now
	 * available to the NIC.
	 */
	/*
	 * While there is no actual BD associated with the index,
	 * the similar scheme is being used to communicate to
	 * the NIC that space is available for status completions.
	 */
	#define STATUS_DOORBELL_IDX_MASK UINT32_C(0xffffff)
	#define STATUS_DOORBELL_IDX_SFT 0
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested. This value is '3' for Status
	 * door bell operations.
	 */
	#define STATUS_DOORBELL_KEY_MASK UINT32_C(0xf0000000)
	#define STATUS_DOORBELL_KEY_SFT 28
	/* Status Operation */
		#define STATUS_DOORBELL_KEY_STAT  (UINT32_C(0x3) << 28)
		#define STATUS_DOORBELL_KEY_LAST STATUS_DOORBELL_KEY_STAT
} status_doorbell_t, *pstatus_doorbell_t;

/* push32_doorbell (size:1024b/128B) */

typedef struct push32_doorbell {
	uint32_t	key_sz_idx;
	/*
	 * This is the BD Index of last BD of the push packet
	 * that will be used to transmit data on the TX ring mapped
	 * to this door bell.
	 */
	#define PUSH32_DOORBELL_IDX_MASK UINT32_C(0xffffff)
	#define PUSH32_DOORBELL_IDX_SFT 0
	/*
	 * This is the number of 16B BDs spaces consumed in the TX
	 * Ring by the "backup" version of the packet being pushed.
	 * A value of 1 is invalid since backup must start with a
	 * long 32B BE.
	 * A value of 2 indicates just the first 32B BE.
	 * A value of 3 indicates 32B+16B BD. etc.
	 * A value of 0 indicates 16x16B BD spaces are consumed.
	 */
	#define PUSH32_DOORBELL_SZ_MASK UINT32_C(0xf000000)
	#define PUSH32_DOORBELL_SZ_SFT  24
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested. This value is 4 for push
	 * door bell operations.
	 */
	#define PUSH32_DOORBELL_KEY_MASK UINT32_C(0xf0000000)
	#define PUSH32_DOORBELL_KEY_SFT 28
	/* Push Operation */
		#define PUSH32_DOORBELL_KEY_PUSH  (UINT32_C(0x4) << 28)
		#define PUSH32_DOORBELL_KEY_LAST PUSH32_DOORBELL_KEY_PUSH
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define PUSH32_DOORBELL_TYPE_MASK		UINT32_C(0x3f)
	#define PUSH32_DOORBELL_TYPE_SFT		0
	/*
	 * Indicates that this BD is 32B long and is used for
	 * normal L2 packet transmission.
	 */
		#define PUSH32_DOORBELL_TYPE_TX_BD_LONG	UINT32_C(0x10)
		#define PUSH32_DOORBELL_TYPE_LAST		PUSH32_DOORBELL_TYPE_TX_BD_LONG
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	#define PUSH32_DOORBELL_FLAGS_MASK	UINT32_C(0xffc0)
	#define PUSH32_DOORBELL_FLAGS_SFT		6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 *
	 *	This bit must be set on all push doorbells.
	 */
	#define PUSH32_DOORBELL_FLAGS_PACKET_END	UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in it's
	 * processing.
	 * If this bit
	 * is set to 0, then the packet will be completed normally.
	 *
	 * This bit must be valid only on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_FLAGS_NO_CMPL	UINT32_C(0x80)
	/*
	 * This value must match the sz field in the first
	 * 32b of the push operation except that if
	 * 16x16B BD locations
	 * are consumed in the ring by this packet, then
	 * this value must be 16 (not zero).
	 */
	#define PUSH32_DOORBELL_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define PUSH32_DOORBELL_FLAGS_BD_CNT_SFT	8
	/*
	 * This value is a hint for the length of the entire packet.
	 * It is used by the chip to optimize internal processing.
	 *
	 * The packet will be dropped if the hint is too short.
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_FLAGS_LHINT_MASK	UINT32_C(0x6000)
	#define PUSH32_DOORBELL_FLAGS_LHINT_SFT	13
	/* indicates packet length < 512B */
		#define PUSH32_DOORBELL_FLAGS_LHINT_LT512	(UINT32_C(0x0) << 13)
	/* indicates 512 <= packet length < 1KB */
		#define PUSH32_DOORBELL_FLAGS_LHINT_LT1K	(UINT32_C(0x1) << 13)
	/* indicates 1KB <= packet length < 2KB */
		#define PUSH32_DOORBELL_FLAGS_LHINT_LT2K	(UINT32_C(0x2) << 13)
	/* indicates packet length >= 2KB */
		#define PUSH32_DOORBELL_FLAGS_LHINT_GTE2K	(UINT32_C(0x3) << 13)
		#define PUSH32_DOORBELL_FLAGS_LHINT_LAST	PUSH32_DOORBELL_FLAGS_LHINT_GTE2K
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_FLAGS_COAL_NOW	UINT32_C(0x8000)
	/*
	 * This is the length of the host physical buffer this BD describes
	 * in bytes.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD.
	 *
	 * This field must be valid on the first BD of a packet.
	 */
	uint32_t	opaque;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor. The flag is ignored if the LSO flag is set.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor.
	 *
	 * For outer UDP checksum, global outer UDP checksum TE_NIC register
	 * needs to be enabled. If the global outer UDP checksum TE_NIC
	 * register bit is set, outer UDP checksum will be calculated for the
	 * following cases:
	 * 1. Packets with tcp_udp_chksum flag set to offload checksum for
	 * inner packet AND the inner packet is TCP/UDP. If the inner packet is
	 * ICMP for example (non-TCP/UDP), even if the tcp_udp_chksum is set,
	 * the outer UDP checksum will not be calculated.
	 * 2. Packets with lso flag set which implies inner TCP checksum
	 * calculation as part of LSO operation.
	 */
	#define PUSH32_DOORBELL_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to 1, the device will treat this packet with LSO(Large
	 * Send Offload) processing for both normal or encapsulated
	 * packets, which is a form of TCP segmentation. When this bit
	 * is 1, the hdr_size and mss fields must be valid. The driver
	 * doesn't need to set t_ip_chksum, ip_chksum, and tcp_udp_chksum
	 * flags since the controller will replace the appropriate
	 * checksum fields for segmented packets.
	 *
	 * When this bit is 1, the hdr_size and mss fields must be valid.
	 */
	#define PUSH32_DOORBELL_LFLAGS_LSO		UINT32_C(0x20)
	/*
	 * If set to zero when LSO is '1', then the IPID will be treated
	 * as a 16b number and will be wrapped if it exceeds a value of
	 * 0xffff.
	 *
	 * If set to one when LSO is '1', then the IPID will be treated
	 * as a 15b number and will be wrapped if it exceeds a value of
	 * 0x7fff.
	 */
	#define PUSH32_DOORBELL_LFLAGS_IPID_FMT	UINT32_C(0x40)
	/*
	 * If set to zero when LSO is '1', then the IPID of the tunnel
	 * IP header will not be modified during LSO operations.
	 *
	 * If set to one when LSO is '1', then the IPID of the tunnel
	 * IP header will be incremented for each subsequent segment of an
	 * LSO operation.
	 *
	 * The flag is ignored if the LSO packet is a normal (non-tunneled)
	 * TCP packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_T_IPID		UINT32_C(0x80)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	uint16_t	hdr_size;
	/*
	 * When LSO is '1', this field must contain the offset of the
	 * TCP payload from the beginning of the packet in as
	 * 16b words. In case of encapsulated/tunneling packet, this field
	 * contains the offset of the inner TCP payload from beginning of the
	 * packet as 16-bit words.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_HDR_SIZE_MASK UINT32_C(0x1ff)
	#define PUSH32_DOORBELL_HDR_SIZE_SFT 0
	uint32_t	mss;
	/*
	 * This is the MSS value that will be used to do the LSO processing.
	 * The value is the length in bytes of the TCP payload for each
	 * segment generated by the LSO operation.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_MSS_MASK UINT32_C(0x7fff)
	#define PUSH32_DOORBELL_MSS_SFT 0
	uint16_t	unused_2;
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define PUSH32_DOORBELL_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_DE	UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define PUSH32_DOORBELL_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID88A8  (UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID8100  (UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9100  (UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9200  (UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9300  (UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPIDCFG   (UINT32_C(0x5) << 16)
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_LAST	PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_RESERVED_MASK UINT32_C(0xff80000)
	#define PUSH32_DOORBELL_CFA_META_VLAN_RESERVED_SFT 19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_CFA_META_KEY_MASK	UINT32_C(0xf0000000)
	#define PUSH32_DOORBELL_CFA_META_KEY_SFT	28
	/* No editing */
		#define PUSH32_DOORBELL_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define PUSH32_DOORBELL_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
		#define PUSH32_DOORBELL_CFA_META_KEY_LAST	PUSH32_DOORBELL_CFA_META_KEY_VLAN_TAG
	/*
	 * This is the data for the push packet. If the packet
	 * data does not fit in the first pass, data writing
	 * can continue at offset 4 of the doorbell for up to 4 additional
	 * passes for a total data size of 512B maximum.
	 */
	uint32_t	data[25];
} push32_doorbell_t, *ppush32_doorbell_t;

/*******************
 * hwrm_func_reset *
 *******************/


/* hwrm_func_reset_input (size:192b/24B) */

typedef struct hwrm_func_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id_valid field to be
	 * configured.
	 */
	#define HWRM_FUNC_RESET_INPUT_ENABLES_VF_ID_VALID	UINT32_C(0x1)
	/*
	 * The ID of the VF that this PF is trying to reset.
	 * Only the parent PF shall be allowed to reset a child VF.
	 *
	 * A parent PF driver shall use this field only when a specific child
	 * VF is requested to be reset.
	 */
	uint16_t	vf_id;
	/* This value indicates the level of a function reset. */
	uint8_t	func_reset_level;
	/*
	 * Reset the caller function and its children VFs (if any). If no
	 * children functions exist, then reset the caller function only.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETALL	UINT32_C(0x0)
	/* Reset the caller function only */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETME	UINT32_C(0x1)
	/*
	 * Reset all children VFs of the caller function driver if the
	 * caller is a PF driver.
	 * It is an error to specify this level by a VF driver.
	 * It is an error to specify this level by a PF driver with
	 * no children VFs.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETCHILDREN UINT32_C(0x2)
	/*
	 * Reset a specific VF of the caller function driver if the caller
	 * is the parent PF driver.
	 * It is an error to specify this level by a VF driver.
	 * It is an error to specify this level by a PF driver that is not
	 * the parent of the VF that is being requested to reset.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETVF	UINT32_C(0x3)
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_LAST	HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETVF
	uint8_t	unused_0;
} hwrm_func_reset_input_t, *phwrm_func_reset_input_t;

/* hwrm_func_reset_output (size:128b/16B) */

typedef struct hwrm_func_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_reset_output_t, *phwrm_func_reset_output_t;

/********************
 * hwrm_func_getfid *
 ********************/


/* hwrm_func_getfid_input (size:192b/24B) */

typedef struct hwrm_func_getfid_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pci_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_GETFID_INPUT_ENABLES_PCI_ID	UINT32_C(0x1)
	/*
	 * This value is the PCI ID of the queried function.
	 * If ARI is enabled, then it is
	 * Bus Number (8b):Function Number(8b). Otherwise, it is
	 * Bus Number (8b):Device Number (5b):Function Number(3b).
	 */
	uint16_t	pci_id;
	uint8_t	unused_0[2];
} hwrm_func_getfid_input_t, *phwrm_func_getfid_input_t;

/* hwrm_func_getfid_output (size:128b/16B) */

typedef struct hwrm_func_getfid_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value. This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_getfid_output_t, *phwrm_func_getfid_output_t;

/**********************
 * hwrm_func_vf_alloc *
 **********************/


/* hwrm_func_vf_alloc_input (size:192b/24B) */

typedef struct hwrm_func_vf_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the first_vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_ALLOC_INPUT_ENABLES_FIRST_VF_ID	UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	first_vf_id;
	/* The number of virtual functions requested. */
	uint16_t	num_vfs;
} hwrm_func_vf_alloc_input_t, *phwrm_func_vf_alloc_input_t;

/* hwrm_func_vf_alloc_output (size:128b/16B) */

typedef struct hwrm_func_vf_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The ID of the first VF allocated. */
	uint16_t	first_vf_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_alloc_output_t, *phwrm_func_vf_alloc_output_t;

/*********************
 * hwrm_func_vf_free *
 *********************/


/* hwrm_func_vf_free_input (size:192b/24B) */

typedef struct hwrm_func_vf_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the first_vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_FREE_INPUT_ENABLES_FIRST_VF_ID	UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	first_vf_id;
	/*
	 * The number of virtual functions requested.
	 * 0xFFFF - Cleanup all children of this PF.
	 */
	uint16_t	num_vfs;
} hwrm_func_vf_free_input_t, *phwrm_func_vf_free_input_t;

/* hwrm_func_vf_free_output (size:128b/16B) */

typedef struct hwrm_func_vf_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_free_output_t, *phwrm_func_vf_free_output_t;

/********************
 * hwrm_func_vf_cfg *
 ********************/


/* hwrm_func_vf_cfg_input (size:576b/72B) */

typedef struct hwrm_func_vf_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mtu field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_MTU			UINT32_C(0x1)
	/*
	 * This bit must be '1' for the guest_vlan field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_GUEST_VLAN		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the async_event_cr field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_ASYNC_EVENT_CR	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the dflt_mac_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_DFLT_MAC_ADDR		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the num_rsscos_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_RSSCOS_CTXS	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_cmpl_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_CMPL_RINGS	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the num_tx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_TX_RINGS		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the num_rx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_RX_RINGS		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the num_l2_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_L2_CTXS		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the num_vnics field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_VNICS		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the num_stat_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_STAT_CTXS		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the num_hw_ring_grps field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_HW_RING_GRPS	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the num_ktls_tx_key_ctxs field to
	 * be configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_KTLS_TX_KEY_CTXS	UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the num_ktls_rx_key_ctxs field to
	 * be configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_KTLS_RX_KEY_CTXS	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the num_quic_tx_key_ctxs field to
	 * be configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_QUIC_TX_KEY_CTXS	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the num_quic_rx_key_ctxs field to
	 * be configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_QUIC_RX_KEY_CTXS	UINT32_C(0x8000)
	/*
	 * The maximum transmission unit requested on the function.
	 * The HWRM should make sure that the mtu of
	 * the function does not exceed the mtu of the physical
	 * port that this function is associated with.
	 *
	 * In addition to requesting mtu per function, it is
	 * possible to configure mtu per transmit ring.
	 * By default, the mtu of each transmit ring associated
	 * with a function is equal to the mtu of the function.
	 * The HWRM should make sure that the mtu of each transmit
	 * ring that is assigned to a function has a valid mtu.
	 */
	uint16_t	mtu;
	/*
	 * The guest VLAN for the function being configured.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	guest_vlan;
	/*
	 * ID of the target completion ring for receiving asynchronous
	 * event completions. If this field is not valid, then the
	 * HWRM shall use the default completion ring of the function
	 * that is being configured as the target completion ring for
	 * providing any asynchronous event completions for that
	 * function.
	 * If this field is valid, then the HWRM shall use the
	 * completion ring identified by this ID as the target
	 * completion ring for providing any asynchronous event
	 * completions for the function that is being configured.
	 */
	uint16_t	async_event_cr;
	/*
	 * This value is the current MAC address requested by the VF
	 * driver to be configured on this VF. A value of
	 * 00-00-00-00-00-00 indicates no MAC address configuration
	 * is requested by the VF driver.
	 * The parent PF driver may reject or overwrite this
	 * MAC address.
	 */
	uint8_t	dflt_mac_addr[6];
	uint32_t	flags;
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of TX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_TX_ASSETS_TEST		UINT32_C(0x1)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RX_ASSETS_TEST		UINT32_C(0x2)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of CMPL rings) are
	 * available. The firmware will return an error if the requested
	 * assets are not available. The firmware will NOT reserve the assets
	 * if they are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_CMPL_ASSETS_TEST	UINT32_C(0x4)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RSS ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RSSCOS_CTX_ASSETS_TEST	UINT32_C(0x8)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of ring groups) are
	 * available. The firmware will return an error if the requested
	 * assets are not available. The firmware will NOT reserve the assets
	 * if they are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RING_GRP_ASSETS_TEST	UINT32_C(0x10)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of stat ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_STAT_CTX_ASSETS_TEST	UINT32_C(0x20)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of VNICs) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_VNIC_ASSETS_TEST	UINT32_C(0x40)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of L2 ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_L2_CTX_ASSETS_TEST	UINT32_C(0x80)
	/*
	 * If this bit is set to 1, the VF driver is requesting FW to enable
	 * PPP TX PUSH feature on all the TX rings specified in the
	 * num_tx_rings field. By default, the PPP TX push feature is
	 * disabled for all the TX rings of the VF. This flag is ignored if
	 * the num_tx_rings field is not specified or the VF doesn't support
	 * PPP tx push feature.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_PPP_PUSH_MODE_ENABLE	UINT32_C(0x100)
	/*
	 * If this bit is set to 1, the VF driver is requesting FW to disable
	 * PPP TX PUSH feature on all the TX rings of the VF. This flag is
	 * ignored if the VF doesn't support PPP tx push feature.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_PPP_PUSH_MODE_DISABLE	UINT32_C(0x200)
	/* The number of RSS/COS contexts requested for the VF. */
	uint16_t	num_rsscos_ctxs;
	/* The number of completion rings requested for the VF. */
	uint16_t	num_cmpl_rings;
	/* The number of transmit rings requested for the VF. */
	uint16_t	num_tx_rings;
	/* The number of receive rings requested for the VF. */
	uint16_t	num_rx_rings;
	/* The number of L2 contexts requested for the VF. */
	uint16_t	num_l2_ctxs;
	/* The number of vnics requested for the VF. */
	uint16_t	num_vnics;
	/* The number of statistic contexts requested for the VF. */
	uint16_t	num_stat_ctxs;
	/* The number of HW ring groups requested for the VF. */
	uint16_t	num_hw_ring_grps;
	/* Number of KTLS Tx Key Contexts requested. */
	uint32_t	num_ktls_tx_key_ctxs;
	/* Number of KTLS Rx Key Contexts requested. */
	uint32_t	num_ktls_rx_key_ctxs;
	/* The number of MSI-X vectors requested for the VF. */
	uint16_t	num_msix;
	uint8_t	unused[2];
	/* Number of QUIC Tx Key Contexts requested. */
	uint32_t	num_quic_tx_key_ctxs;
	/* Number of QUIC Rx Key Contexts requested. */
	uint32_t	num_quic_rx_key_ctxs;
} hwrm_func_vf_cfg_input_t, *phwrm_func_vf_cfg_input_t;

/* hwrm_func_vf_cfg_output (size:128b/16B) */

typedef struct hwrm_func_vf_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_cfg_output_t, *phwrm_func_vf_cfg_output_t;

/*******************
 * hwrm_func_qcaps *
 *******************/


/* hwrm_func_qcaps_input (size:192b/24B) */

typedef struct hwrm_func_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * 0xFFFE (REQUESTING_PARENT_FID) This is a special FID
	 * to be used by a trusted VF to query its parent PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_qcaps_input_t, *phwrm_func_qcaps_input_t;

/* hwrm_func_qcaps_output (size:1152b/144B) */

typedef struct hwrm_func_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value. This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	/*
	 * Port ID of port that this function is associated with.
	 * Valid only for the PF.
	 * 0xFF... (All Fs) if this function is not associated with
	 * any port.
	 * 0xFF... (All Fs) if this function is called from a VF.
	 */
	uint16_t	port_id;
	uint32_t	flags;
	/* If 1, then Push mode is supported on this function. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PUSH_MODE_SUPPORTED		UINT32_C(0x1)
	/*
	 * If 1, then the global MSI-X auto-masking is enabled for the
	 * device.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GLOBAL_MSIX_AUTOMASKING		UINT32_C(0x2)
	/*
	 * If 1, then the Precision Time Protocol (PTP) processing
	 * is supported on this function.
	 * The HWRM should enable PTP on only a single Physical
	 * Function (PF) per port.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PTP_SUPPORTED			UINT32_C(0x4)
	/*
	 * If 1, then RDMA over Converged Ethernet (RoCE) v1
	 * is supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ROCE_V1_SUPPORTED			UINT32_C(0x8)
	/*
	 * If 1, then RDMA over Converged Ethernet (RoCE) v2
	 * is supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ROCE_V2_SUPPORTED			UINT32_C(0x10)
	/*
	 * If 1, then control and configuration of WoL magic packet
	 * are supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WOL_MAGICPKT_SUPPORTED		UINT32_C(0x20)
	/*
	 * If 1, then control and configuration of bitmap pattern
	 * packet are supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WOL_BMP_SUPPORTED			UINT32_C(0x40)
	/*
	 * If set to 1, then the control and configuration of rate limit
	 * of an allocated TX ring on the queried function is supported.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_TX_RING_RL_SUPPORTED		UINT32_C(0x80)
	/*
	 * If 1, then control and configuration of minimum and
	 * maximum bandwidths are supported on the queried function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_TX_BW_CFG_SUPPORTED		UINT32_C(0x100)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to set the rate limits
	 * on the TX rings of its children VFs.
	 * If this query is for a PF and this flag is set to 0, then
	 * the PF does not have the capability to set the rate limits
	 * on the TX rings of its children VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VF_TX_RING_RL_SUPPORTED		UINT32_C(0x200)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to set the minimum and/or
	 * maximum bandwidths for its children VFs.
	 * If this query is for a PF and this flag is set to 0, then
	 * the PF does not have the capability to set the minimum or
	 * maximum bandwidths for its children VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VF_BW_CFG_SUPPORTED		UINT32_C(0x400)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is supported
	 * on the queried function.
	 * If set to 0, then standard TX ring mode is not available
	 * on the queried function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_STD_TX_RING_MODE_SUPPORTED		UINT32_C(0x800)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect GENEVE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GENEVE_TUN_FLAGS_SUPPORTED		UINT32_C(0x1000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect NVGRE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_NVGRE_TUN_FLAGS_SUPPORTED		UINT32_C(0x2000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect GRE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GRE_TUN_FLAGS_SUPPORTED		UINT32_C(0x4000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect MPLS tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_MPLS_TUN_FLAGS_SUPPORTED		UINT32_C(0x8000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to support pcie stats.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PCIE_STATS_SUPPORTED		UINT32_C(0x10000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to adopt the VF's belonging
	 * to another PF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ADOPTED_PF_SUPPORTED		UINT32_C(0x20000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the administrative privilege to configure another
	 * PF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ADMIN_PF_SUPPORTED			UINT32_C(0x40000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then
	 * the PF will know that the firmware has the capability to track
	 * the virtual link status.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_LINK_ADMIN_STATUS_SUPPORTED	UINT32_C(0x80000)
	/*
	 * If 1, then this function supports the push mode that uses
	 * write combine buffers and the long inline tx buffer descriptor.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WCB_PUSH_MODE			UINT32_C(0x100000)
	/*
	 * If 1, then FW has capability to allocate TX rings dynamically
	 * in ring alloc even if PF reserved pool is zero.
	 * This bit will be used only for PFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_DYNAMIC_TX_RING_ALLOC		UINT32_C(0x200000)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of Hot Reset.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_HOT_RESET_CAPABLE			UINT32_C(0x400000)
	/*
	 * This flag will be set to 1 by the FW if FW supports adapter error
	 * recovery.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ERROR_RECOVERY_CAPABLE		UINT32_C(0x800000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then
	 * the PF has the capability to support extended stats.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_STATS_SUPPORTED		UINT32_C(0x1000000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then host
	 * must initiate reset or reload (or fastboot) the firmware image
	 * upon detection of device shutdown state.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ERR_RECOVER_RELOAD			UINT32_C(0x2000000)
	/*
	 * If the query is for a VF, then this flag (always set to 0) shall
	 * be ignored. If this query is for a PF and this flag is set to 1,
	 * host, when registered for the default vnic change async event,
	 * receives async notification whenever a default vnic state is
	 * changed for any of child or adopted VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_NOTIFY_VF_DEF_VNIC_CHNG_SUPPORTED	UINT32_C(0x4000000)
	/* If set to 1, then the vlan acceleration for TX is disabled. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VLAN_ACCELERATION_TX_DISABLED	UINT32_C(0x8000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_COREDUMP_XXX commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_COREDUMP_CMD_SUPPORTED		UINT32_C(0x10000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_CRASHDUMP_XXX commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_CRASHDUMP_CMD_SUPPORTED		UINT32_C(0x20000000)
	/*
	 * If the query is for a VF, then this flag should be ignored.
	 * If the query is for a PF and this flag is set to 1, then
	 * the PF has the capability to support retrieval of
	 * rx_port_stats_ext_pfc_wd statistics (supported by the PFC
	 * WatchDog feature) via the hwrm_port_qstats_ext_pfc_wd command.
	 * If this flag is set to 1, only that (supported) command should
	 * be used for retrieval of PFC related statistics (rather than
	 * hwrm_port_qstats_ext command, which could previously be used).
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PFC_WD_STATS_SUPPORTED		UINT32_C(0x40000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_QCAPS command
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_DBG_QCAPS_CMD_SUPPORTED		UINT32_C(0x80000000)
	/*
	 * This value is current MAC address configured for this
	 * function. A value of 00-00-00-00-00-00 indicates no
	 * MAC address is currently configured.
	 */
	uint8_t	mac_address[6];
	/*
	 * The maximum number of RSS/COS contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_rsscos_ctx;
	/*
	 * The maximum number of completion rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_cmpl_rings;
	/*
	 * The maximum number of transmit rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_tx_rings;
	/*
	 * The maximum number of receive rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_rx_rings;
	/*
	 * The maximum number of L2 contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_l2_ctxs;
	/*
	 * The maximum number of VNICs that can be
	 * allocated to the function.
	 */
	uint16_t	max_vnics;
	/*
	 * The identifier for the first VF enabled on a PF. This
	 * is valid only on the PF with SR-IOV enabled.
	 * 0xFF... (All Fs) if this command is called on a PF with
	 * SR-IOV disabled or on a VF.
	 */
	uint16_t	first_vf_id;
	/*
	 * The maximum number of VFs that can be
	 * allocated to the function. This is valid only on the
	 * PF with SR-IOV enabled. 0xFF... (All Fs) if this
	 * command is called on a PF with SR-IOV disabled or
	 * on a VF.
	 */
	uint16_t	max_vfs;
	/*
	 * The maximum number of statistic contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_stat_ctx;
	/*
	 * The maximum number of Encapsulation records that can be
	 * offloaded by this function.
	 */
	uint32_t	max_encap_records;
	/*
	 * The maximum number of decapsulation records that can
	 * be offloaded by this function.
	 */
	uint32_t	max_decap_records;
	/*
	 * The maximum number of Exact Match (EM) flows that can be
	 * offloaded by this function on the TX side.
	 */
	uint32_t	max_tx_em_flows;
	/*
	 * The maximum number of Wildcard Match (WM) flows that can
	 * be offloaded by this function on the TX side.
	 */
	uint32_t	max_tx_wm_flows;
	/*
	 * The maximum number of Exact Match (EM) flows that can be
	 * offloaded by this function on the RX side.
	 */
	uint32_t	max_rx_em_flows;
	/*
	 * The maximum number of Wildcard Match (WM) flows that can
	 * be offloaded by this function on the RX side.
	 */
	uint32_t	max_rx_wm_flows;
	/*
	 * The maximum number of multicast filters that can
	 * be supported by this function on the RX side.
	 */
	uint32_t	max_mcast_filters;
	/*
	 * The maximum value of flow_id that can be supported
	 * in completion records.
	 */
	uint32_t	max_flow_id;
	/*
	 * The maximum number of HW ring groups that can be
	 * supported on this function.
	 */
	uint32_t	max_hw_ring_grps;
	/*
	 * The maximum number of strict priority transmit rings
	 * that can be allocated to the function.
	 * This number indicates the maximum number of TX rings
	 * that can be assigned strict priorities out of the
	 * maximum number of TX rings that can be allocated
	 * (max_tx_rings) to the function.
	 */
	uint16_t	max_sp_tx_rings;
	/*
	 * The maximum number of MSI-X vectors that may be allocated across
	 * all VFs for the function. This is valid only on the PF with SR-IOV
	 * enabled. Returns zero if this command is called on a PF with
	 * SR-IOV disabled or on a VF.
	 */
	uint16_t	max_msix_vfs;
	uint32_t	flags_ext;
	/*
	 * If 1, the device can be configured to set the ECN bits in the
	 * IP header of received packets if the receive queue length
	 * exceeds a given threshold.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECN_MARK_SUPPORTED			UINT32_C(0x1)
	/*
	 * If 1, the device can report the number of received packets
	 * that it marked as having experienced congestion.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECN_STATS_SUPPORTED			UINT32_C(0x2)
	/*
	 * If 1, the device can report extended hw statistics (including
	 * additional tpa statistics).
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_EXT_HW_STATS_SUPPORTED			UINT32_C(0x4)
	/*
	 * If set to 1, then the core firmware has support to enable/
	 * disable hot reset support for interface dynamically through
	 * HWRM_FUNC_CFG.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_HOT_RESET_IF_SUPPORT			UINT32_C(0x8)
	/* If 1, the proxy mode is supported on this function */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PROXY_MODE_SUPPORT			UINT32_C(0x10)
	/*
	 * If 1, the tx rings source interface override feature is supported
	 * on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_TX_PROXY_SRC_INTF_OVERRIDE_SUPPORT	UINT32_C(0x20)
	/*
	 * If 1, the device supports scheduler queues. SCHQs can be managed
	 * using RING_SCHQ_ALLOC/CFG/FREE commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_SCHQ_SUPPORTED				UINT32_C(0x40)
	/*
	 * If set to 1, then this function supports the TX push mode that
	 * uses ping-pong buffers from the push pages.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PPP_PUSH_MODE_SUPPORTED			UINT32_C(0x80)
	/*
	 * If set to 1, then this function doesn't have the privilege to
	 * configure the EVB mode of the port it uses.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_EVB_MODE_CFG_NOT_SUPPORTED		UINT32_C(0x100)
	/*
	 * If set to 1, then the HW and FW support the SoC packet DMA
	 * datapath between SoC and NIC. This function can act as the
	 * HWRM communication transport agent on behalf of the SoC SPD
	 * software module. This capability is only advertised to the
	 * SoC PFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_SOC_SPD_SUPPORTED			UINT32_C(0x200)
	/*
	 * If set to 1, then this function supports FW_LIVEPATCH for
	 * firmware livepatch commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_FW_LIVEPATCH_SUPPORTED			UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of fast Reset.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_FAST_RESET_CAPABLE			UINT32_C(0x800)
	/*
	 * When this bit is '1', it indicates that firmware and hardware
	 * are capable of updating tx_metadata via hwrm_ring_cfg command.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_TX_METADATA_CFG_CAPABLE			UINT32_C(0x1000)
	/*
	 * If set to 1, then the device can report the action
	 * needed to activate set nvm options.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_NVM_OPTION_ACTION_SUPPORTED		UINT32_C(0x2000)
	/*
	 * When this bit is '1', it indicates that the BD metadata feature
	 * is supported for this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_BD_METADATA_SUPPORTED			UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates that the echo request feature
	 * is supported for this function. If the driver registers for the
	 * echo request asynchronous event, then the firmware can send an
	 * unsolicited echo request to the driver and expect an echo
	 * response.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECHO_REQUEST_SUPPORTED			UINT32_C(0x8000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * NPAR 1.2 on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_NPAR_1_2_SUPPORTED			UINT32_C(0x10000)
	/* When this bit is '1', it indicates that PTM feature is supported. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PTP_PTM_SUPPORTED			UINT32_C(0x20000)
	/* When this bit is '1', it indicates that PPS feature is supported. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PTP_PPS_SUPPORTED			UINT32_C(0x40000)
	/*
	 * When this bit is '1', it indicates that VF config. change
	 * async event is supported on the parent PF if the async.
	 * event is registered by the PF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_VF_CFG_ASYNC_FOR_PF_SUPPORTED		UINT32_C(0x80000)
	/*
	 * When this bit is '1', the NIC supports configuration of
	 * partition_min_bw and partition_max_bw. Configuration of a
	 * minimum guaranteed bandwidth is only supported if the
	 * min_bw_supported flag is also set.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PARTITION_BW_SUPPORTED			UINT32_C(0x100000)
	/*
	 * When this bit is '1', the FW supports configuration of
	 * PCP and TPID values of the default VLAN.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_DFLT_VLAN_TPID_PCP_SUPPORTED		UINT32_C(0x200000)
	/* When this bit is '1', it indicates that HW and FW support KTLS. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_KTLS_SUPPORTED				UINT32_C(0x400000)
	/*
	 * When this bit is '1', the firmware supports HWRM_PORT_EP_TX_CFG
	 * and HWRM_PORT_EP_TX_QCFG for endpoint rate control, and additions
	 * to HWRM_QUEUE_GLOBAL_CFG and HWRM_QUEUE_GLOBAL_QCFG for receive
	 * rate control. Configuration of a minimum guaranteed bandwidth
	 * is only supported if the min_bw_supported flag is also set.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_EP_RATE_CONTROL				UINT32_C(0x800000)
	/*
	 * When this bit is '1', the firmware supports enforcement of
	 * minimum guaranteed bandwidth. A minimum guaranteed bandwidth
	 * could be configured for a partition or for an endpoint. Firmware
	 * only sets this flag if one or both of the ep_rate_control and
	 * partition_bw_supported flags are set.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_MIN_BW_SUPPORTED				UINT32_C(0x1000000)
	/*
	 * When this bit is '1', HW supports TX coalesced completion
	 * records.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_TX_COAL_CMPL_CAP				UINT32_C(0x2000000)
	/*
	 * When this bit is '1', it indicates the FW has full support
	 * for all backing store types with the BACKING_STORE_CFG/QCFG
	 * V2 APIs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_BS_V2_SUPPORTED				UINT32_C(0x4000000)
	/*
	 * When this bit is '1', it indicates the FW forces to use the
	 * BACKING_STORE_CFG/QCFG V2 APIs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_BS_V2_REQUIRED				UINT32_C(0x8000000)
	/*
	 * When this bit is '1', it indicates that FW will support a single
	 * 64bit real time clock for PTP.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PTP_64BIT_RTC_SUPPORTED			UINT32_C(0x10000000)
	/*
	 * When this bit is '1', it indicates the FW is capable of
	 * supporting Doorbell Pacing.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_DBR_PACING_SUPPORTED			UINT32_C(0x20000000)
	/*
	 * When this bit is '1', it indicates the FW is capable of
	 * supporting HW based doorbell drop recovery.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_HW_DBR_DROP_RECOV_SUPPORTED		UINT32_C(0x40000000)
	/*
	 * When this bit is '1', it indicates the driver can disable the CQ
	 * overflow detection and can also skip the index updates for CQ.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_DISABLE_CQ_OVERFLOW_DETECTION_SUPPORTED	UINT32_C(0x80000000)
	/* The maximum number of SCHQs supported by this device. */
	uint8_t	max_schqs;
	uint8_t	mpc_chnls_cap;
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the TX crypto engine block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_TCE	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the RX crypto engine block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_RCE	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the TX configurable flow processing block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_TE_CFA	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the RX configurable flow processing block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_RE_CFA	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the primate processor block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_PRIMATE	UINT32_C(0x10)
	/*
	 * Maximum number of Key Contexts supported per HWRM
	 * function call for allocating Key Contexts.
	 */
	uint16_t	max_key_ctxs_alloc;
	uint32_t	flags_ext2;
	/*
	 * When this bit is '1', it indicates that FW will support
	 * timestamping on all RX packets, not just PTP type packets.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_RX_ALL_PKTS_TIMESTAMPS_SUPPORTED	UINT32_C(0x1)
	/* When this bit is '1', it indicates that HW and FW support QUIC. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_QUIC_SUPPORTED			UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that KDNet mode is
	 * supported on the port for this function. This bit is
	 * never set for a VF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_KDNET_SUPPORTED			UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates the FW is capable of
	 * supporting Enhanced Doorbell Pacing.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_DBR_PACING_EXT_SUPPORTED		UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that FW is capable of
	 * supporting software based doorbell drop recovery.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_SW_DBR_DROP_RECOVERY_SUPPORTED	UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates the FW supports collection
	 * and query of the generic statistics.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_GENERIC_STATS_SUPPORTED		UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that the HW is capable of
	 * supporting UDP GSO on the function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_UDP_GSO_SUPPORTED			UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that SyncE feature is
	 * supported.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_SYNCE_SUPPORTED			UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates the FW is capable of
	 * supporting doorbell pacing version 0. As doorbell pacing
	 * notification from hardware for Thor2 is completely different
	 * from Thor1, this flag is used to differentiate the doorbell
	 * pacing notification between Thor1 and Thor2. Thor1 uses
	 * dbr_pacing_supported and dbr_pacing_ext_supported flags for
	 * doorbell pacing whereas Thor2 uses dbr_pacing_v0_supported flag.
	 * These flags will never be set at the same time for Thor2.
	 * Based on this flag, host drivers assume doorbell pacing is needed
	 * for Thor2.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_DBR_PACING_V0_SUPPORTED		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the HW supports
	 * two-completion TX packet timestamp feature, a second completion
	 * carrying packet TX timestamp in addition to the standard
	 * completion returned for packets. Host driver should not use
	 * HWRM port timestamp query (HWRM_PORT_TS_QUERY) command for
	 * TX timestamp read when two-completion timestamp feature is
	 * supported.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_TX_PKT_TS_CMPL_SUPPORTED		UINT32_C(0x200)
	/*
	 * When this bit is '1', it indicates that the hardware based
	 * link aggregation group (L2 and RoCE) feature is supported.
	 * This LAG feature is only supported on the THOR2 or newer NIC
	 * with multiple ports.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_HW_LAG_SUPPORTED			UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates all contexts can be stored
	 * on chip instead of using host based backing store memory.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_ON_CHIP_CTX_SUPPORTED		UINT32_C(0x800)
	/*
	 * When this bit is '1', it indicates that the HW supports
	 * using a steering tag in the memory transactions targeting
	 * L2 or RoCE ring resources.
	 * Steering Tags are system-specific values that must follow the
	 * encoding requirements of the hardware platform. On devices that
	 * support steering to multiple address domains, a value of 0 in
	 * bit 0 of the steering tag specifies the address is associated
	 * with the SOC address space, and a value of 1 indicates the
	 * address is associated with the host address space.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_STEERING_TAG_SUPPORTED		UINT32_C(0x1000)
	/*
	 * When this bit is '1', it indicates that driver can enable
	 * support for an enhanced VF scale.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_ENHANCED_VF_SCALE_SUPPORTED	UINT32_C(0x2000)
	/*
	 * When this bit is '1', it indicates that FW is capable of
	 * supporting partition based XID management for KTLS/QUIC
	 * Tx/Rx Key Context types.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_KEY_XID_PARTITION_SUPPORTED	UINT32_C(0x4000)
	/*
	 * This bit is only valid on the condition that both
	 * 'ktls_supported' and 'quic_supported' flags are set. When this
	 * bit is valid, it conveys information below:
	 * 1. If it is set to '1', it indicates that the firmware allows the
	 *	driver to run KTLS and QUIC concurrently;
	 * 2. If it is cleared to '0', it indicates that the driver has to
	 *	make sure all crypto connections on all functions are of the
	 *	same type, i.e., either KTLS or QUIC.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_CONCURRENT_KTLS_QUIC_SUPPORTED	UINT32_C(0x8000)
	/*
	 * When this bit is '1', it indicates that the device supports
	 * setting a cross TC cap on a scheduler queue.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_SCHQ_CROSS_TC_CAP_SUPPORTED	UINT32_C(0x10000)
	/*
	 * When this bit is '1', it indicates that the device supports
	 * setting a per TC cap on a scheduler queue.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_SCHQ_PER_TC_CAP_SUPPORTED		UINT32_C(0x20000)
	/*
	 * When this bit is '1', it indicates that the device supports
	 * setting a per TC reservation on a scheduler queues.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_SCHQ_PER_TC_RESERVATION_SUPPORTED	UINT32_C(0x40000)
	/*
	 * When this bit is '1', it indicates that firmware supports query
	 * for statistics related to invalid doorbell errors and drops.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_DB_ERROR_STATS_SUPPORTED		UINT32_C(0x80000)
	/*
	 * When this bit is '1', it indicates that the device supports
	 * VF RoCE resource management.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_ROCE_VF_RESOURCE_MGMT_SUPPORTED	UINT32_C(0x100000)
	/*
	 * When this bit is '1', it indicates that the device supports
	 * UDCC management.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_UDCC_SUPPORTED			UINT32_C(0x200000)
	/*
	 * When this bit is '1', it indicates that the device supports Timed
	 * Transmit TxTime scheduling; this is applicable to L2 flows only.
	 * It is expected that host software assigns each packet a transmit
	 * time and posts packets for transmit in time order. NIC hardware
	 * transmits the packet at time assigned by software.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_TIMED_TX_SO_TXTIME_SUPPORTED	UINT32_C(0x400000)
	/*
	 * This bit indicates the method used for the advertisement of the
	 * max resource limit for the PF and its VFs.
	 * When this bit is '1', it indicates that the maximum resource
	 * limits for both RoCE and L2 are software defined. These limits
	 * are queried using the HWRM backing store qcaps v1
	 * and v2(max_num_entries). For RoCE, the resource limits are
	 * derived from nvm options. For L2, the resources will continue
	 * to use FW enforced SW limits based on chip config and per PF
	 * function NVM resource parameters.
	 * If this bit is '0', the FW will use to legacy behavior.
	 * For RoCE, the maximum resource values supported by the chip will
	 * be returned. For L2, the maximum resource values returned will
	 * be the FW enforced SW limits based on chip config and per PF
	 * function NVM resource parameters.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_SW_MAX_RESOURCE_LIMITS_SUPPORTED	UINT32_C(0x800000)
	/*
	 * When this bit is '1', it indicates that the device supports
	 * migrating ingress NIC flows to Truflow.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_TF_INGRESS_NIC_FLOW_SUPPORTED	UINT32_C(0x1000000)
	/*
	 * When this bit is '1', it indicates that the Firmware supports
	 * query and clear of the port loopback statistics.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_LPBK_STATS_SUPPORTED		UINT32_C(0x2000000)
	/*
	 * When this bit is '1', it indicates that the device supports
	 * migrating egress NIC flows to Truflow.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_TF_EGRESS_NIC_FLOW_SUPPORTED	UINT32_C(0x4000000)
	/*
	 * When this bit is '1', it indicates that the device supports
	 * multiple lossless CoS queues.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_MULTI_LOSSLESS_QUEUES_SUPPORTED	UINT32_C(0x8000000)
	/*
	 * When this bit is '1', it indicates that the firmware supports
	 * peer memory map storing feature.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_PEER_MMAP_SUPPORTED		UINT32_C(0x10000000)
	/*
	 * When this bit is '1', it indicates that the device supports Timed
	 * Transmit packet pacing; this is applicable to L2 flows only.
	 * Host software passes the transmit rate of an L2 flow to the
	 * hardware and hardware uses this rate to derive the transmit time
	 * for scheduling packet transmission of the flow.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_TIMED_TX_PACING_SUPPORTED		UINT32_C(0x20000000)
	/*
	 * When this bit is '1', it indicates that the device supports VF
	 * statistics ejection. Firmware is capable of copying VF statistics
	 * to two host buffers - one buffer allocated by VF driver and
	 * another buffer allocated by the parent PF driver. This bit is
	 * only set on a PF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_VF_STAT_EJECTION_SUPPORTED		UINT32_C(0x40000000)
	/*
	 * When this bit is '1', it indicates that the parent PF allocated
	 * the Host DMA buffer to capture the coredump. So that any VF
	 * driver instance can issue HWRM_DBG_COREDUMP_CAPTURE command
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT2_HOST_COREDUMP_SUPPORTED		UINT32_C(0x80000000)
	uint16_t	tunnel_disable_flag;
	/*
	 * When this bit is '1', it indicates that the VXLAN parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_VXLAN	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that the NGE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_NGE	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that the NVGRE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_NVGRE	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates that the L2GRE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_L2GRE	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that the GRE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_GRE	UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the IPINIP parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_IPINIP	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that the MPLS parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_MPLS	UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the PPPOE parsing
	 * is disabled in hardware
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_TUNNEL_DISABLE_FLAG_DISABLE_PPPOE	UINT32_C(0x80)
	uint16_t	xid_partition_cap;
	/*
	 * When this bit is '1', it indicates that FW is capable of
	 * supporting partition based XID management for Tx crypto
	 * key contexts.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_XID_PARTITION_CAP_TX_CK	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that FW is capable of
	 * supporting partition based XID management for Rx crypto
	 * key contexts.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_XID_PARTITION_CAP_RX_CK	UINT32_C(0x2)
	/*
	 * This value uniquely identifies the hardware NIC used by the
	 * function. The value returned will be the same for all functions.
	 * A value of 00-00-00-00-00-00-00-00 indicates no device serial number
	 * is currently configured. This is the same value that is returned by
	 * PCIe Capability Device Serial Number.
	 */
	uint8_t	device_serial_number[8];
	/*
	 * This field is only valid in the XID partition mode. It indicates
	 * the number contexts per partition.
	 */
	uint16_t	ctxs_per_partition;
	/*
	 * The maximum number of tso segments that NIC can handle during the
	 * large segmentation offload.
	 * If this field is zero, that means there is no limit on the TSO
	 * segment limit.
	 * Note that this field will be zero for older firmware that
	 * doesn't report the max TSO segment limit.
	 */
	uint16_t	max_tso_segs;
	/*
	 * The maximum number of address vectors that may be allocated across
	 * all VFs for the function. This is valid only on the PF with VF RoCE
	 * (SR-IOV) enabled. Returns zero if this command is called on a PF
	 * with VF RoCE (SR-IOV) disabled or on a VF.
	 */
	uint32_t	roce_vf_max_av;
	/*
	 * The maximum number of completion queues that may be allocated across
	 * all VFs for the function. This is valid only on the PF with VF RoCE
	 * (SR-IOV) enabled. Returns zero if this command is called on a PF
	 * with VF RoCE (SR-IOV) disabled or on a VF.
	 */
	uint32_t	roce_vf_max_cq;
	/*
	 * The maximum number of memory regions plus memory windows that may be
	 * allocated across all VFs for the function. This is valid only on the
	 * PF with VF RoCE (SR-IOV) enabled. Returns zero if this command is
	 * called on a PF with VF RoCE (SR-IOV) disabled or on a VF.
	 */
	uint32_t	roce_vf_max_mrw;
	/*
	 * The maximum number of queue pairs that may be allocated across
	 * all VFs for the function. This is valid only on the PF with VF RoCE
	 * (SR-IOV) enabled. Returns zero if this command is called on a PF
	 * with VF RoCE (SR-IOV) disabled or on a VF.
	 */
	uint32_t	roce_vf_max_qp;
	/*
	 * The maximum number of shared receive queues that may be allocated
	 * across all VFs for the function. This is valid only on the PF with
	 * VF RoCE (SR-IOV) enabled. Returns zero if this command is called on
	 * a PF with VF RoCE (SR-IOV) disabled or on a VF.
	 */
	uint32_t	roce_vf_max_srq;
	/*
	 * The maximum number of GIDs that may be allocated across all VFs for
	 * the function. This is valid only on the PF with VF RoCE (SR-IOV)
	 * enabled. Returns zero if this command is called on a PF with VF RoCE
	 * (SR-IOV) disabled or on a VF.
	 */
	uint32_t	roce_vf_max_gid;
	uint32_t	flags_ext3;
	/*
	 * When this bit is '1', firmware supports the driver using
	 * FUNC_CFG (or FUNC_VF_CFG) to decrease resource reservations
	 * while some resources are still allocated. An error is returned
	 * if the driver tries to set the reservation to be less than the
	 * number of allocated resources.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT3_RM_RSV_WHILE_ALLOC_CAP	UINT32_C(0x1)
	uint8_t	unused_3[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_func_qcaps_output_t, *phwrm_func_qcaps_output_t;

/******************
 * hwrm_func_qcfg *
 ******************/


/* hwrm_func_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * 0xFFFE (REQUESTING_PARENT_FID) This is a special FID
	 * to be used by a trusted VF to query its parent PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_qcfg_input_t, *phwrm_func_qcfg_input_t;

/* hwrm_func_qcfg_output (size:1280b/160B) */

typedef struct hwrm_func_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value. This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	/*
	 * Port ID of port that this function is associated with.
	 * 0xFF... (All Fs) if this function is not associated with
	 * any port.
	 */
	uint16_t	port_id;
	/*
	 * This value is the current VLAN setting for this
	 * function. The value of 0 for this field indicates
	 * no priority tagging or VLAN is used.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	vlan;
	uint16_t	flags;
	/*
	 * If 1, then magic packet based Out-Of-Box WoL is enabled on
	 * the port associated with this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_OOB_WOL_MAGICPKT_ENABLED	UINT32_C(0x1)
	/*
	 * If 1, then bitmap pattern based Out-Of-Box WoL packet is enabled
	 * on the port associated with this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_OOB_WOL_BMP_ENABLED	UINT32_C(0x2)
	/*
	 * If set to 1, then FW based DCBX agent is enabled and running on
	 * the port associated with this function.
	 * If set to 0, then DCBX agent is not running in the firmware.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FW_DCBX_AGENT_ENABLED	UINT32_C(0x4)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is enabled
	 * on the queried function.
	 * If set to 0, then the standard TX ring mode is disabled
	 * on the queried function. In this extended TX ring resource
	 * mode, the minimum and maximum bandwidth settings are not
	 * supported to allow the allocation of TX rings to span multiple
	 * scheduler nodes.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_STD_TX_RING_MODE_ENABLED	UINT32_C(0x8)
	/*
	 * If set to 1 then FW based LLDP agent is enabled and running on
	 * the port associated with this function.
	 * If set to 0 then the LLDP agent is not running in the firmware.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FW_LLDP_AGENT_ENABLED	UINT32_C(0x10)
	/*
	 * If set to 1, then multi-host mode is active for this function.
	 * The NIC is attached to two or more independent host systems
	 * through two or more PCIe endpoints.
	 * If set to 0, then multi-host mode is inactive for this function
	 * or not applicable for this device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_MULTI_HOST		UINT32_C(0x20)
	/*
	 * If the function that is being queried is a PF, then the HWRM shall
	 * set this field to 0 and the HWRM client shall ignore this field.
	 * If the function that is being queried is a VF, then the HWRM shall
	 * set this field to 1 if the queried VF is trusted, otherwise the
	 * HWRM shall set this field to 0.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_TRUSTED_VF		UINT32_C(0x40)
	/*
	 * If set to 1, then secure mode is enabled for this function or
	 * device. If set to 0, then secure mode is disabled (or normal mode)
	 * for this function or device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_SECURE_MODE_ENABLED	UINT32_C(0x80)
	/*
	 * If set to 1, then this PF is enabled with a preboot driver that
	 * requires access to the legacy L2 ring model and legacy 32b
	 * doorbells. If set to 0, then this PF is not allowed to use
	 * the legacy L2 rings. This feature is not allowed on VFs and
	 * is only relevant for devices that require a context backing
	 * store.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_PREBOOT_LEGACY_L2_RINGS	UINT32_C(0x100)
	/*
	 * If set to 1, then the firmware and all currently registered driver
	 * instances support hot reset. The hot reset support will be updated
	 * dynamically based on the driver interface advertisement.
	 * If set to 0, then the adapter is not currently able to initiate
	 * hot reset.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_HOT_RESET_ALLOWED		UINT32_C(0x200)
	/*
	 * If set to 1, then the PPP tx push mode is enabled for all the
	 * reserved TX rings of this function. If set to 0, then PPP tx push
	 * mode is disabled for all the reserved TX rings of this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_PPP_PUSH_MODE_ENABLED	UINT32_C(0x400)
	/*
	 * If set to 1, then the firmware will notify driver using async
	 * event when a ring is disabled due to a Hardware error.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_RING_MONITOR_ENABLED	UINT32_C(0x800)
	/*
	 * If set to 1, then the firmware and all currently registered driver
	 * instances support fast reset. The fast reset support will be
	 * updated dynamically based on the driver interface advertisement.
	 * If set to 0, then the adapter is not currently able to initiate
	 * fast reset.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FAST_RESET_ALLOWED	UINT32_C(0x1000)
	/*
	 * If set to 1, then multi-root mode is active for this function.
	 * The NIC is attached to a single host with a single operating
	 * system, but through two or more PCIe endpoints.
	 * If set to 0, then multi-root mode is inactive for this function
	 * or not applicable for this device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_MULTI_ROOT		UINT32_C(0x2000)
	/*
	 * This flag indicates RDMA support for child VFS of
	 * a physical function.
	 * If set to 1, RoCE is supported on all child VFs.
	 * If set to 0, RoCE is disabled on all child VFs.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_ENABLE_RDMA_SRIOV		UINT32_C(0x4000)
	/*
	 * When set to 1, indicates the field roce_vnic_id in the structure
	 * is valid. If this bit is 0, the driver should not use the
	 * 'roce_vnic_id' field.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_ROCE_VNIC_ID_VALID	UINT32_C(0x8000)
	/*
	 * This value is current MAC address configured for this
	 * function. A value of 00-00-00-00-00-00 indicates no
	 * MAC address is currently configured.
	 */
	uint8_t	mac_address[6];
	/*
	 * This value is current PCI ID of this
	 * function. If ARI is enabled, then it is
	 * Bus Number (8b):Function Number(8b). Otherwise, it is
	 * Bus Number (8b):Device Number (4b):Function Number(4b).
	 * If multi-host mode is active, the 4 lsb will indicate
	 * the PF index for this function.
	 */
	uint16_t	pci_id;
	/*
	 * The number of RSS/COS contexts currently
	 * allocated to the function.
	 */
	uint16_t	alloc_rsscos_ctx;
	/*
	 * The number of completion rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_cmpl_rings;
	/*
	 * The number of transmit rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_tx_rings;
	/*
	 * The number of receive rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_rx_rings;
	/* The allocated number of L2 contexts to the function. */
	uint16_t	alloc_l2_ctx;
	/* The allocated number of vnics to the function. */
	uint16_t	alloc_vnics;
	/*
	 * The maximum transmission unit of the function
	 * configured by the admin pf.
	 * If the reported mtu value is non-zero then it will be used for the
	 * rings allocated on this function, otherwise the default
	 * value is used if ring MTU is not specified.
	 * The driver cannot use any MTU bigger than this value
	 * if it is non-zero.
	 */
	uint16_t	admin_mtu;
	/*
	 * The maximum receive unit of the function.
	 * For vnics allocated on this function, this default
	 * value is used if vnic MRU is not specified.
	 */
	uint16_t	mru;
	/* The statistics context assigned to a function. */
	uint16_t	stat_ctx_id;
	/*
	 * The HWRM shall return Unknown value for this field
	 * when this command is used to query VF's configuration.
	 */
	uint8_t	port_partition_type;
	/* Single physical function */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_SPF	UINT32_C(0x0)
	/* Multiple physical functions */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_MPFS	UINT32_C(0x1)
	/* Network Partitioning 1.0 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_0 UINT32_C(0x2)
	/* Network Partitioning 1.5 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_5 UINT32_C(0x3)
	/* Network Partitioning 2.0 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR2_0 UINT32_C(0x4)
	/* Network Partitioning 1.2 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_2 UINT32_C(0x5)
	/* Unknown */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_UNKNOWN UINT32_C(0xff)
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_LAST   HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_UNKNOWN
	/*
	 * This field will indicate number of physical functions on this
	 * port_partition. HWRM shall return unavail (i.e. value of 0) for this
	 * field when this command is used to query VF's configuration or from
	 * older firmware that doesn't support this field.
	 */
	uint8_t	port_pf_cnt;
	/* number of PFs is not available */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_UNAVAIL UINT32_C(0x0)
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_LAST   HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_UNAVAIL
	/*
	 * The default VNIC ID assigned to a function that is
	 * being queried.
	 */
	uint16_t	dflt_vnic_id;
	uint16_t	max_mtu_configured;
	/*
	 * Minimum guaranteed transmit bandwidth for this function. When
	 * specified for a PF, does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates the minimum bandwidth is not configured.
	 */
	uint32_t	min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_LAST		HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of link bandwidth. */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum transmit rate for this function. When specified for a PF,
	 * does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates that the maximum bandwidth is not configured.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_LAST		HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of link bandwidth. */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * This value indicates the Edge virtual bridge mode for the
	 * domain that this function belongs to.
	 */
	uint8_t	evb_mode;
	/* No Edge Virtual Bridging (EVB) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_NO_EVB UINT32_C(0x0)
	/* Virtual Ethernet Bridge (VEB) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEB	UINT32_C(0x1)
	/* Virtual Ethernet Port Aggregator (VEPA) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEPA   UINT32_C(0x2)
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_LAST  HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEPA
	uint8_t	options;
	/*
	 * This value indicates the PCIE device cache line size.
	 * The cache line size allows the DMA writes to terminate and
	 * start at the cache boundary.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_MASK	UINT32_C(0x3)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SFT	0
	/* Cache Line Size 64 bytes */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_64	UINT32_C(0x0)
	/* Cache Line Size 128 bytes */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_128	UINT32_C(0x1)
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_LAST	HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_128
	/* This value is the virtual link admin state setting. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_MASK	UINT32_C(0xc)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_SFT	2
	/* Admin link state is in forced down mode. */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_DOWN  (UINT32_C(0x0) << 2)
	/* Admin link state is in forced up mode. */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_UP	(UINT32_C(0x1) << 2)
	/*
	 * Admin link state is in auto mode - follows the physical link
	 * state.
	 */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_AUTO	(UINT32_C(0x2) << 2)
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_LAST	HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_AUTO
	/* Reserved for future. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_RSVD_MASK		UINT32_C(0xf0)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_RSVD_SFT			4
	/*
	 * The number of VFs that are allocated to the function.
	 * This is valid only on the PF with SR-IOV enabled.
	 * 0xFF... (All Fs) if this command is called on a PF with
	 * SR-IOV disabled or on a VF.
	 */
	uint16_t	alloc_vfs;
	/*
	 * The number of allocated multicast filters for this
	 * function on the RX side.
	 */
	uint32_t	alloc_mcast_filters;
	/*
	 * The number of allocated HW ring groups for this
	 * function.
	 */
	uint32_t	alloc_hw_ring_grps;
	/*
	 * The number of strict priority transmit rings out of
	 * currently allocated TX rings to the function
	 * (alloc_tx_rings).
	 */
	uint16_t	alloc_sp_tx_rings;
	/*
	 * The number of statistics contexts
	 * currently reserved for the function.
	 */
	uint16_t	alloc_stat_ctx;
	/*
	 * This field specifies how many NQs are reserved for the PF.
	 * Remaining NQs that belong to the PF are available for VFs.
	 * Once a PF has created VFs, it cannot change how many NQs are
	 * reserved for itself (since the NQs must be contiguous in HW).
	 */
	uint16_t	alloc_msix;
	/*
	 * The number of registered VF's associated with the PF. This field
	 * should be ignored when the request received on the VF interface.
	 * This field will be updated on the PF interface to initiate
	 * the unregister request on PF in the HOT Reset Process.
	 */
	uint16_t	registered_vfs;
	/*
	 * The size of the doorbell BAR in KBytes reserved for L2 including
	 * any area that is shared between L2 and RoCE. The L2 driver
	 * should only map the L2 portion of the doorbell BAR. Any rounding
	 * of the BAR size to the native CPU page size should be performed
	 * by the driver. If the value is zero, no special partitioning
	 * of the doorbell BAR between L2 and RoCE is required.
	 */
	uint16_t	l2_doorbell_bar_size_kb;
	/*
	 * A bitmask indicating the active endpoints. Each bit represents a
	 * specific endpoint, with bit 0 indicating EP 0 and bit 3 indicating
	 * EP 3. For example:
	 * - a single root system would return 0x1
	 * - a 2x8 system (where EPs 0 and 2 are active) would return 0x5
	 * - a 4x4 system (where EPs 0-3 are active) would return 0xF
	 */
	uint8_t	active_endpoints;
	/*
	 * For backward compatibility this field must be set to 1.
	 * Older drivers might look for this field to be 1 before
	 * processing the message.
	 */
	uint8_t	always_1;
	/*
	 * This GRC address location is used by the Host driver interfaces to
	 * poll the adapter ready state to re-initiate the registration process
	 * again after receiving the RESET Notify event.
	 */
	uint32_t	reset_addr_poll;
	/*
	 * This field specifies legacy L2 doorbell size in KBytes. Drivers
	 * should use this value to find out the doorbell page offset from the
	 * BAR.
	 */
	uint16_t	legacy_l2_db_size_kb;
	uint16_t	svif_info;
	/*
	 * This field specifies the source virtual interface of the function
	 * being queried. Drivers can use this to program svif field in the
	 * L2 context table
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_MASK	UINT32_C(0x7fff)
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_SFT	0
	/* This field specifies whether svif is valid or not */
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_VALID	UINT32_C(0x8000)
	uint8_t	mpc_chnls;
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the TX crypto engine block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_TCE_ENABLED	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the RX crypto engine block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_RCE_ENABLED	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the TX configurable flow processing block is
	 * enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_TE_CFA_ENABLED	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the RX configurable flow processing block is
	 * enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_RE_CFA_ENABLED	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the primate processor block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_PRIMATE_ENABLED	UINT32_C(0x10)
	/*
	 * Configured doorbell page size for this function.
	 * This field is valid for PF only.
	 */
	uint8_t	db_page_size;
	/* DB page size is 4KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_4KB   UINT32_C(0x0)
	/* DB page size is 8KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_8KB   UINT32_C(0x1)
	/* DB page size is 16KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_16KB  UINT32_C(0x2)
	/* DB page size is 32KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_32KB  UINT32_C(0x3)
	/* DB page size is 64KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_64KB  UINT32_C(0x4)
	/* DB page size is 128KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_128KB UINT32_C(0x5)
	/* DB page size is 256KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_256KB UINT32_C(0x6)
	/* DB page size is 512KB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_512KB UINT32_C(0x7)
	/* DB page size is 1MB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_1MB   UINT32_C(0x8)
	/* DB page size is 2MB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_2MB   UINT32_C(0x9)
	/* DB page size is 4MB. */
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_4MB   UINT32_C(0xa)
	#define HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_LAST HWRM_FUNC_QCFG_OUTPUT_DB_PAGE_SIZE_4MB
	/*
	 * RoCE VNIC ID for the function. If the function does not have a valid
	 * RoCE vnic id, then the roce_vnic_id_valid bit in flags is set to 0.
	 */
	uint16_t	roce_vnic_id;
	/*
	 * Minimum guaranteed bandwidth for the network partition made up
	 * of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no minimum bandwidth is configured.
	 * The format of this field is defined to match min_bw, even though
	 * the partition minimum rate is always specified as a percentage.
	 */
	uint32_t	partition_min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_SFT		0
	/*
	 * The granularity of the value (bits or bytes). Firmware never sets
	 * this field.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_LAST		HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BYTES
	/* Always percentage of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Bandwidth value is in hundredths of a percent of link bandwidth. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The maximum bandwidth that may be used by the network partition
	 * made up of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no maximum bandwidth is configured.
	 * The format of this field is defined to match max_bw, even though
	 * the partition bandwidth must be specified as a percentage.
	 */
	uint32_t	partition_max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_SFT		0
	/*
	 * The granularity of the value (bits or bytes). Firmware never sets
	 * this field.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_LAST		HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BYTES
	/* Always a percentage of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in hundredths of a percent of link bandwidth. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The maximum transmission unit of the function
	 * configured by the host pf/vf.
	 * If the reported mtu value is non-zero then it will be used for the
	 * rings allocated on this function, otherwise the default
	 * value is used if ring MTU is not specified.
	 */
	uint16_t	host_mtu;
	uint16_t	flags2;
	/*
	 * If set to 1, then VF drivers are requested to insert a DSCP
	 * value into all outgoing L2 packets such that DSCP=VF ID modulo 64
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS2_SRIOV_DSCP_INSERT_ENABLED	UINT32_C(0x1)
	uint8_t	unused_4[2];
	/*
	 * KDNet mode for the port for this function. If a VF, KDNet
	 * mode is always disabled.
	 */
	uint8_t	port_kdnet_mode;
	/* KDNet mode is not enabled on the port for this function. */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_KDNET_MODE_DISABLED UINT32_C(0x0)
	/* KDNet mode is enabled on the port for this function. */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_KDNET_MODE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_KDNET_MODE_LAST	HWRM_FUNC_QCFG_OUTPUT_PORT_KDNET_MODE_ENABLED
	/*
	 * If KDNet mode is enabled, the PCI function number of the
	 * KDNet partition.
	 */
	uint8_t	kdnet_pcie_function;
	/*
	 * Function ID of the KDNET function on this port. If the
	 * KDNET partition does not exist and the FW supports this
	 * feature, 0xffff will be returned.
	 */
	uint16_t	port_kdnet_fid;
	uint8_t	unused_5[2];
	/* Number of KTLS Tx Key Contexts allocated. */
	uint32_t	num_ktls_tx_key_ctxs;
	/* Number of KTLS Rx Key Contexts allocated. */
	uint32_t	num_ktls_rx_key_ctxs;
	/*
	 * The LAG idx of this function. The lag_id is per port and the
	 * valid lag_id is from 0 to 7, if there is no valid lag_id,
	 * 0xff will be returned.
	 * This HW lag id is used for Truflow programming only.
	 */
	uint8_t	lag_id;
	/* Partition interface for this function. */
	uint8_t	parif;
	/*
	 * The LAG ID of a hardware link aggregation group (LAG) whose
	 * member ports include the port of this function. The LAG was
	 * previously created using HWRM_FUNC_LAG_CREATE. If the port of this
	 * function is not a member of any LAG, the fw_lag_id will be 0xff.
	 */
	uint8_t	fw_lag_id;
	uint8_t	unused_6;
	/* Number of QUIC Tx Key Contexts allocated. */
	uint32_t	num_quic_tx_key_ctxs;
	/* Number of QUIC Rx Key Contexts allocated. */
	uint32_t	num_quic_rx_key_ctxs;
	/*
	 * Number of AVs per VF. Only valid for PF. This field is ignored
	 * when the flag, l2_vf_resource_mgmt, is not set in RoCE
	 * initialize_fw.
	 */
	uint32_t	roce_max_av_per_vf;
	/*
	 * Number of CQs per VF. Only valid for PF. This field is ignored when
	 * the flag, l2_vf_resource_mgmt, is not set in RoCE initialize_fw.
	 */
	uint32_t	roce_max_cq_per_vf;
	/*
	 * Number of MR/MWs per VF. Only valid for PF. This field is ignored
	 * when the flag, l2_vf_resource_mgmt, is not set in RoCE
	 * initialize_fw.
	 */
	uint32_t	roce_max_mrw_per_vf;
	/*
	 * Number of QPs per VF. Only valid for PF. This field is ignored when
	 * the flag, l2_vf_resource_mgmt, is not set in RoCE initialize_fw.
	 */
	uint32_t	roce_max_qp_per_vf;
	/*
	 * Number of SRQs per VF. Only valid for PF. This field is ignored
	 * when the flag, l2_vf_resource_mgmt, is not set in RoCE
	 * initialize_fw.
	 */
	uint32_t	roce_max_srq_per_vf;
	/*
	 * Number of GIDs per VF. Only valid for PF. This field is ignored
	 * when the flag, l2_vf_resource_mgmt, is not set in RoCE
	 * initialize_fw.
	 */
	uint32_t	roce_max_gid_per_vf;
	/*
	 * Bitmap of context types that have XID partition enabled.
	 * Only valid for PF.
	 */
	uint16_t	xid_partition_cfg;
	/*
	 * When this bit is '1', it indicates that driver enables XID
	 * partition on Tx crypto key contexts.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_XID_PARTITION_CFG_TX_CK	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that driver enables XID
	 * partition on Rx crypto key contexts.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_XID_PARTITION_CFG_RX_CK	UINT32_C(0x2)
	uint8_t	unused_7;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_qcfg_output_t, *phwrm_func_qcfg_output_t;

/*****************
 * hwrm_func_cfg *
 *****************/


/* hwrm_func_cfg_input (size:1280b/160B) */

typedef struct hwrm_func_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	/*
	 * This field specifies how many NQs will be reserved for the PF.
	 * Remaining NQs that belong to the PF become available for VFs.
	 * Once a PF has created VFs, it cannot change how many NQs are
	 * reserved for itself (since the NQs must be contiguous in HW).
	 */
	uint16_t	num_msix;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function is disabled with
	 * source MAC address check.
	 * This is an anti-spoofing check. If this flag is set,
	 * then the function shall be configured to disallow
	 * transmission of frames with the source MAC address that
	 * is configured for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_SRC_MAC_ADDR_CHECK_DISABLE	UINT32_C(0x1)
	/*
	 * When this bit is '1', the function is enabled with
	 * source MAC address check.
	 * This is an anti-spoofing check. If this flag is set,
	 * then the function shall be configured to allow
	 * transmission of frames with the source MAC address that
	 * is configured for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_SRC_MAC_ADDR_CHECK_ENABLE	UINT32_C(0x2)
	/* reserved. */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSVD_MASK			UINT32_C(0x1fc)
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSVD_SFT			2
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is requested to be
	 * enabled on the function being configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STD_TX_RING_MODE_ENABLE	UINT32_C(0x200)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then the standard TX ring mode is requested to
	 * be disabled on the function being configured. In this extended
	 * TX ring resource mode, the minimum and maximum bandwidth settings
	 * are not supported to allow the allocation of TX rings to
	 * span multiple scheduler nodes.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STD_TX_RING_MODE_DISABLE	UINT32_C(0x400)
	/*
	 * If this bit is set, virtual mac address configured
	 * in this command will be persistent over warm boot.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_VIRT_MAC_PERSIST		UINT32_C(0x800)
	/*
	 * This bit only applies to the VF. If this bit is set, the statistic
	 * context counters will not be cleared when the statistic context is
	 * freed or a function reset is called on VF. This bit will be
	 * cleared when the PF is unloaded or a function reset is called on
	 * the PF.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_NO_AUTOCLEAR_STATISTIC	UINT32_C(0x1000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of TX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TX_ASSETS_TEST		UINT32_C(0x2000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RX_ASSETS_TEST		UINT32_C(0x4000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of CMPL rings) are
	 * available. The firmware will return an error if the requested
	 * assets are not available. The firmware will NOT reserve the assets
	 * if they are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_CMPL_ASSETS_TEST		UINT32_C(0x8000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RSS ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSSCOS_CTX_ASSETS_TEST	UINT32_C(0x10000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of ring groups) are
	 * available. The firmware will return an error if the requested
	 * assets are not available. The firmware will NOT reserve the assets
	 * if they are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RING_GRP_ASSETS_TEST	UINT32_C(0x20000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of stat ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STAT_CTX_ASSETS_TEST	UINT32_C(0x40000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of VNICs) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_VNIC_ASSETS_TEST		UINT32_C(0x80000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of L2 ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_L2_CTX_ASSETS_TEST		UINT32_C(0x100000)
	/*
	 * This configuration change can be initiated by a PF driver. This
	 * configuration request shall be targeted to a VF. From local host
	 * resident HWRM clients, only the parent PF driver shall be allowed
	 * to initiate this change on one of its children VFs. If this bit is
	 * set to 1, then the VF that is being configured is requested to be
	 * trusted.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TRUSTED_VF_ENABLE		UINT32_C(0x200000)
	/*
	 * When this bit it set, even if PF reserved pool size is zero,
	 * FW will allow driver to create TX rings in ring alloc,
	 * by reserving TX ring, S3 node dynamically.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_DYNAMIC_TX_RING_ALLOC	UINT32_C(0x400000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of NQ rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firmware will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_NQ_ASSETS_TEST		UINT32_C(0x800000)
	/*
	 * This configuration change can be initiated by a PF driver. This
	 * configuration request shall be targeted to a VF. From local host
	 * resident HWRM clients, only the parent PF driver shall be allowed
	 * to initiate this change on one of its children VFs. If this bit is
	 * set to 1, then the VF that is being configured is requested to be
	 * untrusted.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TRUSTED_VF_DISABLE		UINT32_C(0x1000000)
	/*
	 * This bit is used by preboot drivers on a PF that require access
	 * to the legacy L2 ring model and legacy 32b doorbells. This
	 * feature is not allowed on VFs and is only relevant for devices
	 * that require a context backing store.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PREBOOT_LEGACY_L2_RINGS	UINT32_C(0x2000000)
	/*
	 * If this bit is set to 0, then the interface does not support hot
	 * reset capability which it advertised with the hot_reset_support
	 * flag in HWRM_FUNC_DRV_RGTR. If any of the function has set this
	 * flag to 0, adapter cannot do the hot reset. In this state, if the
	 * firmware receives a hot reset request, firmware must fail the
	 * request. If this bit is set to 1, then interface is renabling the
	 * hot reset capability.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_HOT_RESET_IF_EN_DIS		UINT32_C(0x4000000)
	/*
	 * If this bit is set to 1, the PF driver is requesting FW
	 * to enable PPP TX PUSH feature on all the TX rings specified in
	 * the num_tx_rings field. By default, the PPP TX push feature is
	 * disabled for all the TX rings of the function. This flag is
	 * ignored if num_tx_rings field is not specified or the function
	 * doesn't support PPP tx push feature.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PPP_PUSH_MODE_ENABLE	UINT32_C(0x8000000)
	/*
	 * If this bit is set to 1, the PF driver is requesting FW
	 * to disable PPP TX PUSH feature on all the TX rings specified in
	 * the num_tx_rings field. This flag is ignored if num_tx_rings
	 * field is not specified or the function doesn't support PPP tx
	 * push feature.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PPP_PUSH_MODE_DISABLE	UINT32_C(0x10000000)
	/*
	 * If this bit is set to 1, the driver is requesting FW to enable
	 * the BD_METADATA feature for this function. The FW returns error
	 * on this request if the TX_METADATA is enabled for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_BD_METADATA_ENABLE		UINT32_C(0x20000000)
	/*
	 * If this bit is set to 1, the driver is requesting FW to disable
	 * the BD_METADATA feature for this function. The FW returns error
	 * on this request if the TX_METADATA is enabled for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_BD_METADATA_DISABLE		UINT32_C(0x40000000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the admin_mtu field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ADMIN_MTU		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MRU			UINT32_C(0x2)
	/*
	 * This bit must be '1' for the num_rsscos_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_RSSCOS_CTXS	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the num_cmpl_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_CMPL_RINGS	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the num_tx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_TX_RINGS		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_rx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_RX_RINGS		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the num_l2_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_L2_CTXS		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the num_vnics field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_VNICS		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the num_stat_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_STAT_CTXS		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dflt_mac_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_MAC_ADDR		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the dflt_vlan field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_VLAN		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the dflt_ip_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_IP_ADDR		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the min_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MIN_BW		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the max_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MAX_BW		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the async_event_cr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ASYNC_EVENT_CR	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the vlan_antispoof_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_VLAN_ANTISPOOF_MODE	UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the allowed_vlan_pris field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ALLOWED_VLAN_PRIS	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the evb_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_EVB_MODE		UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the num_mcast_filters field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_MCAST_FILTERS	UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the num_hw_ring_grps field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_HW_RING_GRPS	UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the cache_linesize field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_CACHE_LINESIZE	UINT32_C(0x100000)
	/*
	 * This bit must be '1' for the num_msix field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_MSIX		UINT32_C(0x200000)
	/*
	 * This bit must be '1' for the link admin state field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ADMIN_LINK_STATE	UINT32_C(0x400000)
	/*
	 * This bit must be '1' for the hot_reset_if_en_dis field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_HOT_RESET_IF_SUPPORT	UINT32_C(0x800000)
	/*
	 * This bit must be '1' for the schq_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_SCHQ_ID		UINT32_C(0x1000000)
	/*
	 * This bit must be '1' for the mpc_chnls field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MPC_CHNLS		UINT32_C(0x2000000)
	/*
	 * This bit must be '1' for the partition_min_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_PARTITION_MIN_BW	UINT32_C(0x4000000)
	/*
	 * This bit must be '1' for the partition_max_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_PARTITION_MAX_BW	UINT32_C(0x8000000)
	/*
	 * This bit must be '1' for the tpid field to be
	 * configured. This bit is only valid when dflt_vlan enable
	 * bit is set.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_TPID			UINT32_C(0x10000000)
	/*
	 * This bit must be '1' for the host_mtu field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_HOST_MTU		UINT32_C(0x20000000)
	/*
	 * This bit must be '1' for the num_ktls_tx_key_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_KTLS_TX_KEY_CTXS	UINT32_C(0x40000000)
	/*
	 * This bit must be '1' for the num_ktls_rx_key_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_KTLS_RX_KEY_CTXS	UINT32_C(0x80000000)
	/*
	 * This field can be used by the admin PF to configure
	 * mtu of foster PFs.
	 * The maximum transmission unit of the function.
	 * The HWRM should make sure that the mtu of
	 * the function does not exceed the mtu of the physical
	 * port that this function is associated with.
	 *
	 * In addition to configuring mtu per function, it is
	 * possible to configure mtu per transmit ring.
	 * By default, the mtu of each transmit ring associated
	 * with a function is equal to the mtu of the function.
	 * The HWRM should make sure that the mtu of each transmit
	 * ring that is assigned to a function has a valid mtu.
	 */
	uint16_t	admin_mtu;
	/*
	 * The maximum receive unit of the function.
	 * The HWRM should make sure that the mru of
	 * the function does not exceed the mru of the physical
	 * port that this function is associated with.
	 *
	 * In addition to configuring mru per function, it is
	 * possible to configure mru per vnic.
	 * By default, the mru of each vnic associated
	 * with a function is equal to the mru of the function.
	 * The HWRM should make sure that the mru of each vnic
	 * that is assigned to a function has a valid mru.
	 */
	uint16_t	mru;
	/*
	 * The number of RSS/COS contexts requested for the
	 * function.
	 */
	uint16_t	num_rsscos_ctxs;
	/*
	 * The number of completion rings requested for the
	 * function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	num_cmpl_rings;
	/*
	 * The number of transmit rings requested for the function.
	 * This does not include the rings allocated to any
	 * children functions if any.
	 */
	uint16_t	num_tx_rings;
	/*
	 * The number of receive rings requested for the function.
	 * This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	num_rx_rings;
	/* The requested number of L2 contexts for the function. */
	uint16_t	num_l2_ctxs;
	/* The requested number of vnics for the function. */
	uint16_t	num_vnics;
	/* The requested number of statistic contexts for the function. */
	uint16_t	num_stat_ctxs;
	/*
	 * The number of HW ring groups that should
	 * be reserved for this function.
	 */
	uint16_t	num_hw_ring_grps;
	/* The default MAC address for the function being configured. */
	uint8_t	dflt_mac_addr[6];
	/*
	 * The default VLAN for the function being configured.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	dflt_vlan;
	/*
	 * The default IP address for the function being configured.
	 * This address is only used in enabling source property check.
	 */
	uint32_t	dflt_ip_addr[4];
	/*
	 * Minimum guaranteed transmit bandwidth for this function. When
	 * specified for a PF, does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates the minimum bandwidth is not configured.
	 */
	uint32_t	min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_LAST		HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum transmit rate for this function. When specified for a PF,
	 * does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates that the maximum bandwidth is not configured.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_LAST		HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * ID of the target completion ring for receiving asynchronous
	 * event completions. If this field is not valid, then the
	 * HWRM shall use the default completion ring of the function
	 * that is being configured as the target completion ring for
	 * providing any asynchronous event completions for that
	 * function.
	 * If this field is valid, then the HWRM shall use the
	 * completion ring identified by this ID as the target
	 * completion ring for providing any asynchronous event
	 * completions for the function that is being configured.
	 */
	uint16_t	async_event_cr;
	/* VLAN Anti-spoofing mode. */
	uint8_t	vlan_antispoof_mode;
	/* No VLAN anti-spoofing checks are enabled */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_NOCHECK		UINT32_C(0x0)
	/* Validate VLAN against the configured VLAN(s) */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_VALIDATE_VLAN	UINT32_C(0x1)
	/* Insert VLAN if it does not exist, otherwise discard */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_IF_VLANDNE	UINT32_C(0x2)
	/* Insert VLAN if it does not exist, override VLAN if it exists */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_OR_OVERRIDE_VLAN UINT32_C(0x3)
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_LAST		HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_OR_OVERRIDE_VLAN
	/*
	 * This bit field defines VLAN PRIs that are allowed on
	 * this function.
	 * If nth bit is set, then VLAN PRI n is allowed on this
	 * function.
	 */
	uint8_t	allowed_vlan_pris;
	/*
	 * The evb_mode is configured on a per port basis. The default evb_mode
	 * is configured based on the NVM EVB mode setting upon firmware
	 * initialization. The HWRM allows a PF driver to change EVB mode for a
	 * port used by the PF only when one of the following conditions is
	 * satisfied.
	 * 1. The current operating mode is single function mode.
	 *	(ie. one PF per port)
	 * 2. For SmartNIC, any one of the PAXC PFs is permitted to change the
	 *	EVB mode of the port used by the PAXC PF. None of the X86 PFs
	 *	should have privileges.
	 * The HWRM doesn't permit any PFs to change the underlying EVB mode
	 * when running as MHB or NPAR mode in performance NIC configuration.
	 * The HWRM doesn't permit a VF driver to change the EVB mode.
	 * Once the HWRM determines a function doesn't meet the conditions
	 * to configure the EVB mode, it sets the evb_mode_cfg_not_supported
	 * flag in HWRM_FUNC_QCAPS command response for the function.
	 * The HWRM takes into account the switching of EVB mode from one to
	 * another and reconfigure hardware resources as required. The
	 * switching from VEB to VEPA mode requires the disabling of the
	 * loopback traffic. Additionally, source knockouts are handled
	 * differently in VEB and VEPA modes.
	 */
	uint8_t	evb_mode;
	/* No Edge Virtual Bridging (EVB) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_NO_EVB UINT32_C(0x0)
	/* Virtual Ethernet Bridge (VEB) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_VEB	UINT32_C(0x1)
	/* Virtual Ethernet Port Aggregator (VEPA) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_VEPA   UINT32_C(0x2)
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_LAST  HWRM_FUNC_CFG_INPUT_EVB_MODE_VEPA
	uint8_t	options;
	/*
	 * This value indicates the PCIE device cache line size.
	 * The cache line size allows the DMA writes to terminate and
	 * start at the cache boundary.
	 */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_MASK	UINT32_C(0x3)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SFT	0
	/* Cache Line Size 64 bytes */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_64	UINT32_C(0x0)
	/* Cache Line Size 128 bytes */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_128	UINT32_C(0x1)
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_LAST	HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_128
	/* This value is the virtual link admin state setting. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_MASK	UINT32_C(0xc)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_SFT	2
	/* Admin state is forced down. */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_DOWN  (UINT32_C(0x0) << 2)
	/* Admin state is forced up. */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_UP	(UINT32_C(0x1) << 2)
	/*
	 * Admin state is in auto mode - is to follow the physical link
	 * state.
	 */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_AUTO	(UINT32_C(0x2) << 2)
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_LAST	HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_AUTO
	/* Reserved for future. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_RSVD_MASK		UINT32_C(0xf0)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_RSVD_SFT			4
	/*
	 * The number of multicast filters that should
	 * be reserved for this function on the RX side.
	 */
	uint16_t	num_mcast_filters;
	/* Used by a PF driver to associate a SCHQ with a VF. */
	uint16_t	schq_id;
	uint16_t	mpc_chnls;
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the TX crypto engine block.
	 * When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TCE_ENABLE	UINT32_C(0x1)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the TX crypto engine block.
	 * When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TCE_DISABLE	UINT32_C(0x2)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the RX crypto engine block.
	 * When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RCE_ENABLE	UINT32_C(0x4)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the RX crypto engine block.
	 * When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RCE_DISABLE	UINT32_C(0x8)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the TX configurable flow processing
	 * block. When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TE_CFA_ENABLE	UINT32_C(0x10)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the TX configurable flow processing
	 * block. When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TE_CFA_DISABLE	UINT32_C(0x20)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the RX configurable flow processing
	 * block. When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RE_CFA_ENABLE	UINT32_C(0x40)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the RX configurable flow processing
	 * block. When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RE_CFA_DISABLE	UINT32_C(0x80)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the primate processor block.
	 * When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_PRIMATE_ENABLE	UINT32_C(0x100)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the primate processor block.
	 * When this bit is '0', this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_PRIMATE_DISABLE	UINT32_C(0x200)
	/*
	 * Minimum guaranteed bandwidth for the network partition made up
	 * of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no minimum bandwidth is configured. The sum of the
	 * minimum bandwidths for all partitions on a link must not exceed
	 * 100%.
	 * The format of this field is defined to match min_bw, even though
	 * it does not allow all the options for min_bw at this time.
	 */
	uint32_t	partition_min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_SFT		0
	/*
	 * The granularity of the value (bits or bytes). Firmware ignores
	 * this field.
	 */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_LAST		HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BYTES
	/* Bandwidth units. Must be set to percent1_100. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in hundredths of a percent of link bandwidth. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The maximum bandwidth that may be used by the network partition
	 * made up of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no maximum bandwidth is configured.
	 * The format of this field is defined to match max_bw, even though it
	 * does not allow all the options for max_bw at this time.
	 */
	uint32_t	partition_max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_SFT		0
	/*
	 * The granularity of the value (bits or bytes). Firmware ignores
	 * this field.
	 */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_LAST		HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BYTES
	/* Bandwidth units. Must be set to percent1_100. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in hundredths of a percent of link bandwidth. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The TPID for the function for which default VLAN
	 * is configured. If the dflt_vlan is not specified
	 * with the TPID, FW returns error. If the TPID is
	 * not specified with dflt_vlan, the default TPID of
	 * 0x8100 will be used. This field is specified in
	 * network byte order.
	 */
	uint16_t	tpid;
	/*
	 * This field can be used by the host PF to configure
	 * mtu value.
	 * The maximum transmission unit of the function.
	 * The HWRM should make sure that the mtu of
	 * the function does not exceed the mtu of the physical
	 * port that this function is associated with.
	 *
	 * In addition to configuring mtu per function, it is
	 * possible to configure mtu per transmit ring.
	 * By default, the mtu of each transmit ring associated
	 * with a function is equal to the mtu of the function.
	 * The HWRM should make sure that the mtu of each transmit
	 * ring that is assigned to a function has a valid mtu.
	 */
	uint16_t	host_mtu;
	uint32_t	flags2;
	/*
	 * If this bit is set to 1, the driver is requesting the firmware
	 * to see if the assets (i.e., the number of KTLS key contexts)
	 * requested in this command are available. The firmware will return
	 * an error if the requested assets are not available. The firmware
	 * will NOT reserve the assets if they are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS2_KTLS_KEY_CTX_ASSETS_TEST	UINT32_C(0x1)
	/*
	 * If this bit is set to 1, the driver is requesting the firmware
	 * to see if the assets (i.e., the number of QUIC key contexts)
	 * requested in this command are available. The firmware will return
	 * an error if the requested assets are not available. The firmware
	 * will NOT reserve the assets if they are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS2_QUIC_KEY_CTX_ASSETS_TEST	UINT32_C(0x2)
	uint32_t	enables2;
	/*
	 * This bit must be '1' for the kdnet_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_KDNET		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the db_page_size field to be
	 * configured. Legacy controller core FW may silently ignore
	 * the db_page_size programming request through this command.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_DB_PAGE_SIZE		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the num_quic_tx_key_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_QUIC_TX_KEY_CTXS	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the num_quic_rx_key_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_QUIC_RX_KEY_CTXS	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the roce_max_av_per_vf field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_ROCE_MAX_AV_PER_VF	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the roce_max_cq_per_vf field to be
	 * configured. Only valid for PF.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_ROCE_MAX_CQ_PER_VF	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the roce_max_mrw_per_vf field to be
	 * configured. Only valid for PF.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_ROCE_MAX_MRW_PER_VF	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the roce_max_qp_per_vf field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_ROCE_MAX_QP_PER_VF	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the roce_max_srq_per_vf field to be
	 * configured. Only valid for PF.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_ROCE_MAX_SRQ_PER_VF	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the roce_max_gid_per_vf field to be
	 * configured. Only valid for PF.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_ROCE_MAX_GID_PER_VF	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the xid_partition_cfg field to be
	 * configured. Only valid for PF.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES2_XID_PARTITION_CFG	UINT32_C(0x400)
	/*
	 * KDNet mode for the port for this function. If NPAR is
	 * also configured on this port, it takes precedence. KDNet
	 * mode is ignored for a VF.
	 */
	uint8_t	port_kdnet_mode;
	/* KDNet mode is not enabled. */
	#define HWRM_FUNC_CFG_INPUT_PORT_KDNET_MODE_DISABLED UINT32_C(0x0)
	/* KDNet mode enabled. */
	#define HWRM_FUNC_CFG_INPUT_PORT_KDNET_MODE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_CFG_INPUT_PORT_KDNET_MODE_LAST	HWRM_FUNC_CFG_INPUT_PORT_KDNET_MODE_ENABLED
	/*
	 * This field can be used by the PF driver to configure the doorbell
	 * page size. L2 driver can use different pages to ring the doorbell
	 * for L2 push operation. The doorbell page size should be configured
	 * to match the native CPU page size for proper RoCE and L2 doorbell
	 * operations. This value supersedes the older method of configuring
	 * the doorbell page size by the RoCE driver using the command queue
	 * method. The default is 4K.
	 */
	uint8_t	db_page_size;
	/* DB page size is 4KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_4KB   UINT32_C(0x0)
	/* DB page size is 8KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_8KB   UINT32_C(0x1)
	/* DB page size is 16KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_16KB  UINT32_C(0x2)
	/* DB page size is 32KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_32KB  UINT32_C(0x3)
	/* DB page size is 64KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_64KB  UINT32_C(0x4)
	/* DB page size is 128KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_128KB UINT32_C(0x5)
	/* DB page size is 256KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_256KB UINT32_C(0x6)
	/* DB page size is 512KB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_512KB UINT32_C(0x7)
	/* DB page size is 1MB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_1MB   UINT32_C(0x8)
	/* DB page size is 2MB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_2MB   UINT32_C(0x9)
	/* DB page size is 4MB. */
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_4MB   UINT32_C(0xa)
	#define HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_LAST HWRM_FUNC_CFG_INPUT_DB_PAGE_SIZE_4MB
	uint8_t	unused_1[2];
	/* Number of KTLS Tx Key Contexts requested. */
	uint32_t	num_ktls_tx_key_ctxs;
	/* Number of KTLS Rx Key Contexts requested. */
	uint32_t	num_ktls_rx_key_ctxs;
	/* Number of QUIC Tx Key Contexts requested. */
	uint32_t	num_quic_tx_key_ctxs;
	/* Number of QUIC Rx Key Contexts requested. */
	uint32_t	num_quic_rx_key_ctxs;
	/* Number of AVs per VF. Only valid for PF. */
	uint32_t	roce_max_av_per_vf;
	/* Number of CQs per VF. Only valid for PF. */
	uint32_t	roce_max_cq_per_vf;
	/* Number of MR/MWs per VF. Only valid for PF. */
	uint32_t	roce_max_mrw_per_vf;
	/* Number of QPs per VF. Only valid for PF. */
	uint32_t	roce_max_qp_per_vf;
	/* Number of SRQs per VF. Only valid for PF. */
	uint32_t	roce_max_srq_per_vf;
	/* Number of GIDs per VF. Only valid for PF. */
	uint32_t	roce_max_gid_per_vf;
	/*
	 * Bitmap of context types that have XID partition enabled.
	 * Only valid for PF.
	 */
	uint16_t	xid_partition_cfg;
	/*
	 * When this bit is '1', it indicates that driver enables XID
	 * partition on Tx crypto key contexts.
	 */
	#define HWRM_FUNC_CFG_INPUT_XID_PARTITION_CFG_TX_CK	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that driver enables XID
	 * partition on Rx crypto key contexts.
	 */
	#define HWRM_FUNC_CFG_INPUT_XID_PARTITION_CFG_RX_CK	UINT32_C(0x2)
	uint16_t	unused_2;
} hwrm_func_cfg_input_t, *phwrm_func_cfg_input_t;

/* hwrm_func_cfg_output (size:128b/16B) */

typedef struct hwrm_func_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_cfg_output_t, *phwrm_func_cfg_output_t;

/* hwrm_func_cfg_cmd_err (size:64b/8B) */

typedef struct hwrm_func_cfg_cmd_err {
	/* command specific error codes for the cmd_err field in hwrm_err_output */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_UNKNOWN			UINT32_C(0x0)
	/* The partition minimum bandwidth is out of range. */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_MIN_BW_RANGE	UINT32_C(0x1)
	/* The minimum bandwidth is more than the maximum bandwidth. */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_MIN_MORE_THAN_MAX  UINT32_C(0x2)
	/*
	 * The NIC does not support enforcement of a minimum guaranteed
	 * bandwidth for a partition.
	 */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_MIN_BW_UNSUPPORTED UINT32_C(0x3)
	/* Partition bandwidths must be specified as a percentage. */
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_BW_PERCENT	UINT32_C(0x4)
	#define HWRM_FUNC_CFG_CMD_ERR_CODE_LAST			HWRM_FUNC_CFG_CMD_ERR_CODE_PARTITION_BW_PERCENT
	uint8_t	unused_0[7];
} hwrm_func_cfg_cmd_err_t, *phwrm_func_cfg_cmd_err_t;

/********************
 * hwrm_func_qstats *
 ********************/


/* hwrm_func_qstats_input (size:192b/24B) */

typedef struct hwrm_func_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * A privileged PF can query for other function's statistics.
	 */
	uint16_t	fid;
	uint8_t	flags;
	/*
	 * This bit should be set to 1 when request is for only RoCE
	 * statistics. This will be honored only if the caller_fid is
	 * a privileged PF. In all other cases FID and caller_fid should
	 * be the same.
	 */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_ROCE_ONLY	UINT32_C(0x1)
	/*
	 * This bit should be set to 1 when request is for the counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x2)
	/*
	 * This bit should be set to 1 when request is for only L2
	 * statistics. This will be honored only if the caller_fid is
	 * a privileged PF. In all other cases FID and caller_fid should
	 * be the same.
	 */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_L2_ONLY	UINT32_C(0x4)
	uint8_t	unused_0[5];
} hwrm_func_qstats_input_t, *phwrm_func_qstats_input_t;

/* hwrm_func_qstats_output (size:1408b/176B) */

typedef struct hwrm_func_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of transmitted unicast packets on the function. */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets on the function. */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets on the function. */
	uint64_t	tx_bcast_pkts;
	/*
	 * Number of transmitted packets that were discarded due to
	 * internal NIC resource problems. For transmit, this
	 * can only happen if TMP is configured to allow dropping
	 * in HOL blocking conditions, which is not a normal
	 * configuration.
	 */
	uint64_t	tx_discard_pkts;
	/*
	 * Number of dropped packets on transmit path on the function.
	 * These are packets that have been marked for drop by
	 * the TE CFA block or are packets that exceeded the
	 * transmit MTU limit for the function.
	 */
	uint64_t	tx_drop_pkts;
	/* Number of transmitted bytes for unicast traffic on the function. */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic on the function. */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic on the function. */
	uint64_t	tx_bcast_bytes;
	/* Number of received unicast packets on the function. */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets on the function. */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets on the function. */
	uint64_t	rx_bcast_pkts;
	/*
	 * Number of received packets that were discarded on the function
	 * due to resource limitations. This can happen for 3 reasons.
	 * # The BD used for the packet has a bad format.
	 * # There were no BDs available in the ring for the packet.
	 * # There were no BDs available on-chip for the packet.
	 */
	uint64_t	rx_discard_pkts;
	/*
	 * Number of dropped packets on received path on the function.
	 * These are packets that have been marked for drop by the
	 * RE CFA.
	 */
	uint64_t	rx_drop_pkts;
	/* Number of received bytes for unicast traffic on the function. */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic on the function. */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic on the function. */
	uint64_t	rx_bcast_bytes;
	/* Number of aggregated unicast packets on the function. */
	uint64_t	rx_agg_pkts;
	/* Number of aggregated unicast bytes on the function. */
	uint64_t	rx_agg_bytes;
	/* Number of aggregation events on the function. */
	uint64_t	rx_agg_events;
	/* Number of aborted aggregations on the function. */
	uint64_t	rx_agg_aborts;
	/*
	 * This field is the sequence of the statistics of a function being
	 * cleared. Firmware starts the sequence from zero. It increments
	 * the sequence number every time the statistics of the function
	 * are cleared, which can be triggered by a clear statistics request
	 * or by freeing all statistics contexts of the function. If a user
	 * is interested in knowing if the statistics have been cleared
	 * since the last query, it can keep track of this sequence number
	 * between queries.
	 */
	uint8_t	clear_seq;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_qstats_output_t, *phwrm_func_qstats_output_t;

/************************
 * hwrm_func_qstats_ext *
 ************************/


/* hwrm_func_qstats_ext_input (size:256b/32B) */

typedef struct hwrm_func_qstats_ext_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * A privileged PF can query for other function's statistics.
	 */
	uint16_t	fid;
	uint8_t	flags;
	/*
	 * This bit should be set to 1 when request is for only RoCE
	 * statistics. This will be honored only if the caller_fid is
	 * a privileged PF. In all other cases FID and caller_fid should
	 * be the same.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_ROCE_ONLY	UINT32_C(0x1)
	/*
	 * This bit should be set to 1 when request is for the counter mask
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x2)
	uint8_t	unused_0[1];
	uint32_t	enables;
	/*
	 * This bit must be '1' for the schq_id and traffic_class fields to
	 * be configured.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_ENABLES_SCHQ_ID	UINT32_C(0x1)
	/* Specifies the SCHQ for which to gather statistics */
	uint16_t	schq_id;
	/*
	 * Specifies the traffic class for which to gather statistics. Valid
	 * values are 0 through (max_configurable_queues - 1), where
	 * max_configurable_queues is in the response of HWRM_QUEUE_QPORTCFG
	 */
	uint16_t	traffic_class;
	uint8_t	unused_1[4];
} hwrm_func_qstats_ext_input_t, *phwrm_func_qstats_ext_input_t;

/* hwrm_func_qstats_ext_output (size:1536b/192B) */

typedef struct hwrm_func_qstats_ext_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on received path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA errors */
	uint64_t	rx_tpa_events;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_qstats_ext_output_t, *phwrm_func_qstats_ext_output_t;

/***********************
 * hwrm_func_clr_stats *
 ***********************/


/* hwrm_func_clr_stats_input (size:192b/24B) */

typedef struct hwrm_func_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_clr_stats_input_t, *phwrm_func_clr_stats_input_t;

/* hwrm_func_clr_stats_output (size:128b/16B) */

typedef struct hwrm_func_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_clr_stats_output_t, *phwrm_func_clr_stats_output_t;

/**************************
 * hwrm_func_vf_resc_free *
 **************************/


/* hwrm_func_vf_resc_free_input (size:192b/24B) */

typedef struct hwrm_func_vf_resc_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[6];
} hwrm_func_vf_resc_free_input_t, *phwrm_func_vf_resc_free_input_t;

/* hwrm_func_vf_resc_free_output (size:128b/16B) */

typedef struct hwrm_func_vf_resc_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_resc_free_output_t, *phwrm_func_vf_resc_free_output_t;

/**********************
 * hwrm_func_drv_rgtr *
 **********************/


/* hwrm_func_drv_rgtr_input (size:896b/112B) */

typedef struct hwrm_func_drv_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is requesting
	 * all requests from its children VF drivers to be
	 * forwarded to itself.
	 * This flag can only be set by the PF driver.
	 * If a VF driver sets this flag, it should be ignored
	 * by the HWRM.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FWD_ALL_MODE			UINT32_C(0x1)
	/*
	 * When this bit is '1', the function is requesting none of
	 * the requests from its children VF drivers to be
	 * forwarded to itself.
	 * This flag can only be set by the PF driver.
	 * If a VF driver sets this flag, it should be ignored
	 * by the HWRM.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FWD_NONE_MODE			UINT32_C(0x2)
	/*
	 * When this bit is '1', then ver_maj_8b, ver_min_8b, ver_upd_8b
	 * fields shall be ignored and ver_maj, ver_min, ver_upd
	 * and ver_patch shall be used for the driver version information.
	 * When this bit is '0', then ver_maj_8b, ver_min_8b, ver_upd_8b
	 * fields shall be used for the driver version information and
	 * ver_maj, ver_min, ver_upd and ver_patch shall be ignored.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_16BIT_VER_MODE		UINT32_C(0x4)
	/*
	 * When this bit is '1', the function is indicating support of
	 * 64bit flow handle. The firmware that only supports 64bit flow
	 * handle should check this bit before allowing processing of
	 * HWRM_CFA_FLOW_XXX commands from the requesting function as
	 * firmware with 64bit flow handle support can only be compatible
	 * with drivers that support 64bit flow handle. The legacy drivers
	 * that don't support 64bit flow handle won't be able to use
	 * HWRM_CFA_FLOW_XXX commands when running with new firmware that
	 * only supports 64bit flow handle. The new firmware support 64bit
	 * flow handle returns HWRM_ERR_CODE_CMD_NOT_SUPPORTED
	 * status to the legacy driver when encounters these commands.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FLOW_HANDLE_64BIT_MODE	UINT32_C(0x8)
	/*
	 * When this bit is '1', the function is indicating support of
	 * Hot Reset. The driver interface will destroy the resources,
	 * unregister the function and register again up on receiving
	 * the RESET_NOTIFY Async notification from the core firmware.
	 * The core firmware will this use flag and trigger the Hot Reset
	 * process only if all the registered driver instances are capable
	 * of this support.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_HOT_RESET_SUPPORT		UINT32_C(0x10)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * error recovery capability. Error recovery support will be used by
	 * firmware only if all the driver instances support error recovery
	 * process. By setting this bit, driver is indicating support for
	 * corresponding async event completion message. These will be
	 * delivered to the driver even if they did not register for it.
	 * If supported, after receiving reset notify async event with fatal
	 * flag set in event data1, then all the drivers have to tear down
	 * their resources without sending any HWRM commands to FW.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_ERROR_RECOVERY_SUPPORT	UINT32_C(0x20)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * Master capability. The Firmware will use this capability to select
	 * the Master function. The master function will be used to initiate
	 * designated functionality like error recovery etc. If none of the
	 * registered PF's or trusted VF's indicate this support, then
	 * firmware will select the 1st registered PF as Master capable
	 * instance.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_MASTER_SUPPORT		UINT32_C(0x40)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * fast reset capability. Fast reset support will be used by
	 * firmware only if all the driver instances support fast reset
	 * process. By setting this bit, driver is indicating support for
	 * corresponding async event completion message. These will be
	 * delivered to the driver even if they did not register for it.
	 * If supported, after receiving reset notify async event with fast
	 * reset flag set in event data1, then all the drivers have to tear
	 * down their resources without sending any HWRM commands to FW.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FAST_RESET_SUPPORT		UINT32_C(0x80)
	/*
	 * When this bit is 1, the function's driver is indicating the
	 * support of handling the vnic_rss_cfg's INVALID_PARAM error
	 * returned by firmware. Firmware returns error, if host driver
	 * configures the invalid hash_types bit combination for a given
	 * IP version.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_RSS_STRICT_HASH_TYPE_SUPPORT	UINT32_C(0x100)
	/*
	 * When this bit is 1, the function's driver is indicating the
	 * support of handling the NPAR 1.2 feature where the s-tag may be
	 * a value other than 0x8100 or 0x88a8.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_NPAR_1_2_SUPPORT		UINT32_C(0x200)
	/*
	 * When this bit is 1, the function's driver is indicating the
	 * support for asymmetric queue configuration, such that queue
	 * ids and service profiles on TX side are not the same as the
	 * corresponding queue configuration on the RX side
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_ASYM_QUEUE_CFG_SUPPORT	UINT32_C(0x400)
	/*
	 * When this bit is 1, the function's driver is indicating to the
	 * firmware that the Ingress NIC flows will be programmed by the
	 * TruFlow application and the firmware flow manager should reject
	 * flow-create commands that programs ingress lookup flows for this
	 * function.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_TF_INGRESS_NIC_FLOW_MODE	UINT32_C(0x800)
	/*
	 * When this bit is 1, the function's driver is indicating to the
	 * firmware that the Egress NIC flows will be programmed by the
	 * TruFlow application and the firmware flow manager should reject
	 * flow-create commands that programs Egress lookup flows for this
	 * function.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_TF_EGRESS_NIC_FLOW_MODE	UINT32_C(0x1000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the os_type field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_OS_TYPE		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ver field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_VER		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the timestamp field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_TIMESTAMP	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vf_req_fwd field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_VF_REQ_FWD	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the async_event_fwd field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_ASYNC_EVENT_FWD	UINT32_C(0x10)
	/*
	 * This value indicates the type of OS. The values are based on
	 * CIM_OperatingSystem.mof file as published by the DMTF.
	 */
	uint16_t	os_type;
	/* Unknown */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UNKNOWN   UINT32_C(0x0)
	/* Other OS not listed below. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_OTHER	UINT32_C(0x1)
	/* MSDOS OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_MSDOS	UINT32_C(0xe)
	/* Windows OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WINDOWS   UINT32_C(0x12)
	/* Solaris OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_SOLARIS   UINT32_C(0x1d)
	/* Linux OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_LINUX	UINT32_C(0x24)
	/* FreeBSD OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_FREEBSD   UINT32_C(0x2a)
	/* VMware ESXi OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_ESXI	UINT32_C(0x68)
	/* Microsoft Windows 8 64-bit OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WIN864	UINT32_C(0x73)
	/* Microsoft Windows Server 2012 R2 OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WIN2012R2 UINT32_C(0x74)
	/* UEFI driver. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UEFI	UINT32_C(0x8000)
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_LAST	HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UEFI
	/* This is the 8bit major version of the driver. */
	uint8_t	ver_maj_8b;
	/* This is the 8bit minor version of the driver. */
	uint8_t	ver_min_8b;
	/* This is the 8bit update version of the driver. */
	uint8_t	ver_upd_8b;
	uint8_t	unused_0[3];
	/*
	 * This is a 32-bit timestamp provided by the driver for
	 * keep alive.
	 * The timestamp is in multiples of 1ms.
	 */
	uint32_t	timestamp;
	uint8_t	unused_1[4];
	/*
	 * This is a 256-bit bit mask provided by the PF driver for
	 * letting the HWRM know what commands issued by the VF driver
	 * to the HWRM should be forwarded to the PF driver.
	 * Nth bit refers to the Nth req_type.
	 *
	 * Setting Nth bit to 1 indicates that requests from the
	 * VF driver with req_type equal to N shall be forwarded to
	 * the parent PF driver.
	 *
	 * This field is not valid for the VF driver.
	 */
	uint32_t	vf_req_fwd[8];
	/*
	 * This is a 256-bit bit mask provided by the function driver
	 * (PF or VF driver) to indicate the list of asynchronous event
	 * completions to be forwarded.
	 *
	 * Nth bit refers to the Nth event_id.
	 *
	 * Setting Nth bit to 1 by the function driver shall result in
	 * the HWRM forwarding asynchronous event completion with
	 * event_id equal to N.
	 *
	 * If all bits are set to 0 (value of 0), then the HWRM shall
	 * not forward any asynchronous event completion to this
	 * function driver.
	 */
	uint32_t	async_event_fwd[8];
	/* This is the 16bit major version of the driver. */
	uint16_t	ver_maj;
	/* This is the 16bit minor version of the driver. */
	uint16_t	ver_min;
	/* This is the 16bit update version of the driver. */
	uint16_t	ver_upd;
	/* This is the 16bit patch version of the driver. */
	uint16_t	ver_patch;
} hwrm_func_drv_rgtr_input_t, *phwrm_func_drv_rgtr_input_t;

/* hwrm_func_drv_rgtr_output (size:128b/16B) */

typedef struct hwrm_func_drv_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', it indicates that the
	 * HWRM_FUNC_DRV_IF_CHANGE call is supported.
	 */
	#define HWRM_FUNC_DRV_RGTR_OUTPUT_FLAGS_IF_CHANGE_SUPPORTED	UINT32_C(0x1)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_drv_rgtr_output_t, *phwrm_func_drv_rgtr_output_t;

/************************
 * hwrm_func_drv_unrgtr *
 ************************/


/* hwrm_func_drv_unrgtr_input (size:192b/24B) */

typedef struct hwrm_func_drv_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is notifying
	 * the HWRM to prepare for the shutdown.
	 */
	#define HWRM_FUNC_DRV_UNRGTR_INPUT_FLAGS_PREPARE_FOR_SHUTDOWN	UINT32_C(0x1)
	uint8_t	unused_0[4];
} hwrm_func_drv_unrgtr_input_t, *phwrm_func_drv_unrgtr_input_t;

/* hwrm_func_drv_unrgtr_output (size:128b/16B) */

typedef struct hwrm_func_drv_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_drv_unrgtr_output_t, *phwrm_func_drv_unrgtr_output_t;

/**********************
 * hwrm_func_buf_rgtr *
 **********************/


/* hwrm_func_buf_rgtr_input (size:1024b/128B) */

typedef struct hwrm_func_buf_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_RGTR_INPUT_ENABLES_VF_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the err_buf_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_RGTR_INPUT_ENABLES_ERR_BUF_ADDR	UINT32_C(0x2)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	/*
	 * This field represents the number of pages used for request
	 * buffer(s).
	 */
	uint16_t	req_buf_num_pages;
	/*
	 * This field represents the page size used for request
	 * buffer(s).
	 */
	uint16_t	req_buf_page_size;
	/* 16 bytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_16B UINT32_C(0x4)
	/* 4 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_4K  UINT32_C(0xc)
	/* 8 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_8K  UINT32_C(0xd)
	/* 64 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_64K UINT32_C(0x10)
	/* 2 Mbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_2M  UINT32_C(0x15)
	/* 4 Mbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_4M  UINT32_C(0x16)
	/* 1 Gbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_1G  UINT32_C(0x1e)
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_LAST HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_1G
	/* The length of the request buffer per VF in bytes. */
	uint16_t	req_buf_len;
	/* The length of the response buffer in bytes. */
	uint16_t	resp_buf_len;
	uint8_t	unused_0[2];
	/* This field represents the page address of page #0. */
	uint64_t	req_buf_page_addr0;
	/* This field represents the page address of page #1. */
	uint64_t	req_buf_page_addr1;
	/* This field represents the page address of page #2. */
	uint64_t	req_buf_page_addr2;
	/* This field represents the page address of page #3. */
	uint64_t	req_buf_page_addr3;
	/* This field represents the page address of page #4. */
	uint64_t	req_buf_page_addr4;
	/* This field represents the page address of page #5. */
	uint64_t	req_buf_page_addr5;
	/* This field represents the page address of page #6. */
	uint64_t	req_buf_page_addr6;
	/* This field represents the page address of page #7. */
	uint64_t	req_buf_page_addr7;
	/* This field represents the page address of page #8. */
	uint64_t	req_buf_page_addr8;
	/* This field represents the page address of page #9. */
	uint64_t	req_buf_page_addr9;
	/*
	 * This field is used to receive the error reporting from
	 * the chipset. Only applicable for PFs.
	 */
	uint64_t	error_buf_addr;
	/*
	 * This field is used to receive the response forwarded by the
	 * HWRM.
	 */
	uint64_t	resp_buf_addr;
} hwrm_func_buf_rgtr_input_t, *phwrm_func_buf_rgtr_input_t;

/* hwrm_func_buf_rgtr_output (size:128b/16B) */

typedef struct hwrm_func_buf_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_buf_rgtr_output_t, *phwrm_func_buf_rgtr_output_t;

/************************
 * hwrm_func_buf_unrgtr *
 ************************/


/* hwrm_func_buf_unrgtr_input (size:192b/24B) */

typedef struct hwrm_func_buf_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_UNRGTR_INPUT_ENABLES_VF_ID	UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[2];
} hwrm_func_buf_unrgtr_input_t, *phwrm_func_buf_unrgtr_input_t;

/* hwrm_func_buf_unrgtr_output (size:128b/16B) */

typedef struct hwrm_func_buf_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_buf_unrgtr_output_t, *phwrm_func_buf_unrgtr_output_t;

/**********************
 * hwrm_func_drv_qver *
 **********************/


/* hwrm_func_drv_qver_input (size:192b/24B) */

typedef struct hwrm_func_drv_qver_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint32_t	reserved;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	/*
	 * This field is used to indicate the driver type.
	 * L2 or RoCE
	 */
	uint8_t	driver_type;
	/* L2 driver version */
	#define HWRM_FUNC_DRV_QVER_INPUT_DRIVER_TYPE_L2   UINT32_C(0x0)
	/* RoCE driver version */
	#define HWRM_FUNC_DRV_QVER_INPUT_DRIVER_TYPE_ROCE UINT32_C(0x1)
	#define HWRM_FUNC_DRV_QVER_INPUT_DRIVER_TYPE_LAST HWRM_FUNC_DRV_QVER_INPUT_DRIVER_TYPE_ROCE
	uint8_t	unused_0;
} hwrm_func_drv_qver_input_t, *phwrm_func_drv_qver_input_t;

/* hwrm_func_drv_qver_output (size:256b/32B) */

typedef struct hwrm_func_drv_qver_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value indicates the type of OS. The values are based on
	 * CIM_OperatingSystem.mof file as published by the DMTF.
	 */
	uint16_t	os_type;
	/* Unknown */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UNKNOWN   UINT32_C(0x0)
	/* Other OS not listed below. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_OTHER	UINT32_C(0x1)
	/* MSDOS OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_MSDOS	UINT32_C(0xe)
	/* Windows OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WINDOWS   UINT32_C(0x12)
	/* Solaris OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_SOLARIS   UINT32_C(0x1d)
	/* Linux OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_LINUX	UINT32_C(0x24)
	/* FreeBSD OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_FREEBSD   UINT32_C(0x2a)
	/* VMware ESXi OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_ESXI	UINT32_C(0x68)
	/* Microsoft Windows 8 64-bit OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WIN864	UINT32_C(0x73)
	/* Microsoft Windows Server 2012 R2 OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WIN2012R2 UINT32_C(0x74)
	/* UEFI driver. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UEFI	UINT32_C(0x8000)
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_LAST	HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UEFI
	/* This is the 8bit major version of the driver. */
	uint8_t	ver_maj_8b;
	/* This is the 8bit minor version of the driver. */
	uint8_t	ver_min_8b;
	/* This is the 8bit update version of the driver. */
	uint8_t	ver_upd_8b;
	uint8_t	unused_0[3];
	/* This is the 16bit major version of the driver. */
	uint16_t	ver_maj;
	/* This is the 16bit minor version of the driver. */
	uint16_t	ver_min;
	/* This is the 16bit update version of the driver. */
	uint16_t	ver_upd;
	/* This is the 16bit patch version of the driver. */
	uint16_t	ver_patch;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_drv_qver_output_t, *phwrm_func_drv_qver_output_t;

/****************************
 * hwrm_func_resource_qcaps *
 ****************************/


/* hwrm_func_resource_qcaps_input (size:192b/24B) */

typedef struct hwrm_func_resource_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_resource_qcaps_input_t, *phwrm_func_resource_qcaps_input_t;

/* hwrm_func_resource_qcaps_output (size:704b/88B) */

typedef struct hwrm_func_resource_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Maximum guaranteed number of VFs supported by PF. Not applicable for
	 * VFs.
	 */
	uint16_t	max_vfs;
	/* Maximum guaranteed number of MSI-X vectors supported by function. */
	uint16_t	max_msix;
	/*
	 * Hint of strategy to be used by PF driver to reserve resources for
	 * its VF.
	 */
	uint16_t	vf_reservation_strategy;
	/*
	 * The PF driver should evenly divide its remaining resources among
	 * all VFs.
	 */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MAXIMAL	UINT32_C(0x0)
	/* The PF driver should only reserve minimal resources for each VF. */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL	UINT32_C(0x1)
	/*
	 * The PF driver should not reserve any resources for each VF until
	 * the VF interface is brought up.
	 */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL_STATIC UINT32_C(0x2)
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_LAST	HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL_STATIC
	/* Minimum guaranteed number of RSS/COS contexts. */
	uint16_t	min_rsscos_ctx;
	/* Maximum non-guaranteed number of RSS/COS contexts */
	uint16_t	max_rsscos_ctx;
	/* Minimum guaranteed number of completion rings */
	uint16_t	min_cmpl_rings;
	/* Maximum non-guaranteed number of completion rings */
	uint16_t	max_cmpl_rings;
	/* Minimum guaranteed number of transmit rings */
	uint16_t	min_tx_rings;
	/* Maximum non-guaranteed number of transmit rings */
	uint16_t	max_tx_rings;
	/* Minimum guaranteed number of receive rings */
	uint16_t	min_rx_rings;
	/* Maximum non-guaranteed number of receive rings */
	uint16_t	max_rx_rings;
	/* Minimum guaranteed number of L2 contexts */
	uint16_t	min_l2_ctxs;
	/* Maximum non-guaranteed number of L2 contexts */
	uint16_t	max_l2_ctxs;
	/* Minimum guaranteed number of VNICs */
	uint16_t	min_vnics;
	/* Maximum non-guaranteed number of VNICs */
	uint16_t	max_vnics;
	/* Minimum guaranteed number of statistic contexts */
	uint16_t	min_stat_ctx;
	/* Maximum non-guaranteed number of statistic contexts */
	uint16_t	max_stat_ctx;
	/* Minimum guaranteed number of ring groups */
	uint16_t	min_hw_ring_grps;
	/* Maximum non-guaranteed number of ring groups */
	uint16_t	max_hw_ring_grps;
	/*
	 * Maximum number of inputs into the transmit scheduler for this
	 * function. The number of TX rings assigned to the function cannot
	 * exceed this value.
	 */
	uint16_t	max_tx_scheduler_inputs;
	uint16_t	flags;
	/*
	 * When this bit is '1', it indicates that VF_RESOURCE_CFG supports
	 * feature to reserve all minimum resources when minimum >= 1,
	 * otherwise returns an error.
	 */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_FLAGS_MIN_GUARANTEED	UINT32_C(0x1)
	/* Minimum guaranteed number of MSI-X vectors supported by function */
	uint16_t	min_msix;
	/* Minimum guaranteed number of KTLS Tx Key Contexts */
	uint32_t	min_ktls_tx_key_ctxs;
	/* Maximum non-guaranteed number of KTLS Tx Key Contexts */
	uint32_t	max_ktls_tx_key_ctxs;
	/* Minimum guaranteed number of KTLS Rx Key Contexts */
	uint32_t	min_ktls_rx_key_ctxs;
	/* Maximum non-guaranteed number of KTLS Rx Key Contexts */
	uint32_t	max_ktls_rx_key_ctxs;
	/* Minimum guaranteed number of QUIC Tx Key Contexts */
	uint32_t	min_quic_tx_key_ctxs;
	/* Maximum non-guaranteed number of QUIC Tx Key Contexts */
	uint32_t	max_quic_tx_key_ctxs;
	/* Minimum guaranteed number of QUIC Rx Key Contexts */
	uint32_t	min_quic_rx_key_ctxs;
	/* Maximum non-guaranteed number of QUIC Rx Key Contexts */
	uint32_t	max_quic_rx_key_ctxs;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_resource_qcaps_output_t, *phwrm_func_resource_qcaps_output_t;

/*****************************
 * hwrm_func_vf_resource_cfg *
 *****************************/


/* hwrm_func_vf_resource_cfg_input (size:704b/88B) */

typedef struct hwrm_func_vf_resource_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF ID that is being configured by PF */
	uint16_t	vf_id;
	/* Maximum guaranteed number of MSI-X vectors for the function */
	uint16_t	max_msix;
	/* Minimum guaranteed number of RSS/COS contexts */
	uint16_t	min_rsscos_ctx;
	/* Maximum non-guaranteed number of RSS/COS contexts */
	uint16_t	max_rsscos_ctx;
	/* Minimum guaranteed number of completion rings */
	uint16_t	min_cmpl_rings;
	/* Maximum non-guaranteed number of completion rings */
	uint16_t	max_cmpl_rings;
	/* Minimum guaranteed number of transmit rings */
	uint16_t	min_tx_rings;
	/* Maximum non-guaranteed number of transmit rings */
	uint16_t	max_tx_rings;
	/* Minimum guaranteed number of receive rings */
	uint16_t	min_rx_rings;
	/* Maximum non-guaranteed number of receive rings */
	uint16_t	max_rx_rings;
	/* Minimum guaranteed number of L2 contexts */
	uint16_t	min_l2_ctxs;
	/* Maximum non-guaranteed number of L2 contexts */
	uint16_t	max_l2_ctxs;
	/* Minimum guaranteed number of VNICs */
	uint16_t	min_vnics;
	/* Maximum non-guaranteed number of VNICs */
	uint16_t	max_vnics;
	/* Minimum guaranteed number of statistic contexts */
	uint16_t	min_stat_ctx;
	/* Maximum non-guaranteed number of statistic contexts */
	uint16_t	max_stat_ctx;
	/* Minimum guaranteed number of ring groups */
	uint16_t	min_hw_ring_grps;
	/* Maximum non-guaranteed number of ring groups */
	uint16_t	max_hw_ring_grps;
	uint16_t	flags;
	/*
	 * If this bit is set, all minimum resources requested should be
	 * reserved if minimum >= 1, otherwise return error. In case of
	 * error, keep all existing reservations before the call.
	 */
	#define HWRM_FUNC_VF_RESOURCE_CFG_INPUT_FLAGS_MIN_GUARANTEED	UINT32_C(0x1)
	/* Minimum guaranteed number of MSI-X vectors for the function */
	uint16_t	min_msix;
	/* Minimum guaranteed number of KTLS Tx Key Contexts */
	uint32_t	min_ktls_tx_key_ctxs;
	/* Maximum non-guaranteed number of KTLS Tx Key Contexts */
	uint32_t	max_ktls_tx_key_ctxs;
	/* Minimum guaranteed number of KTLS Rx Key Contexts */
	uint32_t	min_ktls_rx_key_ctxs;
	/* Maximum non-guaranteed number of KTLS Rx Key Contexts */
	uint32_t	max_ktls_rx_key_ctxs;
	/* Minimum guaranteed number of QUIC Tx Key Contexts */
	uint32_t	min_quic_tx_key_ctxs;
	/* Maximum non-guaranteed number of QUIC Tx Key Contexts */
	uint32_t	max_quic_tx_key_ctxs;
	/* Minimum guaranteed number of QUIC Rx Key Contexts */
	uint32_t	min_quic_rx_key_ctxs;
	/* Maximum non-guaranteed number of QUIC Rx Key Contexts */
	uint32_t	max_quic_rx_key_ctxs;
} hwrm_func_vf_resource_cfg_input_t, *phwrm_func_vf_resource_cfg_input_t;

/* hwrm_func_vf_resource_cfg_output (size:384b/48B) */

typedef struct hwrm_func_vf_resource_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved number of RSS/COS contexts */
	uint16_t	reserved_rsscos_ctx;
	/* Reserved number of completion rings */
	uint16_t	reserved_cmpl_rings;
	/* Reserved number of transmit rings */
	uint16_t	reserved_tx_rings;
	/* Reserved number of receive rings */
	uint16_t	reserved_rx_rings;
	/* Reserved number of L2 contexts */
	uint16_t	reserved_l2_ctxs;
	/* Reserved number of VNICs */
	uint16_t	reserved_vnics;
	/* Reserved number of statistic contexts */
	uint16_t	reserved_stat_ctx;
	/* Reserved number of ring groups */
	uint16_t	reserved_hw_ring_grps;
	/* Actual number of KTLS Tx Key Contexts reserved */
	uint32_t	reserved_ktls_tx_key_ctxs;
	/* Actual number of KTLS Rx Key Contexts reserved */
	uint32_t	reserved_ktls_rx_key_ctxs;
	/* Actual number of QUIC Tx Key Contexts reserved */
	uint32_t	reserved_quic_tx_key_ctxs;
	/* Actual number of QUIC Rx Key Contexts reserved */
	uint32_t	reserved_quic_rx_key_ctxs;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_resource_cfg_output_t, *phwrm_func_vf_resource_cfg_output_t;

/*********************************
 * hwrm_func_backing_store_qcaps *
 *********************************/


/* hwrm_func_backing_store_qcaps_input (size:128b/16B) */

typedef struct hwrm_func_backing_store_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_backing_store_qcaps_input_t, *phwrm_func_backing_store_qcaps_input_t;

/* hwrm_func_backing_store_qcaps_output (size:832b/104B) */

typedef struct hwrm_func_backing_store_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Maximum number of QP context entries supported for this function. */
	uint32_t	qp_max_entries;
	/*
	 * Minimum number of QP context entries that are needed to be reserved
	 * for QP1 for the PF and its VFs. PF drivers must allocate at least
	 * this many QP context entries, even if RoCE will not be used.
	 */
	uint16_t	qp_min_qp1_entries;
	/*
	 * Maximum number of QP context entries that can be used for L2 and
	 * mid-path.
	 */
	uint16_t	qp_max_l2_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	qp_entry_size;
	/* Maximum number of SRQ context entries that can be used for L2. */
	uint16_t	srq_max_l2_entries;
	/* Maximum number of SRQ context entries supported for this function. */
	uint32_t	srq_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	srq_entry_size;
	/* Maximum number of CQ context entries that can be used for L2. */
	uint16_t	cq_max_l2_entries;
	/* Maximum number of CQ context entries supported for this function. */
	uint32_t	cq_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	cq_entry_size;
	/* Maximum number of VNIC context entries supported for this function. */
	uint16_t	vnic_max_vnic_entries;
	/*
	 * Maximum number of Ring table context entries supported for this
	 * function.
	 */
	uint16_t	vnic_max_ring_table_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	vnic_entry_size;
	/*
	 * Maximum number of statistic context entries supported for this
	 * function.
	 */
	uint32_t	stat_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	stat_entry_size;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	tqm_entry_size;
	/* Minimum number of TQM context entries required per ring. */
	uint32_t	tqm_min_entries_per_ring;
	/*
	 * Maximum number of TQM context entries supported per ring. This is
	 * actually a recommended TQM queue size based on worst case usage of
	 * the TQM queue.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * TQM slowpath rings should be sized as follows:
	 *
	 * num_entries = num_vnics + num_l2_tx_rings + 2 * num_roce_qps + tqm_min_size
	 *
	 * Where:
	 *   num_vnics is the number of VNICs allocated in the VNIC backing
	 *   store
	 *   num_l2_tx_rings is the number of L2 rings in the QP backing store
	 *   num_roce_qps is the number of RoCE QPs in the QP backing store
	 *   tqm_min_size is tqm_min_entries_per_ring reported by
	 *	HWRM_FUNC_BACKING_STORE_QCAPS
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_max_entries_per_ring;
	/*
	 * Maximum number of MR plus AV context entries supported for this
	 * function.
	 */
	uint32_t	mrav_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	mrav_entry_size;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	tim_entry_size;
	/* Maximum number of Timer context entries supported for this function. */
	uint32_t	tim_max_entries;
	/*
	 * When this field is zero, the 32b `mrav_num_entries` field in the
	 * `backing_store_cfg` and `backing_store_qcfg` commands represents
	 * the total number of MR plus AV entries allowed in the MR/AV backing
	 * store PBL.
	 *
	 * When this field is non-zero, the 32b `mrav_num_entries` field in
	 * the `backing_store_cfg` and `backing_store_qcfg` commands is
	 * logically divided into two 16b fields. Bits `[31:16]` represents
	 * the `mr_num_entries` and bits `[15:0]` represents `av_num_entries`.
	 * Both of these values are represented in a unit granularity
	 * specified by this field. For example, if this field is 16 and
	 * `mrav_num_entries` is `0x02000100`, then the number of MR entries
	 * is 8192 and the number of AV entries is 4096.
	 */
	uint16_t	mrav_num_entries_units;
	/*
	 * The number of entries specified for any TQM ring must be a
	 * multiple of this value to prevent any resource allocation
	 * limitations.
	 */
	uint8_t	tqm_entries_multiple;
	/*
	 * Initializer to be used by drivers
	 * to initialize context memory to ensure
	 * context subsystem flags an error for an attack
	 * before the first time context load.
	 */
	uint8_t	ctx_kind_initializer;
	/*
	 * Specifies which context kinds need to be initialized with the
	 * ctx_kind_initializer.
	 */
	uint16_t	ctx_init_mask;
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_QP	UINT32_C(0x1)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_SRQ	UINT32_C(0x2)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_CQ	UINT32_C(0x4)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_VNIC	UINT32_C(0x8)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_STAT	UINT32_C(0x10)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_MRAV	UINT32_C(0x20)
	/*
	 * If this bit is '1' then the Tx KTLS context type should be
	 * initialized with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_TKC	UINT32_C(0x40)
	/*
	 * If this bit is '1' then the Rx KTLS context type should be
	 * initialized with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_RKC	UINT32_C(0x80)
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	qp_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	srq_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	cq_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	vnic_init_offset;
	/*
	 * Count of TQM fastpath rings to be used for allocating backing store.
	 * Backing store configuration must be specified for each TQM ring from
	 * this count in `backing_store_cfg`.
	 * Only first 8 TQM FP rings will be advertised with this field.
	 */
	uint8_t	tqm_fp_rings_count;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	stat_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	mrav_init_offset;
	/*
	 * Count of TQM extended fastpath rings to be used for allocating
	 * backing store beyond 8 rings(rings 9,10,11)
	 * Backing store configuration must be specified for each TQM ring from
	 * this count in `backing_store_cfg`.
	 */
	uint8_t	tqm_fp_rings_count_ext;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for Tx
	 * KTLS context type.
	 */
	uint8_t	tkc_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for Rx
	 * KTLS context type.
	 */
	uint8_t	rkc_init_offset;
	/* Tx KTLS context entry size in bytes. */
	uint16_t	tkc_entry_size;
	/* Rx KTLS context entry size in bytes. */
	uint16_t	rkc_entry_size;
	/*
	 * Maximum number of Tx KTLS context entries supported for this
	 * function.
	 */
	uint32_t	tkc_max_entries;
	/*
	 * Maximum number of Rx KTLS context entries supported for this
	 * function.
	 */
	uint32_t	rkc_max_entries;
	/*
	 * Additional number of RoCE QP context entries required for this
	 * function to support fast QP destroy feature.
	 */
	uint16_t	fast_qpmd_qp_num_entries;
	/* Reserved for future. */
	uint8_t	rsvd1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_qcaps_output_t, *phwrm_func_backing_store_qcaps_output_t;

/* tqm_fp_ring_cfg (size:128b/16B) */

typedef struct tqm_fp_ring_cfg {
	/* TQM ring page size and level. */
	uint8_t	tqm_ring_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LAST	TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_LAST   TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_1G
	uint8_t	unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring_page_dir;
} tqm_fp_ring_cfg_t, *ptqm_fp_ring_cfg_t;

/*******************************
 * hwrm_func_backing_store_cfg *
 *******************************/


/* hwrm_func_backing_store_cfg_input (size:2688b/336B) */

typedef struct hwrm_func_backing_store_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set, the firmware only uses on-chip resources and does not
	 * expect any backing store to be provided by the host driver. This
	 * mode provides minimal L2 functionality (e.g. limited L2 resources,
	 * no RoCE).
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_FLAGS_PREBOOT_MODE		UINT32_C(0x1)
	/*
	 * When set, the 32b `mrav_num_entries` field is logically divided
	 * into two 16b fields, `mr_num_entries` and `av_num_entries`.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_FLAGS_MRAV_RESERVATION_SPLIT	UINT32_C(0x2)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the qp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_QP		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the srq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_SRQ		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_CQ		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vnic fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_VNIC		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stat fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_STAT		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_sp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_SP	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING0	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING1	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING2	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING3	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING4	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING5	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING6	UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING7	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the mrav fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_MRAV		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the tim fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TIM		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the tqm_ring8 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING8	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the tqm_ring9 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING9	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the tqm_ring10 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING10	UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the Tx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TKC		UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the Rx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_RKC		UINT32_C(0x100000)
	/*
	 * This bit must be '1' for the number of QPs reserved for fast
	 * qp modify destroy feature to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_QP_FAST_QPMD	UINT32_C(0x200000)
	/* QPC page size and level. */
	uint8_t	qpc_pg_size_qpc_lvl;
	/* QPC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_2
	/* QPC page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_1G
	/* SRQ page size and level. */
	uint8_t	srq_pg_size_srq_lvl;
	/* SRQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_2
	/* SRQ page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_1G
	/* CQ page size and level. */
	uint8_t	cq_pg_size_cq_lvl;
	/* CQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_2
	/* CQ page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_1G
	/* VNIC page size and level. */
	uint8_t	vnic_pg_size_vnic_lvl;
	/* VNIC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_2
	/* VNIC page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_1G
	/* Stat page size and level. */
	uint8_t	stat_pg_size_stat_lvl;
	/* Stat PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_2
	/* Stat page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_1G
	/* TQM slow path page size and level. */
	uint8_t	tqm_sp_pg_size_tqm_sp_lvl;
	/* TQM slow path PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_2
	/* TQM slow path page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_1G
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_1G
	/* MR/AV page size and level. */
	uint8_t	mrav_pg_size_mrav_lvl;
	/* MR/AV PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_2
	/* MR/AV page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_1G
	/* Timer page size and level. */
	uint8_t	tim_pg_size_tim_lvl;
	/* Timer PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_2
	/* Timer page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_1G
	/* QP page directory. */
	uint64_t	qpc_page_dir;
	/* SRQ page directory. */
	uint64_t	srq_page_dir;
	/* CQ page directory. */
	uint64_t	cq_page_dir;
	/* VNIC page directory. */
	uint64_t	vnic_page_dir;
	/* Stat page directory. */
	uint64_t	stat_page_dir;
	/* TQM slowpath page directory. */
	uint64_t	tqm_sp_page_dir;
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/* MR/AV page directory. */
	uint64_t	mrav_page_dir;
	/* Timer page directory. */
	uint64_t	tim_page_dir;
	/* Number of QPs. */
	uint32_t	qp_num_entries;
	/* Number of SRQs. */
	uint32_t	srq_num_entries;
	/* Number of CQs. */
	uint32_t	cq_num_entries;
	/* Number of Stats. */
	uint32_t	stat_num_entries;
	/*
	 * Number of TQM slowpath entries.
	 *
	 * TQM slowpath rings should be sized as follows:
	 *
	 * num_entries = num_vnics + num_l2_tx_rings + 2 * num_roce_qps + tqm_min_size
	 *
	 * Where:
	 *   num_vnics is the number of VNICs allocated in the VNIC backing
	 *   store num_l2_tx_rings is the number of L2 rings in the QP backing
	 *   store num_roce_qps is the number of RoCE QPs in the QP backing
	 *   store tqm_min_size is tqm_min_entries_per_ring reported by
	 *   HWRM_FUNC_BACKING_STORE_QCAPS
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_sp_num_entries;
	/*
	 * Number of TQM ring 0 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring0_num_entries;
	/*
	 * Number of TQM ring 1 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring1_num_entries;
	/*
	 * Number of TQM ring 2 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring2_num_entries;
	/*
	 * Number of TQM ring 3 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring3_num_entries;
	/*
	 * Number of TQM ring 4 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring4_num_entries;
	/*
	 * Number of TQM ring 5 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring5_num_entries;
	/*
	 * Number of TQM ring 6 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring6_num_entries;
	/*
	 * Number of TQM ring 7 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring7_num_entries;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries. For versions
	 * of firmware that support the split reservation, when it is not
	 * specified half of the entries will be reserved for MRs and the
	 * other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `mr_num_entries` and bits `[15:0]` represents
	 * `av_num_entries`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 */
	uint32_t	mrav_num_entries;
	/* Number of Timer entries. */
	uint32_t	tim_num_entries;
	/* Number of entries to reserve for QP1 */
	uint16_t	qp_num_qp1_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	qp_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	qp_entry_size;
	/* Number of entries to reserve for L2 */
	uint16_t	srq_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	srq_entry_size;
	/* Number of entries to reserve for L2 */
	uint16_t	cq_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	cq_entry_size;
	/* Number of entries to reserve for VNIC entries */
	uint16_t	vnic_num_vnic_entries;
	/* Number of entries to reserve for Ring table entries */
	uint16_t	vnic_num_ring_table_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	vnic_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	stat_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tqm_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	mrav_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tim_entry_size;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring8_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring8_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring8_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring8_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring9_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring9_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring9_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring9_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring10_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring10_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring10_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring10_page_dir;
	/* Number of Tx KTLS context entries allocated. */
	uint32_t	tkc_num_entries;
	/* Number of Rx KTLS context entries allocated. */
	uint32_t	rkc_num_entries;
	/* Tx KTLS context page directory. */
	uint64_t	tkc_page_dir;
	/* Rx KTLS context page directory. */
	uint64_t	rkc_page_dir;
	/* Number of bytes allocated for each Tx KTLS context entry. */
	uint16_t	tkc_entry_size;
	/* Number of bytes allocated for each Rx KTLS context entry. */
	uint16_t	rkc_entry_size;
	/* Tx KTLS context page size and level. */
	uint8_t	tkc_pg_size_tkc_lvl;
	/* Tx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_2
	/* Tx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_1G
	/* Rx KTLS context page size and level. */
	uint8_t	rkc_pg_size_rkc_lvl;
	/* Rx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_2
	/* Rx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_1G
	/*
	 * Number of RoCE QP context entries reserved for this
	 * function to support fast QP modify destroy feature.
	 */
	uint16_t	qp_num_fast_qpmd_entries;
} hwrm_func_backing_store_cfg_input_t, *phwrm_func_backing_store_cfg_input_t;

/* hwrm_func_backing_store_cfg_output (size:128b/16B) */

typedef struct hwrm_func_backing_store_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_cfg_output_t, *phwrm_func_backing_store_cfg_output_t;

/********************************
 * hwrm_func_backing_store_qcfg *
 ********************************/


/* hwrm_func_backing_store_qcfg_input (size:128b/16B) */

typedef struct hwrm_func_backing_store_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_backing_store_qcfg_input_t, *phwrm_func_backing_store_qcfg_input_t;

/* hwrm_func_backing_store_qcfg_output (size:2496b/312B) */

typedef struct hwrm_func_backing_store_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When set, the firmware only uses on-chip resources and does not
	 * expect any backing store to be provided by the host driver. This
	 * mode provides minimal L2 functionality (e.g. limited L2 resources,
	 * no RoCE).
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_FLAGS_PREBOOT_MODE		UINT32_C(0x1)
	/*
	 * When set, the 32b `mrav_num_entries` field is logically divided
	 * into two 16b fields, `mr_num_entries` and `av_num_entries`.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_FLAGS_MRAV_RESERVATION_SPLIT	UINT32_C(0x2)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the qp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_QP		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the srq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_SRQ		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_CQ		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vnic fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_VNIC		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stat fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_STAT		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_sp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_SP	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING0	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING1	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING2	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING3	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING4	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING5	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING6	UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING7	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the mrav fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_MRAV		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the tim fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TIM		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the tqm_ring8 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING8	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the tqm_ring9 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING9	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the tqm_ring10 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING10	UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the Tx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TKC		UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the Rx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_RKC		UINT32_C(0x100000)
	/*
	 * This bit must be '1' for the number of QPs reserved for fast
	 * qp modify destroy feature to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_QP_FAST_QPMD	UINT32_C(0x200000)
	/* QPC page size and level. */
	uint8_t	qpc_pg_size_qpc_lvl;
	/* QPC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_2
	/* QPC page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_1G
	/* SRQ page size and level. */
	uint8_t	srq_pg_size_srq_lvl;
	/* SRQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_2
	/* SRQ page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_1G
	/* CQ page size and level. */
	uint8_t	cq_pg_size_cq_lvl;
	/* CQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_2
	/* CQ page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_1G
	/* VNIC page size and level. */
	uint8_t	vnic_pg_size_vnic_lvl;
	/* VNIC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_2
	/* VNIC page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_1G
	/* Stat page size and level. */
	uint8_t	stat_pg_size_stat_lvl;
	/* Stat PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_2
	/* Stat page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_1G
	/* TQM slow path page size and level. */
	uint8_t	tqm_sp_pg_size_tqm_sp_lvl;
	/* TQM slow path PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_2
	/* TQM slow path page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_1G
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_1G
	/* MR/AV page size and level. */
	uint8_t	mrav_pg_size_mrav_lvl;
	/* MR/AV PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_2
	/* MR/AV page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_1G
	/* Timer page size and level. */
	uint8_t	tim_pg_size_tim_lvl;
	/* Timer PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_2
	/* Timer page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_1G
	/* QP page directory. */
	uint64_t	qpc_page_dir;
	/* SRQ page directory. */
	uint64_t	srq_page_dir;
	/* CQ page directory. */
	uint64_t	cq_page_dir;
	/* VNIC page directory. */
	uint64_t	vnic_page_dir;
	/* Stat page directory. */
	uint64_t	stat_page_dir;
	/* TQM slowpath page directory. */
	uint64_t	tqm_sp_page_dir;
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/* MR/AV page directory. */
	uint64_t	mrav_page_dir;
	/* Timer page directory. */
	uint64_t	tim_page_dir;
	/* Number of entries to reserve for QP1 */
	uint16_t	qp_num_qp1_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	qp_num_l2_entries;
	/* Number of QPs. */
	uint32_t	qp_num_entries;
	/* Number of SRQs. */
	uint32_t	srq_num_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	srq_num_l2_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	cq_num_l2_entries;
	/* Number of CQs. */
	uint32_t	cq_num_entries;
	/* Number of entries to reserve for VNIC entries */
	uint16_t	vnic_num_vnic_entries;
	/* Number of entries to reserve for Ring table entries */
	uint16_t	vnic_num_ring_table_entries;
	/* Number of Stats. */
	uint32_t	stat_num_entries;
	/* Number of TQM slowpath entries. */
	uint32_t	tqm_sp_num_entries;
	/* Number of TQM ring 0 entries. */
	uint32_t	tqm_ring0_num_entries;
	/* Number of TQM ring 1 entries. */
	uint32_t	tqm_ring1_num_entries;
	/* Number of TQM ring 2 entries. */
	uint32_t	tqm_ring2_num_entries;
	/* Number of TQM ring 3 entries. */
	uint32_t	tqm_ring3_num_entries;
	/* Number of TQM ring 4 entries. */
	uint32_t	tqm_ring4_num_entries;
	/* Number of TQM ring 5 entries. */
	uint32_t	tqm_ring5_num_entries;
	/* Number of TQM ring 6 entries. */
	uint32_t	tqm_ring6_num_entries;
	/* Number of TQM ring 7 entries. */
	uint32_t	tqm_ring7_num_entries;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries. For versions
	 * of firmware that support the split reservation, when it is not
	 * specified half of the entries will be reserved for MRs and the
	 * other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `mr_num_entries` and bits `[15:0]` represents
	 * `av_num_entries`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 */
	uint32_t	mrav_num_entries;
	/* Number of Timer entries. */
	uint32_t	tim_num_entries;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring8_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring8_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring8_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring8_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring9_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring9_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring9_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring9_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring10_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring10_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring10_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring10_page_dir;
	/* Number of Tx KTLS context entries. */
	uint32_t	tkc_num_entries;
	/* Number of Rx KTLS context entries. */
	uint32_t	rkc_num_entries;
	/* Tx KTLS context page directory. */
	uint64_t	tkc_page_dir;
	/* Rx KTLS context page directory. */
	uint64_t	rkc_page_dir;
	/* Tx KTLS context page size and level. */
	uint8_t	tkc_pg_size_tkc_lvl;
	/* Tx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_2
	/* Tx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_1G
	/* Rx KTLS context page size and level. */
	uint8_t	rkc_pg_size_rkc_lvl;
	/* Rx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_2
	/* Rx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_1G
	/*
	 * Number of RoCE QP context entries required for this
	 * function to support fast QP modify destroy feature.
	 */
	uint16_t	qp_num_fast_qpmd_entries;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as 1
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_qcfg_output_t, *phwrm_func_backing_store_qcfg_output_t;

/****************************
 * hwrm_error_recovery_qcfg *
 ****************************/


/* hwrm_error_recovery_qcfg_input (size:192b/24B) */

typedef struct hwrm_error_recovery_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} hwrm_error_recovery_qcfg_input_t, *phwrm_error_recovery_qcfg_input_t;

/* hwrm_error_recovery_qcfg_output (size:1664b/208B) */

typedef struct hwrm_error_recovery_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this flag is set to 1, error recovery will be initiated
	 * through master function driver.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FLAGS_HOST	UINT32_C(0x1)
	/*
	 * When this flag is set to 1, error recovery will be performed
	 * through Co processor.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FLAGS_CO_CPU	UINT32_C(0x2)
	/*
	 * Driver Polling frequency. This value is in units of 100msec.
	 * Typical value would be 10 to indicate 1sec.
	 * Drivers can poll FW health status, Heartbeat, reset_counter with
	 * this frequency.
	 */
	uint32_t	driver_polling_freq;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 30 to indicate 3sec.
	 * Master function wait period from detecting a fatal error to
	 * initiating reset. In this time period Master PF expects every
	 * active driver will detect fatal error.
	 */
	uint32_t	master_func_wait_period;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 50 to indicate 5sec.
	 * Normal function wait period from fatal error detection to
	 * polling FW health status. In this time period, drivers should not
	 * do any PCIe MMIO transaction and should not send any HWRM commands.
	 */
	uint32_t	normal_func_wait_period;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 20 to indicate 2sec.
	 * This field indicates that, master function wait period after chip
	 * reset. After this time, master function should reinitialize with
	 * FW.
	 */
	uint32_t	master_func_wait_period_after_reset;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 60 to indicate 6sec.
	 * This field is applicable to both master and normal functions.
	 * Even after chip reset, if FW status not changed to ready,
	 * then all the functions can poll for this much time and bailout.
	 */
	uint32_t	max_bailout_time_after_reset;
	/*
	 * FW health status register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates upper 30bits of the register address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_health_status_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SFT	2
	/*
	 * FW HeartBeat register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_heartbeat_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SFT	2
	/*
	 * FW reset counter.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_reset_cnt_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SFT	2
	/*
	 * Reset Inprogress Register address for PFs.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	reset_inprogress_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SFT	2
	/* This field indicates the mask value for reset_inprogress_reg. */
	uint32_t	reset_inprogress_reg_mask;
	uint8_t	unused_0[3];
	/*
	 * Array of registers and value count to reset the Chip
	 * Each array count has reset_reg, reset_reg_val, delay_after_reset
	 * in TLV format. Depending upon Chip type, number of reset registers
	 * will vary. Drivers have to write reset_reg_val in the reset_reg
	 * location in the same sequence in order to recover from a fatal
	 * error.
	 */
	uint8_t	reg_array_cnt;
	/*
	 * Reset register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	reset_reg[16];
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SFT	2
	/* Value to be written in reset_reg to reset the controller. */
	uint32_t	reset_reg_val[16];
	/*
	 * This value is in units of 1msec.
	 * Typical value would be 10 to indicate 10msec.
	 * Some of the operations like Core reset require delay before
	 * accessing PCIE MMIO register space.
	 * If this value is non-zero, drivers have to wait for
	 * this much time after writing reset_reg_val in reset_reg.
	 */
	uint8_t	delay_after_reset[16];
	/*
	 * Error recovery counter.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	err_recovery_cnt_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SFT	2
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_error_recovery_qcfg_output_t, *phwrm_error_recovery_qcfg_output_t;

/***************************
 * hwrm_func_echo_response *
 ***************************/


/* hwrm_func_echo_response_input (size:192b/24B) */

typedef struct hwrm_func_echo_response_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	event_data1;
	uint32_t	event_data2;
} hwrm_func_echo_response_input_t, *phwrm_func_echo_response_input_t;

/* hwrm_func_echo_response_output (size:128b/16B) */

typedef struct hwrm_func_echo_response_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_echo_response_output_t, *phwrm_func_echo_response_output_t;

/**************************
 * hwrm_func_ptp_pin_qcfg *
 **************************/


/* hwrm_func_ptp_pin_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_ptp_pin_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} hwrm_func_ptp_pin_qcfg_input_t, *phwrm_func_ptp_pin_qcfg_input_t;

/* hwrm_func_ptp_pin_qcfg_output (size:128b/16B) */

typedef struct hwrm_func_ptp_pin_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of TSIO pins that are configured on this board
	 * Up to 4 pins can be returned in the response.
	 */
	uint8_t	num_pins;
	/* Pin state */
	uint8_t	state;
	/*
	 * When this bit is '1', TSIO pin 0 is enabled.
	 * When this bit is '0', TSIO pin 0 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN0_ENABLED	UINT32_C(0x1)
	/*
	 * When this bit is '1', TSIO pin 1 is enabled.
	 * When this bit is '0', TSIO pin 1 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN1_ENABLED	UINT32_C(0x2)
	/*
	 * When this bit is '1', TSIO pin 2 is enabled.
	 * When this bit is '0', TSIO pin 2 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN2_ENABLED	UINT32_C(0x4)
	/*
	 * When this bit is '1', TSIO pin 3 is enabled.
	 * When this bit is '0', TSIO pin 3 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN3_ENABLED	UINT32_C(0x8)
	/* Type of function for Pin #0. */
	uint8_t	pin0_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_LAST	HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_OUT
	/* Type of function for Pin #1. */
	uint8_t	pin1_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_LAST	HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_OUT
	/* Type of function for Pin #2. */
	uint8_t	pin2_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_NONE			UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_PPS_IN			UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_PPS_OUT		UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNC_IN		UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNC_OUT		UINT32_C(0x4)
	/* SYNCE primary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNCE_PRIMARY_CLOCK_OUT   UINT32_C(0x5)
	/* SYNCE secondary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNCE_SECONDARY_CLOCK_OUT UINT32_C(0x6)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_LAST			HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNCE_SECONDARY_CLOCK_OUT
	/* Type of function for Pin #3. */
	uint8_t	pin3_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_NONE			UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_PPS_IN			UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_PPS_OUT		UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNC_IN		UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNC_OUT		UINT32_C(0x4)
	/* SYNCE primary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNCE_PRIMARY_CLOCK_OUT   UINT32_C(0x5)
	/* SYNCE secondary OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNCE_SECONDARY_CLOCK_OUT UINT32_C(0x6)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_LAST			HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNCE_SECONDARY_CLOCK_OUT
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_pin_qcfg_output_t, *phwrm_func_ptp_pin_qcfg_output_t;

/*************************
 * hwrm_func_ptp_pin_cfg *
 *************************/


/* hwrm_func_ptp_pin_cfg_input (size:256b/32B) */

typedef struct hwrm_func_ptp_pin_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pin0_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN0_STATE	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pin0_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN0_USAGE	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the pin1_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN1_STATE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the pin1_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN1_USAGE	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the pin2_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN2_STATE	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the pin2_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN2_USAGE	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the pin3_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN3_STATE	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the pin3_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN3_USAGE	UINT32_C(0x80)
	/* Enable or disable functionality of Pin #0. */
	uint8_t	pin0_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_ENABLED
	/* Configure function for TSIO pin#0. */
	uint8_t	pin0_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_OUT
	/* Enable or disable functionality of Pin #1. */
	uint8_t	pin1_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_ENABLED
	/* Configure function for TSIO pin#1. */
	uint8_t	pin1_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_OUT
	/* Enable or disable functionality of Pin #2. */
	uint8_t	pin2_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_ENABLED
	/* Configure function for TSIO pin#2. */
	uint8_t	pin2_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_NONE			UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_PPS_IN			UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_PPS_OUT		UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNC_IN		UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNC_OUT		UINT32_C(0x4)
	/* SYNCE primary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNCE_PRIMARY_CLOCK_OUT   UINT32_C(0x5)
	/* SYNCE secondary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNCE_SECONDARY_CLOCK_OUT UINT32_C(0x6)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_LAST			HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNCE_SECONDARY_CLOCK_OUT
	/* Enable or disable functionality of Pin #3. */
	uint8_t	pin3_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_ENABLED
	/* Configure function for TSIO pin#3. */
	uint8_t	pin3_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_NONE			UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_PPS_IN			UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_PPS_OUT		UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNC_IN		UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNC_OUT		UINT32_C(0x4)
	/* SYNCE primary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNCE_PRIMARY_CLOCK_OUT   UINT32_C(0x5)
	/* SYNCE secondary clock OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNCE_SECONDARY_CLOCK_OUT UINT32_C(0x6)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_LAST			HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNCE_SECONDARY_CLOCK_OUT
	uint8_t	unused_0[4];
} hwrm_func_ptp_pin_cfg_input_t, *phwrm_func_ptp_pin_cfg_input_t;

/* hwrm_func_ptp_pin_cfg_output (size:128b/16B) */

typedef struct hwrm_func_ptp_pin_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_pin_cfg_output_t, *phwrm_func_ptp_pin_cfg_output_t;

/*********************
 * hwrm_func_ptp_cfg *
 *********************/


/* hwrm_func_ptp_cfg_input (size:384b/48B) */

typedef struct hwrm_func_ptp_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/*
	 * This bit must be '1' for the ptp_pps_event field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_PPS_EVENT		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ptp_freq_adj_dll_source field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_DLL_SOURCE	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the ptp_freq_adj_dll_phase field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_DLL_PHASE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_period field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_PERIOD	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_up field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_UP	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_phase field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_PHASE	UINT32_C(0x20)
	/* This bit must be '1' for ptp_set_time field to be configured. */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_SET_TIME		UINT32_C(0x40)
	/* This field is used to enable interrupt for a specific PPS event. */
	uint8_t	ptp_pps_event;
	/*
	 * When this bit is set to '1', interrupt is enabled for internal
	 * PPS event. Latches timestamp on PPS_OUT TSIO Pin. If user does
	 * not configure PPS_OUT on a TSIO pin, then firmware will allocate
	 * PPS_OUT to an unallocated pin.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_PPS_EVENT_INTERNAL	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', interrupt is enabled for external
	 * PPS event. Latches timestamp on PPS_IN TSIO pin.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_PPS_EVENT_EXTERNAL	UINT32_C(0x2)
	/*
	 * This field is used to set the source signal used to discipline
	 * PHC (PTP Hardware Clock)
	 */
	uint8_t	ptp_freq_adj_dll_source;
	/* No source is selected. Use servo to discipline PHC */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_NONE	UINT32_C(0x0)
	/* TSIO Pin #0 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_0  UINT32_C(0x1)
	/* TSIO Pin #1 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_1  UINT32_C(0x2)
	/* TSIO Pin #2 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_2  UINT32_C(0x3)
	/* TSIO Pin #3 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_3  UINT32_C(0x4)
	/* Port #0 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_0  UINT32_C(0x5)
	/* Port #1 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_1  UINT32_C(0x6)
	/* Port #2 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_2  UINT32_C(0x7)
	/* Port #3 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_3  UINT32_C(0x8)
	/* Invalid signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_INVALID UINT32_C(0xff)
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_LAST   HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_INVALID
	/*
	 * This field is used to provide phase adjustment for DLL
	 * used to discipline PHC (PTP Hardware clock)
	 */
	uint8_t	ptp_freq_adj_dll_phase;
	/* No Phase adjustment. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_NONE UINT32_C(0x0)
	/* 4Khz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_4K   UINT32_C(0x1)
	/* 8Khz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_8K   UINT32_C(0x2)
	/* 10Mhz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_10M  UINT32_C(0x3)
	/* 25Mhz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_25M  UINT32_C(0x4)
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_LAST HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_25M
	uint8_t	unused_0[3];
	/*
	 * Period in nanoseconds (ns) for external signal
	 * input.
	 */
	uint32_t	ptp_freq_adj_ext_period;
	/*
	 * Up time in nanoseconds (ns) of the duty cycle
	 * of the external signal. This value should be
	 * less than ptp_freq_adj_ext_period.
	 */
	uint32_t	ptp_freq_adj_ext_up;
	/*
	 * Phase value is provided. This field provides the
	 * least significant 32 bits of the phase input. The
	 * most significant 16 bits come from
	 * ptp_freq_adj_ext_phase_upper field. Setting this
	 * field requires setting ptp_freq_adj_ext_period
	 * field as well to identify the external signal
	 * pin.
	 */
	uint32_t	ptp_freq_adj_ext_phase_lower;
	/*
	 * Phase value is provided. The lower 16 bits of this field is used
	 * with the 32 bit value from ptp_freq_adj_ext_phase_lower
	 * to provide a 48 bit value input for Phase.
	 */
	uint32_t	ptp_freq_adj_ext_phase_upper;
	/*
	 * Allows driver to set the full 64bit time in FW. The upper 16 bits
	 * will be stored in FW and the lower 48bits will be programmed in
	 * PHC. Firmware will send a broadcast async event to all functions
	 * to indicate the programmed upper 16 bits.
	 */
	uint64_t	ptp_set_time;
} hwrm_func_ptp_cfg_input_t, *phwrm_func_ptp_cfg_input_t;

/* hwrm_func_ptp_cfg_output (size:128b/16B) */

typedef struct hwrm_func_ptp_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_cfg_output_t, *phwrm_func_ptp_cfg_output_t;

/**************************
 * hwrm_func_ptp_ts_query *
 **************************/


/* hwrm_func_ptp_ts_query_input (size:192b/24B) */

typedef struct hwrm_func_ptp_ts_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If set, the response includes PPS event timestamps */
	#define HWRM_FUNC_PTP_TS_QUERY_INPUT_FLAGS_PPS_TIME	UINT32_C(0x1)
	/* If set, the response includes PTM timestamps */
	#define HWRM_FUNC_PTP_TS_QUERY_INPUT_FLAGS_PTM_TIME	UINT32_C(0x2)
	uint8_t	unused_0[4];
} hwrm_func_ptp_ts_query_input_t, *phwrm_func_ptp_ts_query_input_t;

/* hwrm_func_ptp_ts_query_output (size:320b/40B) */

typedef struct hwrm_func_ptp_ts_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Timestamp value of last PPS event latched. */
	uint64_t	pps_event_ts;
	/*
	 * PHC timestamp value when PTM responseD request is received
	 * at downstream port (t4'). This is a 48 bit timestamp in nanoseconds.
	 */
	uint64_t	ptm_local_ts;
	/*
	 * PTM System timestamp value corresponding to t4' at
	 * root complex (T4'). Together with ptm_local_ts, these
	 * two timestamps provide the cross-trigger timestamps.
	 * Driver can directly use these values for cross-trigger.
	 * This is a 48 bit timestamp in nanoseconds.
	 */
	uint64_t	ptm_system_ts;
	/*
	 * PTM Link delay. This is the time taken at root complex (RC)
	 * between receiving PTM request and sending PTM response to
	 * downstream port. This is a 32 bit value in nanoseconds.
	 */
	uint32_t	ptm_link_delay;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_ts_query_output_t, *phwrm_func_ptp_ts_query_output_t;

/*************************
 * hwrm_func_ptp_ext_cfg *
 *************************/


/* hwrm_func_ptp_ext_cfg_input (size:256b/32B) */

typedef struct hwrm_func_ptp_ext_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/*
	 * This bit must be '1' for the phc_master_fid field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_ENABLES_PHC_MASTER_FID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the phc_sec_fid field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_ENABLES_PHC_SEC_FID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the phc_sec_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_ENABLES_PHC_SEC_MODE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the failover_timer field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_ENABLES_FAILOVER_TIMER	UINT32_C(0x8)
	/*
	 * This field is used to configure the Master function. Only this
	 * function can modify or condition the PHC. Only driver calls from
	 * this function are allowed to adjust frequency of PHC or configure
	 * PPS functionality.
	 * If driver does not specify this FID, then firmware will auto select
	 * the first function that makes the call to modify PHC as the Master.
	 */
	uint16_t	phc_master_fid;
	/*
	 * This field is used to configure the secondary function. This
	 * function becomes the Master function in case of failover from
	 * Master function.
	 * If driver does not specify this FID, firmware will auto select
	 * the last non-master function to make a call to condition PHC as
	 * secondary.
	 */
	uint16_t	phc_sec_fid;
	/*
	 * This field is used to configure conditions under which a function
	 * can become a secondary function.
	 */
	uint8_t	phc_sec_mode;
	/*
	 * Immediately failover to the current secondary function. If there
	 * is no secondary function available, failover does not happen.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_SWITCH  UINT32_C(0x0)
	/*
	 * All functions (PF and VF) can be used during auto selection
	 * of a secondary function. This is not used in case of admin
	 * configured secondary function.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_ALL	UINT32_C(0x1)
	/*
	 * Only PF's can be selected as a secondary function during auto
	 * selection. This is not used in case of admin configured secondary
	 * function.
	 */
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_PF_ONLY UINT32_C(0x2)
	#define HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_LAST   HWRM_FUNC_PTP_EXT_CFG_INPUT_PHC_SEC_MODE_PF_ONLY
	uint8_t	unused_0;
	/*
	 * This field indicates the failover time is milliseconds. If the
	 * timeout expires, firmware will failover PTP configurability from
	 * current master to secondary fid.
	 * 0 - Failover timer is automatically selected based on the last
	 * adjFreq() call. If adjFreq() is not called for 3 * (last interval)
	 * the failover kicks in. For example, if last interval between
	 * adjFreq() calls was 2 seconds and the next adjFreq() is not made for
	 * at least 6 seconds, then secondary takes over as master to condition
	 * PHC. Firmware rounds up the failover timer to be a multiple of 250
	 * ms. Firmware checks every 250 ms to see if timer expired.
	 * 0xFFFFFFFF - If driver specifies this value, then failover never
	 * happens. Admin or auto selected Master will always be used for
	 * conditioning PHC.
	 * X - If driver specifies any other value, this is admin indicated
	 * failover timeout. If no adjFreq() call is made within this timeout
	 * value, then failover happens. This value should be a multiple of
	 * 250 ms. Firmware checks every 250 ms to see if timer expired.
	 */
	uint32_t	failover_timer;
	uint8_t	unused_1[4];
} hwrm_func_ptp_ext_cfg_input_t, *phwrm_func_ptp_ext_cfg_input_t;

/* hwrm_func_ptp_ext_cfg_output (size:128b/16B) */

typedef struct hwrm_func_ptp_ext_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_ext_cfg_output_t, *phwrm_func_ptp_ext_cfg_output_t;

/**************************
 * hwrm_func_ptp_ext_qcfg *
 **************************/


/* hwrm_func_ptp_ext_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_ptp_ext_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} hwrm_func_ptp_ext_qcfg_input_t, *phwrm_func_ptp_ext_qcfg_input_t;

/* hwrm_func_ptp_ext_qcfg_output (size:256b/32B) */

typedef struct hwrm_func_ptp_ext_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Firmware returns the current PHC master function. This function
	 * could either be admin selected or auto selected.
	 */
	uint16_t	phc_master_fid;
	/*
	 * Firmware returns the current PHC secondary function. This function
	 * could either be admin selected or auto selected.
	 */
	uint16_t	phc_sec_fid;
	/*
	 * Firmware returns the last non-master/non-secondary function to
	 * make a call to condition PHC.
	 */
	uint16_t	phc_active_fid0;
	/*
	 * Firmware returns the second last non-master/non-secondary function
	 * to make a call to condition PHC.
	 */
	uint16_t	phc_active_fid1;
	/*
	 * Timestamp indicating the last time a failover happened. The master
	 * and secondary functions in the failover event is indicated in the
	 * next two fields.
	 */
	uint32_t	last_failover_event;
	/*
	 * Last failover happened from this function. This was the master
	 * function at the time of failover.
	 */
	uint16_t	from_fid;
	/*
	 * Last failover happened to this function. This was the secondary
	 * function at the time of failover.
	 */
	uint16_t	to_fid;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_ext_qcfg_output_t, *phwrm_func_ptp_ext_qcfg_output_t;

/*************************************
 * hwrm_func_timedtx_pacing_rate_add *
 *************************************/


/* hwrm_func_timedtx_pacing_rate_add_input (size:192b/24B) */

typedef struct hwrm_func_timedtx_pacing_rate_add_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This field indicates TimedTx pacing rate in kbps.
	 * The driver needs to add the rate into the hardware rate table
	 * before requesting the pacing rate for a flow in TimedTX BD and
	 * this addition should be done for each function rather than for
	 * each flow/QP within the function.
	 */
	uint32_t	rate;
	uint8_t	unused_0[4];
} hwrm_func_timedtx_pacing_rate_add_input_t, *phwrm_func_timedtx_pacing_rate_add_input_t;

/* hwrm_func_timedtx_pacing_rate_add_output (size:128b/16B) */

typedef struct hwrm_func_timedtx_pacing_rate_add_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field indicates the logical rate ID that is assigned to the
	 * rate in the rate table. The driver should use this ID for future
	 * reference to this rate.
	 */
	uint16_t	rate_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_timedtx_pacing_rate_add_output_t, *phwrm_func_timedtx_pacing_rate_add_output_t;

/****************************************
 * hwrm_func_timedtx_pacing_rate_delete *
 ****************************************/


/* hwrm_func_timedtx_pacing_rate_delete_input (size:192b/24B) */

typedef struct hwrm_func_timedtx_pacing_rate_delete_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The logical rate ID that is returned in the TimedTX pacing rate
	 * add operation.
	 */
	uint16_t	rate_id;
	uint8_t	unused_0[6];
} hwrm_func_timedtx_pacing_rate_delete_input_t, *phwrm_func_timedtx_pacing_rate_delete_input_t;

/* hwrm_func_timedtx_pacing_rate_delete_output (size:128b/16B) */

typedef struct hwrm_func_timedtx_pacing_rate_delete_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_timedtx_pacing_rate_delete_output_t, *phwrm_func_timedtx_pacing_rate_delete_output_t;

/***************************************
 * hwrm_func_timedtx_pacing_rate_query *
 ***************************************/


/* hwrm_func_timedtx_pacing_rate_query_input (size:192b/24B) */

typedef struct hwrm_func_timedtx_pacing_rate_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} hwrm_func_timedtx_pacing_rate_query_input_t, *phwrm_func_timedtx_pacing_rate_query_input_t;

/* hwrm_func_timedtx_pacing_rate_query_output (size:4224b/528B) */

typedef struct hwrm_func_timedtx_pacing_rate_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field indicates the rates that the function has added into
	 * the hardware rate table. This is an array of 128 entries. Starting
	 * with index 0, registered rates are populated in the initial entries
	 * of the array, remaining entries are filled up with 0.
	 */
	uint32_t	rates[128];
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_timedtx_pacing_rate_query_output_t, *phwrm_func_timedtx_pacing_rate_query_output_t;

/***************************
 * hwrm_func_key_ctx_alloc *
 ***************************/


/* hwrm_func_key_ctx_alloc_input (size:384b/48B) */

typedef struct hwrm_func_key_ctx_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Function ID. */
	uint16_t	fid;
	/*
	 * Number of Key Contexts to be allocated.
	 * When running in the XID partition mode, if the call is made by
	 * a VF driver, this field specifies the number of XIDs requested
	 * by the VF driver. The XID partitions are managed by the PF
	 * driver in XID partition mode and the VF command will be
	 * redirected to the PF driver. The PF driver may reduce this
	 * number if it cannot allocate a big enough block of XID
	 * partitions to satisfy the request.
	 * This field must not exceed the maximum batch size specified in
	 * the max_key_ctxs_alloc field of the HWRM_FUNC_QCAPS response,
	 * must not be zero, and must be integer multiples of the
	 * partition size specified in the ctxs_per_partition field of
	 * the HWRM_FUNC_QCAPS response.
	 */
	uint16_t	num_key_ctxs;
	/*
	 * DMA buffer size in bytes. This field in invalid in the XID
	 * partition mode.
	 */
	uint32_t	dma_bufr_size_bytes;
	/* Key Context type. */
	uint8_t	key_ctx_type;
	/* KTLS Tx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_TX	UINT32_C(0x0)
	/* KTLS Rx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_RX	UINT32_C(0x1)
	/* QUIC Tx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_QUIC_TX UINT32_C(0x2)
	/* QUIC Rx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_QUIC_RX UINT32_C(0x3)
	#define HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_LAST   HWRM_FUNC_KEY_CTX_ALLOC_INPUT_KEY_CTX_TYPE_QUIC_RX
	uint8_t	unused_0[7];
	/*
	 * Host DMA address to send back KTLS context IDs. This field is
	 * invalid in the XID partition mode.
	 */
	uint64_t	host_dma_addr;
	/*
	 * This field is only used by the PF driver that manages the XID
	 * partitions. This field specifies the starting XID of one or
	 * more contiguous XID partitions allocated by the PF driver.
	 * This field is not used by the VF driver.
	 * If the call is successful, this starting XID value will be
	 * returned in the partition_start_xid field of the response.
	 */
	uint32_t	partition_start_xid;
	uint8_t	unused_1[4];
} hwrm_func_key_ctx_alloc_input_t, *phwrm_func_key_ctx_alloc_input_t;

/* hwrm_func_key_ctx_alloc_output (size:192b/24B) */

typedef struct hwrm_func_key_ctx_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of Key Contexts that have been allocated. */
	uint16_t	num_key_ctxs_allocated;
	/* Control flags. */
	uint8_t	flags;
	/*
	 * When set, it indicates that all key contexts allocated by this
	 * command are contiguous. As a result, the driver has to read the
	 * start context ID from the first entry of the DMA data buffer
	 * and figures out the end context ID by 'start context ID +
	 * num_key_ctxs_allocated - 1'. In XID partition mode,
	 * this bit should always be set.
	 */
	#define HWRM_FUNC_KEY_CTX_ALLOC_OUTPUT_FLAGS_KEY_CTXS_CONTIGUOUS	UINT32_C(0x1)
	uint8_t	unused_0;
	/*
	 * This field is only valid in the XID partition mode. It indicates
	 * the starting XID that has been allocated.
	 */
	uint32_t	partition_start_xid;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_key_ctx_alloc_output_t, *phwrm_func_key_ctx_alloc_output_t;

/**************************
 * hwrm_func_key_ctx_free *
 **************************/


/* hwrm_func_key_ctx_free_input (size:256b/32B) */

typedef struct hwrm_func_key_ctx_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Function ID. */
	uint16_t	fid;
	/* Key Context type. */
	uint8_t	key_ctx_type;
	/* KTLS Tx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_FREE_INPUT_KEY_CTX_TYPE_TX	UINT32_C(0x0)
	/* KTLS Rx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_FREE_INPUT_KEY_CTX_TYPE_RX	UINT32_C(0x1)
	/* QUIC Tx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_FREE_INPUT_KEY_CTX_TYPE_QUIC_TX UINT32_C(0x2)
	/* QUIC Rx Key Context type. */
	#define HWRM_FUNC_KEY_CTX_FREE_INPUT_KEY_CTX_TYPE_QUIC_RX UINT32_C(0x3)
	#define HWRM_FUNC_KEY_CTX_FREE_INPUT_KEY_CTX_TYPE_LAST   HWRM_FUNC_KEY_CTX_FREE_INPUT_KEY_CTX_TYPE_QUIC_RX
	uint8_t	unused_0;
	/* Starting XID of the partition that needs to be freed. */
	uint32_t	partition_start_xid;
	/*
	 * Number of entries to be freed.
	 * When running in the XID partition mode, this field is only
	 * used by the PF driver that manages the XID partitions.
	 * The PF driver specifies the number of XIDs to be freed and
	 * this number is always equal to the number of XIDs previously
	 * allocated successfully using HWRM_FUNC_KEY_CTX_ALLOC.
	 * This field is not used by the VF driver.
	 */
	uint16_t	num_entries;
	uint8_t	unused_1[6];
} hwrm_func_key_ctx_free_input_t, *phwrm_func_key_ctx_free_input_t;

/* hwrm_func_key_ctx_free_output (size:128b/16B) */

typedef struct hwrm_func_key_ctx_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	rsvd0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been completely
	 * written. When writing a command completion or response to
	 * an internal processor, the order of writes has to be such
	 * that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_key_ctx_free_output_t, *phwrm_func_key_ctx_free_output_t;

/**********************************
 * hwrm_func_backing_store_cfg_v2 *
 **********************************/


/* hwrm_func_backing_store_cfg_v2_input (size:448b/56B) */

typedef struct hwrm_func_backing_store_cfg_v2_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of backing store to be configured. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_QP		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SRQ		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CQ		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_VNIC		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_STAT		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SP_TQM_RING	UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_FP_TQM_RING	UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_MRAV		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_TIM		UINT32_C(0xf)
	/* Tx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_TX_CK		UINT32_C(0x13)
	/* Rx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_RX_CK		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_MP_TQM_RING	UINT32_C(0x15)
	/* SQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SQ_DB_SHADOW	UINT32_C(0x16)
	/* RQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_RQ_DB_SHADOW	UINT32_C(0x17)
	/* SRQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SRQ_DB_SHADOW	UINT32_C(0x18)
	/* CQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CQ_DB_SHADOW	UINT32_C(0x19)
	/* CFA table scope context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_TBL_SCOPE	UINT32_C(0x1c)
	/* XID partition context. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_XID_PARTITION	UINT32_C(0x1d)
	/* SRT trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SRT_TRACE	UINT32_C(0x1e)
	/* SRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_SRT2_TRACE	UINT32_C(0x1f)
	/* CRT trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CRT_TRACE	UINT32_C(0x20)
	/* CRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CRT2_TRACE	UINT32_C(0x21)
	/* RIGP0 trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_RIGP0_TRACE	UINT32_C(0x22)
	/* L2 HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_L2_HWRM_TRACE	UINT32_C(0x23)
	/* RoCE HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_ROCE_HWRM_TRACE	UINT32_C(0x24)
	/* TimedTx pacing TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_TTX_PACING_TQM_RING UINT32_C(0x25)
	/* Context Accelerator CPU 0 trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CA0_TRACE	UINT32_C(0x26)
	/* Context Accelerator CPU 1 trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CA1_TRACE	UINT32_C(0x27)
	/* Context Accelerator CPU 2 trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_CA2_TRACE	UINT32_C(0x28)
	/* RIGP1 trace. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_RIGP1_TRACE	UINT32_C(0x29)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_INVALID		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_LAST		HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_TYPE_INVALID
	/*
	 * Instance of the backing store type. It is zero-based,
	 * which means "0" indicates the first instance. For backing
	 * stores with single instance only, leave this field to 0.
	 * 1. If the backing store type is MPC TQM ring, use the following
	 *	instance value to map to MPC clients:
	 *	TCE (0), RCE (1), TE_CFA(2), RE_CFA (3), PRIMATE(4)
	 * 2. If the backing store type is TBL_SCOPE, use the following
	 *	instance value to map to table scope regions:
	 *	RE_CFA_LKUP (0), RE_CFA_ACT (1), TE_CFA_LKUP(2), TE_CFA_ACT (3)
	 * 3. If the backing store type is XID partition, use the following
	 *	instance value to map to context types:
	 *	TX_CK (0), RX_CK (1)
	 */
	uint16_t	instance;
	/* Control flags. */
	uint32_t	flags;
	/*
	 * When set, the firmware only uses on-chip resources and
	 * does not expect any backing store to be provided by the
	 * host driver. This mode provides minimal L2 functionality
	 * (e.g. limited L2 resources, no RoCE).
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_FLAGS_PREBOOT_MODE	UINT32_C(0x1)
	/*
	 * When set, the driver indicates that the backing store type
	 * to be configured in this command is the last one to do for
	 * the associated PF. That means all backing store type
	 * configurations are done for the corresponding PF after this
	 * command. As a result, the firmware has to do the necessary
	 * post configurations.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_FLAGS_BS_CFG_ALL_DONE	UINT32_C(0x2)
	/*
	 * When set, the driver indicates extending the size of the specific
	 * backing store type instead of configuring the corresponding PBLs.
	 * The size specified in the command will be the new size to be
	 * configured. The operation is only valid when the specific backing
	 * store has been configured before. Otherwise, the firmware will
	 * return an error. The driver needs to zero out the 'entry_size',
	 * 'flags', 'page_dir', and 'page_size_pbl_level' fields, and the
	 * firmware will ignore these inputs. Further, the firmware expects
	 * the 'num_entries' and any valid split entries to be no less than
	 * the initial value that has been configured. If not, it will
	 * return an error code.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_FLAGS_BS_EXTEND	UINT32_C(0x4)
	/* Page directory. */
	uint64_t	page_dir;
	/* Number of entries */
	uint32_t	num_entries;
	/* Number of bytes allocated for each entry */
	uint16_t	entry_size;
	/* Page size and pbl level. */
	uint8_t	page_size_pbl_level;
	/* PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_MASK  UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_SFT   0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LVL_0   UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LVL_1   UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LVL_2   UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LAST   HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PBL_LEVEL_LVL_2
	/* Page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_PAGE_SIZE_PG_1G
	/*
	 * This field counts how many split entries contain valid data.
	 * Below is the table that maps the count value:
	 * | Count |			Indication			|
	 * | ----- | -------------------------------------------------- |
	 * |   0   | None of the split entries has valid data.	|
	 * |   1   | Only "split_entry_0" contains valid data.	|
	 * |   2   | Only "split_entry_0" and "1" have valid data.	|
	 * |   3   | Only "split_entry_0", "1" and "2" have valid data. |
	 * |   4   | All four split entries have valid data.		|
	 */
	uint8_t	subtype_valid_cnt;
	/*
	 * Split entry #0. Note that the four split entries (as a group)
	 * must be cast to a type-specific data structure first before
	 * accessing it! Below is the table that maps a backing store
	 * type to the associated split entry casting data structure.
	 * | Type |	Split Entry Casting Data Structure	|
	 * | ---- | -------------------------------------------------- |
	 * | QPC  |		qpc_split_entries			|
	 * | SRQ  |		srq_split_entries			|
	 * | CQ   |		cq_split_entries			|
	 * | VINC |		vnic_split_entries			|
	 * | MRAV |		mrav_split_entries			|
	 * | TS   |		ts_split_entries			|
	 * | CK   |		ck_split_entries			|
	 */
	uint32_t	split_entry_0;
	/* Split entry #1. */
	uint32_t	split_entry_1;
	/* Split entry #2. */
	uint32_t	split_entry_2;
	/* Split entry #3. */
	uint32_t	split_entry_3;
	uint32_t        enables;
       /*
        * This bit must be '1' for the next_bs_offset field to be
        * configured.
        */
       #define HWRM_FUNC_BACKING_STORE_CFG_V2_INPUT_ENABLES_NEXT_BS_OFFSET     UINT32_C(0x1)
       /*
        * This field specifies the next byte offset of the backing store
        * for the firmware to use. The driver can use this field to
        * direct the firmware to resume the logging-to-host from
        * the host buffer where the firmware was lastly written
        * before it restarts, e.g. due to an error recovery.
        */
        uint32_t        next_bs_offset;
} hwrm_func_backing_store_cfg_v2_input_t, *phwrm_func_backing_store_cfg_v2_input_t;

/* hwrm_func_backing_store_cfg_v2_output (size:128b/16B) */

typedef struct hwrm_func_backing_store_cfg_v2_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	rsvd0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been completely
	 * written. When writing a command completion or response to
	 * an internal processor, the order of writes has to be such
	 * that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_cfg_v2_output_t, *phwrm_func_backing_store_cfg_v2_output_t;

/***********************************
 * hwrm_func_backing_store_qcfg_v2 *
 ***********************************/


/* hwrm_func_backing_store_qcfg_v2_input (size:192b/24B) */

typedef struct hwrm_func_backing_store_qcfg_v2_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of backing store to be configured. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_QP		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SRQ		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CQ		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_VNIC		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_STAT		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SP_TQM_RING	UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_FP_TQM_RING	UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_MRAV		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_TIM		UINT32_C(0xf)
	/* Tx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_TX_CK		UINT32_C(0x13)
	/* Rx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_RX_CK		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_MP_TQM_RING	UINT32_C(0x15)
	/* SQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SQ_DB_SHADOW	UINT32_C(0x16)
	/* RQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_RQ_DB_SHADOW	UINT32_C(0x17)
	/* SRQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SRQ_DB_SHADOW	UINT32_C(0x18)
	/* CQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CQ_DB_SHADOW	UINT32_C(0x19)
	/* CFA table scope context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_TBL_SCOPE	UINT32_C(0x1c)
	/* VF XID partition in-use table. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_XID_PARTITION_TABLE UINT32_C(0x1d)
	/* SRT trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SRT_TRACE	UINT32_C(0x1e)
	/* SRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_SRT2_TRACE	UINT32_C(0x1f)
	/* CRT trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CRT_TRACE	UINT32_C(0x20)
	/* CRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CRT2_TRACE	UINT32_C(0x21)
	/* RIGP0 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_RIGP0_TRACE	UINT32_C(0x22)
	/* L2 HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_L2_HWRM_TRACE	UINT32_C(0x23)
	/* RoCE HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_ROCE_HWRM_TRACE	UINT32_C(0x24)
	/* TimedTx pacing TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_TTX_PACING_TQM_RING UINT32_C(0x25)
	/* Context Accelerator CPU 0 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CA0_TRACE	UINT32_C(0x26)
	/* Context Accelerator CPU 1 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CA1_TRACE	UINT32_C(0x27)
	/* Context Accelerator CPU 2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_CA2_TRACE	UINT32_C(0x28)
	/* RIGP1 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_RIGP1_TRACE	UINT32_C(0x29)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_INVALID		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_LAST		HWRM_FUNC_BACKING_STORE_QCFG_V2_INPUT_TYPE_INVALID
	/*
	 * Instance of the backing store type. It is zero-based,
	 * which means "0" indicates the first instance. For backing
	 * stores with single instance only, leave this field to 0.
	 * 1. If the backing store type is MPC TQM ring, use the following
	 *	instance value to map to MPC clients:
	 *	TCE (0), RCE (1), TE_CFA(2), RE_CFA (3), PRIMATE(4)
	 * 2. If the backing store type is TBL_SCOPE, use the following
	 *	instance value to map to table scope regions:
	 *	RE_CFA_LKUP (0), RE_CFA_ACT (1), TE_CFA_LKUP(2), TE_CFA_ACT (3)
	 * 3. If the backing store type is XID partition, use the following
	 *	instance value to map to context types:
	 *	TX_CK (0), RX_CK (1)
	 */
	uint16_t	instance;
	uint8_t	rsvd[4];
} hwrm_func_backing_store_qcfg_v2_input_t, *phwrm_func_backing_store_qcfg_v2_input_t;

/* hwrm_func_backing_store_qcfg_v2_output (size:448b/56B) */

typedef struct hwrm_func_backing_store_qcfg_v2_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Type of backing store to be configured. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_QP		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_SRQ		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_CQ		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_VNIC		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_STAT		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_SP_TQM_RING	UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_FP_TQM_RING	UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_MRAV		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_TIM		UINT32_C(0xf)
	/* Tx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_TX_CK		UINT32_C(0x13)
	/* Rx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_RX_CK		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_MP_TQM_RING	UINT32_C(0x15)
	/* CFA table scope context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_TBL_SCOPE	UINT32_C(0x1c)
	/* XID partition context. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_XID_PARTITION	UINT32_C(0x1d)
	/* SRT trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_SRT_TRACE	UINT32_C(0x1e)
	/* SRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_SRT2_TRACE	UINT32_C(0x1f)
	/* CRT trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_CRT_TRACE	UINT32_C(0x20)
	/* CRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_CRT2_TRACE	UINT32_C(0x21)
	/* RIGP0 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_RIGP0_TRACE	UINT32_C(0x22)
	/* L2 HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_L2_HWRM_TRACE	UINT32_C(0x23)
	/* RoCE HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_ROCE_HWRM_TRACE	UINT32_C(0x24)
	/* TimedTx pacing TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_TTX_PACING_TQM_RING UINT32_C(0x25)
	/* Context Accelerator CPU 0 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_CA0_TRACE	UINT32_C(0x26)
	/* Context Accelerator CPU 1 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_CA1_TRACE	UINT32_C(0x27)
	/* Context Accelerator CPU 2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_CA2_TRACE	UINT32_C(0x28)
	/* RIGP1 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_RIGP1_TRACE	UINT32_C(0x29)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_INVALID		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_LAST		HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_TYPE_INVALID
	/*
	 * Instance of the backing store type. It is zero-based,
	 * which means "0" indicates the first instance. For backing
	 * stores with single instance only, leave this field to 0.
	 * 1. If the backing store type is MPC TQM ring, use the following
	 *	instance value to map to MPC clients:
	 *	TCE (0), RCE (1), TE_CFA(2), RE_CFA (3), PRIMATE(4)
	 * 2. If the backing store type is TBL_SCOPE, use the following
	 *	instance value to map to table scope regions:
	 *	RE_CFA_LKUP (0), RE_CFA_ACT (1), TE_CFA_LKUP(2), TE_CFA_ACT (3)
	 * 3. If the backing store type is XID partition, use the following
	 *	instance value to map to context types:
	 *	TX_CK (0), RX_CK (1)
	 */
	uint16_t	instance;
	/* Control flags. */
	uint32_t	flags;
	/* Page directory. */
	uint64_t	page_dir;
	/* Number of entries */
	uint32_t	num_entries;
	/* Page size and pbl level. */
	uint8_t	page_size_pbl_level;
	/* PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_MASK  UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_SFT   0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LVL_0   UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LVL_1   UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LVL_2   UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LAST   HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PBL_LEVEL_LVL_2
	/* Page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_V2_OUTPUT_PAGE_SIZE_PG_1G
	/*
	 * This field counts how many split entries contain valid data.
	 * Below is the table that maps the count value:
	 * | count |			Indication			|
	 * | ----- | -------------------------------------------------- |
	 * |   0   | None of the split entries has valid data.	|
	 * |   1   | Only "split_entry_0" contains valid data.	|
	 * |   2   | Only "split_entry_0" and "1" have valid data.	|
	 * |   3   | Only "split_entry_0", "1" and "2" have valid data. |
	 * |   4   | All four split entries have valid data.		|
	 */
	uint8_t	subtype_valid_cnt;
	uint8_t	rsvd[2];
	/*
	 * Split entry #0. Note that the four split entries (as a group)
	 * must be cast to a type-specific data structure first before
	 * accessing it! Below is the table that maps a backing store
	 * type to the associated split entry casting data structure.
	 * | Type |	Split Entry Casting Data Structure	|
	 * | ---- | -------------------------------------------------- |
	 * | QPC  |		qpc_split_entries			|
	 * | SRQ  |		srq_split_entries			|
	 * | CQ   |		cq_split_entries			|
	 * | VINC |		vnic_split_entries			|
	 * | MRAV |		mrav_split_entries			|
	 * | TS   |		ts_split_entries			|
	 * | CK   |		ck_split_entries			|
	 */
	uint32_t	split_entry_0;
	/* Split entry #1. */
	uint32_t	split_entry_1;
	/* Split entry #2. */
	uint32_t	split_entry_2;
	/* Split entry #3. */
	uint32_t	split_entry_3;
	uint8_t	rsvd2[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been completely
	 * written. When writing a command completion or response to
	 * an internal processor, the order of writes has to be such
	 * that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_qcfg_v2_output_t, *phwrm_func_backing_store_qcfg_v2_output_t;

/* Common structure to cast QPC split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is QPC. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* qpc_split_entries (size:128b/16B) */

typedef struct qpc_split_entries {
	/* Number of L2 QP backing store entries. */
	uint32_t	qp_num_l2_entries;
	/* Number of QP1 entries. */
	uint32_t	qp_num_qp1_entries;
	/*
	 * Number of RoCE QP context entries required for this
	 * function to support fast QP modify destroy feature.
	 */
	uint32_t	qp_num_fast_qpmd_entries;
	uint32_t	rsvd;
} qpc_split_entries_t, *pqpc_split_entries_t;

/* Common structure to cast SRQ split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is SRQ. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* srq_split_entries (size:128b/16B) */

typedef struct srq_split_entries {
	/* Number of L2 SRQ backing store entries. */
	uint32_t	srq_num_l2_entries;
	uint32_t	rsvd;
	uint64_t	rsvd2;
} srq_split_entries_t, *psrq_split_entries_t;

/* Common structure to cast CQ split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is CQ. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* cq_split_entries (size:128b/16B) */

typedef struct cq_split_entries {
	/* Number of L2 CQ backing store entries. */
	uint32_t	cq_num_l2_entries;
	uint32_t	rsvd;
	uint64_t	rsvd2;
} cq_split_entries_t, *pcq_split_entries_t;

/* Common structure to cast VNIC split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is VNIC. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* vnic_split_entries (size:128b/16B) */

typedef struct vnic_split_entries {
	/* Number of VNIC backing store entries. */
	uint32_t	vnic_num_vnic_entries;
	uint32_t	rsvd;
	uint64_t	rsvd2;
} vnic_split_entries_t, *pvnic_split_entries_t;

/* Common structure to cast MRAV split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is MRAV. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* mrav_split_entries (size:128b/16B) */

typedef struct mrav_split_entries {
	/* Number of AV backing store entries. */
	uint32_t	mrav_num_av_entries;
	uint32_t	rsvd;
	uint64_t	rsvd2;
} mrav_split_entries_t, *pmrav_split_entries_t;

/* Common structure to cast TBL_SCOPE split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is TBL_SCOPE. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* ts_split_entries (size:128b/16B) */

typedef struct ts_split_entries {
	/* Max number of TBL_SCOPE region entries (QCAPS). */
	uint32_t	region_num_entries;
	/* tsid to configure (CFG). */
	uint8_t	tsid;
	/*
	 * Lkup static bucket count (power of 2).
	 * Array is indexed by enum cfa_dir
	 */
	uint8_t	lkup_static_bkt_cnt_exp[2];
	uint8_t	rsvd;
	uint64_t	rsvd2;
} ts_split_entries_t, *pts_split_entries_t;

/* Common structure to cast crypto key split entries. This casting is required in the following HWRM command inputs/outputs if the backing store type is TX_CK or RX_CK. 1. hwrm_func_backing_store_cfg_v2_input 2. hwrm_func_backing_store_qcfg_v2_output 3. hwrm_func_backing_store_qcaps_v2_output */
/* ck_split_entries (size:128b/16B) */

typedef struct ck_split_entries {
	/*
	 * Number of QUIC backing store entries. That means the number of KTLS
	 * backing store entries is the difference between this number and the
	 * total number of crypto key entries.
	 */
	uint32_t	num_quic_entries;
	uint32_t	rsvd;
	uint64_t	rsvd2;
} ck_split_entries_t, *pck_split_entries_t;

/************************************
 * hwrm_func_backing_store_qcaps_v2 *
 ************************************/


/* hwrm_func_backing_store_qcaps_v2_input (size:192b/24B) */

typedef struct hwrm_func_backing_store_qcaps_v2_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of backing store to be queried. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_QP		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SRQ		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CQ		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_VNIC		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_STAT		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SP_TQM_RING	UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_FP_TQM_RING	UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_MRAV		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_TIM		UINT32_C(0xf)
	/* Tx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_TX_CK		UINT32_C(0x13)
	/* Rx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_RX_CK		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_MP_TQM_RING	UINT32_C(0x15)
	/* SQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SQ_DB_SHADOW	UINT32_C(0x16)
	/* RQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_RQ_DB_SHADOW	UINT32_C(0x17)
	/* SRQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SRQ_DB_SHADOW	UINT32_C(0x18)
	/* CQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CQ_DB_SHADOW	UINT32_C(0x19)
	/* CFA table scope context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_TBL_SCOPE	UINT32_C(0x1c)
	/* XID partition context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_XID_PARTITION	UINT32_C(0x1d)
	/* SRT trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SRT_TRACE	UINT32_C(0x1e)
	/* SRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_SRT2_TRACE	UINT32_C(0x1f)
	/* CRT trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CRT_TRACE	UINT32_C(0x20)
	/* CRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CRT2_TRACE	UINT32_C(0x21)
	/* RIGP0 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_RIGP0_TRACE	UINT32_C(0x22)
	/* L2 HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_L2_HWRM_TRACE	UINT32_C(0x23)
	/* RoCE HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_ROCE_HWRM_TRACE	UINT32_C(0x24)
	/* TimedTx pacing TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_TTX_PACING_TQM_RING UINT32_C(0x25)
	/* Context Accelerator CPU 0 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CA0_TRACE	UINT32_C(0x26)
	/* Context Accelerator CPU 1 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CA1_TRACE	UINT32_C(0x27)
	/* Context Accelerator CPU 2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_CA2_TRACE	UINT32_C(0x28)
	/* RIGP1 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_RIGP1_TRACE	UINT32_C(0x29)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_INVALID		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_LAST		HWRM_FUNC_BACKING_STORE_QCAPS_V2_INPUT_TYPE_INVALID
	uint8_t	rsvd[6];
} hwrm_func_backing_store_qcaps_v2_input_t, *phwrm_func_backing_store_qcaps_v2_input_t;

/* hwrm_func_backing_store_qcaps_v2_output (size:448b/56B) */

typedef struct hwrm_func_backing_store_qcaps_v2_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Type of backing store to be queried. */
	uint16_t	type;
	/* Queue pair. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_QP		UINT32_C(0x0)
	/* Shared receive queue. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SRQ		UINT32_C(0x1)
	/* Completion queue. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CQ		UINT32_C(0x2)
	/* Virtual NIC. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_VNIC		UINT32_C(0x3)
	/* Statistic context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_STAT		UINT32_C(0x4)
	/* Slow-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SP_TQM_RING	UINT32_C(0x5)
	/* Fast-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_FP_TQM_RING	UINT32_C(0x6)
	/* Memory Region and Memory Address Vector Context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_MRAV		UINT32_C(0xe)
	/* TIM. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_TIM		UINT32_C(0xf)
	/* Tx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_TX_CK		UINT32_C(0x13)
	/* Rx crypto key. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_RX_CK		UINT32_C(0x14)
	/* Mid-path TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_MP_TQM_RING	UINT32_C(0x15)
	/* SQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SQ_DB_SHADOW	UINT32_C(0x16)
	/* RQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_RQ_DB_SHADOW	UINT32_C(0x17)
	/* SRQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SRQ_DB_SHADOW	UINT32_C(0x18)
	/* CQ Doorbell shadow region. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CQ_DB_SHADOW	UINT32_C(0x19)
	/* CFA table scope context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_TBL_SCOPE	UINT32_C(0x1c)
	/* XID partition context. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_XID_PARTITION	UINT32_C(0x1d)
	/* SRT trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SRT_TRACE	UINT32_C(0x1e)
	/* SRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_SRT2_TRACE	UINT32_C(0x1f)
	/* CRT trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CRT_TRACE	UINT32_C(0x20)
	/* CRT2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CRT2_TRACE	UINT32_C(0x21)
	/* RIGP0 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_RIGP0_TRACE	UINT32_C(0x22)
	/* L2 HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_L2_HWRM_TRACE	UINT32_C(0x23)
	/* RoCE HWRM trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_ROCE_HWRM_TRACE	UINT32_C(0x24)
	/* TimedTx pacing TQM ring. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_TTX_PACING_TQM_RING UINT32_C(0x25)
	/* Context Accelerator CPU 0 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CA0_TRACE	UINT32_C(0x26)
	/* Context Accelerator CPU 1 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CA1_TRACE	UINT32_C(0x27)
	/* Context Accelerator CPU 2 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_CA2_TRACE	UINT32_C(0x28)
	/* RIGP1 trace. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_RIGP1_TRACE	UINT32_C(0x29)
	/* Invalid type. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_INVALID		UINT32_C(0xffff)
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_LAST		HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_TYPE_INVALID
	/* Number of bytes per backing store entry. */
	uint16_t	entry_size;
	/* Control flags. */
	uint32_t	flags;
	/*
	 * When set, it indicates the context type should be initialized
	 * with the 'ctx_init_value' at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_ENABLE_CTX_KIND_INIT		UINT32_C(0x1)
	/* When set, it indicates the context type is valid. */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_TYPE_VALID			UINT32_C(0x2)
	/*
	 * When set, it indicates the region for this type is not a regular
	 * context memory but a driver managed memory that is created,
	 * initialized and managed by the driver.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_DRIVER_MANAGED_MEMORY	UINT32_C(0x4)
	/*
	 * When set, it indicates the support of the following capability
	 * that is specific to the QP type:
	 * - For 2-port adapters, the ability to extend the RoCE QP
	 *   entries configured on a PF, during some network events such as
	 *   Link Down. These additional entries count is included in the
	 *   advertised 'max_num_entries'.
	 * - The count of RoCE QP entries, derived from 'max_num_entries'
	 *   (max_num_entries - qp_num_qp1_entries - qp_num_l2_entries -
	 *   qp_num_fast_qpmd_entries, note qp_num_fast_qpmd_entries is
	 *   always zero when QPs are pseudo-statically allocated), includes
	 *   the count of QPs that can be migrated from the other PF (e.g.,
	 *   during network link down). Therefore, during normal operation
	 *   when both PFs are active, the supported number of RoCE QPs for
	 *   each of the PF is half of the advertised value.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_ROCE_QP_PSEUDO_STATIC_ALLOC	UINT32_C(0x8)
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_FW_DBG_TRACE                      UINT32_C(0x10)

	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_FW_BIN_DBG_TRACE          UINT32_C(0x20)

	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_FLAGS_NEXT_BS_OFFSET            UINT32_C(0x40)
	/*
	 * Bit map of the valid instances associated with the
	 * backing store type.
	 * 1. If the backing store type is MPC TQM ring, use the following
	 *	bits to map to MPC clients:
	 *	TCE (0), RCE (1), TE_CFA(2), RE_CFA (3), PRIMATE(4)
	 * 2. If the backing store type is TBL_SCOPE, use the following
	 *	bits to map to table scope regions:
	 *	RE_CFA_LKUP (0), RE_CFA_ACT (1), TE_CFA_LKUP(2), TE_CFA_ACT (3)
	 * 3. If the backing store type is VF XID partition in-use table, use
	 *	the following bits to map to context types:
	 *	TX_CK (0), RX_CK (1)
	 */
	uint32_t	instance_bit_map;
	/*
	 * Initializer to be used by drivers to initialize context memory
	 * to ensure context subsystem flags an error for an attack before
	 * the first time context load.
	 */
	uint8_t	ctx_init_value;
	/*
	 * Specifies the doubleword offset of ctx_init_value for this
	 * context type.
	 */
	uint8_t	ctx_init_offset;
	/*
	 * Some backing store types, e.g., TQM rings, require the number
	 * of entries to be a multiple of this value to prevent any
	 * resource allocation limitations. If not applicable, leave
	 * this field with "0".
	 */
	uint8_t	entry_multiple;
	uint8_t	rsvd;
	/* Maximum number of backing store entries supported for this type. */
	uint32_t	max_num_entries;
	/*
	 * Minimum number of backing store entries required for this type.
	 * This field is only valid for some backing store types, e.g.,
	 * TQM rings. If not applicable, leave this field with "0".
	 */
	uint32_t	min_num_entries;
	/*
	 * Next valid backing store type. If current type queried is already
	 * the last valid type, firmware must set this field to invalid type.
	 */
	uint16_t	next_valid_type;
	/*
	 * This field counts how many split entries contain valid data.
	 * Below is the table that maps the count value:
	 * | count |			Indication			|
	 * | ----- | -------------------------------------------------- |
	 * |   0   | None of the split entries has valid data.	|
	 * |   1   | Only "split_entry_0" contains valid data.	|
	 * |   2   | Only "split_entry_0" and "1" have valid data.	|
	 * |   3   | Only "split_entry_0", "1" and "2" have valid data. |
	 * |   4   | All four split entries have valid data.		|
	 */
	uint8_t	subtype_valid_cnt;
	/*
	 * Bitmap that indicates if each of the 'split_entry' denotes an
	 * exact count (i.e., min = max). When the exact count bit is set,
	 * it indicates the exact number of entries as advertised has to be
	 * configured. The 'split_entry' to be set to contain exact count by
	 * this bitmap needs to be a valid split entry specified by
	 * 'subtype_valid_cnt'.
	 */
	uint8_t	exact_cnt_bit_map;
	/*
	 * When this bit is '1', it indicates 'split_entry_0' contains
	 * an exact count.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_EXACT_CNT_BIT_MAP_SPLIT_ENTRY_0_EXACT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates 'split_entry_1' contains
	 * an exact count.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_EXACT_CNT_BIT_MAP_SPLIT_ENTRY_1_EXACT	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates 'split_entry_2' contains
	 * an exact count.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_EXACT_CNT_BIT_MAP_SPLIT_ENTRY_2_EXACT	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates 'split_entry_3' contains
	 * an exact count.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_EXACT_CNT_BIT_MAP_SPLIT_ENTRY_3_EXACT	UINT32_C(0x8)
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_EXACT_CNT_BIT_MAP_UNUSED_MASK		UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCAPS_V2_OUTPUT_EXACT_CNT_BIT_MAP_UNUSED_SFT		4
	/*
	 * Split entry #0. Note that the four split entries (as a group)
	 * must be cast to a type-specific data structure first before
	 * accessing it! Below is the table that maps a backing store
	 * type to the associated split entry casting data structure.
	 * | Type |	Split Entry Casting Data Structure	|
	 * | ---- | -------------------------------------------------- |
	 * | QPC  |		qpc_split_entries			|
	 * | SRQ  |		srq_split_entries			|
	 * | CQ   |		cq_split_entries			|
	 * | VINC |		vnic_split_entries			|
	 * | MRAV |		mrav_split_entries			|
	 * | TS   |		ts_split_entries			|
	 */
	uint32_t	split_entry_0;
	/* Split entry #1. */
	uint32_t	split_entry_1;
	/* Split entry #2. */
	uint32_t	split_entry_2;
	/* Split entry #3. */
	uint32_t	split_entry_3;
	uint8_t	rsvd3[3];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been completely
	 * written. When writing a command completion or response to
	 * an internal processor, the order of writes has to be such
	 * that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_qcaps_v2_output_t, *phwrm_func_backing_store_qcaps_v2_output_t;

/****************************
 * hwrm_func_dbr_pacing_cfg *
 ****************************/


/* hwrm_func_dbr_pacing_cfg_input (size:320b/40B) */

typedef struct hwrm_func_dbr_pacing_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * This bit must be '1' to enable DBR NQ events. The NQ ID to
	 * receive the events must be specified in the primary_nq_id
	 * field.
	 */
	#define HWRM_FUNC_DBR_PACING_CFG_INPUT_FLAGS_DBR_NQ_EVENT_ENABLE	UINT32_C(0x1)
	/* This bit must be '1' to disable DBR NQ events. */
	#define HWRM_FUNC_DBR_PACING_CFG_INPUT_FLAGS_DBR_NQ_EVENT_DISABLE	UINT32_C(0x2)
	uint8_t	unused_0[7];
	uint32_t	enables;
	/*
	 * This bit must be '1' for the primary_nq_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_DBR_PACING_CFG_INPUT_ENABLES_PRIMARY_NQ_ID_VALID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pacing_threshold field to be
	 * configured.
	 */
	#define HWRM_FUNC_DBR_PACING_CFG_INPUT_ENABLES_PACING_THRESHOLD_VALID	UINT32_C(0x2)
	/*
	 * Specify primary function's NQ ID to receive the doorbell pacing
	 * threshold crossing events.
	 */
	uint32_t	primary_nq_id;
	/*
	 * Specify pacing threshold value, as a percentage of the max
	 * doorbell FIFO depth. The range is 1 to 36.
	 */
	uint32_t	pacing_threshold;
	uint8_t	unused_1[4];
} hwrm_func_dbr_pacing_cfg_input_t, *phwrm_func_dbr_pacing_cfg_input_t;

/* hwrm_func_dbr_pacing_cfg_output (size:128b/16B) */

typedef struct hwrm_func_dbr_pacing_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_func_dbr_pacing_cfg_output_t, *phwrm_func_dbr_pacing_cfg_output_t;

/*****************************
 * hwrm_func_dbr_pacing_qcfg *
 *****************************/


/* hwrm_func_dbr_pacing_qcfg_input (size:128b/16B) */

typedef struct hwrm_func_dbr_pacing_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_dbr_pacing_qcfg_input_t, *phwrm_func_dbr_pacing_qcfg_input_t;

/* hwrm_func_dbr_pacing_qcfg_output (size:512b/64B) */

typedef struct hwrm_func_dbr_pacing_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/* When this bit is '1', it indicates DBR NQ events are enabled. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_FLAGS_DBR_NQ_EVENT_ENABLED	UINT32_C(0x1)
	uint8_t	unused_0[7];
	/*
	 * The Doorbell global FIFO occupancy register. This field should be
	 * used by the driver and user library in the doorbell pacing
	 * algorithm. Lower 2 bits indicates address space location and upper
	 * 30 bits indicates upper 30bits of the register address. A value of
	 * 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	dbr_stat_db_fifo_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_LAST	HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_STAT_DB_FIFO_REG_ADDR_SFT	2
	/*
	 * This field indicates the mask value for dbr_stat_db_fifo_reg
	 * to get the high watermark for doorbell FIFO.
	 */
	uint32_t	dbr_stat_db_fifo_reg_watermark_mask;
	/*
	 * This field indicates the shift value for dbr_stat_db_fifo_reg
	 * to get the high watermark for doorbell FIFO.
	 */
	uint8_t	dbr_stat_db_fifo_reg_watermark_shift;
	uint8_t	unused_1[3];
	/*
	 * This field indicates the mask value for dbr_stat_db_fifo_reg
	 * to get the amount of room left for doorbell FIFO.
	 */
	uint32_t	dbr_stat_db_fifo_reg_fifo_room_mask;
	/*
	 * This field indicates the shift value for dbr_stat_db_fifo_reg
	 * to get the amount of room left for doorbell FIFO.
	 */
	uint8_t	dbr_stat_db_fifo_reg_fifo_room_shift;
	uint8_t	unused_2[3];
	/*
	 * DBR_REG_AEQ_ARM register. This field should be used by the driver
	 * to rearm the interrupt for regeneration of a notification to the
	 * host from the hardware when the global doorbell occupancy threshold
	 * is above the threshold value. Lower 2 bits indicates address space
	 * location and upper 30 bits indicates upper 30bits of the register
	 * address. A value of 0xFFFF-FFFF indicates this register does not
	 * exist.
	 */
	uint32_t	dbr_throttling_aeq_arm_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_LAST	HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_FUNC_DBR_PACING_QCFG_OUTPUT_DBR_THROTTLING_AEQ_ARM_REG_ADDR_SFT	2
	/*
	 * This field indicates the value to be written for
	 * dbr_throttling_aeq_arm_reg register.
	 */
	uint8_t	dbr_throttling_aeq_arm_reg_val;
	uint8_t	unused_3[3];
	/* This field indicates the maximum depth of the doorbell FIFO. */
	uint32_t	dbr_stat_db_max_fifo_depth;
	/*
	 * Specifies primary function's NQ ID.
	 * A value of 0xFFFF FFFF indicates NQ ID is invalid.
	 */
	uint32_t	primary_nq_id;
	/*
	 * Specifies the pacing threshold value, as a percentage of the
	 * max doorbell FIFO depth. The range is 1 to 100.
	 */
	uint32_t	pacing_threshold;
	uint8_t	unused_4[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_func_dbr_pacing_qcfg_output_t, *phwrm_func_dbr_pacing_qcfg_output_t;

/****************************************
 * hwrm_func_dbr_pacing_broadcast_event *
 ****************************************/


/* hwrm_func_dbr_pacing_broadcast_event_input (size:128b/16B) */

typedef struct hwrm_func_dbr_pacing_broadcast_event_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_dbr_pacing_broadcast_event_input_t, *phwrm_func_dbr_pacing_broadcast_event_input_t;

/* hwrm_func_dbr_pacing_broadcast_event_output (size:128b/16B) */

typedef struct hwrm_func_dbr_pacing_broadcast_event_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_func_dbr_pacing_broadcast_event_output_t, *phwrm_func_dbr_pacing_broadcast_event_output_t;

/*************************************
 * hwrm_func_dbr_pacing_nqlist_query *
 *************************************/


/* hwrm_func_dbr_pacing_nqlist_query_input (size:128b/16B) */

typedef struct hwrm_func_dbr_pacing_nqlist_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_dbr_pacing_nqlist_query_input_t, *phwrm_func_dbr_pacing_nqlist_query_input_t;

/* hwrm_func_dbr_pacing_nqlist_query_output (size:384b/48B) */

typedef struct hwrm_func_dbr_pacing_nqlist_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id0;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id1;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id2;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id3;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id4;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id5;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id6;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id7;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id8;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id9;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id10;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id11;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id12;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id13;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id14;
	/* ID of an NQ ring allocated for DBR pacing notifications. */
	uint16_t	nq_ring_id15;
	/* Number of consecutive NQ ring IDs populated in the response. */
	uint32_t	num_nqs;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_dbr_pacing_nqlist_query_output_t, *phwrm_func_dbr_pacing_nqlist_query_output_t;

/************************************
 * hwrm_func_dbr_recovery_completed *
 ************************************/


/* hwrm_func_dbr_recovery_completed_input (size:192b/24B) */

typedef struct hwrm_func_dbr_recovery_completed_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Specifies the epoch value with the one that was specified by the
	 * firmware in the error_report_doorbell_drop_threshold async event
	 * corresponding to the specific recovery cycle.
	 */
	uint32_t	epoch;
	/* The epoch value. */
	#define HWRM_FUNC_DBR_RECOVERY_COMPLETED_INPUT_EPOCH_VALUE_MASK UINT32_C(0xffffff)
	#define HWRM_FUNC_DBR_RECOVERY_COMPLETED_INPUT_EPOCH_VALUE_SFT 0
	uint8_t	unused_0[4];
} hwrm_func_dbr_recovery_completed_input_t, *phwrm_func_dbr_recovery_completed_input_t;

/* hwrm_func_dbr_recovery_completed_output (size:128b/16B) */

typedef struct hwrm_func_dbr_recovery_completed_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_func_dbr_recovery_completed_output_t, *phwrm_func_dbr_recovery_completed_output_t;

/***********************
 * hwrm_func_synce_cfg *
 ***********************/


/* hwrm_func_synce_cfg_input (size:192b/24B) */

typedef struct hwrm_func_synce_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	enables;
	/*
	 * This bit must be '1' for the freq_profile field to be
	 * configured.
	 */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_ENABLES_FREQ_PROFILE	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the primary_clock_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_ENABLES_PRIMARY_CLOCK	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the secondary_clock_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_ENABLES_SECONDARY_CLOCK	UINT32_C(0x4)
	/* Frequency profile for SyncE recovered clock. */
	uint8_t	freq_profile;
	/* Invalid frequency profile */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_FREQ_PROFILE_INVALID UINT32_C(0x0)
	/* 25MHz SyncE clock profile */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_FREQ_PROFILE_25MHZ   UINT32_C(0x1)
	#define HWRM_FUNC_SYNCE_CFG_INPUT_FREQ_PROFILE_LAST   HWRM_FUNC_SYNCE_CFG_INPUT_FREQ_PROFILE_25MHZ
	/*
	 * Enable or disable primary clock for PF/port, overriding previous
	 * primary clock setting.
	 */
	uint8_t	primary_clock_state;
	/* Disable clock */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_PRIMARY_CLOCK_STATE_DISABLE UINT32_C(0x0)
	/* Enable clock */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_PRIMARY_CLOCK_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_FUNC_SYNCE_CFG_INPUT_PRIMARY_CLOCK_STATE_LAST   HWRM_FUNC_SYNCE_CFG_INPUT_PRIMARY_CLOCK_STATE_ENABLE
	/*
	 * Enable or disable secondary clock for PF/port, overriding previous
	 * secondary clock setting.
	 */
	uint8_t	secondary_clock_state;
	/* Clock disabled */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_SECONDARY_CLOCK_STATE_DISABLE UINT32_C(0x0)
	/* Clock enabled */
	#define HWRM_FUNC_SYNCE_CFG_INPUT_SECONDARY_CLOCK_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_FUNC_SYNCE_CFG_INPUT_SECONDARY_CLOCK_STATE_LAST   HWRM_FUNC_SYNCE_CFG_INPUT_SECONDARY_CLOCK_STATE_ENABLE
	uint8_t	unused_0[4];
} hwrm_func_synce_cfg_input_t, *phwrm_func_synce_cfg_input_t;

/* hwrm_func_synce_cfg_output (size:128b/16B) */

typedef struct hwrm_func_synce_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_synce_cfg_output_t, *phwrm_func_synce_cfg_output_t;

/************************
 * hwrm_func_synce_qcfg *
 ************************/


/* hwrm_func_synce_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_synce_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} hwrm_func_synce_qcfg_input_t, *phwrm_func_synce_qcfg_input_t;

/* hwrm_func_synce_qcfg_output (size:128b/16B) */

typedef struct hwrm_func_synce_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Frequency profile for SyncE recovered clock. */
	uint8_t	freq_profile;
	/* Invalid frequency profile */
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_FREQ_PROFILE_INVALID UINT32_C(0x0)
	/* 25MHz SyncE clock profile */
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_FREQ_PROFILE_25MHZ   UINT32_C(0x1)
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_FREQ_PROFILE_LAST   HWRM_FUNC_SYNCE_QCFG_OUTPUT_FREQ_PROFILE_25MHZ
	/* SyncE recovered clock state */
	uint8_t	state;
	/*
	 * When this bit is '1', primary clock is enabled for this PF/port.
	 * When this bit is '0', primary clock is disabled for this PF/port.
	 */
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_STATE_PRIMARY_CLOCK_ENABLED	UINT32_C(0x1)
	/*
	 * When this bit is '1', secondary clock is enabled for this
	 * PF/port.
	 * When this bit is '0', secondary clock is disabled for this
	 * PF/port.
	 */
	#define HWRM_FUNC_SYNCE_QCFG_OUTPUT_STATE_SECONDARY_CLOCK_ENABLED	UINT32_C(0x2)
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_synce_qcfg_output_t, *phwrm_func_synce_qcfg_output_t;

/************************
 * hwrm_func_lag_create *
 ************************/


/* hwrm_func_lag_create_input (size:192b/24B) */

typedef struct hwrm_func_lag_create_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	enables;
	/*
	 * This bit must be '1' for the active_port_map field to be
	 * configured.
	 */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ENABLES_ACTIVE_PORT_MAP	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the member_port_map field to be
	 * configured.
	 */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ENABLES_MEMBER_PORT_MAP	UINT32_C(0x2)
	/* This bit must be '1' for the aggr_mode field to be configured. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ENABLES_AGGR_MODE	UINT32_C(0x4)
	/* rsvd1 is 5 b */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ENABLES_RSVD1_MASK	UINT32_C(0xf8)
	#define HWRM_FUNC_LAG_CREATE_INPUT_ENABLES_RSVD1_SFT	3
	/*
	 * This is the bitmap of all active ports in the LAG. Each bit
	 * represents a front panel port of the device. Ports are numbered
	 * from 0 to n - 1 on a device with n ports. The number of front panel
	 * ports is specified in the port_cnt field of the HWRM_PORT_PHY_QCAPS
	 * response. The active_port_map must always be a subset of the
	 * member_port_map. An active port is eligible to send and receive
	 * traffic.
	 *
	 * If the LAG mode is active-backup, only one port can be an active
	 * port at a given time. All other ports in the member_port_map that
	 * are not the active port are backup port. When the active port
	 * fails, another member port takes over to become the active port.
	 * The driver should use HWRM_FUNC_LAG_UPDATE to update
	 * the active_port_map by only setting the port bit of the new active
	 * port.
	 *
	 * In active-active, balance_xor or 802_3_ad mode, all member ports
	 * can be active ports. If the driver determines that an active
	 * port is down or unable to function, it should use
	 * HWRM_FUNC_LAG_UPDATE to update the active_port_map by clearing
	 * the port bit that has failed.
	 */
	uint8_t	active_port_map;
	/* If this bit is set to '1', the port0 is a lag active port. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ACTIVE_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag active port. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ACTIVE_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag active port. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ACTIVE_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag active port. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ACTIVE_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd3 is 4 b */
	#define HWRM_FUNC_LAG_CREATE_INPUT_ACTIVE_PORT_MAP_RSVD3_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_CREATE_INPUT_ACTIVE_PORT_MAP_RSVD3_SFT  4
	/*
	 * This is the bitmap of all member ports in the LAG. Each bit
	 * represents a front panel port of the device. Ports are numbered
	 * from 0 to n - 1 on a device with n ports. The number of front panel
	 * ports is specified in the port_cnt field of the HWRM_PORT_PHY_QCAPS
	 * response. There must be at least 2 ports in the member ports and
	 * each must not be a member of another LAG. Note that on a 4-port
	 * device, there can be either 2 ports or 4 ports in the member ports.
	 * Using 3 member ports is not supported.
	 */
	uint8_t	member_port_map;
	/* If this bit is set to '1', the port0 is a lag member port. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_MEMBER_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag member port. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_MEMBER_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag member port. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_MEMBER_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag member port. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_MEMBER_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd4 is 4 b */
	#define HWRM_FUNC_LAG_CREATE_INPUT_MEMBER_PORT_MAP_RSVD4_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_CREATE_INPUT_MEMBER_PORT_MAP_RSVD4_SFT  4
	/* Link aggregation mode being used. */
	uint8_t	link_aggr_mode;
	/* active active mode. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_AGGR_MODE_ACTIVE_ACTIVE UINT32_C(0x1)
	/* active backup mode. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_AGGR_MODE_ACTIVE_BACKUP UINT32_C(0x2)
	/* Balance XOR mode. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_AGGR_MODE_BALANCE_XOR   UINT32_C(0x3)
	/* 802.3AD mode. */
	#define HWRM_FUNC_LAG_CREATE_INPUT_AGGR_MODE_802_3_AD	UINT32_C(0x4)
	#define HWRM_FUNC_LAG_CREATE_INPUT_AGGR_MODE_LAST	HWRM_FUNC_LAG_CREATE_INPUT_AGGR_MODE_802_3_AD
	uint8_t	unused_0[4];
} hwrm_func_lag_create_input_t, *phwrm_func_lag_create_input_t;

/* hwrm_func_lag_create_output (size:128b/16B) */

typedef struct hwrm_func_lag_create_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * LAG ID of the created LAG. This LAG ID will also be returned
	 * in the HWRM_FUNC_QCFG response of all member ports.
	 */
	uint8_t	fw_lag_id;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_lag_create_output_t, *phwrm_func_lag_create_output_t;

/************************
 * hwrm_func_lag_update *
 ************************/


/* hwrm_func_lag_update_input (size:192b/24B) */

typedef struct hwrm_func_lag_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Link aggregation group ID of the LAG to be updated. */
	uint8_t	fw_lag_id;
	uint8_t	enables;
	/*
	 * This bit must be '1' for the active_port_map field to be
	 * updated.
	 */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ENABLES_ACTIVE_PORT_MAP	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the member_port_map field to be
	 * updated.
	 */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ENABLES_MEMBER_PORT_MAP	UINT32_C(0x2)
	/* This bit must be '1' for the aggr_mode field to be updated. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ENABLES_AGGR_MODE	UINT32_C(0x4)
	/* rsvd1 is 5 b */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ENABLES_RSVD1_MASK	UINT32_C(0xf8)
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ENABLES_RSVD1_SFT	3
	/*
	 * This is the bitmap of all active ports in the LAG. Each bit
	 * represents a front panel port of the device. Ports are numbered
	 * from 0 to n - 1 on a device with n ports. The number of front panel
	 * ports is specified in the port_cnt field of the HWRM_PORT_PHY_QCAPS
	 * response. The active_port_map must always be a subset of the
	 * member_port_map. An active port is eligible to send and receive
	 * traffic.
	 *
	 * If the LAG mode is active-backup, only one port can be an active
	 * port at a given time. All other ports in the member_port_map that
	 * are not the active port are backup port. When the active port
	 * fails, another member port takes over to become the active port.
	 * The driver should use HWRM_FUNC_LAG_UPDATE to update
	 * the active_port_map by only setting the port bit of the new active
	 * port.
	 *
	 * In active-active, balance_xor or 802_3_ad mode, all member ports
	 * can be active ports. If the driver determines that an active
	 * port is down or unable to function, it should use
	 * HWRM_FUNC_LAG_UPDATE to update the active_port_map by clearing
	 * the port bit that has failed.
	 */
	uint8_t	active_port_map;
	/* If this bit is set to '1', the port0 is a lag active port. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ACTIVE_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag active port. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ACTIVE_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag active port. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ACTIVE_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag active port. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ACTIVE_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd3 is 4 b */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ACTIVE_PORT_MAP_RSVD3_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_UPDATE_INPUT_ACTIVE_PORT_MAP_RSVD3_SFT  4
	/*
	 * This is the bitmap of all member ports in the LAG. Each bit
	 * represents a front panel port of the device. Ports are numbered
	 * from 0 to n - 1 on a device with n ports. The number of front panel
	 * ports is specified in the port_cnt field of the HWRM_PORT_PHY_QCAPS
	 * response. There must be at least 2 ports in the member ports and
	 * each must not be a member of another LAG. Note that on a 4-port
	 * device, there can be either 2 ports or 4 ports in the member ports.
	 * Using 3 member ports is not supported.
	 */
	uint8_t	member_port_map;
	/* If this bit is set to '1', the port0 is a lag member port. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_MEMBER_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag member port. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_MEMBER_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag member port. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_MEMBER_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag member port. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_MEMBER_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd4 is 4 b */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_MEMBER_PORT_MAP_RSVD4_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_UPDATE_INPUT_MEMBER_PORT_MAP_RSVD4_SFT  4
	/* Link aggregation mode being used. */
	uint8_t	link_aggr_mode;
	/* active active mode. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_AGGR_MODE_ACTIVE_ACTIVE UINT32_C(0x1)
	/* active backup mode. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_AGGR_MODE_ACTIVE_BACKUP UINT32_C(0x2)
	/* Balance XOR mode. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_AGGR_MODE_BALANCE_XOR   UINT32_C(0x3)
	/* 802.3AD mode. */
	#define HWRM_FUNC_LAG_UPDATE_INPUT_AGGR_MODE_802_3_AD	UINT32_C(0x4)
	#define HWRM_FUNC_LAG_UPDATE_INPUT_AGGR_MODE_LAST	HWRM_FUNC_LAG_UPDATE_INPUT_AGGR_MODE_802_3_AD
	uint8_t	unused_0[3];
} hwrm_func_lag_update_input_t, *phwrm_func_lag_update_input_t;

/* hwrm_func_lag_update_output (size:128b/16B) */

typedef struct hwrm_func_lag_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_lag_update_output_t, *phwrm_func_lag_update_output_t;

/**********************
 * hwrm_func_lag_free *
 **********************/


/* hwrm_func_lag_free_input (size:192b/24B) */

typedef struct hwrm_func_lag_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Link aggregation group ID of the LAG to be freed. */
	uint8_t	fw_lag_id;
	uint8_t	unused_0[7];
} hwrm_func_lag_free_input_t, *phwrm_func_lag_free_input_t;

/* hwrm_func_lag_free_output (size:128b/16B) */

typedef struct hwrm_func_lag_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_lag_free_output_t, *phwrm_func_lag_free_output_t;

/**********************
 * hwrm_func_lag_qcfg *
 **********************/


/* hwrm_func_lag_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_lag_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Link aggregation group ID of the LAG to be queried. */
	uint8_t	fw_lag_id;
	uint8_t	unused_0[7];
} hwrm_func_lag_qcfg_input_t, *phwrm_func_lag_qcfg_input_t;

/* hwrm_func_lag_qcfg_output (size:128b/16B) */

typedef struct hwrm_func_lag_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the bitmap of all active ports in the LAG. Each bit
	 * represents a front panel port of the device. Ports are numbered
	 * from 0 to n - 1 on a device with n ports. The number of front panel
	 * ports is specified in the port_cnt field of the HWRM_PORT_PHY_QCAPS
	 * response. The active_port_map must always be a subset of the
	 * member_port_map. An active port is eligible to send and receive
	 * traffic.
	 *
	 * If the LAG mode is active-backup, only one port can be an active
	 * port at a given time. All other ports in the member_port_map that
	 * are not the active port are backup port. When the active port
	 * fails, another member port takes over to become the active port.
	 * The driver should use HWRM_FUNC_LAG_UPDATE to update
	 * the active_port_map by only setting the port bit of the new active
	 * port.
	 *
	 * In active-active, balance_xor or 802_3_ad mode, all member ports
	 * can be active ports. If the driver determines that an active
	 * port is down or unable to function, it should use
	 * HWRM_FUNC_LAG_UPDATE to update the active_port_map by clearing
	 * the port bit that has failed.
	 */
	uint8_t	active_port_map;
	/* If this bit is set to '1', the port0 is a lag active port. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_ACTIVE_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag active port. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_ACTIVE_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag active port. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_ACTIVE_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag active port. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_ACTIVE_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd3 is 4 b */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_ACTIVE_PORT_MAP_RSVD3_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_ACTIVE_PORT_MAP_RSVD3_SFT  4
	/*
	 * This is the bitmap of all member ports in the LAG. Each bit
	 * represents a front panel port of the device. Ports are numbered
	 * from 0 to n - 1 on a device with n ports. The number of front panel
	 * ports is specified in the port_cnt field of the HWRM_PORT_PHY_QCAPS
	 * response. There must be at least 2 ports in the member ports and
	 * each must not be a member of another LAG. Note that on a 4-port
	 * device, there can be either 2 ports or 4 ports in the member ports.
	 * Using 3 member ports is not supported.
	 */
	uint8_t	member_port_map;
	/* If this bit is set to '1', the port0 is a lag member port. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_MEMBER_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag member port. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_MEMBER_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag member port. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_MEMBER_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag member port. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_MEMBER_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd4 is 4 b */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_MEMBER_PORT_MAP_RSVD4_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_MEMBER_PORT_MAP_RSVD4_SFT  4
	/* Link aggregation mode being used. */
	uint8_t	link_aggr_mode;
	/* active active mode. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_AGGR_MODE_ACTIVE_ACTIVE UINT32_C(0x1)
	/* active backup mode. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_AGGR_MODE_ACTIVE_BACKUP UINT32_C(0x2)
	/* Balance XOR mode. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_AGGR_MODE_BALANCE_XOR   UINT32_C(0x3)
	/* 802.3AD mode. */
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_AGGR_MODE_802_3_AD	UINT32_C(0x4)
	#define HWRM_FUNC_LAG_QCFG_OUTPUT_AGGR_MODE_LAST	HWRM_FUNC_LAG_QCFG_OUTPUT_AGGR_MODE_802_3_AD
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_lag_qcfg_output_t, *phwrm_func_lag_qcfg_output_t;

/**************************
 * hwrm_func_lag_mode_cfg *
 **************************/


/* hwrm_func_lag_mode_cfg_input (size:192b/24B) */

typedef struct hwrm_func_lag_mode_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	enables;
	/*
	 * This bit must be '1' for the link aggregation enable or
	 * disable flags to be configured.
	 */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ENABLES_FLAGS		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the active_port_map field to be
	 * configured.
	 */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ENABLES_ACTIVE_PORT_MAP	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the member_port_map field to be
	 * configured.
	 */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ENABLES_MEMBER_PORT_MAP	UINT32_C(0x4)
	/* This bit must be '1' for the aggr_mode field to be configured. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ENABLES_AGGR_MODE	UINT32_C(0x8)
	/* This bit must be '1' for the lag id field to be configured. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ENABLES_LAG_ID		UINT32_C(0x10)
	/* rsvd1 is 3 b */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ENABLES_RSVD1_MASK	UINT32_C(0xe0)
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ENABLES_RSVD1_SFT	5
	uint8_t	flags;
	/*
	 * If this bit is set to 1, the driver is requesting FW to disable
	 * link aggregation feature during run time.
	 */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_FLAGS_AGGR_DISABLE	UINT32_C(0x1)
	/*
	 * If this bit is set to 1, the driver is requesting FW to enable
	 * link aggregation feature during run time.
	 */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_FLAGS_AGGR_ENABLE	UINT32_C(0x2)
	/* rsvd2 is 6 b */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_FLAGS_RSVD2_MASK	UINT32_C(0xfc)
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_FLAGS_RSVD2_SFT	2
	/*
	 * This is the bitmap of all active ports in the LAG. Each bit
	 * represents a front panel port of the device starting from port 0.
	 * The number of front panel ports is specified in the port_cnt field
	 * of the HWRM_PORT_PHY_QCAPS response.
	 * The term "active port" is one of member ports which is eligible to
	 * send or receive the traffic.
	 * In the active-backup mode, only one member port is active port at
	 * any given time. If the active port fails, another member port
	 * automatically takes over the active role to ensure continuous
	 * network connectivity.
	 * In the active-active, balance_xor or 802_3_ad mode, all member ports
	 * could be active port, if link status on one port is down, driver
	 * needs to send the NIC a new active-port bitmap with marking this
	 * port as not active port.
	 * The PORT_2 and PORT_3 are only valid if the NIC has four front
	 * panel ports.
	 */
	uint8_t	active_port_map;
	/* If this bit is set to '1', the port0 is a lag active port. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ACTIVE_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag active port. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ACTIVE_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag active port. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ACTIVE_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag active port. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ACTIVE_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd3 is 4 b */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ACTIVE_PORT_MAP_RSVD3_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_ACTIVE_PORT_MAP_RSVD3_SFT  4
	/*
	 * This is the bitmap of all member ports in the LAG. Each bit
	 * represents a front panel port of the device starting from port 0.
	 * The number of front panel ports is specified in the port_cnt field
	 * of the HWRM_PORT_PHY_QCAPS response.
	 * The term "member port" refers to a front panel port that is added to
	 * the bond group as a slave device. These member ports are combined to
	 * create a logical bond interface.
	 * For a 4-port NIC, the LAG member port combination can consist of
	 * either two ports or four ports. However, it is important to note
	 * that the case with three ports in the same lag group is not
	 * supported.
	 * The PORT_2 and PORT_3 are only valid if the NIC has four front
	 * panel ports. There could be a case to use multiple LAG groups,
	 * for example, if the NIC has four front panel ports, the lag feature
	 * can use up to two LAG groups, with two ports assigned to each group.
	 */
	uint8_t	member_port_map;
	/* If this bit is set to '1', the port0 is a lag member port. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_MEMBER_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag member port. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_MEMBER_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag member port. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_MEMBER_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag member port. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_MEMBER_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd4 is 4 b */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_MEMBER_PORT_MAP_RSVD4_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_MEMBER_PORT_MAP_RSVD4_SFT  4
	/* Link aggregation mode being used. */
	uint8_t	link_aggr_mode;
	/* active active mode. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_AGGR_MODE_ACTIVE_ACTIVE UINT32_C(0x1)
	/* active backup mode. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_AGGR_MODE_ACTIVE_BACKUP UINT32_C(0x2)
	/* Balance XOR mode. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_AGGR_MODE_BALANCE_XOR   UINT32_C(0x3)
	/* 802.3AD mode. */
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_AGGR_MODE_802_3_AD	UINT32_C(0x4)
	#define HWRM_FUNC_LAG_MODE_CFG_INPUT_AGGR_MODE_LAST	HWRM_FUNC_LAG_MODE_CFG_INPUT_AGGR_MODE_802_3_AD
	/* Link aggregation group idx being used. */
	uint8_t	lag_id;
	uint8_t	unused_0[2];
} hwrm_func_lag_mode_cfg_input_t, *phwrm_func_lag_mode_cfg_input_t;

/* hwrm_func_lag_mode_cfg_output (size:128b/16B) */

typedef struct hwrm_func_lag_mode_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Link aggregation group idx being used. */
	uint8_t	lag_id;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_lag_mode_cfg_output_t, *phwrm_func_lag_mode_cfg_output_t;

/***************************
 * hwrm_func_lag_mode_qcfg *
 ***************************/


/* hwrm_func_lag_mode_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_lag_mode_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} hwrm_func_lag_mode_qcfg_input_t, *phwrm_func_lag_mode_qcfg_input_t;

/* hwrm_func_lag_mode_qcfg_output (size:128b/16B) */

typedef struct hwrm_func_lag_mode_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	aggr_enabled;
	/*
	 * This flag is used to query whether link aggregation is enabled
	 * or disabled during run time.
	 */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_AGGR_ENABLED	UINT32_C(0x1)
	/* rsvd1 is 7 b */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_RSVD1_MASK	UINT32_C(0xfe)
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_RSVD1_SFT	1
	/*
	 * This is the bitmap of all active ports in the LAG. Each bit
	 * represents a front panel port of the device starting from port 0.
	 * The number of front panel ports is specified in the port_cnt field
	 * of the HWRM_PORT_PHY_QCAPS response.
	 * The term "active port" is one of member ports which is eligible to
	 * send or receive the traffic.
	 * In the active-backup mode, only one member port is active port at
	 * any given time. If the active port fails, another member port
	 * automatically takes over the active role to ensure continuous
	 * network connectivity.
	 * In the active-active, balance_xor or 802_3_ad mode, all member ports
	 * could be active port, if link status on one port is down, driver
	 * needs to send the NIC a new active-port bitmap with marking this
	 * port as not active port.
	 * The PORT_2 and PORT_3 are only valid if the NIC has four front
	 * panel ports.
	 */
	uint8_t	active_port_map;
	/* If this bit is set to '1', the port0 is a lag active port. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_ACTIVE_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag active port. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_ACTIVE_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag active port. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_ACTIVE_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag active port. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_ACTIVE_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd2 is 4 b */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_ACTIVE_PORT_MAP_RSVD2_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_ACTIVE_PORT_MAP_RSVD2_SFT  4
	/*
	 * This is the bitmap of all member ports in the LAG. Each bit
	 * represents a front panel port of the device starting from port 0.
	 * The number of front panel ports is specified in the port_cnt field
	 * of the HWRM_PORT_PHY_QCAPS response.
	 * The term "member port" refers to a front panel port that is added to
	 * the bond group as a slave device. These member ports are combined to
	 * create a logical bond interface.
	 * For a 4-port NIC, the LAG member port combination can consist of
	 * either two ports or four ports. However, it is important to note
	 * that the case with three ports in the same lag group is not
	 * supported.
	 * The PORT_2 and PORT_3 are only valid if the NIC has four front
	 * panel ports. There could be a case to use multiple LAG groups,
	 * for example, if the NIC has four front panel ports, the lag feature
	 * can use up to two LAG groups, with two ports assigned to each group.
	 */
	uint8_t	member_port_map;
	/* If this bit is set to '1', the port0 is a lag member port. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_MEMBER_PORT_MAP_PORT_0	UINT32_C(0x1)
	/* If this bit is set to '1', the port1 is a lag member port. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_MEMBER_PORT_MAP_PORT_1	UINT32_C(0x2)
	/* If this bit is set to '1', the port2 is a lag member port. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_MEMBER_PORT_MAP_PORT_2	UINT32_C(0x4)
	/* If this bit is set to '1', the port3 is a lag member port. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_MEMBER_PORT_MAP_PORT_3	UINT32_C(0x8)
	/* rsvd3 is 4 b */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_MEMBER_PORT_MAP_RSVD3_MASK UINT32_C(0xf0)
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_MEMBER_PORT_MAP_RSVD3_SFT  4
	/* Link aggregation mode being used. */
	uint8_t	link_aggr_mode;
	/* active active mode. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_AGGR_MODE_ACTIVE_ACTIVE UINT32_C(0x1)
	/* active backup mode. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_AGGR_MODE_ACTIVE_BACKUP UINT32_C(0x2)
	/* Balance XOR mode. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_AGGR_MODE_BALANCE_XOR   UINT32_C(0x3)
	/* 802.3AD mode. */
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_AGGR_MODE_802_3_AD	UINT32_C(0x4)
	#define HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_AGGR_MODE_LAST	HWRM_FUNC_LAG_MODE_QCFG_OUTPUT_AGGR_MODE_802_3_AD
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_lag_mode_qcfg_output_t, *phwrm_func_lag_mode_qcfg_output_t;

/***********************
 * hwrm_func_vlan_qcfg *
 ***********************/


/* hwrm_func_vlan_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_vlan_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_vlan_qcfg_input_t, *phwrm_func_vlan_qcfg_input_t;

/* hwrm_func_vlan_qcfg_output (size:320b/40B) */

typedef struct hwrm_func_vlan_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint64_t	unused_0;
	/* S-TAG VLAN identifier configured for the function. */
	uint16_t	stag_vid;
	/* S-TAG PCP value configured for the function. */
	uint8_t	stag_pcp;
	uint8_t	unused_1;
	/*
	 * S-TAG TPID value configured for the function. This field is
	 * specified in network byte order.
	 */
	uint16_t	stag_tpid;
	/* C-TAG VLAN identifier configured for the function. */
	uint16_t	ctag_vid;
	/* C-TAG PCP value configured for the function. */
	uint8_t	ctag_pcp;
	uint8_t	unused_2;
	/*
	 * C-TAG TPID value configured for the function. This field is
	 * specified in network byte order.
	 */
	uint16_t	ctag_tpid;
	/* Future use. */
	uint32_t	rsvd2;
	/* Future use. */
	uint32_t	rsvd3;
	uint8_t	unused_3[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vlan_qcfg_output_t, *phwrm_func_vlan_qcfg_output_t;

/**********************
 * hwrm_func_vlan_cfg *
 **********************/


/* hwrm_func_vlan_cfg_input (size:384b/48B) */

typedef struct hwrm_func_vlan_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	uint32_t	enables;
	/*
	 * This bit must be '1' for the stag_vid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_VID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ctag_vid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_VID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the stag_pcp field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_PCP	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ctag_pcp field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_PCP	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stag_tpid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_TPID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ctag_tpid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_TPID	UINT32_C(0x20)
	/* S-TAG VLAN identifier configured for the function. */
	uint16_t	stag_vid;
	/* S-TAG PCP value configured for the function. */
	uint8_t	stag_pcp;
	uint8_t	unused_1;
	/*
	 * S-TAG TPID value configured for the function. This field is
	 * specified in network byte order.
	 */
	uint16_t	stag_tpid;
	/* C-TAG VLAN identifier configured for the function. */
	uint16_t	ctag_vid;
	/* C-TAG PCP value configured for the function. */
	uint8_t	ctag_pcp;
	uint8_t	unused_2;
	/*
	 * C-TAG TPID value configured for the function. This field is
	 * specified in network byte order.
	 */
	uint16_t	ctag_tpid;
	/* Future use. */
	uint32_t	rsvd1;
	/* Future use. */
	uint32_t	rsvd2;
	uint8_t	unused_3[4];
} hwrm_func_vlan_cfg_input_t, *phwrm_func_vlan_cfg_input_t;

/* hwrm_func_vlan_cfg_output (size:128b/16B) */

typedef struct hwrm_func_vlan_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vlan_cfg_output_t, *phwrm_func_vlan_cfg_output_t;

/*******************************
 * hwrm_func_vf_vnic_ids_query *
 *******************************/


/* hwrm_func_vf_vnic_ids_query_input (size:256b/32B) */

typedef struct hwrm_func_vf_vnic_ids_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[2];
	/* Max number of vnic ids in vnic id table */
	uint32_t	max_vnic_id_cnt;
	/* This is the address for VF VNIC ID table */
	uint64_t	vnic_id_tbl_addr;
} hwrm_func_vf_vnic_ids_query_input_t, *phwrm_func_vf_vnic_ids_query_input_t;

/* hwrm_func_vf_vnic_ids_query_output (size:128b/16B) */

typedef struct hwrm_func_vf_vnic_ids_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Actual number of vnic ids
	 *
	 * Each VNIC ID is written as a 32-bit number.
	 */
	uint32_t	vnic_id_cnt;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_vnic_ids_query_output_t, *phwrm_func_vf_vnic_ids_query_output_t;

/***********************
 * hwrm_func_vf_bw_cfg *
 ***********************/


/* hwrm_func_vf_bw_cfg_input (size:960b/120B) */

typedef struct hwrm_func_vf_bw_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The number of VF functions that are being configured.
	 * The cmd space allows up to 50 VFs' BW to be configured with one cmd.
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid and the rate scale percentage. */
	uint16_t	vfn[48];
	/* The physical VF id the adjustment will be made to. */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_VFID_MASK	UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_VFID_SFT	0
	/*
	 * This field configures the rate scale percentage of the VF as specified
	 * by the physical VF id.
	 */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_MASK	UINT32_C(0xf000)
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_SFT	12
	/* 0% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_0	(UINT32_C(0x0) << 12)
	/* 6.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_6_66   (UINT32_C(0x1) << 12)
	/* 13.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_13_33  (UINT32_C(0x2) << 12)
	/* 20% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_20	(UINT32_C(0x3) << 12)
	/* 26.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_26_66  (UINT32_C(0x4) << 12)
	/* 33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_33_33  (UINT32_C(0x5) << 12)
	/* 40% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_40	(UINT32_C(0x6) << 12)
	/* 46.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_46_66  (UINT32_C(0x7) << 12)
	/* 53.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_53_33  (UINT32_C(0x8) << 12)
	/* 60% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_60	(UINT32_C(0x9) << 12)
	/* 66.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_66_66  (UINT32_C(0xa) << 12)
	/* 53.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_73_33  (UINT32_C(0xb) << 12)
	/* 80% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_80	(UINT32_C(0xc) << 12)
	/* 86.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_86_66  (UINT32_C(0xd) << 12)
	/* 93.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_93_33  (UINT32_C(0xe) << 12)
	/* 100% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_100	(UINT32_C(0xf) << 12)
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_LAST	HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_100
} hwrm_func_vf_bw_cfg_input_t, *phwrm_func_vf_bw_cfg_input_t;

/* hwrm_func_vf_bw_cfg_output (size:128b/16B) */

typedef struct hwrm_func_vf_bw_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_bw_cfg_output_t, *phwrm_func_vf_bw_cfg_output_t;

/************************
 * hwrm_func_vf_bw_qcfg *
 ************************/


/* hwrm_func_vf_bw_qcfg_input (size:960b/120B) */

typedef struct hwrm_func_vf_bw_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The number of VF functions that are being queried.
	 * The inline response space allows the host to query up to 50 VFs'
	 * rate scale percentage
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid */
	uint16_t	vfn[48];
	/* The physical VF id of interest */
	#define HWRM_FUNC_VF_BW_QCFG_INPUT_VFN_VFID_MASK UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_QCFG_INPUT_VFN_VFID_SFT 0
} hwrm_func_vf_bw_qcfg_input_t, *phwrm_func_vf_bw_qcfg_input_t;

/* hwrm_func_vf_bw_qcfg_output (size:960b/120B) */

typedef struct hwrm_func_vf_bw_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of VF functions that are being queried.
	 * The inline response space allows the host to query up to 50 VFs'
	 * rate scale percentage.
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid and the rate scale percentage. */
	uint16_t	vfn[48];
	/* The physical VF id the adjustment will be made to. */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_VFID_MASK	UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_VFID_SFT	0
	/*
	 * This field configures the rate scale percentage of the VF as specified
	 * by the physical VF id.
	 */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_MASK	UINT32_C(0xf000)
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_SFT	12
	/* 0% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_0	(UINT32_C(0x0) << 12)
	/* 6.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_6_66   (UINT32_C(0x1) << 12)
	/* 13.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_13_33  (UINT32_C(0x2) << 12)
	/* 20% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_20	(UINT32_C(0x3) << 12)
	/* 26.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_26_66  (UINT32_C(0x4) << 12)
	/* 33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_33_33  (UINT32_C(0x5) << 12)
	/* 40% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_40	(UINT32_C(0x6) << 12)
	/* 46.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_46_66  (UINT32_C(0x7) << 12)
	/* 53.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_53_33  (UINT32_C(0x8) << 12)
	/* 60% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_60	(UINT32_C(0x9) << 12)
	/* 66.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_66_66  (UINT32_C(0xa) << 12)
	/* 53.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_73_33  (UINT32_C(0xb) << 12)
	/* 80% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_80	(UINT32_C(0xc) << 12)
	/* 86.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_86_66  (UINT32_C(0xd) << 12)
	/* 93.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_93_33  (UINT32_C(0xe) << 12)
	/* 100% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_100	(UINT32_C(0xf) << 12)
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_LAST	HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_100
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_bw_qcfg_output_t, *phwrm_func_vf_bw_qcfg_output_t;

/***************************
 * hwrm_func_drv_if_change *
 ***************************/


/* hwrm_func_drv_if_change_input (size:192b/24B) */

typedef struct hwrm_func_drv_if_change_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is indicating
	 * that the IF state is changing to UP state. The call should
	 * be made at the beginning of the driver's open call before
	 * resources are allocated. After making the call, the driver
	 * should check the response to see if any resources may have
	 * changed (see the response below). If the driver fails
	 * the open call, the driver should make this call again with
	 * this bit cleared to indicate that the IF state is not UP.
	 * During the driver's close call when the IF state is changing
	 * to DOWN, the driver should make this call with the bit cleared
	 * after all resources have been freed.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_INPUT_FLAGS_UP	UINT32_C(0x1)
	uint32_t	unused;
} hwrm_func_drv_if_change_input_t, *phwrm_func_drv_if_change_input_t;

/* hwrm_func_drv_if_change_output (size:128b/16B) */

typedef struct hwrm_func_drv_if_change_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', it indicates that the resources reserved
	 * for this function may have changed. The driver should check
	 * resource capabilities and reserve resources again before
	 * allocating resources.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_OUTPUT_FLAGS_RESC_CHANGE	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that the firmware got changed /
	 * reset. The driver should do complete re-initialization when that
	 * bit is set.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_OUTPUT_FLAGS_HOT_FW_RESET_DONE	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that capabilities
	 * for this function may have changed. The driver should
	 * query for changes to capabilities.
	 * The CAPS_CHANGE bit will only be set when it is safe for the
	 * driver to completely re-initialize all resources for the function
	 * including any children VFs.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_OUTPUT_FLAGS_CAPS_CHANGE	UINT32_C(0x4)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_drv_if_change_output_t, *phwrm_func_drv_if_change_output_t;

/*******************************
 * hwrm_func_host_pf_ids_query *
 *******************************/


/* hwrm_func_host_pf_ids_query_input (size:192b/24B) */

typedef struct hwrm_func_host_pf_ids_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	host;
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to SOC host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_SOC	UINT32_C(0x1)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP0 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_0	UINT32_C(0x2)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP1 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_1	UINT32_C(0x4)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP2 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_2	UINT32_C(0x8)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP3 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_3	UINT32_C(0x10)
	/*
	 * This provides a filter of what PF(s) will be returned in the
	 * query..
	 */
	uint8_t	filter;
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field). This includes the hidden PFs.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ALL  UINT32_C(0x0)
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field) that is available for L2 traffic.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_L2   UINT32_C(0x1)
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field) that is available for ROCE traffic.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ROCE UINT32_C(0x2)
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_LAST HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ROCE
	uint8_t	unused_1[6];
} hwrm_func_host_pf_ids_query_input_t, *phwrm_func_host_pf_ids_query_input_t;

/* hwrm_func_host_pf_ids_query_output (size:128b/16B) */

typedef struct hwrm_func_host_pf_ids_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This provides the first PF ID of the device. */
	uint16_t	first_pf_id;
	uint16_t	pf_ordinal_mask;
	/*
	 * When this bit is '1', it indicates first PF belongs to one of
	 * the hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_0	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates 2nd PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_1	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates 3rd PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates 4th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_3	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates 5th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_4	UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates 6th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_5	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates 7th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_6	UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates 8th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_7	UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates 9th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_8	UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates 10th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_9	UINT32_C(0x200)
	/*
	 * When this bit is '1', it indicates 11th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_10	UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates 12th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_11	UINT32_C(0x800)
	/*
	 * When this bit is '1', it indicates 13th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_12	UINT32_C(0x1000)
	/*
	 * When this bit is '1', it indicates 14th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_13	UINT32_C(0x2000)
	/*
	 * When this bit is '1', it indicates 15th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_14	UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates 16th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_15	UINT32_C(0x8000)
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_host_pf_ids_query_output_t, *phwrm_func_host_pf_ids_query_output_t;

/*********************
 * hwrm_func_spd_cfg *
 *********************/


/* hwrm_func_spd_cfg_input (size:384b/48B) */

typedef struct hwrm_func_spd_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* Set this bit is '1' to enable the SPD datapath forwarding. */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_FWD_ENABLE	UINT32_C(0x1)
	/* Set this bit is '1' to disable the SPD datapath forwarding. */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_FWD_DISABLE	UINT32_C(0x2)
	/*
	 * Set this bit is '1' to enable the SPD datapath checksum
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_CSUM_ENABLE	UINT32_C(0x4)
	/*
	 * Set this bit is '1' to disable the SPD datapath checksum
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_CSUM_DISABLE	UINT32_C(0x8)
	/*
	 * Set this bit is '1' to enable the SPD datapath debug
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_DBG_ENABLE	UINT32_C(0x10)
	/*
	 * Set this bit is '1' to disable the SPD datapath debug
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_DBG_DISABLE	UINT32_C(0x20)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_ETHERTYPE		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the hash_mode_flags field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_MODE_FLAGS	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the hash_type field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_TYPE		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ring_tbl_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_RING_TBL_ADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the hash_key_tbl_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_KEY_TBL_ADDR	UINT32_C(0x10)
	/*
	 * Ethertype value used in the encapsulated SPD packet header.
	 * The user must choose a value that is not conflicting with
	 * publicly defined ethertype values. By default, the ethertype
	 * value of 0xffff is used if there is no user specified value.
	 */
	uint16_t	ethertype;
	/* Flags to specify different RSS hash modes. */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1', it indicates using current RSS
	 * hash mode setting configured in the device.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_DEFAULT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_4	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_4	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_2	UINT32_C(0x10)
	uint8_t	unused_1;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_IPV4	UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_TCP_IPV4	UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_UDP_IPV4	UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_IPV6	UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_TCP_IPV6	UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_UDP_IPV6	UINT32_C(0x20)
	/* This is the address for rss ring group table */
	uint64_t	ring_grp_tbl_addr;
	/* This is the address for rss hash key table */
	uint64_t	hash_key_tbl_addr;
} hwrm_func_spd_cfg_input_t, *phwrm_func_spd_cfg_input_t;

/* hwrm_func_spd_cfg_output (size:128b/16B) */

typedef struct hwrm_func_spd_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_spd_cfg_output_t, *phwrm_func_spd_cfg_output_t;

/**********************
 * hwrm_func_spd_qcfg *
 **********************/


/* hwrm_func_spd_qcfg_input (size:128b/16B) */

typedef struct hwrm_func_spd_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_spd_qcfg_input_t, *phwrm_func_spd_qcfg_input_t;

/* hwrm_func_spd_qcfg_output (size:512b/64B) */

typedef struct hwrm_func_spd_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * The SPD datapath forwarding is currently enabled when this
	 * flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_FWD_ENABLED	UINT32_C(0x1)
	/*
	 * The SPD datapath checksum feature is currently enabled when
	 * this flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_CSUM_ENABLED	UINT32_C(0x2)
	/*
	 * The SPD datapath debug feature is currently enabled when
	 * this flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_DBG_ENABLED	UINT32_C(0x4)
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_IPV4	UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_TCP_IPV4	UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_UDP_IPV4	UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_IPV6	UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_TCP_IPV6	UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_UDP_IPV6	UINT32_C(0x20)
	/* This is the value of rss hash key */
	uint32_t	hash_key[10];
	/* Flags to specify different RSS hash modes. */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1', it indicates using current RSS
	 * hash mode setting configured in the device.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_DEFAULT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_4	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_4	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_2	UINT32_C(0x10)
	uint8_t	unused_1;
	/*
	 * Ethertype value used in the encapsulated SPD packet header.
	 * The user must choose a value that is not conflicting with
	 * publicly defined ethertype values. By default, the ethertype
	 * value of 0xffff is used if there is no user specified value.
	 */
	uint16_t	ethertype;
	uint8_t	unused_2[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_spd_qcfg_output_t, *phwrm_func_spd_qcfg_output_t;

/*********************
 * hwrm_port_phy_cfg *
 *********************/


/* hwrm_port_phy_cfg_input (size:512b/64B) */

typedef struct hwrm_port_phy_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is set to '1', the PHY for the port shall
	 * be reset.
	 *
	 * # If this bit is set to 1, then the HWRM shall reset the
	 * PHY after applying PHY configuration changes specified
	 * in this command.
	 * # In order to guarantee that PHY configuration changes
	 * specified in this command take effect, the HWRM
	 * client should set this flag to 1.
	 * # If this bit is not set to 1, then the HWRM may reset
	 * the PHY depending on the current PHY configuration and
	 * settings specified in this command.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_RESET_PHY		UINT32_C(0x1)
	/* deprecated bit. Do not use!!! */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_DEPRECATED		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', and the force_pam4_link_speed
	 * bit in the 'enables' field is '0', the link shall be forced
	 * to the force_link_speed value.
	 *
	 * When this bit is set to '1', and the force_pam4_link_speed
	 * bit in the 'enables' field is '1', the link shall be forced
	 * to the force_pam4_link_speed value.
	 *
	 * When this bit is set to '1', the HWRM client should
	 * not enable any of the auto negotiation related
	 * fields represented by auto_XXX fields in this command.
	 * When this bit is set to '1' and the HWRM client has
	 * enabled a auto_XXX field in this command, then the
	 * HWRM shall ignore the enabled auto_XXX field.
	 *
	 * When this bit is set to zero, the link
	 * shall be allowed to autoneg.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FORCE			UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the auto-negotiation process
	 * shall be restarted on the link.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_RESTART_AUTONEG		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', Energy Efficient Ethernet
	 * (EEE) is requested to be enabled on this link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_ENABLE		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', Energy Efficient Ethernet
	 * (EEE) is requested to be disabled on this link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_DISABLE		UINT32_C(0x20)
	/*
	 * When this bit is set to '1' and EEE is enabled on this
	 * link, then TX LPI is requested to be enabled on the link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 * If EEE is disabled on this port, then this flag shall be
	 * ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_TX_LPI_ENABLE	UINT32_C(0x40)
	/*
	 * When this bit is set to '1' and EEE is enabled on this
	 * link, then TX LPI is requested to be disabled on the link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 * If EEE is disabled on this port, then this flag shall be
	 * ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_TX_LPI_DISABLE	UINT32_C(0x80)
	/*
	 * When set to 1, then the HWRM shall enable FEC autonegotiation
	 * on this port if supported. When enabled, at least one of the
	 * FEC modes must be advertised by enabling the fec_clause_74_enable,
	 * fec_clause_91_enable, fec_rs544_1xn_enable, fec_rs544_ieee_enable,
	 * fec_rs272_1xn_enable, or fec_rs272_ieee_enable flag. If none
	 * of the FEC mode is currently enabled, the HWRM shall choose
	 * a default advertisement setting.
	 * The default advertisement setting can be queried by calling
	 * hwrm_port_phy_qcfg. Note that the link speed must be
	 * in autonegotiation mode for FEC autonegotiation to take effect.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC autonegotiation is not supported, then the HWRM shall
	 * ignore this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_AUTONEG_ENABLE	UINT32_C(0x100)
	/*
	 * When set to 1, then the HWRM shall disable FEC autonegotiation
	 * on this port and use forced FEC mode. In forced FEC mode, one
	 * or more FEC forced settings under the same clause can be set.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC autonegotiation is not supported, then the HWRM shall
	 * ignore this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_AUTONEG_DISABLE	UINT32_C(0x200)
	/*
	 * When set to 1, then the HWRM shall enable FEC CLAUSE 74 (Fire
	 * Code) on this port if supported, by advertising FEC CLAUSE 74 if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC CLAUSE 74 is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE74_ENABLE	UINT32_C(0x400)
	/*
	 * When set to 1, then the HWRM shall disable FEC CLAUSE 74 (Fire
	 * Code) on this port if supported, by not advertising FEC CLAUSE 74
	 * if FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC CLAUSE 74 is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE74_DISABLE	UINT32_C(0x800)
	/*
	 * When set to 1, then the HWRM shall enable FEC CLAUSE 91
	 * (Reed Solomon RS(528,514) for NRZ) on this port if supported,
	 * by advertising FEC RS(528,514) if FEC autonegotiation is enabled
	 * or force enabled otherwise. In forced FEC mode, this flag
	 * will only take effect if the speed is NRZ. Additional
	 * RS544 or RS272 flags (also under clause 91) may be set for PAM4
	 * in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(528,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE91_ENABLE	UINT32_C(0x1000)
	/*
	 * When set to 1, then the HWRM shall disable FEC CLAUSE 91
	 * (Reed Solomon RS(528,514) for NRZ) on this port if supported, by
	 * not advertising RS(528,514) if FEC autonegotiation is enabled or
	 * force disabled otherwise. When set to 0, then this flag shall be
	 * ignored. If FEC RS(528,514) is not supported, then the HWRM
	 * shall ignore this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE91_DISABLE	UINT32_C(0x2000)
	/*
	 * When this bit is set to '1', the link shall be forced to
	 * be taken down.
	 *
	 * # When this bit is set to '1", all other
	 * command input settings related to the link speed shall
	 * be ignored.
	 * Once the link state is forced down, it can be
	 * explicitly cleared from that state by setting this flag
	 * to '0'.
	 * # If this flag is set to '0', then the link shall be
	 * cleared from forced down state if the link is in forced
	 * down state.
	 * There may be conditions (e.g. out-of-band or sideband
	 * configuration changes for the link) outside the scope
	 * of the HWRM implementation that may clear forced down
	 * link state.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FORCE_LINK_DWN		UINT32_C(0x4000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS544_1XN
	 * on this port if supported, by advertising FEC RS544_1XN if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4. If this flag and fec_rs544_ieee_enable are set, the
	 * HWRM shall choose one of the RS544 modes.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS544_1XN is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_1XN_ENABLE	UINT32_C(0x8000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS544_1XN
	 * on this port if supported, by not advertising FEC RS544_1XN if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS544_1XN is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_1XN_DISABLE	UINT32_C(0x10000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS(544,514)
	 * on this port if supported, by advertising FEC RS(544,514) if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4. If this flag and fec_rs544_1xn_enable are set, the
	 * HWRM shall choose one of the RS544 modes.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(544,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_IEEE_ENABLE	UINT32_C(0x20000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS(544,514)
	 * on this port if supported, by not advertising FEC RS(544,514) if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(544,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_IEEE_DISABLE	UINT32_C(0x40000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS272_1XN
	 * on this port if supported, by advertising FEC RS272_1XN if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4. If this flag and fec_rs272_ieee_enable are set, the
	 * HWRM shall choose one of the RS272 modes. Note that RS272
	 * and RS544 modes cannot be set at the same time in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS272_1XN is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_1XN_ENABLE	UINT32_C(0x80000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS272_1XN
	 * on this port if supported, by not advertising FEC RS272_1XN if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS272_1XN is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_1XN_DISABLE	UINT32_C(0x100000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS(272,257)
	 * on this port if supported, by advertising FEC RS(272,257) if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4. If this flag and fec_rs272_1xn_enable are set, the
	 * HWRM shall choose one of the RS272 modes. Note that RS272
	 * and RS544 modes cannot be set at the same time in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(272,257) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_IEEE_ENABLE	UINT32_C(0x200000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS(272,257)
	 * on this port if supported, by not advertising FEC RS(272,257) if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(272,257) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_IEEE_DISABLE	UINT32_C(0x400000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the auto_mode field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_MODE			UINT32_C(0x1)
	/*
	 * This bit must be '1' for the auto_duplex field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_DUPLEX		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the auto_pause field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_PAUSE			UINT32_C(0x4)
	/*
	 * This bit must be '1' for the auto_link_speed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEED		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the auto_link_speed_mask field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEED_MASK	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the wirespeed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_WIRESPEED			UINT32_C(0x20)
	/*
	 * This bit must be '1' for the lpbk field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_LPBK			UINT32_C(0x40)
	/*
	 * This bit must be '1' for the preemphasis field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_PREEMPHASIS		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the force_pause field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_FORCE_PAUSE		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the eee_link_speed_mask field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_EEE_LINK_SPEED_MASK	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tx_lpi_timer field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_TX_LPI_TIMER		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the force_pam4_link_speed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_FORCE_PAM4_LINK_SPEED	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the auto_pam4_link_speed_mask field to
	 * be configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_PAM4_LINK_SPEED_MASK	UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the force_link_speeds2 field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_FORCE_LINK_SPEEDS2		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the auto_link_speeds2_mask field to
	 * be configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEEDS2_MASK	UINT32_C(0x4000)
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	/*
	 * This is the speed that will be used if the force
	 * bit is '1'. If unsupported speed is selected, an error
	 * will be generated.
	 */
	uint16_t	force_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_LAST HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10MB
	/*
	 * This value is used to identify what autoneg mode is
	 * used when the link speed is not being forced.
	 */
	uint8_t	auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_NONE	UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ALL_SPEEDS   UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode
	 * has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ONE_SPEED	UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for
	 * autoneg. This mode has been DEPRECATED. An HWRM client should not
	 * use this mode.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ONE_OR_BELOW UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask
	 * values that are provided. The included speeds are specified in the
	 * auto_link_speed and auto_pam4_link_speed fields.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_SPEED_MASK   UINT32_C(0x4)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_LAST	HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_SPEED_MASK
	/*
	 * This is the duplex setting that will be used if the autoneg_mode
	 * is "one_speed" or "one_or_below".
	 */
	uint8_t	auto_duplex;
	/* Half Duplex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_HALF UINT32_C(0x0)
	/* Full duplex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_FULL UINT32_C(0x1)
	/* Both Half and Full duplex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_BOTH UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_LAST HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_BOTH
	/*
	 * This value is used to configure the pause that will be
	 * used for autonegotiation.
	 * Add text on the usage of auto_pause and force_pause.
	 */
	uint8_t	auto_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_TX		UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_RX		UINT32_C(0x2)
	/*
	 * When set to 1, the advertisement of pause is enabled.
	 *
	 * # When the auto_mode is not set to none and this flag is
	 * set to 1, then the auto_pause bits on this port are being
	 * advertised and autoneg pause results are being interpreted.
	 * # When the auto_mode is not set to none and this
	 * flag is set to 0, the pause is forced as indicated in
	 * force_pause, and also advertised as auto_pause bits, but
	 * the autoneg results are not interpreted since the pause
	 * configuration is being forced.
	 * # When the auto_mode is set to none and this flag is set to
	 * 1, auto_pause bits should be ignored and should be set to 0.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_AUTONEG_PAUSE	UINT32_C(0x4)
	/*
	 * This field is only used by management firmware to communicate with
	 * core firmware regarding phy_port_cfg.
	 * It mainly used to notify core firmware that management firmware is
	 * using port for NCSI over RMII communication or not.
	 */
	uint8_t	mgmt_flag;
	/*
	 * Bit denoting if management firmware is using the link for
	 * NCSI over RMII communication.
	 * When set to 1, management firmware is no longer using the given
	 * port.
	 * When set to 0, management firmware is using the given port.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_MGMT_FLAG_LINK_RELEASE	UINT32_C(0x1)
	/*
	 * Validity bit, set to 1 to indicate other bits in mgmt_flags are
	 * valid.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_MGMT_FLAG_MGMT_VALID	UINT32_C(0x80)
	/*
	 * This is the speed that will be used if the autoneg_mode
	 * is "one_speed" or "one_or_below". If an unsupported speed
	 * is selected, an error will be generated.
	 */
	uint16_t	auto_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_LAST HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10MB
	/*
	 * This is a mask of link speeds that will be used if
	 * autoneg_mode is "mask". If unsupported speed is enabled
	 * an error will be generated.
	 */
	uint16_t	auto_link_speed_mask;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10MB	UINT32_C(0x2000)
	/* This value controls the wirespeed feature. */
	uint8_t	wirespeed;
	/* Wirespeed feature is disabled. */
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_OFF UINT32_C(0x0)
	/* Wirespeed feature is enabled. */
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_ON  UINT32_C(0x1)
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_LAST HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_ON
	/* This value controls the loopback setting for the PHY. */
	uint8_t	lpbk;
	/* No loopback is selected. Normal operation. */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_NONE	UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_LOCAL	UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_REMOTE   UINT32_C(0x2)
	/*
	 * The HW will be configured with external loopback such that
	 * host data is sent on the transmitter and based on the external
	 * loopback connection the data will be received without
	 * modification.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_EXTERNAL UINT32_C(0x3)
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_LAST	HWRM_PORT_PHY_CFG_INPUT_LPBK_EXTERNAL
	/*
	 * This value is used to configure the pause that will be
	 * used for force mode.
	 */
	uint8_t	force_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAUSE_TX	UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAUSE_RX	UINT32_C(0x2)
	uint8_t	unused_1;
	/*
	 * This value controls the pre-emphasis to be used for the
	 * link. Driver should not set this value (use
	 * enable.preemphasis = 0) unless driver is sure of setting.
	 * Normally HWRM FW will determine proper pre-emphasis.
	 */
	uint32_t	preemphasis;
	/*
	 * Setting for link speed mask that is used to
	 * advertise speeds during autonegotiation when EEE is enabled.
	 * This field is valid only when EEE is enabled.
	 * The speeds specified in this field shall be a subset of
	 * speeds specified in auto_link_speed_mask.
	 * If EEE is enabled,then at least one speed shall be provided
	 * in this mask.
	 */
	uint16_t	eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD1	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD2	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD3	UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD4	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	/*
	 * This is the speed that will be used if the force and force_pam4
	 * bits are '1'. If unsupported speed is selected, an error
	 * will be generated.
	 */
	uint16_t	force_pam4_link_speed;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_200GB UINT32_C(0x7d0)
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_LAST HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_200GB
	/*
	 * Requested setting of TX LPI timer in microseconds.
	 * This field is valid only when EEE is enabled and TX LPI is
	 * enabled.
	 */
	uint32_t	tx_lpi_timer;
	#define HWRM_PORT_PHY_CFG_INPUT_TX_LPI_TIMER_MASK UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_CFG_INPUT_TX_LPI_TIMER_SFT 0
	/* This field specifies which PAM4 speeds are enabled for auto mode. */
	uint16_t	auto_link_pam4_speed_mask;
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_200G	UINT32_C(0x4)
	/*
	 * This is the speed that will be used if the force_link_speeds2
	 * bit is '1'. If unsupported speed is selected, an error
	 * will be generated.
	 */
	uint16_t	force_link_speeds2;
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_1GB		UINT32_C(0xa)
	/* 10Gb (NRZ: 10G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_10GB	UINT32_C(0x64)
	/* 25Gb (NRZ: 25G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_25GB	UINT32_C(0xfa)
	/* 40Gb (NRZ: 10G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_40GB	UINT32_C(0x190)
	/* 50Gb (NRZ: 25G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_50GB	UINT32_C(0x1f4)
	/* 100Gb (NRZ: 25G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_100GB	UINT32_C(0x3e8)
	/* 50Gb (PAM4-56: 50G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_50GB_PAM4_56   UINT32_C(0x1f5)
	/* 100Gb (PAM4-56: 50G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_100GB_PAM4_56  UINT32_C(0x3e9)
	/* 200Gb (PAM4-56: 50G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_200GB_PAM4_56  UINT32_C(0x7d1)
	/* 400Gb (PAM4-56: 50G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_400GB_PAM4_56  UINT32_C(0xfa1)
	/* 100Gb (PAM4-112: 100G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_100GB_PAM4_112 UINT32_C(0x3ea)
	/* 200Gb (PAM4-112: 100G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_200GB_PAM4_112 UINT32_C(0x7d2)
	/* 400Gb (PAM4-112: 100G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_400GB_PAM4_112 UINT32_C(0xfa2)
	/* 800Gb (PAM4-112: 100G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_800GB_PAM4_112 UINT32_C(0x1f42)
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_LAST	HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEEDS2_800GB_PAM4_112
	/*
	 * This is a mask of link speeds that will be used if
	 * auto_link_speeds2_mask bit in the "enables" field is 1.
	 * If unsupported speed is enabled an error will be generated.
	 */
	uint16_t	auto_link_speeds2_mask;
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_1GB		UINT32_C(0x1)
	/* 10Gb (NRZ: 10G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_10GB		UINT32_C(0x2)
	/* 25Gb (NRZ: 25G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_25GB		UINT32_C(0x4)
	/* 40Gb (NRZ: 10G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_40GB		UINT32_C(0x8)
	/* 50Gb (NRZ: 25G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_50GB		UINT32_C(0x10)
	/* 100Gb (NRZ: 25G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_100GB		UINT32_C(0x20)
	/* 50Gb (PAM4-56: 50G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_50GB_PAM4_56	UINT32_C(0x40)
	/* 100Gb (PAM4-56: 50G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_100GB_PAM4_56	UINT32_C(0x80)
	/* 200Gb (PAM4-56: 50G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_200GB_PAM4_56	UINT32_C(0x100)
	/* 400Gb (PAM4-56: 50G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_400GB_PAM4_56	UINT32_C(0x200)
	/* 100Gb (PAM4-112: 100G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_100GB_PAM4_112	UINT32_C(0x400)
	/* 200Gb (PAM4-112: 100G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_200GB_PAM4_112	UINT32_C(0x800)
	/* 400Gb (PAM4-112: 100G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_400GB_PAM4_112	UINT32_C(0x1000)
	/* 800Gb (PAM4-112: 100G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEEDS2_MASK_800GB_PAM4_112	UINT32_C(0x2000)
	uint8_t	unused_2[6];
} hwrm_port_phy_cfg_input_t, *phwrm_port_phy_cfg_input_t;

/* hwrm_port_phy_cfg_output (size:128b/16B) */

typedef struct hwrm_port_phy_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_cfg_output_t, *phwrm_port_phy_cfg_output_t;

/* hwrm_port_phy_cfg_cmd_err (size:64b/8B) */

typedef struct hwrm_port_phy_cfg_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* Unable to complete operation due to invalid speed */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_ILLEGAL_SPEED UINT32_C(0x1)
	/*
	 * retry the command since the phy is not ready.
	 * retry count is returned in opaque_0.
	 * This is only valid for the first command and
	 * this value will not change for successive calls.
	 * but if a 0 is returned at any time then this should
	 * be treated as an un recoverable failure,
	 *
	 * retry interval in milliseconds is returned in opaque_1.
	 * This specifies the time that user should wait before
	 * issuing the next port_phy_cfg command.
	 */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_RETRY	UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_LAST	HWRM_PORT_PHY_CFG_CMD_ERR_CODE_RETRY
	uint8_t	unused_0[7];
} hwrm_port_phy_cfg_cmd_err_t, *phwrm_port_phy_cfg_cmd_err_t;

/**********************
 * hwrm_port_phy_qcfg *
 **********************/


/* hwrm_port_phy_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_phy_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_phy_qcfg_input_t, *phwrm_port_phy_qcfg_input_t;

/* hwrm_port_phy_qcfg_output (size:832b/104B) */

typedef struct hwrm_port_phy_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value indicates the current link status. */
	uint8_t	link;
	/* There is no link or cable detected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_NO_LINK UINT32_C(0x0)
	/* There is no link, but a cable has been detected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SIGNAL  UINT32_C(0x1)
	/* There is a link. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LINK	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LAST   HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LINK
	uint8_t	active_fec_signal_mode;
	/*
	 * This value indicates the current link signaling mode of the
	 * connection.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_MASK		UINT32_C(0xf)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_SFT		0
	/* NRZ signaling */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_NRZ		UINT32_C(0x0)
	/* PAM4-56 signaling */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_PAM4		UINT32_C(0x1)
	/* PAM4-112 signaling */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_PAM4_112		UINT32_C(0x2)
		#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_LAST		HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_PAM4_112
	/* This value indicates the current active FEC mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_MASK		UINT32_C(0xf0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_SFT		4
	/* No active FEC */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_NONE_ACTIVE	(UINT32_C(0x0) << 4)
	/* FEC CLAUSE 74 (Fire Code) active, autonegotiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_CLAUSE74_ACTIVE	(UINT32_C(0x1) << 4)
	/* FEC CLAUSE 91 RS(528,514) active, autonegotiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_CLAUSE91_ACTIVE	(UINT32_C(0x2) << 4)
	/* FEC RS544_1XN active, autonegotiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS544_1XN_ACTIVE   (UINT32_C(0x3) << 4)
	/* FEC RS(544,528) active, autonegotiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS544_IEEE_ACTIVE  (UINT32_C(0x4) << 4)
	/* FEC RS272_1XN active, autonegotiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_1XN_ACTIVE   (UINT32_C(0x5) << 4)
	/* FEC RS(272,257) active, autonegotiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_IEEE_ACTIVE  (UINT32_C(0x6) << 4)
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_LAST		HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_IEEE_ACTIVE
	/*
	 * This value indicates the current link speed of the connection.
	 * The signal_mode field indicates if the link is using
	 * NRZ or PAM4 signaling.
	 */
	uint16_t	link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_200GB UINT32_C(0x7d0)
	/* 400Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_400GB UINT32_C(0xfa0)
	/* 800Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_800GB UINT32_C(0x1f40)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10MB
	/*
	 * This value is indicates the duplex of the current
	 * configuration.
	 */
	uint8_t	duplex_cfg;
	/* Half Duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_HALF UINT32_C(0x0)
	/* Full duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_FULL UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_LAST HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_FULL
	/*
	 * This value is used to indicate the current
	 * pause configuration. When autoneg is enabled, this value
	 * represents the autoneg results of pause configuration.
	 */
	uint8_t	pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PAUSE_TX	UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PAUSE_RX	UINT32_C(0x2)
	/*
	 * The supported speeds for the port. This is a bit mask.
	 * For each speed that is supported, the corresponding
	 * bit will be set to '1'.
	 */
	uint16_t	support_speeds;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10MB	UINT32_C(0x2000)
	/*
	 * Current setting of forced link speed.
	 * When the link speed is not being forced, this
	 * value shall be set to 0.
	 */
	uint16_t	force_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10MB
	/* Current setting of auto negotiation mode. */
	uint8_t	auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_NONE	UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ALL_SPEEDS   UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode
	 * has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ONE_SPEED	UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for
	 * autoneg. This mode has been DEPRECATED. An HWRM client should not
	 * use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ONE_OR_BELOW UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask value
	 * that is provided.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_SPEED_MASK   UINT32_C(0x4)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_SPEED_MASK
	/*
	 * Current setting of pause autonegotiation.
	 * Move autoneg_pause flag here.
	 */
	uint8_t	auto_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_TX		UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_RX		UINT32_C(0x2)
	/*
	 * When set to 1, the advertisement of pause is enabled.
	 *
	 * # When the auto_mode is not set to none and this flag is
	 * set to 1, then the auto_pause bits on this port are being
	 * advertised and autoneg pause results are being interpreted.
	 * # When the auto_mode is not set to none and this
	 * flag is set to 0, the pause is forced as indicated in
	 * force_pause, and also advertised as auto_pause bits, but
	 * the autoneg results are not interpreted since the pause
	 * configuration is being forced.
	 * # When the auto_mode is set to none and this flag is set to
	 * 1, auto_pause bits should be ignored and should be set to 0.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_AUTONEG_PAUSE	UINT32_C(0x4)
	/*
	 * Current setting for auto_link_speed. This field is only
	 * valid when auto_mode is set to "one_speed" or "one_or_below".
	 */
	uint16_t	auto_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10MB
	/*
	 * Current setting for auto_link_speed_mask that is used to
	 * advertise speeds during autonegotiation.
	 * This field is only valid when auto_mode is set to "mask".
	 * The speeds specified in this field shall be a subset of
	 * supported speeds on this port.
	 */
	uint16_t	auto_link_speed_mask;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10MB	UINT32_C(0x2000)
	/* Current setting for wirespeed. */
	uint8_t	wirespeed;
	/* Wirespeed feature is disabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_OFF UINT32_C(0x0)
	/* Wirespeed feature is enabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_ON  UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_ON
	/* Current setting for loopback. */
	uint8_t	lpbk;
	/* No loopback is selected. Normal operation. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_NONE	UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_LOCAL	UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_REMOTE   UINT32_C(0x2)
	/*
	 * The HW will be configured with external loopback such that
	 * host data is sent on the transmitter and based on the external
	 * loopback connection the data will be received without
	 * modification.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_EXTERNAL UINT32_C(0x3)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_EXTERNAL
	/*
	 * Current setting of forced pause.
	 * When the pause configuration is not being forced, then
	 * this value shall be set to 0.
	 */
	uint8_t	force_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAUSE_TX	UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAUSE_RX	UINT32_C(0x2)
	/*
	 * This value indicates the current status of the optics module on
	 * this port.
	 */
	uint8_t	module_status;
	/* Module is inserted and accepted */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NONE	UINT32_C(0x0)
	/* Module is rejected and transmit side Laser is disabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_DISABLETX	UINT32_C(0x1)
	/* Module mismatch warning. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_WARNINGMSG	UINT32_C(0x2)
	/* Module is rejected and powered down. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_PWRDOWN	UINT32_C(0x3)
	/* Module is not inserted. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTINSERTED   UINT32_C(0x4)
	/* Module is powered down because of over current fault. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_CURRENTFAULT  UINT32_C(0x5)
	/* Module is overheated. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_OVERHEATED	UINT32_C(0x6)
	/* Module status is not applicable. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTAPPLICABLE UINT32_C(0xff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTAPPLICABLE
	/* Current setting for preemphasis. */
	uint32_t	preemphasis;
	/* This field represents the major version of the PHY. */
	uint8_t	phy_maj;
	/* This field represents the minor version of the PHY. */
	uint8_t	phy_min;
	/* This field represents the build version of the PHY. */
	uint8_t	phy_bld;
	/* This value represents a PHY type. */
	uint8_t	phy_type;
	/* Unknown */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_UNKNOWN	UINT32_C(0x0)
	/* BASE-CR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASECR	UINT32_C(0x1)
	/* BASE-KR4 (Deprecated) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR4	UINT32_C(0x2)
	/* BASE-LR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASELR	UINT32_C(0x3)
	/* BASE-SR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASESR	UINT32_C(0x4)
	/* BASE-KR2 (Deprecated) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR2	UINT32_C(0x5)
	/* BASE-KX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKX	UINT32_C(0x6)
	/* BASE-KR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR	UINT32_C(0x7)
	/* BASE-T */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASET		UINT32_C(0x8)
	/* EEE capable BASE-T */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASETE	UINT32_C(0x9)
	/* SGMII connected external PHY */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_SGMIIEXTPHY	UINT32_C(0xa)
	/* 25G_BASECR_CA_L */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_L  UINT32_C(0xb)
	/* 25G_BASECR_CA_S */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_S  UINT32_C(0xc)
	/* 25G_BASECR_CA_N */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_N  UINT32_C(0xd)
	/* 25G_BASESR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASESR	UINT32_C(0xe)
	/* 100G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASECR4	UINT32_C(0xf)
	/* 100G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR4	UINT32_C(0x10)
	/* 100G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASELR4	UINT32_C(0x11)
	/* 100G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASEER4	UINT32_C(0x12)
	/* 100G_BASESR10 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR10	UINT32_C(0x13)
	/* 40G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASECR4	UINT32_C(0x14)
	/* 40G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASESR4	UINT32_C(0x15)
	/* 40G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASELR4	UINT32_C(0x16)
	/* 40G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASEER4	UINT32_C(0x17)
	/* 40G_ACTIVE_CABLE */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_ACTIVE_CABLE UINT32_C(0x18)
	/* 1G_baseT */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASET	UINT32_C(0x19)
	/* 1G_baseSX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASESX	UINT32_C(0x1a)
	/* 1G_baseCX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASECX	UINT32_C(0x1b)
	/* 200G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASECR4	UINT32_C(0x1c)
	/* 200G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASESR4	UINT32_C(0x1d)
	/* 200G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASELR4	UINT32_C(0x1e)
	/* 200G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASEER4	UINT32_C(0x1f)
	/* 50G_BASECR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_50G_BASECR	UINT32_C(0x20)
	/* 50G_BASESR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_50G_BASESR	UINT32_C(0x21)
	/* 50G_BASELR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_50G_BASELR	UINT32_C(0x22)
	/* 50G_BASEER */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_50G_BASEER	UINT32_C(0x23)
	/* 100G_BASECR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASECR2	UINT32_C(0x24)
	/* 100G_BASESR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR2	UINT32_C(0x25)
	/* 100G_BASELR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASELR2	UINT32_C(0x26)
	/* 100G_BASEER2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASEER2	UINT32_C(0x27)
	/* 400G_BASECR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASECR	UINT32_C(0x28)
	/* 100G_BASESR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR	UINT32_C(0x29)
	/* 100G_BASELR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASELR	UINT32_C(0x2a)
	/* 100G_BASEER */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASEER	UINT32_C(0x2b)
	/* 200G_BASECR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASECR2	UINT32_C(0x2c)
	/* 200G_BASESR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASESR2	UINT32_C(0x2d)
	/* 200G_BASELR2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASELR2	UINT32_C(0x2e)
	/* 200G_BASEER2 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASEER2	UINT32_C(0x2f)
	/* 400G_BASECR8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_400G_BASECR8	UINT32_C(0x30)
	/* 200G_BASESR8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_400G_BASESR8	UINT32_C(0x31)
	/* 400G_BASELR8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_400G_BASELR8	UINT32_C(0x32)
	/* 400G_BASEER8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_400G_BASEER8	UINT32_C(0x33)
	/* 400G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_400G_BASECR4	UINT32_C(0x34)
	/* 400G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_400G_BASESR4	UINT32_C(0x35)
	/* 400G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_400G_BASELR4	UINT32_C(0x36)
	/* 400G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_400G_BASEER4	UINT32_C(0x37)
	/* 800G_BASECR8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_800G_BASECR8	UINT32_C(0x38)
	/* 800G_BASESR8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_800G_BASESR8	UINT32_C(0x39)
	/* 800G_BASELR8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_800G_BASELR8	UINT32_C(0x3a)
	/* 800G_BASEER8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_800G_BASEER8	UINT32_C(0x3b)
	/* 800G_BASEFR8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_800G_BASEFR8	UINT32_C(0x3c)
	/* 800G_BASEDR8 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_800G_BASEDR8	UINT32_C(0x3d)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_LAST		HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_800G_BASEDR8
	/* This value represents a media type. */
	uint8_t	media_type;
	/* Unknown */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_UNKNOWN UINT32_C(0x0)
	/* Twisted Pair */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_TP	UINT32_C(0x1)
	/* Direct Attached Copper */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_DAC	UINT32_C(0x2)
	/* Fiber */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_FIBRE   UINT32_C(0x3)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_LAST   HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_FIBRE
	/* This value represents a transceiver type. */
	uint8_t	xcvr_pkg_type;
	/* PHY and MAC are in the same package */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_INTERNAL UINT32_C(0x1)
	/* PHY and MAC are in different packages */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_EXTERNAL UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_EXTERNAL
	uint8_t	eee_config_phy_addr;
	/* This field represents PHY address. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_ADDR_MASK		UINT32_C(0x1f)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_ADDR_SFT		0
	/*
	 * This field represents flags related to EEE configuration.
	 * These EEE configuration flags are valid only when the
	 * auto_mode is not set to none (in other words autonegotiation
	 * is enabled).
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_MASK		UINT32_C(0xe0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_SFT		5
	/*
	 * When set to 1, Energy Efficient Ethernet (EEE) mode is
	 * enabled. Speeds for autoneg with EEE mode enabled are based on
	 * eee_link_speed_mask.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_ENABLED	UINT32_C(0x20)
	/*
	 * This flag is valid only when eee_enabled is set to 1.
	 *
	 * # If eee_enabled is set to 0, then EEE mode is disabled
	 * and this flag shall be ignored.
	 * # If eee_enabled is set to 1 and this flag is set to 1,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * and in use.
	 * # If eee_enabled is set to 1 and this flag is set to 0,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * but is currently not in use.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_ACTIVE	UINT32_C(0x40)
	/*
	 * This flag is valid only when eee_enabled is set to 1.
	 *
	 * # If eee_enabled is set to 0, then EEE mode is disabled
	 * and this flag shall be ignored.
	 * # If eee_enabled is set to 1 and this flag is set to 1,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * and TX LPI is enabled.
	 * # If eee_enabled is set to 1 and this flag is set to 0,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * but TX LPI is disabled.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_TX_LPI	UINT32_C(0x80)
	/*
	 * When set to 1, the parallel detection is used to determine
	 * the speed of the link partner.
	 *
	 * Parallel detection is used when a autonegotiation capable
	 * device is connected to a link partner that is not capable
	 * of autonegotiation.
	 */
	uint8_t	parallel_detect;
	/*
	 * When set to 1, the parallel detection is used to determine
	 * the speed of the link partner.
	 *
	 * Parallel detection is used when a autonegotiation capable
	 * device is connected to a link partner that is not capable
	 * of autonegotiation.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PARALLEL_DETECT	UINT32_C(0x1)
	/*
	 * The advertised speeds for the port by the link partner.
	 * Each advertised speed will be set to '1'.
	 */
	uint16_t	link_partner_adv_speeds;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10MB	UINT32_C(0x2000)
	/*
	 * The advertised autoneg for the port by the link partner.
	 * This field is deprecated and should be set to 0.
	 */
	uint8_t	link_partner_adv_auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_NONE	UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ALL_SPEEDS   UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode
	 * has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ONE_SPEED	UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for
	 * autoneg. This mode has been DEPRECATED. An HWRM client should not
	 * use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ONE_OR_BELOW UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask value
	 * that is provided.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_SPEED_MASK   UINT32_C(0x4)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_SPEED_MASK
	/* The advertised pause settings on the port by the link partner. */
	uint8_t	link_partner_adv_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_PAUSE_TX	UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_PAUSE_RX	UINT32_C(0x2)
	/*
	 * Current setting for link speed mask that is used to
	 * advertise speeds during autonegotiation when EEE is enabled.
	 * This field is valid only when eee_enabled flags is set to 1.
	 * The speeds specified in this field shall be a subset of
	 * speeds specified in auto_link_speed_mask.
	 */
	uint16_t	adv_eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD1	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD2	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD3	UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD4	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	/*
	 * Current setting for link speed mask that is advertised by
	 * the link partner when EEE is enabled.
	 * This field is valid only when eee_enabled flags is set to 1.
	 */
	uint16_t	link_partner_adv_eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD1	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD2	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD3	UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD4	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	uint32_t	xcvr_identifier_type_tx_lpi_timer;
	/*
	 * Current setting of TX LPI timer in microseconds.
	 * This field is valid only when_eee_enabled flag is set to 1
	 * and tx_lpi_enabled is set to 1.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_TX_LPI_TIMER_MASK		UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_TX_LPI_TIMER_SFT		0
	/* This value represents transceiver identifier type. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_MASK	UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFT	24
	/* Unknown */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_UNKNOWN   (UINT32_C(0x0) << 24)
	/* SFP/SFP+/SFP28 */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFP	(UINT32_C(0x3) << 24)
	/* QSFP+ */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP	(UINT32_C(0xc) << 24)
	/* QSFP+ */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFPPLUS  (UINT32_C(0xd) << 24)
	/* QSFP28/QSFP56 or later */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP28	(UINT32_C(0x11) << 24)
	/* QSFP-DD */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFPDD	(UINT32_C(0x18) << 24)
	/* QSFP112 */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP112   (UINT32_C(0x1e) << 24)
	/* SFP-DD CMIS */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFPDD	(UINT32_C(0x1f) << 24)
	/* SFP CMIS */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_CSFP	(UINT32_C(0x20) << 24)
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_CSFP
	/*
	 * This value represents the current configuration of
	 * Forward Error Correction (FEC) on the port.
	 */
	uint16_t	fec_cfg;
	/*
	 * When set to 1, then FEC is not supported on this port. If this
	 * flag is set to 1, then all other FEC configuration flags shall be
	 * ignored. When set to 0, then FEC is supported as indicated by
	 * other configuration flags.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_NONE_SUPPORTED	UINT32_C(0x1)
	/*
	 * When set to 1, then FEC autonegotiation is supported on this port.
	 * When set to 0, then FEC autonegotiation is not supported on this
	 * port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_AUTONEG_SUPPORTED	UINT32_C(0x2)
	/*
	 * When set to 1, then FEC autonegotiation is enabled on this port.
	 * When set to 0, then FEC autonegotiation is disabled if supported.
	 * This flag should be ignored if FEC autonegotiation is not
	 * supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_AUTONEG_ENABLED	UINT32_C(0x4)
	/*
	 * When set to 1, then FEC CLAUSE 74 (Fire Code) is supported on this
	 * port. When set to 0, then FEC CLAUSE 74 (Fire Code) is not
	 * supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE74_SUPPORTED	UINT32_C(0x8)
	/*
	 * When set to 1, then FEC CLAUSE 74 (Fire Code) is enabled on this
	 * port. This means that FEC CLAUSE 74 is either advertised if
	 * FEC autonegotiation is enabled or FEC CLAUSE 74 is force enabled.
	 * When set to 0, then FEC CLAUSE 74 (Fire Code) is disabled if
	 * supported. This flag should be ignored if FEC CLAUSE 74 is not
	 * supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE74_ENABLED	UINT32_C(0x10)
	/*
	 * When set to 1, then FEC CLAUSE 91 (Reed Solomon RS(528,514) for
	 * NRZ) is supported on this port.
	 * When set to 0, then FEC RS(528,418) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE91_SUPPORTED	UINT32_C(0x20)
	/*
	 * When set to 1, then FEC CLAUSE 91 (Reed Solomon RS(528,514) for
	 * NRZ) is enabled on this port. This means that FEC RS(528,514) is
	 * either advertised if FEC autonegotiation is enabled or FEC
	 * RS(528,514) is force enabled. When set to 0, then FEC RS(528,514)
	 * is disabled if supported.
	 * This flag should be ignored if FEC CLAUSE 91 is not supported on
	 * this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE91_ENABLED	UINT32_C(0x40)
	/*
	 * When set to 1, then FEC RS544_1XN is supported on this port.
	 * When set to 0, then FEC RS544_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_1XN_SUPPORTED	UINT32_C(0x80)
	/*
	 * When set to 1, then RS544_1XN is enabled on this
	 * port. This means that FEC RS544_1XN is either advertised if
	 * FEC autonegotiation is enabled or FEC RS544_1XN is force enabled.
	 * When set to 0, then FEC RS544_1XN is disabled if supported.
	 * This flag should be ignored if FEC RS544_1XN is not supported on
	 * this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_1XN_ENABLED	UINT32_C(0x100)
	/*
	 * When set to 1, then FEC RS(544,514) is supported on this port.
	 * When set to 0, then FEC RS(544,514) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_IEEE_SUPPORTED	UINT32_C(0x200)
	/*
	 * When set to 1, then RS(544,514) is enabled on this
	 * port. This means that FEC RS(544,514) is either advertised if
	 * FEC autonegotiation is enabled or FEC RS(544,514) is force
	 * enabled. When set to 0, then FEC RS(544,514) is disabled if
	 * supported. This flag should be ignored if FEC RS(544,514) is not
	 * supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_IEEE_ENABLED	UINT32_C(0x400)
	/*
	 * When set to 1, then FEC RS272_1XN is supported on this port.
	 * When set to 0, then FEC RS272_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_1XN_SUPPORTED	UINT32_C(0x800)
	/*
	 * When set to 1, then RS272_1XN is enabled on this
	 * port. This means that FEC RS272_1XN is either advertised if
	 * FEC autonegotiation is enabled or FEC RS272_1XN is force
	 * enabled. When set to 0, then FEC RS272_1XN is disabled if
	 * supported.
	 * This flag should be ignored if FEC RS272_1XN is not supported on
	 * this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_1XN_ENABLED	UINT32_C(0x1000)
	/*
	 * When set to 1, then FEC RS(272,514) is supported on this port.
	 * When set to 0, then FEC RS(272,514) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_IEEE_SUPPORTED	UINT32_C(0x2000)
	/*
	 * When set to 1, then RS(272,257) is enabled on this
	 * port. This means that FEC RS(272,257) is either advertised if
	 * FEC autonegotiation is enabled or FEC RS(272,257) is force
	 * enabled. When set to 0, then FEC RS(272,257) is disabled if
	 * supported.
	 * This flag should be ignored if FEC RS(272,257) is not supported on
	 * this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_IEEE_ENABLED	UINT32_C(0x4000)
	/*
	 * This value is indicates the duplex of the current
	 * connection state.
	 */
	uint8_t	duplex_state;
	/* Half Duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_HALF UINT32_C(0x0)
	/* Full duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_FULL UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_LAST HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_FULL
	/* Option flags fields. */
	uint8_t	option_flags;
	/* When this bit is '1', Media auto detect is enabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_OPTION_FLAGS_MEDIA_AUTO_DETECT	UINT32_C(0x1)
	/*
	 * When this bit is '1', active_fec_signal_mode can be
	 * trusted.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_OPTION_FLAGS_SIGNAL_MODE_KNOWN	UINT32_C(0x2)
	/*
	 * When this bit is '1', speeds2 fields are used to get
	 * speed details.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_OPTION_FLAGS_SPEEDS2_SUPPORTED	UINT32_C(0x4)
	/*
	 * Up to 16 bytes of null padded ASCII string representing
	 * PHY vendor.
	 * If the string is set to null, then the vendor name is not
	 * available.
	 */
	char	phy_vendor_name[16];
	/*
	 * Up to 16 bytes of null padded ASCII string that
	 * identifies vendor specific part number of the PHY.
	 * If the string is set to null, then the vendor specific
	 * part number is not available.
	 */
	char	phy_vendor_partnumber[16];
	/*
	 * The supported PAM4 speeds for the port. This is a bit mask.
	 * For each speed that is supported, the corresponding
	 * bit will be set to '1'.
	 */
	uint16_t	support_pam4_speeds;
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_200G	UINT32_C(0x4)
	/*
	 * Current setting of forced PAM4 link speed.
	 * When the link speed is not being forced, this
	 * value shall be set to 0.
	 */
	uint16_t	force_pam4_link_speed;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_200GB UINT32_C(0x7d0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_200GB
	/*
	 * Current setting for auto_pam4_link_speed_mask that is used to
	 * advertise speeds during autonegotiation.
	 * This field is only valid when auto_mode is set to "mask".
	 * The speeds specified in this field shall be a subset of
	 * supported speeds on this port.
	 */
	uint16_t	auto_pam4_link_speed_mask;
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_200G	UINT32_C(0x4)
	/*
	 * The advertised PAM4 speeds for the port by the link partner.
	 * Each advertised speed will be set to '1'.
	 */
	uint8_t	link_partner_pam4_adv_speeds;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_50GB	UINT32_C(0x1)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_100GB	UINT32_C(0x2)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_200GB	UINT32_C(0x4)
	/*
	 * This field is used to indicate the reasons for link down.
	 * This field is set to 0, if the link down reason is unknown.
	 */
	uint8_t	link_down_reason;
	/* Remote fault */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_DOWN_REASON_RF	UINT32_C(0x1)
	/*
	 * The supported speeds for the port. This is a bit mask.
	 * For each speed that is supported, the corresponding
	 * bit will be set to '1'. This is valid only if speeds2_supported
	 * is set in option_flags
	 */
	uint16_t	support_speeds2;
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_1GB		UINT32_C(0x1)
	/* 10Gb (NRZ: 10G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_10GB		UINT32_C(0x2)
	/* 25Gb (NRZ: 25G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_25GB		UINT32_C(0x4)
	/* 40Gb (NRZ: 10G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_40GB		UINT32_C(0x8)
	/* 50Gb (NRZ: 25G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_50GB		UINT32_C(0x10)
	/* 100Gb (NRZ: 25G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_100GB		UINT32_C(0x20)
	/* 50Gb (PAM4-56: 50G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_50GB_PAM4_56	UINT32_C(0x40)
	/* 100Gb (PAM4-56: 50G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_100GB_PAM4_56	UINT32_C(0x80)
	/* 200Gb (PAM4-56: 50G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_200GB_PAM4_56	UINT32_C(0x100)
	/* 400Gb (PAM4-56: 50G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_400GB_PAM4_56	UINT32_C(0x200)
	/* 100Gb (PAM4-112: 100G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_100GB_PAM4_112	UINT32_C(0x400)
	/* 200Gb (PAM4-112: 100G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_200GB_PAM4_112	UINT32_C(0x800)
	/* 400Gb (PAM4-112: 100G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_400GB_PAM4_112	UINT32_C(0x1000)
	/* 800Gb (PAM4-112: 100G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS2_800GB_PAM4_112	UINT32_C(0x2000)
	/*
	 * Current setting of forced link speed. When the link speed is not
	 * being forced, this value shall be set to 0.
	 * This field is valid only if speeds2_supported is set in
	 * option_flags.
	 */
	uint16_t	force_link_speeds2;
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_1GB		UINT32_C(0xa)
	/* 10Gb (NRZ: 10G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_10GB	UINT32_C(0x64)
	/* 25Gb (NRZ: 25G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_25GB	UINT32_C(0xfa)
	/* 40Gb (NRZ: 10G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_40GB	UINT32_C(0x190)
	/* 50Gb (NRZ: 25G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_50GB	UINT32_C(0x1f4)
	/* 100Gb (NRZ: 25G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_100GB	UINT32_C(0x3e8)
	/* 50Gb (PAM4-56: 50G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_50GB_PAM4_56   UINT32_C(0x1f5)
	/* 100Gb (PAM4-56: 50G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_100GB_PAM4_56  UINT32_C(0x3e9)
	/* 200Gb (PAM4-56: 50G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_200GB_PAM4_56  UINT32_C(0x7d1)
	/* 400Gb (PAM4-56: 50G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_400GB_PAM4_56  UINT32_C(0xfa1)
	/* 100Gb (PAM4-112: 100G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_100GB_PAM4_112 UINT32_C(0x3ea)
	/* 200Gb (PAM4-112: 100G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_200GB_PAM4_112 UINT32_C(0x7d2)
	/* 400Gb (PAM4-112: 100G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_400GB_PAM4_112 UINT32_C(0xfa2)
	/* 800Gb (PAM4-112: 100G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_800GB_PAM4_112 UINT32_C(0x1f42)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEEDS2_800GB_PAM4_112
	/*
	 * Current setting of auto_link speed_mask that is used to advertise
	 * speeds during autonegotiation.
	 * This field is only valid when auto_mode is set to "mask".
	 * and if speeds2_supported is set in option_flags
	 * The speeds specified in this field shall be a subset of
	 * supported speeds on this port.
	 */
	uint16_t	auto_link_speeds2;
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_1GB		UINT32_C(0x1)
	/* 10Gb (NRZ: 10G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_10GB		UINT32_C(0x2)
	/* 25Gb (NRZ: 25G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_25GB		UINT32_C(0x4)
	/* 40Gb (NRZ: 10G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_40GB		UINT32_C(0x8)
	/* 50Gb (NRZ: 25G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_50GB		UINT32_C(0x10)
	/* 100Gb (NRZ: 25G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_100GB		UINT32_C(0x20)
	/* 50Gb (PAM4-56: 50G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_50GB_PAM4_56	UINT32_C(0x40)
	/* 100Gb (PAM4-56: 50G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_100GB_PAM4_56	UINT32_C(0x80)
	/* 200Gb (PAM4-56: 50G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_200GB_PAM4_56	UINT32_C(0x100)
	/* 400Gb (PAM4-56: 50G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_400GB_PAM4_56	UINT32_C(0x200)
	/* 100Gb (PAM4-112: 100G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_100GB_PAM4_112	UINT32_C(0x400)
	/* 200Gb (PAM4-112: 100G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_200GB_PAM4_112	UINT32_C(0x800)
	/* 400Gb (PAM4-112: 100G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_400GB_PAM4_112	UINT32_C(0x1000)
	/* 800Gb (PAM4-112: 100G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEEDS2_800GB_PAM4_112	UINT32_C(0x2000)
	/*
	 * This field is indicate the number of lanes used to transfer
	 * data. If the link is down, the value is zero.
	 * This is valid only if speeds2_supported is set in option_flags.
	 */
	uint8_t	active_lanes;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_qcfg_output_t, *phwrm_port_phy_qcfg_output_t;

/*********************
 * hwrm_port_mac_cfg *
 *********************/


/* hwrm_port_mac_cfg_input (size:448b/56B) */

typedef struct hwrm_port_mac_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * In this field, there are a number of CoS mappings related flags
	 * that are used to configure CoS mappings and their corresponding
	 * priorities in the hardware.
	 * For the priorities of CoS mappings, the HWRM uses the following
	 * priority order (high to low) by default:
	 * # vlan pri
	 * # ip_dscp
	 * # tunnel_vlan_pri
	 * # default cos
	 *
	 * A subset of CoS mappings can be enabled.
	 * If a priority is not specified for an enabled CoS mapping, the
	 * priority will be assigned in the above order for the enabled CoS
	 * mappings. For example, if vlan_pri and ip_dscp CoS mappings are
	 * enabled and their priorities are not specified, the following
	 * priority order (high to low) will be used by the HWRM:
	 * # vlan_pri
	 * # ip_dscp
	 * # default cos
	 *
	 * vlan_pri CoS mapping together with default CoS with lower priority
	 * are enabled by default by the HWRM.
	 */
	uint32_t	flags;
	/*
	 * When this bit is '1', this command will configure
	 * the MAC to match the current link state of the PHY.
	 * If the link is not established on the PHY, then this
	 * bit has no effect.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_MATCH_LINK			UINT32_C(0x1)
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_VLAN_PRI2COS_ENABLE	UINT32_C(0x2)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_TUNNEL_PRI2COS_ENABLE	UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_IP_DSCP2COS_ENABLE		UINT32_C(0x8)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * enable timestamp capture capability on the receive side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_RX_TS_CAPTURE_ENABLE	UINT32_C(0x10)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * disable timestamp capture capability on the receive side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_RX_TS_CAPTURE_DISABLE	UINT32_C(0x20)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * enable timestamp capture capability on the transmit side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_TX_TS_CAPTURE_ENABLE	UINT32_C(0x40)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * disable timestamp capture capability on the transmit side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_TX_TS_CAPTURE_DISABLE	UINT32_C(0x80)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is requested to
	 * be enabled on this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_OOB_WOL_ENABLE		UINT32_C(0x100)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is requested to
	 * be disabled on this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_OOB_WOL_DISABLE		UINT32_C(0x200)
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_VLAN_PRI2COS_DISABLE	UINT32_C(0x400)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_TUNNEL_PRI2COS_DISABLE	UINT32_C(0x800)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_IP_DSCP2COS_DISABLE	UINT32_C(0x1000)
	/*
	 * When this bit is set to '1', and the ptp_tx_ts_capture_enable
	 * bit is set, then the device uses one step Tx timestamping.
	 * This bit is temporary and used for experimental purposes.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_ONE_STEP_TX_TS		UINT32_C(0x2000)
	/*
	 * When this bit is '1', the controller is requested to enable
	 * timestamp capture capability on all packets (not just PTP)
	 * of the receive side of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_ALL_RX_TS_CAPTURE_ENABLE	UINT32_C(0x4000)
	/*
	 * When this bit is '1', the controller is requested to disable
	 * timestamp capture capability on all packets (not just PTP)
	 * of the receive side of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_ALL_RX_TS_CAPTURE_DISABLE	UINT32_C(0x8000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ipg field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_IPG				UINT32_C(0x1)
	/*
	 * This bit must be '1' for the lpbk field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_LPBK			UINT32_C(0x2)
	/*
	 * This bit must be '1' for the vlan_pri2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_VLAN_PRI2COS_MAP_PRI	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the tunnel_pri2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_TUNNEL_PRI2COS_MAP_PRI	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the dscp2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_DSCP2COS_MAP_PRI		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the rx_ts_capture_ptp_msg_type field to
	 * be configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_RX_TS_CAPTURE_PTP_MSG_TYPE	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tx_ts_capture_ptp_msg_type field to
	 * be configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_TX_TS_CAPTURE_PTP_MSG_TYPE	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the cos_field_cfg field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_COS_FIELD_CFG		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ppb field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_PPB		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the ptp_adj_phase field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_PTP_ADJ_PHASE		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the ptp_load_control field to
	 * be configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_PTP_LOAD_CONTROL		UINT32_C(0x800)
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	/*
	 * This value is used to configure the minimum IPG that will
	 * be sent between packets by this port.
	 */
	uint8_t	ipg;
	/* This value controls the loopback setting for the MAC. */
	uint8_t	lpbk;
	/* No loopback is selected. Normal operation. */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_LAST  HWRM_PORT_MAC_CFG_INPUT_LPBK_REMOTE
	/*
	 * This value controls the priority setting of VLAN PRI to CoS
	 * mapping based on VLAN Tags of inner packet headers of
	 * tunneled packets or packet headers of non-tunneled packets.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	vlan_pri2cos_map_pri;
	/* Reserved field. */
	uint8_t	reserved1;
	/*
	 * This value controls the priority setting of VLAN PRI to CoS
	 * mapping based on VLAN Tags of tunneled header.
	 * This mapping only applies when tunneled headers
	 * are present.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	tunnel_pri2cos_map_pri;
	/*
	 * This value controls the priority setting of IP DSCP to CoS
	 * mapping based on inner IP header of tunneled packets or
	 * IP header of non-tunneled packets.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	dscp2pri_map_pri;
	/*
	 * This is a 16-bit bit mask that is used to request a
	 * specific configuration of time stamp capture of PTP messages
	 * on the receive side of this port.
	 * This field shall be ignored if the ptp_rx_ts_capture_enable
	 * flag is not set in this command.
	 * Otherwise, if bit 'i' is set, then the HWRM is being
	 * requested to configure the receive side of the port to
	 * capture the time stamp of every received PTP message
	 * with messageType field value set to i.
	 */
	uint16_t	rx_ts_capture_ptp_msg_type;
	/*
	 * This is a 16-bit bit mask that is used to request a
	 * specific configuration of time stamp capture of PTP messages
	 * on the transmit side of this port.
	 * This field shall be ignored if the ptp_tx_ts_capture_enable
	 * flag is not set in this command.
	 * Otherwise, if bit 'i' is set, then the HWRM is being
	 * requested to configure the transmit side of the port to
	 * capture the time stamp of every transmitted PTP message
	 * with messageType field value set to i.
	 */
	uint16_t	tx_ts_capture_ptp_msg_type;
	/* Configuration of CoS fields. */
	uint8_t	cos_field_cfg;
	/* Reserved */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_RSVD1			UINT32_C(0x1)
	/*
	 * This field is used to specify selection of VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the inner packet headers of tunneled packets or
	 * non-tunneled packets.
	 * This field is valid only if inner VLAN PRI to CoS mapping
	 * is enabled.
	 * If VLAN PRI to CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_MASK	UINT32_C(0x6)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_SFT	1
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the inner packet headers
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_INNERMOST	(UINT32_C(0x0) << 1)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the inner packet headers.
	 * No VLAN PRI shall be selected for this configuration
	 * if only one VLAN Tag is present in the inner
	 * packet headers.
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTER	(UINT32_C(0x1) << 1)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the inner packet headers
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTERMOST	(UINT32_C(0x2) << 1)
	/* Unspecified */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED	(UINT32_C(0x3) << 1)
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_LAST	HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used to specify selection of tunnel VLAN
	 * PRI value based on whether one or two VLAN Tags are
	 * present in tunnel headers.
	 * This field is valid only if tunnel VLAN PRI to CoS mapping
	 * is enabled.
	 * If tunnel VLAN PRI to CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_MASK	UINT32_C(0x18)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_SFT	3
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the tunnel packet headers
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_INNERMOST	(UINT32_C(0x0) << 3)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the tunnel packet headers.
	 * No tunnel VLAN PRI shall be selected for this
	 * configuration if only one VLAN Tag is present in
	 * the tunnel packet headers.
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTER	(UINT32_C(0x1) << 3)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the tunnel packet headers
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTERMOST	(UINT32_C(0x2) << 3)
	/* Unspecified */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED  (UINT32_C(0x3) << 3)
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_LAST	HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field shall be used to provide default CoS value
	 * that has been configured on this port.
	 * This field is valid only if default CoS mapping
	 * is enabled.
	 * If default CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_DEFAULT_COS_MASK	UINT32_C(0xe0)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_DEFAULT_COS_SFT	5
	uint8_t	unused_0[3];
	/*
	 * This signed field specifies by how much to adjust the frequency
	 * of sync timer updates (measured in parts per billion).
	 */
	int32_t	ptp_freq_adj_ppb;
	uint8_t	unused_1[3];
	/*
	 * This value controls how PTP configuration like freq_adj and
	 * phase are loaded in the hardware block.
	 */
	uint8_t	ptp_load_control;
	/* PTP configuration is not loaded in hardware. */
	#define HWRM_PORT_MAC_CFG_INPUT_PTP_LOAD_CONTROL_NONE	UINT32_C(0x0)
	/*
	 * PTP configuration will be loaded immediately in the hardware
	 * block. By default, it will always be immediate.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_PTP_LOAD_CONTROL_IMMEDIATE UINT32_C(0x1)
	/*
	 * PTP configuration will loaded at the next Pulse per second (PPS)
	 * event in the hardware block.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_PTP_LOAD_CONTROL_PPS_EVENT UINT32_C(0x2)
	#define HWRM_PORT_MAC_CFG_INPUT_PTP_LOAD_CONTROL_LAST	HWRM_PORT_MAC_CFG_INPUT_PTP_LOAD_CONTROL_PPS_EVENT
	/*
	 * This unsigned field specifies the phase offset to be applied
	 * to the PHC (PTP Hardware Clock). This field is specified in
	 * nanoseconds.
	 */
	int64_t	ptp_adj_phase;
} hwrm_port_mac_cfg_input_t, *phwrm_port_mac_cfg_input_t;

/* hwrm_port_mac_cfg_output (size:128b/16B) */

typedef struct hwrm_port_mac_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be received on the port.
	 * This value does not include the number of bytes used by
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mru;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be transmitted on the port.
	 * This value does not include the number of bytes used by
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mtu;
	/* Current configuration of the IPG value. */
	uint8_t	ipg;
	/* Current value of the loopback value. */
	uint8_t	lpbk;
	/* No loopback is selected. Normal operation. */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_LAST  HWRM_PORT_MAC_CFG_OUTPUT_LPBK_REMOTE
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_mac_cfg_output_t, *phwrm_port_mac_cfg_output_t;

/**********************
 * hwrm_port_mac_qcfg *
 **********************/


/* hwrm_port_mac_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_mac_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_mac_qcfg_input_t, *phwrm_port_mac_qcfg_input_t;

/* hwrm_port_mac_qcfg_output (size:256b/32B) */

typedef struct hwrm_port_mac_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be received on the port.
	 * This value does not include the number of bytes used by the
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mru;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be transmitted on the port.
	 * This value does not include the number of bytes used by the
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mtu;
	/*
	 * The minimum IPG that will
	 * be sent between packets by this port.
	 */
	uint8_t	ipg;
	/* The loopback setting for the MAC. */
	uint8_t	lpbk;
	/* No loopback is selected. Normal operation. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_LAST  HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_REMOTE
	/*
	 * Priority setting for VLAN PRI to CoS mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the corresponding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	vlan_pri2cos_map_pri;
	/*
	 * In this field, a number of CoS mappings related flags
	 * are used to indicate configured CoS mappings.
	 */
	uint8_t	flags;
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_VLAN_PRI2COS_ENABLE	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_TUNNEL_PRI2COS_ENABLE	UINT32_C(0x2)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_IP_DSCP2COS_ENABLE	UINT32_C(0x4)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is enabled on this
	 * port.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_OOB_WOL_ENABLE		UINT32_C(0x8)
	/* When this bit is '1', PTP is enabled for RX on this port. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_PTP_RX_TS_CAPTURE_ENABLE	UINT32_C(0x10)
	/* When this bit is '1', PTP is enabled for TX on this port. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_PTP_TX_TS_CAPTURE_ENABLE	UINT32_C(0x20)
	/*
	 * Priority setting for tunnel VLAN PRI to CoS mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the corresponding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	tunnel_pri2cos_map_pri;
	/*
	 * Priority setting for DSCP to PRI mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the corresponding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	dscp2pri_map_pri;
	/*
	 * This is a 16-bit bit mask that represents the
	 * current configuration of time stamp capture of PTP messages
	 * on the receive side of this port.
	 * If bit 'i' is set, then the receive side of the port
	 * is configured to capture the time stamp of every
	 * received PTP message with messageType field value set
	 * to i.
	 * If all bits are set to 0 (i.e. field value set 0),
	 * then the receive side of the port is not configured
	 * to capture timestamp for PTP messages.
	 * If all bits are set to 1, then the receive side of the
	 * port is configured to capture timestamp for all PTP
	 * messages.
	 */
	uint16_t	rx_ts_capture_ptp_msg_type;
	/*
	 * This is a 16-bit bit mask that represents the
	 * current configuration of time stamp capture of PTP messages
	 * on the transmit side of this port.
	 * If bit 'i' is set, then the transmit side of the port
	 * is configured to capture the time stamp of every
	 * received PTP message with messageType field value set
	 * to i.
	 * If all bits are set to 0 (i.e. field value set 0),
	 * then the transmit side of the port is not configured
	 * to capture timestamp for PTP messages.
	 * If all bits are set to 1, then the transmit side of the
	 * port is configured to capture timestamp for all PTP
	 * messages.
	 */
	uint16_t	tx_ts_capture_ptp_msg_type;
	/* Configuration of CoS fields. */
	uint8_t	cos_field_cfg;
	/* Reserved */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_RSVD			UINT32_C(0x1)
	/*
	 * This field is used for selecting VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the inner packet headers of tunneled packets or
	 * non-tunneled packets.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_MASK	UINT32_C(0x6)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_SFT	1
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the inner packet headers
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_INNERMOST	(UINT32_C(0x0) << 1)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the inner packet headers.
	 * No VLAN PRI is selected for this configuration
	 * if only one VLAN Tag is present in the inner
	 * packet headers.
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTER	(UINT32_C(0x1) << 1)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the inner packet headers
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTERMOST	(UINT32_C(0x2) << 1)
	/* Unspecified */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED	(UINT32_C(0x3) << 1)
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_LAST	HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used for selecting tunnel VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the tunnel headers of tunneled packets. This selection
	 * does not apply to non-tunneled packets.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_MASK	UINT32_C(0x18)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_SFT	3
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the tunnel packet headers
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_INNERMOST	(UINT32_C(0x0) << 3)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the tunnel packet headers.
	 * No VLAN PRI is selected for this configuration
	 * if only one VLAN Tag is present in the tunnel
	 * packet headers.
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTER	(UINT32_C(0x1) << 3)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the tunnel packet headers
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTERMOST	(UINT32_C(0x2) << 3)
	/* Unspecified */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED  (UINT32_C(0x3) << 3)
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_LAST	HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used to provide default CoS value that
	 * has been configured on this port.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_DEFAULT_COS_MASK	UINT32_C(0xe0)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_DEFAULT_COS_SFT	5
	uint8_t	unused_1;
	uint16_t	port_svif_info;
	/*
	 * This field specifies the source virtual interface of the port
	 * being queried. Drivers can use this to program port svif field in
	 * the L2 context table.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_MASK	UINT32_C(0x7fff)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_SFT	0
	/* This field specifies whether port_svif is valid or not */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_VALID	UINT32_C(0x8000)
	/*
	 * This field indicates the configured load control for PTP
	 * time of day (TOD) block.
	 */
	uint8_t	ptp_load_control;
	/* Indicates the current load control is none. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PTP_LOAD_CONTROL_NONE	UINT32_C(0x0)
	/* Indicates the current load control is immediate. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PTP_LOAD_CONTROL_IMMEDIATE UINT32_C(0x1)
	/*
	 * Indicates current load control is at next Pulse per Second (PPS)
	 * event.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PTP_LOAD_CONTROL_PPS_EVENT UINT32_C(0x2)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PTP_LOAD_CONTROL_LAST	HWRM_PORT_MAC_QCFG_OUTPUT_PTP_LOAD_CONTROL_PPS_EVENT
	uint8_t	unused_2[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_mac_qcfg_output_t, *phwrm_port_mac_qcfg_output_t;

/**************************
 * hwrm_port_mac_ptp_qcfg *
 **************************/


/* hwrm_port_mac_ptp_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_mac_ptp_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_mac_ptp_qcfg_input_t, *phwrm_port_mac_ptp_qcfg_input_t;

/* hwrm_port_mac_ptp_qcfg_output (size:704b/88B) */

typedef struct hwrm_port_mac_ptp_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * In this field, a number of PTP related flags
	 * are used to indicate configured PTP capabilities.
	 */
	uint8_t	flags;
	/*
	 * When this bit is set to '1', the PTP related registers are
	 * directly accessible by the host.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_DIRECT_ACCESS			UINT32_C(0x1)
	/*
	 * When this bit is set to '1', the device supports one-step
	 * Tx timestamping.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_ONE_STEP_TX_TS			UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the PTP information is accessible
	 * via HWRM commands.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_HWRM_ACCESS			UINT32_C(0x8)
	/*
	 * When this bit is set to '1', two specific registers for current
	 * time (ts_ref_clock_reg_lower and ts_ref_clock_reg_upper) are
	 * directly accessible by the host.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_PARTIAL_DIRECT_ACCESS_REF_CLOCK	UINT32_C(0x10)
	/*
	 * When this bit is set to '1', it indicates that driver has
	 * configured 64bit RTC.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_RTC_CONFIGURED			UINT32_C(0x20)
	/*
	 * When this bit is set to '1', it indicates that current time
	 * exposed to driver is 64bit.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_64B_PHC_TIME			UINT32_C(0x40)
	uint8_t	unused_0[3];
	/*
	 * Offset of the PTP register for the lower 32 bits of timestamp
	 * for RX.
	 */
	uint32_t	rx_ts_reg_off_lower;
	/*
	 * Offset of the PTP register for the upper 32 bits of timestamp
	 * for RX.
	 */
	uint32_t	rx_ts_reg_off_upper;
	/* Offset of the PTP register for the sequence ID for RX. */
	uint32_t	rx_ts_reg_off_seq_id;
	/* Offset of the first PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_0;
	/* Offset of the second PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_1;
	/* Offset of the third PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_2;
	/* Offset of the domain ID for RX. */
	uint32_t	rx_ts_reg_off_domain_id;
	/* Offset of the PTP FIFO register for RX. */
	uint32_t	rx_ts_reg_off_fifo;
	/* Offset of the PTP advance FIFO register for RX. */
	uint32_t	rx_ts_reg_off_fifo_adv;
	/* PTP timestamp granularity for RX. */
	uint32_t	rx_ts_reg_off_granularity;
	/*
	 * Offset of the PTP register for the lower 32 bits of timestamp
	 * for TX.
	 */
	uint32_t	tx_ts_reg_off_lower;
	/*
	 * Offset of the PTP register for the upper 32 bits of timestamp
	 * for TX.
	 */
	uint32_t	tx_ts_reg_off_upper;
	/* Offset of the PTP register for the sequence ID for TX. */
	uint32_t	tx_ts_reg_off_seq_id;
	/* Offset of the PTP FIFO register for TX. */
	uint32_t	tx_ts_reg_off_fifo;
	/* PTP timestamp granularity for TX. */
	uint32_t	tx_ts_reg_off_granularity;
	/* Offset of register to get lower 32 bits of current time. */
	uint32_t	ts_ref_clock_reg_lower;
	/* Offset of register to get upper 32 bits of current time. */
	uint32_t	ts_ref_clock_reg_upper;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_mac_ptp_qcfg_output_t, *phwrm_port_mac_ptp_qcfg_output_t;

/* Port Tx Statistics Format */
/* tx_port_stats (size:3264b/408B) */

typedef struct tx_port_stats {
	/* Total Number of 64 Bytes frames transmitted */
	uint64_t	tx_64b_frames;
	/* Total Number of 65-127 Bytes frames transmitted */
	uint64_t	tx_65b_127b_frames;
	/* Total Number of 128-255 Bytes frames transmitted */
	uint64_t	tx_128b_255b_frames;
	/* Total Number of 256-511 Bytes frames transmitted */
	uint64_t	tx_256b_511b_frames;
	/* Total Number of 512-1023 Bytes frames transmitted */
	uint64_t	tx_512b_1023b_frames;
	/* Total Number of 1024-1518 Bytes frames transmitted */
	uint64_t	tx_1024b_1518b_frames;
	/*
	 * Total Number of each good VLAN (excludes FCS errors)
	 * frame transmitted which is 1519 to 1522 bytes in length
	 * inclusive (excluding framing bits but including FCS bytes).
	 */
	uint64_t	tx_good_vlan_frames;
	/* Total Number of 1519-2047 Bytes frames transmitted */
	uint64_t	tx_1519b_2047b_frames;
	/* Total Number of 2048-4095 Bytes frames transmitted */
	uint64_t	tx_2048b_4095b_frames;
	/* Total Number of 4096-9216 Bytes frames transmitted */
	uint64_t	tx_4096b_9216b_frames;
	/* Total Number of 9217-16383 Bytes frames transmitted */
	uint64_t	tx_9217b_16383b_frames;
	/* Total Number of good frames transmitted */
	uint64_t	tx_good_frames;
	/* Total Number of frames transmitted */
	uint64_t	tx_total_frames;
	/* Total number of unicast frames transmitted */
	uint64_t	tx_ucast_frames;
	/* Total number of multicast frames transmitted */
	uint64_t	tx_mcast_frames;
	/* Total number of broadcast frames transmitted */
	uint64_t	tx_bcast_frames;
	/* Total number of PAUSE control frames transmitted */
	uint64_t	tx_pause_frames;
	/*
	 * Total number of PFC/per-priority PAUSE
	 * control frames transmitted
	 */
	uint64_t	tx_pfc_frames;
	/* Total number of jabber frames transmitted */
	uint64_t	tx_jabber_frames;
	/* Total number of frames transmitted with FCS error */
	uint64_t	tx_fcs_err_frames;
	/* Total number of control frames transmitted */
	uint64_t	tx_control_frames;
	/* Total number of over-sized frames transmitted */
	uint64_t	tx_oversz_frames;
	/* Total number of frames with single deferral */
	uint64_t	tx_single_dfrl_frames;
	/* Total number of frames with multiple deferrals */
	uint64_t	tx_multi_dfrl_frames;
	/* Total number of frames with single collision */
	uint64_t	tx_single_coll_frames;
	/* Total number of frames with multiple collisions */
	uint64_t	tx_multi_coll_frames;
	/* Total number of frames with late collisions */
	uint64_t	tx_late_coll_frames;
	/* Total number of frames with excessive collisions */
	uint64_t	tx_excessive_coll_frames;
	/* Total number of fragmented frames transmitted */
	uint64_t	tx_frag_frames;
	/* Total number of transmit errors */
	uint64_t	tx_err;
	/* Total number of single VLAN tagged frames transmitted */
	uint64_t	tx_tagged_frames;
	/* Total number of double VLAN tagged frames transmitted */
	uint64_t	tx_dbl_tagged_frames;
	/* Total number of runt frames transmitted */
	uint64_t	tx_runt_frames;
	/* Total number of TX FIFO under runs */
	uint64_t	tx_fifo_underruns;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 0 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri0;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 1 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri1;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 2 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri2;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 3 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri3;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 4 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri4;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 5 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri5;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 6 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri6;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 7 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri7;
	/* Total number of EEE LPI Events on TX */
	uint64_t	tx_eee_lpi_events;
	/* EEE LPI Duration Counter on TX */
	uint64_t	tx_eee_lpi_duration;
	/*
	 * Total number of Link Level Flow Control (LLFC) messages
	 * transmitted
	 */
	uint64_t	tx_llfc_logical_msgs;
	/* Total number of HCFC messages transmitted */
	uint64_t	tx_hcfc_msgs;
	/* Total number of TX collisions */
	uint64_t	tx_total_collisions;
	/* Total number of transmitted bytes */
	uint64_t	tx_bytes;
	/* Total number of end-to-end HOL frames */
	uint64_t	tx_xthol_frames;
	/* Total Tx Drops per Port reported by STATS block */
	uint64_t	tx_stat_discard;
	/* Total Tx Error Drops per Port reported by STATS block */
	uint64_t	tx_stat_error;
} tx_port_stats_t, *ptx_port_stats_t;

/* Port Rx Statistics Format */
/* rx_port_stats (size:4224b/528B) */

typedef struct rx_port_stats {
	/* Total Number of 64 Bytes frames received */
	uint64_t	rx_64b_frames;
	/* Total Number of 65-127 Bytes frames received */
	uint64_t	rx_65b_127b_frames;
	/* Total Number of 128-255 Bytes frames received */
	uint64_t	rx_128b_255b_frames;
	/* Total Number of 256-511 Bytes frames received */
	uint64_t	rx_256b_511b_frames;
	/* Total Number of 512-1023 Bytes frames received */
	uint64_t	rx_512b_1023b_frames;
	/* Total Number of 1024-1518 Bytes frames received */
	uint64_t	rx_1024b_1518b_frames;
	/*
	 * Total Number of each good VLAN (excludes FCS errors)
	 * frame received which is 1519 to 1522 bytes in length
	 * inclusive (excluding framing bits but including FCS bytes).
	 */
	uint64_t	rx_good_vlan_frames;
	/* Total Number of 1519-2047 Bytes frames received */
	uint64_t	rx_1519b_2047b_frames;
	/* Total Number of 2048-4095 Bytes frames received */
	uint64_t	rx_2048b_4095b_frames;
	/* Total Number of 4096-9216 Bytes frames received */
	uint64_t	rx_4096b_9216b_frames;
	/* Total Number of 9217-16383 Bytes frames received */
	uint64_t	rx_9217b_16383b_frames;
	/* Total number of frames received */
	uint64_t	rx_total_frames;
	/* Total number of unicast frames received */
	uint64_t	rx_ucast_frames;
	/* Total number of multicast frames received */
	uint64_t	rx_mcast_frames;
	/* Total number of broadcast frames received */
	uint64_t	rx_bcast_frames;
	/* Total number of received frames with FCS error */
	uint64_t	rx_fcs_err_frames;
	/* Total number of control frames received */
	uint64_t	rx_ctrl_frames;
	/* Total number of PAUSE frames received */
	uint64_t	rx_pause_frames;
	/* Total number of PFC frames received */
	uint64_t	rx_pfc_frames;
	/*
	 * Total number of frames received with an unsupported
	 * opcode
	 */
	uint64_t	rx_unsupported_opcode_frames;
	/*
	 * Total number of frames received with an unsupported
	 * DA for pause and PFC
	 */
	uint64_t	rx_unsupported_da_pausepfc_frames;
	/* Total number of frames received with an unsupported SA */
	uint64_t	rx_wrong_sa_frames;
	/* Total number of received packets with alignment error */
	uint64_t	rx_align_err_frames;
	/* Total number of received frames with out-of-range length */
	uint64_t	rx_oor_len_frames;
	/* Total number of received frames with error termination */
	uint64_t	rx_code_err_frames;
	/*
	 * Total number of received frames with a false carrier is
	 * detected during idle, as defined by RX_ER samples active
	 * and RXD is 0xE. The event is reported along with the
	 * statistics generated on the next received frame. Only
	 * one false carrier condition can be detected and logged
	 * between frames.
	 *
	 * Carrier event, valid for 10M/100M speed modes only.
	 */
	uint64_t	rx_false_carrier_frames;
	/* Total number of over-sized frames received */
	uint64_t	rx_ovrsz_frames;
	/* Total number of jabber packets received */
	uint64_t	rx_jbr_frames;
	/* Total number of received frames with MTU error */
	uint64_t	rx_mtu_err_frames;
	/* Total number of received frames with CRC match */
	uint64_t	rx_match_crc_frames;
	/* Total number of frames received promiscuously */
	uint64_t	rx_promiscuous_frames;
	/*
	 * Total number of received frames with one or two VLAN
	 * tags
	 */
	uint64_t	rx_tagged_frames;
	/* Total number of received frames with two VLAN tags */
	uint64_t	rx_double_tagged_frames;
	/* Total number of truncated frames received */
	uint64_t	rx_trunc_frames;
	/* Total number of good frames (without errors) received */
	uint64_t	rx_good_frames;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 0
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri0;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 1
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri1;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 2
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri2;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 3
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri3;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 4
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri4;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 5
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri5;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 6
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri6;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 7
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri7;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 0
	 */
	uint64_t	rx_pfc_ena_frames_pri0;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 1
	 */
	uint64_t	rx_pfc_ena_frames_pri1;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 2
	 */
	uint64_t	rx_pfc_ena_frames_pri2;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 3
	 */
	uint64_t	rx_pfc_ena_frames_pri3;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 4
	 */
	uint64_t	rx_pfc_ena_frames_pri4;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 5
	 */
	uint64_t	rx_pfc_ena_frames_pri5;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 6
	 */
	uint64_t	rx_pfc_ena_frames_pri6;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 7
	 */
	uint64_t	rx_pfc_ena_frames_pri7;
	/* Total Number of frames received with SCH CRC error */
	uint64_t	rx_sch_crc_err_frames;
	/* Total Number of under-sized frames received */
	uint64_t	rx_undrsz_frames;
	/* Total Number of fragmented frames received */
	uint64_t	rx_frag_frames;
	/* Total number of RX EEE LPI Events */
	uint64_t	rx_eee_lpi_events;
	/* EEE LPI Duration Counter on RX */
	uint64_t	rx_eee_lpi_duration;
	/*
	 * Total number of physical type Link Level Flow Control
	 * (LLFC) messages received
	 */
	uint64_t	rx_llfc_physical_msgs;
	/*
	 * Total number of logical type Link Level Flow Control
	 * (LLFC) messages received
	 */
	uint64_t	rx_llfc_logical_msgs;
	/*
	 * Total number of logical type Link Level Flow Control
	 * (LLFC) messages received with CRC error
	 */
	uint64_t	rx_llfc_msgs_with_crc_err;
	/* Total number of HCFC messages received */
	uint64_t	rx_hcfc_msgs;
	/* Total number of HCFC messages received with CRC error */
	uint64_t	rx_hcfc_msgs_with_crc_err;
	/* Total number of received bytes */
	uint64_t	rx_bytes;
	/* Total number of bytes received in runt frames */
	uint64_t	rx_runt_bytes;
	/* Total number of runt frames received */
	uint64_t	rx_runt_frames;
	/* Total Rx Discards per Port reported by STATS block */
	uint64_t	rx_stat_discard;
	uint64_t	rx_stat_err;
} rx_port_stats_t, *prx_port_stats_t;

/********************
 * hwrm_port_qstats *
 ********************/


/* hwrm_port_qstats_input (size:320b/40B) */

typedef struct hwrm_port_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_PORT_QSTATS_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0[5];
	/*
	 * This is the host address where
	 * Tx port statistics will be stored
	 */
	uint64_t	tx_stat_host_addr;
	/*
	 * This is the host address where
	 * Rx port statistics will be stored
	 */
	uint64_t	rx_stat_host_addr;
} hwrm_port_qstats_input_t, *phwrm_port_qstats_input_t;

/* hwrm_port_qstats_output (size:128b/16B) */

typedef struct hwrm_port_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of TX port statistics block in bytes. */
	uint16_t	tx_stat_size;
	/* The size of RX port statistics block in bytes. */
	uint16_t	rx_stat_size;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_qstats_output_t, *phwrm_port_qstats_output_t;

/* Port Tx Statistics extended Format */
/* tx_port_stats_ext (size:2048b/256B) */

typedef struct tx_port_stats_ext {
	/* Total number of tx bytes count on cos queue 0 */
	uint64_t	tx_bytes_cos0;
	/* Total number of tx bytes count on cos queue 1 */
	uint64_t	tx_bytes_cos1;
	/* Total number of tx bytes count on cos queue 2 */
	uint64_t	tx_bytes_cos2;
	/* Total number of tx bytes count on cos queue 3 */
	uint64_t	tx_bytes_cos3;
	/* Total number of tx bytes count on cos queue 4 */
	uint64_t	tx_bytes_cos4;
	/* Total number of tx bytes count on cos queue 5 */
	uint64_t	tx_bytes_cos5;
	/* Total number of tx bytes count on cos queue 6 */
	uint64_t	tx_bytes_cos6;
	/* Total number of tx bytes count on cos queue 7 */
	uint64_t	tx_bytes_cos7;
	/* Total number of tx packets count on cos queue 0 */
	uint64_t	tx_packets_cos0;
	/* Total number of tx packets count on cos queue 1 */
	uint64_t	tx_packets_cos1;
	/* Total number of tx packets count on cos queue 2 */
	uint64_t	tx_packets_cos2;
	/* Total number of tx packets count on cos queue 3 */
	uint64_t	tx_packets_cos3;
	/* Total number of tx packets count on cos queue 4 */
	uint64_t	tx_packets_cos4;
	/* Total number of tx packets count on cos queue 5 */
	uint64_t	tx_packets_cos5;
	/* Total number of tx packets count on cos queue 6 */
	uint64_t	tx_packets_cos6;
	/* Total number of tx packets count on cos queue 7 */
	uint64_t	tx_packets_cos7;
	/*
	 * time duration between transmitting a XON -> XOFF and a subsequent XOFF
	 * -> XON for priority 0
	 */
	uint64_t	pfc_pri0_tx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 0
	 */
	uint64_t	pfc_pri0_tx_transitions;
	/*
	 * time duration between transmitting a XON -> XOFF and a subsequent XOFF
	 * -> XON for priority 1
	 */
	uint64_t	pfc_pri1_tx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 1
	 */
	uint64_t	pfc_pri1_tx_transitions;
	/*
	 * time duration between transmitting a XON -> XOFF and a subsequent XOFF
	 * -> XON for priority 2
	 */
	uint64_t	pfc_pri2_tx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 2
	 */
	uint64_t	pfc_pri2_tx_transitions;
	/*
	 * time duration between transmitting a XON -> XOFF and a subsequent XOFF
	 * -> XON for priority 3
	 */
	uint64_t	pfc_pri3_tx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 3
	 */
	uint64_t	pfc_pri3_tx_transitions;
	/*
	 * time duration between transmitting a XON -> XOFF and a subsequent XOFF
	 * -> XON for priority 4
	 */
	uint64_t	pfc_pri4_tx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 4
	 */
	uint64_t	pfc_pri4_tx_transitions;
	/*
	 * time duration between transmitting a XON -> XOFF and a subsequent XOFF
	 * -> XON for priority 5
	 */
	uint64_t	pfc_pri5_tx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 5
	 */
	uint64_t	pfc_pri5_tx_transitions;
	/*
	 * time duration between transmitting a XON -> XOFF and a subsequent XOFF
	 * -> XON for priority 6
	 */
	uint64_t	pfc_pri6_tx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 6
	 */
	uint64_t	pfc_pri6_tx_transitions;
	/*
	 * time duration between transmitting a XON -> XOFF and a subsequent XOFF
	 * -> XON for priority 7
	 */
	uint64_t	pfc_pri7_tx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 7
	 */
	uint64_t	pfc_pri7_tx_transitions;
} tx_port_stats_ext_t, *ptx_port_stats_ext_t;

/* Port Rx Statistics extended Format */
/* rx_port_stats_ext (size:3904b/488B) */

typedef struct rx_port_stats_ext {
	/* Number of times link state changed to down */
	uint64_t	link_down_events;
	/* Number of times the idle rings with pause bit are found */
	uint64_t	continuous_pause_events;
	/* Number of times the active rings pause bit resumed back */
	uint64_t	resume_pause_events;
	/*
	 * Number of times, the ROCE cos queue PFC is disabled to avoid pause
	 * flood/burst
	 */
	uint64_t	continuous_roce_pause_events;
	/* Number of times, the ROCE cos queue PFC is enabled back */
	uint64_t	resume_roce_pause_events;
	/* Total number of rx bytes count on cos queue 0 */
	uint64_t	rx_bytes_cos0;
	/* Total number of rx bytes count on cos queue 1 */
	uint64_t	rx_bytes_cos1;
	/* Total number of rx bytes count on cos queue 2 */
	uint64_t	rx_bytes_cos2;
	/* Total number of rx bytes count on cos queue 3 */
	uint64_t	rx_bytes_cos3;
	/* Total number of rx bytes count on cos queue 4 */
	uint64_t	rx_bytes_cos4;
	/* Total number of rx bytes count on cos queue 5 */
	uint64_t	rx_bytes_cos5;
	/* Total number of rx bytes count on cos queue 6 */
	uint64_t	rx_bytes_cos6;
	/* Total number of rx bytes count on cos queue 7 */
	uint64_t	rx_bytes_cos7;
	/* Total number of rx packets count on cos queue 0 */
	uint64_t	rx_packets_cos0;
	/* Total number of rx packets count on cos queue 1 */
	uint64_t	rx_packets_cos1;
	/* Total number of rx packets count on cos queue 2 */
	uint64_t	rx_packets_cos2;
	/* Total number of rx packets count on cos queue 3 */
	uint64_t	rx_packets_cos3;
	/* Total number of rx packets count on cos queue 4 */
	uint64_t	rx_packets_cos4;
	/* Total number of rx packets count on cos queue 5 */
	uint64_t	rx_packets_cos5;
	/* Total number of rx packets count on cos queue 6 */
	uint64_t	rx_packets_cos6;
	/* Total number of rx packets count on cos queue 7 */
	uint64_t	rx_packets_cos7;
	/*
	 * time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for
	 * priority 0
	 */
	uint64_t	pfc_pri0_rx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 0
	 */
	uint64_t	pfc_pri0_rx_transitions;
	/*
	 * time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for
	 * priority 1
	 */
	uint64_t	pfc_pri1_rx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 1
	 */
	uint64_t	pfc_pri1_rx_transitions;
	/*
	 * time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for
	 * priority 2
	 */
	uint64_t	pfc_pri2_rx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 2
	 */
	uint64_t	pfc_pri2_rx_transitions;
	/*
	 * time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for
	 * priority 3
	 */
	uint64_t	pfc_pri3_rx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 3
	 */
	uint64_t	pfc_pri3_rx_transitions;
	/*
	 * time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for
	 * priority 4
	 */
	uint64_t	pfc_pri4_rx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 4
	 */
	uint64_t	pfc_pri4_rx_transitions;
	/*
	 * time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for
	 * priority 5
	 */
	uint64_t	pfc_pri5_rx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 5
	 */
	uint64_t	pfc_pri5_rx_transitions;
	/*
	 * time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for
	 * priority 6
	 */
	uint64_t	pfc_pri6_rx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 6
	 */
	uint64_t	pfc_pri6_rx_transitions;
	/*
	 * time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for
	 * priority 7
	 */
	uint64_t	pfc_pri7_rx_duration_us;
	/*
	 * Number of times, a XON -> XOFF and XOFF -> XON transitions occur for
	 * priority 7
	 */
	uint64_t	pfc_pri7_rx_transitions;
	/* Total number of received bits */
	uint64_t	rx_bits;
	/* The number of events where the port receive buffer was over 85% full */
	uint64_t	rx_buffer_passed_threshold;
	/*
	 * This counter represents uncorrected symbol errors post-FEC and may not
	 * be populated in all cases. Each uncorrected FEC block may result in
	 * one or more symbol errors.
	 */
	uint64_t	rx_pcs_symbol_err;
	/* The number of corrected bits on the port according to active FEC */
	uint64_t	rx_corrected_bits;
	/* Total number of rx discard bytes count on cos queue 0 */
	uint64_t	rx_discard_bytes_cos0;
	/* Total number of rx discard bytes count on cos queue 1 */
	uint64_t	rx_discard_bytes_cos1;
	/* Total number of rx discard bytes count on cos queue 2 */
	uint64_t	rx_discard_bytes_cos2;
	/* Total number of rx discard bytes count on cos queue 3 */
	uint64_t	rx_discard_bytes_cos3;
	/* Total number of rx discard bytes count on cos queue 4 */
	uint64_t	rx_discard_bytes_cos4;
	/* Total number of rx discard bytes count on cos queue 5 */
	uint64_t	rx_discard_bytes_cos5;
	/* Total number of rx discard bytes count on cos queue 6 */
	uint64_t	rx_discard_bytes_cos6;
	/* Total number of rx discard bytes count on cos queue 7 */
	uint64_t	rx_discard_bytes_cos7;
	/* Total number of rx discard packets count on cos queue 0 */
	uint64_t	rx_discard_packets_cos0;
	/* Total number of rx discard packets count on cos queue 1 */
	uint64_t	rx_discard_packets_cos1;
	/* Total number of rx discard packets count on cos queue 2 */
	uint64_t	rx_discard_packets_cos2;
	/* Total number of rx discard packets count on cos queue 3 */
	uint64_t	rx_discard_packets_cos3;
	/* Total number of rx discard packets count on cos queue 4 */
	uint64_t	rx_discard_packets_cos4;
	/* Total number of rx discard packets count on cos queue 5 */
	uint64_t	rx_discard_packets_cos5;
	/* Total number of rx discard packets count on cos queue 6 */
	uint64_t	rx_discard_packets_cos6;
	/* Total number of rx discard packets count on cos queue 7 */
	uint64_t	rx_discard_packets_cos7;
	/* Total number of FEC blocks corrected by the FEC function in the PHY */
	uint64_t	rx_fec_corrected_blocks;
	/*
	 * Total number of FEC blocks determined to be uncorrectable by the
	 * FEC function in the PHY
	 */
	uint64_t	rx_fec_uncorrectable_blocks;
	/*
	 * Total number of packets that are dropped due to not matching
	 * any RX filter rules. This value is zero on the non supported
	 * controllers. This counter is per controller, Firmware reports the
	 * same value on active ports. This counter does not include the
	 * packet discards because of no available buffers.
	 */
	uint64_t	rx_filter_miss;
	/*
	 * This field represents the number of FEC symbol errors by counting
	 * once for each 10-bit symbol corrected by FEC block.
	 * rx_fec_corrected_blocks will be incremented if all symbol errors in a
	 * codeword gets corrected.
	 */
	uint64_t	rx_fec_symbol_err;
} rx_port_stats_ext_t, *prx_port_stats_ext_t;

/*
 * Port Rx Statistics extended PFC WatchDog Format.
 * StormDetect and StormRevert event determination is based
 * on an integration period and a percentage threshold.
 * StormDetect event - when percentage of XOFF frames received
 * within an integration period exceeds the configured threshold.
 * StormRevert event - when percentage of XON frames received
 * within an integration period exceeds the configured threshold.
 * Actual number of XOFF/XON frames for the events to be triggered
 * depends on both configured integration period and sampling rate.
 * The statistics in this structure represent counts of specified
 * events from the moment the feature (PFC WatchDog) is enabled via
 * hwrm_queue_pfc_enable_cfg call.
 */
/* rx_port_stats_ext_pfc_wd (size:5120b/640B) */

typedef struct rx_port_stats_ext_pfc_wd {
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri0;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri1;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri2;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri3;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri4;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri5;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri6;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri7;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri0;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri1;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri2;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri3;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri4;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri5;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri6;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri7;
	/*
	 * Total number of packets received during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri0;
	/*
	 * Total number of packets received during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri1;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri2;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri3;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri4;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri5;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri6;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri7;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri0;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri1;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri2;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri3;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri4;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri5;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri6;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri7;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri0;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri1;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri2;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri3;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri4;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri5;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri6;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri7;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri0;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri1;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri2;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri3;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri4;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri5;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri6;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri7;
	/*
	 * Number of packets received during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri0;
	/*
	 * Number of packets received during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri1;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri2;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri3;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri4;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri5;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri6;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri7;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri0;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri1;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri2;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri3;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri4;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri5;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri6;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri7;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri0;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri1;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri2;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri3;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri4;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri5;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri6;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri7;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri0;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri1;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri2;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri3;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri4;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri5;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri6;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri7;
} rx_port_stats_ext_pfc_wd_t, *prx_port_stats_ext_pfc_wd_t;

/************************
 * hwrm_port_qstats_ext *
 ************************/


/* hwrm_port_qstats_ext_input (size:320b/40B) */

typedef struct hwrm_port_qstats_ext_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	/*
	 * The size of TX port extended
	 * statistics block in bytes.
	 */
	uint16_t	tx_stat_size;
	/*
	 * The size of RX port extended
	 * statistics block in bytes
	 */
	uint16_t	rx_stat_size;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for the counter mask,
	 * representing width of each of the stats counters, rather than
	 * counters themselves.
	 */
	#define HWRM_PORT_QSTATS_EXT_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0;
	/*
	 * This is the host address where
	 * Tx port statistics will be stored
	 */
	uint64_t	tx_stat_host_addr;
	/*
	 * This is the host address where
	 * Rx port statistics will be stored
	 */
	uint64_t	rx_stat_host_addr;
} hwrm_port_qstats_ext_input_t, *phwrm_port_qstats_ext_input_t;

/* hwrm_port_qstats_ext_output (size:128b/16B) */

typedef struct hwrm_port_qstats_ext_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of TX port statistics block in bytes. */
	uint16_t	tx_stat_size;
	/* The size of RX port statistics block in bytes. */
	uint16_t	rx_stat_size;
	/* Total number of active cos queues available. */
	uint16_t	total_active_cos_queues;
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates that clear
	 * roce specific counters is supported.
	 */
	#define HWRM_PORT_QSTATS_EXT_OUTPUT_FLAGS_CLEAR_ROCE_COUNTERS_SUPPORTED	UINT32_C(0x1)
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_qstats_ext_output_t, *phwrm_port_qstats_ext_output_t;

/*******************************
 * hwrm_port_qstats_ext_pfc_wd *
 *******************************/


/* hwrm_port_qstats_ext_pfc_wd_input (size:256b/32B) */

typedef struct hwrm_port_qstats_ext_pfc_wd_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	/*
	 * The size of rx_port_stats_ext_pfc_wd
	 * block in bytes
	 */
	uint16_t	pfc_wd_stat_size;
	uint8_t	unused_0[4];
	/*
	 * This is the host address where
	 * rx_port_stats_ext_pfc_wd will be stored
	 */
	uint64_t	pfc_wd_stat_host_addr;
} hwrm_port_qstats_ext_pfc_wd_input_t, *phwrm_port_qstats_ext_pfc_wd_input_t;

/* hwrm_port_qstats_ext_pfc_wd_output (size:128b/16B) */

typedef struct hwrm_port_qstats_ext_pfc_wd_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The size of rx_port_stats_ext_pfc_wd
	 * statistics block in bytes.
	 */
	uint16_t	pfc_wd_stat_size;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_qstats_ext_pfc_wd_output_t, *phwrm_port_qstats_ext_pfc_wd_output_t;

/*************************
 * hwrm_port_lpbk_qstats *
 *************************/


/* hwrm_port_lpbk_qstats_input (size:256b/32B) */

typedef struct hwrm_port_lpbk_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The size of the loopback statistics buffer passed in the
	 * loopback_stat_host_addr in bytes.
	 * Firmware will not exceed this size when it DMAs the
	 * statistics structure to the host. The actual DMA size
	 * will be returned in the response.
	 */
	uint16_t	lpbk_stat_size;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_PORT_LPBK_QSTATS_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0[5];
	/*
	 * This is the host address where
	 * loopback statistics will be stored
	 */
	uint64_t	lpbk_stat_host_addr;
} hwrm_port_lpbk_qstats_input_t, *phwrm_port_lpbk_qstats_input_t;

/* hwrm_port_lpbk_qstats_output (size:128b/16B) */

typedef struct hwrm_port_lpbk_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The size of the loopback statistics block in bytes DMA'ed by the
	 * firmware. Note that this size will never exceed the lpbk_stat_size
	 * field passed in by the driver in the hwrm_port_lpbk_qstats_input
	 * structure.
	 */
	uint16_t	lpbk_stat_size;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_port_lpbk_qstats_output_t, *phwrm_port_lpbk_qstats_output_t;

/* Loopback Port Statistic Format */
/* port_lpbk_stats (size:640b/80B) */

typedef struct port_lpbk_stats {
	/* Number of transmitted unicast frames */
	uint64_t	lpbk_ucast_frames;
	/* Number of transmitted multicast frames */
	uint64_t	lpbk_mcast_frames;
	/* Number of transmitted broadcast frames */
	uint64_t	lpbk_bcast_frames;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	lpbk_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	lpbk_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	lpbk_bcast_bytes;
	/* Number of dropped tx packets */
	uint64_t	lpbk_tx_discards;
	/* Number of error dropped tx packets */
	uint64_t	lpbk_tx_errors;
	/* Number of dropped rx packets */
	uint64_t	lpbk_rx_discards;
	/* Number of error dropped rx packets */
	uint64_t	lpbk_rx_errors;
} port_lpbk_stats_t, *pport_lpbk_stats_t;

/************************
 * hwrm_port_ecn_qstats *
 ************************/


/* hwrm_port_ecn_qstats_input (size:256b/32B) */

typedef struct hwrm_port_ecn_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port that is being queried. Unused if NIC is in
	 * multi-host mode.
	 */
	uint16_t	port_id;
	/*
	 * Size of the DMA buffer the caller has allocated for the firmware to
	 * write into.
	 */
	uint16_t	ecn_stat_buf_size;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_PORT_ECN_QSTATS_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0[3];
	/*
	 * This is the host address where
	 * ECN port statistics will be stored
	 */
	uint64_t	ecn_stat_host_addr;
} hwrm_port_ecn_qstats_input_t, *phwrm_port_ecn_qstats_input_t;

/* hwrm_port_ecn_qstats_output (size:128b/16B) */

typedef struct hwrm_port_ecn_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of bytes of stats the firmware wrote to the DMA buffer. */
	uint16_t	ecn_stat_buf_size;
	/*
	 * Bitmask that indicates which CoS queues have ECN marking enabled.
	 * Bit i corresponds to CoS queue i.
	 */
	uint8_t	mark_en;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_ecn_qstats_output_t, *phwrm_port_ecn_qstats_output_t;

/* ECN mark statistics format */
/* port_stats_ecn (size:512b/64B) */

typedef struct port_stats_ecn {
	/*
	 * Number of packets marked in CoS queue 0.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos0;
	/*
	 * Number of packets marked in CoS queue 1.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos1;
	/*
	 * Number of packets marked in CoS queue 2.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos2;
	/*
	 * Number of packets marked in CoS queue 3.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos3;
	/*
	 * Number of packets marked in CoS queue 4.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos4;
	/*
	 * Number of packets marked in CoS queue 5.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos5;
	/*
	 * Number of packets marked in CoS queue 6.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos6;
	/*
	 * Number of packets marked in CoS queue 7.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos7;
} port_stats_ecn_t, *pport_stats_ecn_t;

/***********************
 * hwrm_port_clr_stats *
 ***********************/


/* hwrm_port_clr_stats_input (size:192b/24B) */

typedef struct hwrm_port_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates clear the following RoCE
	 * specific counters.
	 * RoCE associated TX/RX cos counters
	 * CNP associated TX/RX cos counters
	 * RoCE/CNP specific TX/RX flow counters
	 * Firmware will determine the RoCE/CNP cos queue based on qos
	 * profile.
	 * This flag is honored only when RoCE is enabled on that port.
	 */
	#define HWRM_PORT_CLR_STATS_INPUT_FLAGS_ROCE_COUNTERS	UINT32_C(0x1)
	uint8_t	unused_0[5];
} hwrm_port_clr_stats_input_t, *phwrm_port_clr_stats_input_t;

/* hwrm_port_clr_stats_output (size:128b/16B) */

typedef struct hwrm_port_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_clr_stats_output_t, *phwrm_port_clr_stats_output_t;

/****************************
 * hwrm_port_lpbk_clr_stats *
 ****************************/


/* hwrm_port_lpbk_clr_stats_input (size:192b/24B) */

typedef struct hwrm_port_lpbk_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_lpbk_clr_stats_input_t, *phwrm_port_lpbk_clr_stats_input_t;

/* hwrm_port_lpbk_clr_stats_output (size:128b/16B) */

typedef struct hwrm_port_lpbk_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_lpbk_clr_stats_output_t, *phwrm_port_lpbk_clr_stats_output_t;

/**********************
 * hwrm_port_ts_query *
 **********************/


/* hwrm_port_ts_query_input (size:320b/40B) */

typedef struct hwrm_port_ts_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH		UINT32_C(0x1)
	/* tx path */
		#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_TX		UINT32_C(0x0)
	/* rx path */
		#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_RX		UINT32_C(0x1)
		#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_LAST	HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_RX
	/*
	 * If set, the response includes the current value of the free
	 * running timer.
	 */
	#define HWRM_PORT_TS_QUERY_INPUT_FLAGS_CURRENT_TIME	UINT32_C(0x2)
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[2];
	uint16_t	enables;
	/*
	 * This bit must be '1' for the ts_req_timeout field to be
	 * configured.
	 */
	#define HWRM_PORT_TS_QUERY_INPUT_ENABLES_TS_REQ_TIMEOUT	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ptp_seq_id field to be
	 * configured.
	 */
	#define HWRM_PORT_TS_QUERY_INPUT_ENABLES_PTP_SEQ_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the ptp_hdr_offset field to be
	 * configured.
	 */
	#define HWRM_PORT_TS_QUERY_INPUT_ENABLES_PTP_HDR_OFFSET	UINT32_C(0x4)
	/*
	 * Specifies the timeout in microseconds. If this is specified,
	 * firmware will keep checking for a matching timestamp packet
	 * till the timeout is exhausted. User can specify a max timeout
	 * of 65535 microseconds. Firmware will return HWRM_ERR_CODE_BUSY
	 * if a matching timestamp is not found. Firmware will return
	 * HWRM_ERROR_CODE_FAIL if we are unable to read timestamps
	 * from FIFO.
	 */
	uint16_t	ts_req_timeout;
	/*
	 * Specifies the sequence ID of the PTP timestamp packet we
	 * are interested in. When this is specified, firmware will
	 * only return the timestamp of the packet which matches this
	 * sequence ID.
	 */
	uint32_t	ptp_seq_id;
	/*
	 * Specifies the PTP header offset of the PTP packet for which
	 * the timestamp is requested.
	 */
	uint16_t	ptp_hdr_offset;
	uint8_t	unused_1[6];
} hwrm_port_ts_query_input_t, *phwrm_port_ts_query_input_t;

/* hwrm_port_ts_query_output (size:192b/24B) */

typedef struct hwrm_port_ts_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Timestamp value of PTP message captured, or current value of
	 * free running timer.
	 */
	uint64_t	ptp_msg_ts;
	/* Sequence ID of the PTP message captured. */
	uint16_t	ptp_msg_seqid;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_ts_query_output_t, *phwrm_port_ts_query_output_t;

/***********************
 * hwrm_port_phy_qcaps *
 ***********************/


/* hwrm_port_phy_qcaps_input (size:192b/24B) */

typedef struct hwrm_port_phy_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_phy_qcaps_input_t, *phwrm_port_phy_qcaps_input_t;

/* hwrm_port_phy_qcaps_output (size:320b/40B) */

typedef struct hwrm_port_phy_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* PHY capability flags */
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates that the
	 * link is capable of supporting EEE.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_EEE_SUPPORTED			UINT32_C(0x1)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY is capable of supporting external loopback.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_EXTERNAL_LPBK_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY is capable of supporting loopback in autoneg mode.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_AUTONEG_LPBK_SUPPORTED	UINT32_C(0x4)
	/*
	 * Indicates if the configuration of shared PHY settings is
	 * supported. In cases where a physical port is shared by multiple
	 * functions (e.g. NPAR, multihost, etc), the configuration of PHY
	 * settings may not be allowed. Callers to HWRM_PORT_PHY_CFG will
	 * get an HWRM_ERR_CODE_RESOURCE_ACCESS_DENIED error in this case.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_SHARED_PHY_CFG_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, it indicates that the port counters and extended
	 * port counters will not reset when the firmware shuts down or
	 * resets the PHY. These counters will only be reset during power
	 * cycle or by calling HWRM_PORT_CLR_STATS.
	 * If set to 0, the state of the counters is unspecified when
	 * firmware shuts down or resets the PHY.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_CUMULATIVE_COUNTERS_ON_RESET	UINT32_C(0x10)
	/*
	 * If set to 1, then this field indicates that the
	 * local loopback is not supported on this controller.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_LOCAL_LPBK_NOT_SUPPORTED	UINT32_C(0x20)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY/Link down policy during PF shutdown is totally
	 * controlled by the firmware. It can shutdown the link
	 * even when there are active VFs associated with the PF.
	 * Host PF driver can send HWRM_PHY_CFG command to bring
	 * down the PHY even when the port is shared between VFs
	 * and PFs.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_FW_MANAGED_LINK_DOWN		UINT32_C(0x40)
	/*
	 * If set to 1, this field indicates that the FCS may
	 * be disabled for a given packet via the transmit
	 * buffer descriptor.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_NO_FCS			UINT32_C(0x80)
	/* Number of front panel ports for this device. */
	uint8_t	port_cnt;
	/* Not supported or unknown */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_UNKNOWN UINT32_C(0x0)
	/* single port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_1	UINT32_C(0x1)
	/* 2-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_2	UINT32_C(0x2)
	/* 3-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_3	UINT32_C(0x3)
	/* 4-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_4	UINT32_C(0x4)
	/* 12-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_12	UINT32_C(0xc)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_LAST   HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_12
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * as forced speeds on this link.
	 * For each speed that can be forced on this link, the
	 * corresponding mask bit shall be set to '1'.
	 */
	uint16_t	supported_speeds_force_mode;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10MB	UINT32_C(0x2000)
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * for autonegotiation on this link.
	 * For each speed that can be autonegotiated on this link, the
	 * corresponding mask bit shall be set to '1'.
	 */
	uint16_t	supported_speeds_auto_mode;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10MB	UINT32_C(0x2000)
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * for EEE on this link.
	 * For each speed that can be autonegotiated when EEE is enabled
	 * on this link, the corresponding mask bit shall be set to '1'.
	 * This field is only valid when the eee_supported is set to '1'.
	 */
	uint16_t	supported_speeds_eee_mode;
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD1	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_100MB	UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD2	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_1GB	UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD3	UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD4	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_10GB	UINT32_C(0x40)
	uint32_t	tx_lpi_timer_low;
	/*
	 * The lowest value of TX LPI timer that can be set on this link
	 * when EEE is enabled. This value is in microseconds.
	 * This field is valid only when_eee_supported is set to '1'.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_LOW_MASK UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_LOW_SFT 0
	/*
	 * Reserved field. The HWRM shall set this field to 0.
	 * An HWRM client shall ignore this field.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD2_MASK	UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD2_SFT		24
	uint32_t	valid_tx_lpi_timer_high;
	/*
	 * The highest value of TX LPI timer that can be set on this link
	 * when EEE is enabled. This value is in microseconds.
	 * This field is valid only when_eee_supported is set to '1'.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_HIGH_MASK UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_HIGH_SFT 0
	/*
	 * Reserved field. The HWRM shall set this field to 0.
	 * An HWRM client shall ignore this field.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD_MASK		UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD_SFT		24
	/*
	 * This field is used to advertise which PAM4 speeds are supported
	 * in auto mode.
	 */
	uint16_t	supported_pam4_speeds_auto_mode;
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_200G	UINT32_C(0x4)
	/*
	 * This field is used to advertise which PAM4 speeds are supported
	 * in forced mode.
	 */
	uint16_t	supported_pam4_speeds_force_mode;
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_200G	UINT32_C(0x4)
	/* More PHY capability flags */
	uint16_t	flags2;
	/*
	 * If set to 1, then this field indicates that
	 * 802.3x flow control is not supported.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS2_PAUSE_UNSUPPORTED	UINT32_C(0x1)
	/*
	 * If set to 1, then this field indicates that
	 * priority-based flow control is not supported.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS2_PFC_UNSUPPORTED		UINT32_C(0x2)
	/*
	 * If set to 1, then this field indicates that
	 * bank based addressing is supported in firmware.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS2_BANK_ADDR_SUPPORTED	UINT32_C(0x4)
	/*
	 * If set to 1, then this field indicates that
	 * supported_speed2 field is to be used in lieu of all
	 * supported_speed variants.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS2_SPEEDS2_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, then this field indicates that
	 * the device does not support remote loopback.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS2_REMOTE_LPBK_UNSUPPORTED	UINT32_C(0x10)
	/*
	 * Number of internal ports for this device. This field allows the FW
	 * to advertise how many internal ports are present. Manufacturing
	 * tools uses this to determine how many internal ports should have
	 * the PRBS test run on them. This field always return 0 unless NVM
	 * option "HPTN_MODE" is set to 1.
	 */
	uint8_t	internal_port_cnt;
	uint8_t	unused_0;
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * as forced speeds on this link.
	 * For each speed that can be forced on this link, the
	 * corresponding mask bit shall be set to '1'.
	 * This field is valid only if speeds2_supported bit is set in flags2
	 */
	uint16_t	supported_speeds2_force_mode;
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_1GB		UINT32_C(0x1)
	/* 10Gb (NRZ: 10G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_10GB		UINT32_C(0x2)
	/* 25Gb (NRZ: 25G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_25GB		UINT32_C(0x4)
	/* 40Gb (NRZ: 10G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_40GB		UINT32_C(0x8)
	/* 50Gb (NRZ: 25G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_50GB		UINT32_C(0x10)
	/* 100Gb (NRZ: 25G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_100GB		UINT32_C(0x20)
	/* 50Gb (PAM4-56: 50G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_50GB_PAM4_56	UINT32_C(0x40)
	/* 100Gb (PAM4-56: 50G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_100GB_PAM4_56	UINT32_C(0x80)
	/* 200Gb (PAM4-56: 50G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_200GB_PAM4_56	UINT32_C(0x100)
	/* 400Gb (PAM4-56: 50G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_400GB_PAM4_56	UINT32_C(0x200)
	/* 100Gb (PAM4-112: 100G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_100GB_PAM4_112	UINT32_C(0x400)
	/* 200Gb (PAM4-112: 100G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_200GB_PAM4_112	UINT32_C(0x800)
	/* 400Gb (PAM4-112: 100G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_400GB_PAM4_112	UINT32_C(0x1000)
	/* 800Gb (PAM4-112: 100G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_FORCE_MODE_800GB_PAM4_112	UINT32_C(0x2000)
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * for autonegotiation on this link.
	 * For each speed that can be autonegotiated on this link, the
	 * corresponding mask bit shall be set to '1'.
	 * This field is valid only if speeds2_supported bit is set in flags2
	 */
	uint16_t	supported_speeds2_auto_mode;
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_1GB		UINT32_C(0x1)
	/* 10Gb (NRZ: 10G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_10GB		UINT32_C(0x2)
	/* 25Gb (NRZ: 25G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_25GB		UINT32_C(0x4)
	/* 40Gb (NRZ: 10G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_40GB		UINT32_C(0x8)
	/* 50Gb (NRZ: 25G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_50GB		UINT32_C(0x10)
	/* 100Gb (NRZ: 25G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_100GB		UINT32_C(0x20)
	/* 50Gb (PAM4-56: 50G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_50GB_PAM4_56	UINT32_C(0x40)
	/* 100Gb (PAM4-56: 50G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_100GB_PAM4_56	UINT32_C(0x80)
	/* 200Gb (PAM4-56: 50G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_200GB_PAM4_56	UINT32_C(0x100)
	/* 400Gb (PAM4-56: 50G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_400GB_PAM4_56	UINT32_C(0x200)
	/* 100Gb (PAM4-112: 100G per lane, 1 lane) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_100GB_PAM4_112	UINT32_C(0x400)
	/* 200Gb (PAM4-112: 100G per lane, 2 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_200GB_PAM4_112	UINT32_C(0x800)
	/* 400Gb (PAM4-112: 100G per lane, 4 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_400GB_PAM4_112	UINT32_C(0x1000)
	/* 800Gb (PAM4-112: 100G per lane, 8 lanes) link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS2_AUTO_MODE_800GB_PAM4_112	UINT32_C(0x2000)
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_qcaps_output_t, *phwrm_port_phy_qcaps_output_t;

/***************************
 * hwrm_port_phy_i2c_write *
 ***************************/


/* hwrm_port_phy_i2c_write_input (size:832b/104B) */

typedef struct hwrm_port_phy_i2c_write_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the page_offset field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_I2C_WRITE_INPUT_ENABLES_PAGE_OFFSET	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the bank_number field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_I2C_WRITE_INPUT_ENABLES_BANK_NUMBER	UINT32_C(0x2)
	/* Port ID of port. */
	uint16_t	port_id;
	/* 8-bit I2C slave address. */
	uint8_t	i2c_slave_addr;
	/* The bank number of the page that is being accessed over I2C. */
	uint8_t	bank_number;
	/* The page number that is being accessed over I2C. */
	uint16_t	page_number;
	/* Offset within the page that is being accessed over I2C. */
	uint16_t	page_offset;
	/*
	 * Length of data to write, in bytes starting at the offset
	 * specified above. If the offset is not specified, then
	 * the data shall be written from the beginning of the page.
	 */
	uint8_t	data_length;
	uint8_t	unused_1[7];
	/* Up to 64B of data. */
	uint32_t	data[16];
} hwrm_port_phy_i2c_write_input_t, *phwrm_port_phy_i2c_write_input_t;

/* hwrm_port_phy_i2c_write_output (size:128b/16B) */

typedef struct hwrm_port_phy_i2c_write_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_i2c_write_output_t, *phwrm_port_phy_i2c_write_output_t;

/**************************
 * hwrm_port_phy_i2c_read *
 **************************/


/* hwrm_port_phy_i2c_read_input (size:320b/40B) */

typedef struct hwrm_port_phy_i2c_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the page_offset field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_I2C_READ_INPUT_ENABLES_PAGE_OFFSET	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the bank_number field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_I2C_READ_INPUT_ENABLES_BANK_NUMBER	UINT32_C(0x2)
	/* Port ID of port. */
	uint16_t	port_id;
	/* 8-bit I2C slave address. */
	uint8_t	i2c_slave_addr;
	/* The bank number of the page that is being accessed over I2C. */
	uint8_t	bank_number;
	/* The page number that is being accessed over I2C. */
	uint16_t	page_number;
	/* Offset within the page that is being accessed over I2C. */
	uint16_t	page_offset;
	/*
	 * Length of data to read, in bytes starting at the offset
	 * specified above. If the offset is not specified, then
	 * the data shall be read from the beginning of the page.
	 */
	uint8_t	data_length;
	uint8_t	unused_1[7];
} hwrm_port_phy_i2c_read_input_t, *phwrm_port_phy_i2c_read_input_t;

/* hwrm_port_phy_i2c_read_output (size:640b/80B) */

typedef struct hwrm_port_phy_i2c_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Up to 64B of data. */
	uint32_t	data[16];
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_i2c_read_output_t, *phwrm_port_phy_i2c_read_output_t;

/****************************
 * hwrm_port_phy_mdio_write *
 ****************************/


/* hwrm_port_phy_mdio_write_input (size:320b/40B) */

typedef struct hwrm_port_phy_mdio_write_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint64_t	unused_0;
	/* Port ID of port. */
	uint16_t	port_id;
	/* If phy_address is 0xFF, port_id will be used to derive phy_addr. */
	uint8_t	phy_addr;
	/* 8-bit device address. */
	uint8_t	dev_addr;
	/* 16-bit register address. */
	uint16_t	reg_addr;
	/* 16-bit register data. */
	uint16_t	reg_data;
	/*
	 * When this bit is set to 1 a Clause 45 mdio access is done.
	 * when this bit is set to 0 a Clause 22 mdio access is done.
	 */
	uint8_t	cl45_mdio;
	/*  */
	uint8_t	unused_1[7];
} hwrm_port_phy_mdio_write_input_t, *phwrm_port_phy_mdio_write_input_t;

/* hwrm_port_phy_mdio_write_output (size:128b/16B) */

typedef struct hwrm_port_phy_mdio_write_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_mdio_write_output_t, *phwrm_port_phy_mdio_write_output_t;

/***************************
 * hwrm_port_phy_mdio_read *
 ***************************/


/* hwrm_port_phy_mdio_read_input (size:256b/32B) */

typedef struct hwrm_port_phy_mdio_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint64_t	unused_0;
	/* Port ID of port. */
	uint16_t	port_id;
	/* If phy_address is 0xFF, port_id will be used to derive phy_addr. */
	uint8_t	phy_addr;
	/* 8-bit device address. */
	uint8_t	dev_addr;
	/* 16-bit register address. */
	uint16_t	reg_addr;
	/*
	 * When this bit is set to 1 a Clause 45 mdio access is done.
	 * when this bit is set to 0 a Clause 22 mdio access is done.
	 */
	uint8_t	cl45_mdio;
	/*  */
	uint8_t	unused_1;
} hwrm_port_phy_mdio_read_input_t, *phwrm_port_phy_mdio_read_input_t;

/* hwrm_port_phy_mdio_read_output (size:128b/16B) */

typedef struct hwrm_port_phy_mdio_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* 16-bit register data. */
	uint16_t	reg_data;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_mdio_read_output_t, *phwrm_port_phy_mdio_read_output_t;

/*********************
 * hwrm_port_led_cfg *
 *********************/


/* hwrm_port_led_cfg_input (size:512b/64B) */

typedef struct hwrm_port_led_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the led0_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the led0_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_STATE	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the led0_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_COLOR	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the led0_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_BLINK_ON	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the led0_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_BLINK_OFF	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the led0_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_GROUP_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the led1_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_ID		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the led1_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_STATE	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the led1_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_COLOR	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the led1_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_BLINK_ON	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the led1_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_BLINK_OFF	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the led1_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_GROUP_ID	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the led2_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_ID		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the led2_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_STATE	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the led2_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_COLOR	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the led2_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_BLINK_ON	UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the led2_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_BLINK_OFF	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the led2_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_GROUP_ID	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the led3_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_ID		UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the led3_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_STATE	UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the led3_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_COLOR	UINT32_C(0x100000)
	/*
	 * This bit must be '1' for the led3_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_BLINK_ON	UINT32_C(0x200000)
	/*
	 * This bit must be '1' for the led3_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_BLINK_OFF	UINT32_C(0x400000)
	/*
	 * This bit must be '1' for the led3_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_GROUP_ID	UINT32_C(0x800000)
	/* Port ID of port whose LEDs are configured. */
	uint16_t	port_id;
	/*
	 * The number of LEDs that are being configured.
	 * Up to 4 LEDs can be configured with this command.
	 */
	uint8_t	num_leds;
	/* Reserved field. */
	uint8_t	rsvd;
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The requested state of the LED #0. */
	uint8_t	led0_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_LAST	HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINKALT
	/* The requested color of LED #0. */
	uint8_t	led0_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_LAST	HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREENAMBER
	uint8_t	unused_0;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led0_blink_on;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led0_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #0 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	/* Reserved field. */
	uint8_t	rsvd0;
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The requested state of the LED #1. */
	uint8_t	led1_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_LAST	HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINKALT
	/* The requested color of LED #1. */
	uint8_t	led1_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_LAST	HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREENAMBER
	uint8_t	unused_1;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led1_blink_on;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led1_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #1 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #1 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	/* Reserved field. */
	uint8_t	rsvd1;
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The requested state of the LED #2. */
	uint8_t	led2_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_LAST	HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINKALT
	/* The requested color of LED #2. */
	uint8_t	led2_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_LAST	HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREENAMBER
	uint8_t	unused_2;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led2_blink_on;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led2_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #2 belongs
	 * to.
	 * If set to 0, then the LED #2 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #2 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	/* Reserved field. */
	uint8_t	rsvd2;
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The requested state of the LED #3. */
	uint8_t	led3_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_LAST	HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINKALT
	/* The requested color of LED #3. */
	uint8_t	led3_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_LAST	HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREENAMBER
	uint8_t	unused_3;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led3_blink_on;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led3_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #3 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #3 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	/* Reserved field. */
	uint8_t	rsvd3;
} hwrm_port_led_cfg_input_t, *phwrm_port_led_cfg_input_t;

/* hwrm_port_led_cfg_output (size:128b/16B) */

typedef struct hwrm_port_led_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_led_cfg_output_t, *phwrm_port_led_cfg_output_t;

/**********************
 * hwrm_port_led_qcfg *
 **********************/


/* hwrm_port_led_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_led_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port whose LED configuration is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_led_qcfg_input_t, *phwrm_port_led_qcfg_input_t;

/* hwrm_port_led_qcfg_output (size:448b/56B) */

typedef struct hwrm_port_led_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of LEDs that are configured on this port.
	 * Up to 4 LEDs can be returned in the response.
	 */
	uint8_t	num_leds;
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The type of LED #0. */
	uint8_t	led0_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_INVALID
	/* The current state of the LED #0. */
	uint8_t	led0_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINKALT
	/* The color of LED #0. */
	uint8_t	led0_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREENAMBER
	uint8_t	unused_0;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led0_blink_on;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led0_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 is not grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The type of LED #1. */
	uint8_t	led1_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_INVALID
	/* The current state of the LED #1. */
	uint8_t	led1_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINKALT
	/* The color of LED #1. */
	uint8_t	led1_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREENAMBER
	uint8_t	unused_1;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led1_blink_on;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led1_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #1 is not grouped.
	 * For all other non-zero values of this field, LED #1 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The type of LED #2. */
	uint8_t	led2_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_INVALID
	/* The current state of the LED #2. */
	uint8_t	led2_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINKALT
	/* The color of LED #2. */
	uint8_t	led2_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREENAMBER
	uint8_t	unused_2;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led2_blink_on;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led2_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #2 belongs
	 * to.
	 * If set to 0, then the LED #2 is not grouped.
	 * For all other non-zero values of this field, LED #2 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The type of LED #3. */
	uint8_t	led3_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_INVALID
	/* The current state of the LED #3. */
	uint8_t	led3_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINKALT
	/* The color of LED #3. */
	uint8_t	led3_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREENAMBER
	uint8_t	unused_3;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led3_blink_on;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led3_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #3 is not grouped.
	 * For all other non-zero values of this field, LED #3 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	uint8_t	unused_4[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_led_qcfg_output_t, *phwrm_port_led_qcfg_output_t;

/***********************
 * hwrm_port_led_qcaps *
 ***********************/


/* hwrm_port_led_qcaps_input (size:192b/24B) */

typedef struct hwrm_port_led_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port whose LED configuration is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_led_qcaps_input_t, *phwrm_port_led_qcaps_input_t;

/* hwrm_port_led_qcaps_output (size:384b/48B) */

typedef struct hwrm_port_led_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of LEDs that are configured on this port.
	 * Up to 4 LEDs can be returned in the response.
	 */
	uint8_t	num_leds;
	/* Reserved for future use. */
	uint8_t	unused[3];
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The type of LED #0. */
	uint8_t	led0_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_LAST	HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	uint8_t	unused_0;
	/* The states supported by LED #0. */
	uint16_t	led0_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_ENABLED		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_OFF_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_ON_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_BLINK_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_BLINK_ALT_SUPPORTED	UINT32_C(0x10)
	/* The colors supported by LED #0. */
	uint16_t	led0_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_RSVD		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_AMBER_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_GREEN_SUPPORTED	UINT32_C(0x4)
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The type of LED #1. */
	uint8_t	led1_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_LAST	HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	uint8_t	unused_1;
	/* The states supported by LED #1. */
	uint16_t	led1_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_ENABLED		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_OFF_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_ON_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_BLINK_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_BLINK_ALT_SUPPORTED	UINT32_C(0x10)
	/* The colors supported by LED #1. */
	uint16_t	led1_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_RSVD		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_AMBER_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_GREEN_SUPPORTED	UINT32_C(0x4)
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The type of LED #2. */
	uint8_t	led2_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_LAST	HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	uint8_t	unused_2;
	/* The states supported by LED #2. */
	uint16_t	led2_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_ENABLED		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_OFF_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_ON_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_BLINK_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_BLINK_ALT_SUPPORTED	UINT32_C(0x10)
	/* The colors supported by LED #2. */
	uint16_t	led2_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_RSVD		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_AMBER_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_GREEN_SUPPORTED	UINT32_C(0x4)
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The type of LED #3. */
	uint8_t	led3_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_LAST	HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	uint8_t	unused_3;
	/* The states supported by LED #3. */
	uint16_t	led3_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_ENABLED		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_OFF_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_ON_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_BLINK_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_BLINK_ALT_SUPPORTED	UINT32_C(0x10)
	/* The colors supported by LED #3. */
	uint16_t	led3_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_RSVD		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_AMBER_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_GREEN_SUPPORTED	UINT32_C(0x4)
	uint8_t	unused_4[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_led_qcaps_output_t, *phwrm_port_led_qcaps_output_t;

/***********************
 * hwrm_port_prbs_test *
 ***********************/


/* hwrm_port_prbs_test_input (size:384b/48B) */

typedef struct hwrm_port_prbs_test_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Host address data is to DMA'd to. */
	uint64_t	resp_data_addr;
	/*
	 * Size of the buffer pointed to by resp_data_addr. The firmware may
	 * use this entire buffer or less than the entire buffer, but never
	 * more.
	 */
	uint16_t	data_len;
	uint16_t	flags;
	/*
	 * If set, the port_id field should be interpreted as an internal
	 * port. The internal port id range is returned in port_phy_qcaps
	 * response internal_port_cnt field.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_FLAGS_INTERNAL	UINT32_C(0x1)
	uint32_t	unused_1;
	/* Port ID of port where PRBS test to be run. */
	uint16_t	port_id;
	/* Polynomial selection for PRBS test. */
	uint16_t	poly;
	/* PRBS7 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS7   UINT32_C(0x0)
	/* PRBS9 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS9   UINT32_C(0x1)
	/* PRBS11 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS11  UINT32_C(0x2)
	/* PRBS15 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS15  UINT32_C(0x3)
	/* PRBS23 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS23  UINT32_C(0x4)
	/* PRBS31 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS31  UINT32_C(0x5)
	/* PRBS58 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS58  UINT32_C(0x6)
	/* PRBS49 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS49  UINT32_C(0x7)
	/* PRBS10 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS10  UINT32_C(0x8)
	/* PRBS20 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS20  UINT32_C(0x9)
	/* PRBS13 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS13  UINT32_C(0xa)
	/* Invalid */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_INVALID UINT32_C(0xff)
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_LAST   HWRM_PORT_PRBS_TEST_INPUT_POLY_INVALID
	/*
	 * Configuration bits for PRBS test.
	 * Use enable bit to start/stop test.
	 * Use tx/rx lane map bits to run test on specific lanes,
	 * if set to 0 test will be run on all lanes.
	 */
	uint16_t	prbs_config;
	/*
	 * Set 0 to stop test currently in progress
	 * Set 1 to start test with configuration provided.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_START_STOP		UINT32_C(0x1)
	/*
	 * If set to 1, tx_lane_map bitmap should have lane bits set.
	 * If set to 0, test will be run on all lanes for this port.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_TX_LANE_MAP_VALID	UINT32_C(0x2)
	/*
	 * If set to 1, rx_lane_map bitmap should have lane bits set.
	 * If set to 0, test will be run on all lanes for this port.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_RX_LANE_MAP_VALID	UINT32_C(0x4)
	/* If set to 1, FEC stat t-code 0-7 registers are enabled. */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_FEC_STAT_T0_T7	UINT32_C(0x8)
	/*
	 * If set to 1, FEC stat t-code 8-15 registers are enabled.
	 * If fec_stat_t0_t7 is set, fec_stat_t8_t15 field will be ignored.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_FEC_STAT_T8_T15	UINT32_C(0x10)
	/* If set, prbs test will run t-code project as well. */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_T_CODE		UINT32_C(0x20)
	/* Duration in seconds to run the PRBS test. */
	uint16_t	timeout;
	/*
	 * If tx_lane_map_valid is set to 1, this field is a bitmap
	 * of tx lanes to run PRBS test. bit0 = lane0,
	 * bit1 = lane1 ..bit31 = lane31
	 */
	uint32_t	tx_lane_map;
	/*
	 * If rx_lane_map_valid is set to 1, this field is a bitmap
	 * of rx lanes to run PRBS test. bit0 = lane0,
	 * bit1 = lane1 ..bit31 = lane31
	 */
	uint32_t	rx_lane_map;
} hwrm_port_prbs_test_input_t, *phwrm_port_prbs_test_input_t;

/* hwrm_port_prbs_test_output (size:128b/16B) */

typedef struct hwrm_port_prbs_test_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of stored data. */
	uint16_t	total_data_len;
	/* This field is used in Output records to indicate the output format */
	uint8_t	ber_format;
	/* BER_FORMAT_PRBS */
	#define HWRM_PORT_PRBS_TEST_OUTPUT_BER_FORMAT_PRBS UINT32_C(0x0)
	/* BER_FORMAT_FEC */
	#define HWRM_PORT_PRBS_TEST_OUTPUT_BER_FORMAT_FEC  UINT32_C(0x1)
	#define HWRM_PORT_PRBS_TEST_OUTPUT_BER_FORMAT_LAST HWRM_PORT_PRBS_TEST_OUTPUT_BER_FORMAT_FEC
	uint8_t	unused_0;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_prbs_test_output_t, *phwrm_port_prbs_test_output_t;

/**********************
 * hwrm_port_dsc_dump *
 **********************/


/* hwrm_port_dsc_dump_input (size:320b/40B) */

typedef struct hwrm_port_dsc_dump_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Host address where response diagnostic data is returned. */
	uint64_t	resp_data_addr;
	/*
	 * Size of the host buffer pointed to by resp_data_addr. The firmware
	 * may use this entire buffer or less than the entire buffer, but
	 * never more.
	 */
	uint16_t	data_len;
	uint16_t	unused_0;
	/*
	 * Ignored by the start command.
	 * In legacy buffer mode, this is ignored. The transfer starts
	 * at buffer offset zero and must be transferred in one command.
	 * In big buffer mode, this is the offset into the NIC buffer for
	 * the current retrieve command to start.
	 */
	uint32_t	data_offset;
	/* Port ID of port where dsc dump to be collected. */
	uint16_t	port_id;
	/* Diag level specified by the user */
	uint16_t	diag_level;
	/* SRDS_DIAG_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_LANE	UINT32_C(0x0)
	/* SRDS_DIAG_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_CORE	UINT32_C(0x1)
	/* SRDS_DIAG_EVENT */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EVENT	UINT32_C(0x2)
	/* SRDS_DIAG_EYE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EYE	UINT32_C(0x3)
	/* SRDS_DIAG_REG_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_REG_CORE   UINT32_C(0x4)
	/* SRDS_DIAG_REG_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_REG_LANE   UINT32_C(0x5)
	/* SRDS_DIAG_UC_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_UC_CORE	UINT32_C(0x6)
	/* SRDS_DIAG_UC_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_UC_LANE	UINT32_C(0x7)
	/* SRDS_DIAG_LANE_DEBUG */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_LANE_DEBUG UINT32_C(0x8)
	/* SRDS_DIAG_BER_VERT */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_BER_VERT   UINT32_C(0x9)
	/* SRDS_DIAG_BER_HORZ */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_BER_HORZ   UINT32_C(0xa)
	/* SRDS_DIAG_EVENT_SAFE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EVENT_SAFE UINT32_C(0xb)
	/* SRDS_DIAG_TIMESTAMP */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_TIMESTAMP  UINT32_C(0xc)
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_LAST		HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_TIMESTAMP
	/*
	 * This field is the lane number on which to collect the dsc dump.
	 * If this is 0xFFFF, the dsc dump will be collected for all lanes,
	 * if the hardware and firmware support this feature.
	 */
	uint16_t	lane_number;
	/* Configuration bits. */
	uint16_t	dsc_dump_config;
	/*
	 * Set 0 to retrieve the dsc dump
	 * Set 1 to start the dsc dump
	 * Some configuration parameter for the dscdump report are
	 * set by the start request, and can not be modified until the
	 * retrieve operation is complete, on the next start.
	 */
	#define HWRM_PORT_DSC_DUMP_INPUT_DSC_DUMP_CONFIG_START_RETRIEVE	UINT32_C(0x1)
	/*
	 * Set 0 to limit the report size to 65535 bytes.
	 * Set 1 to allow a larger buffer size.
	 * This can only be set 1 in the start operation.
	 * If this is set 0 in the start operation, the firmware will
	 * assume it needs to only expose up to 65535 bytes of the report,
	 * and only allow a single retrieve operation to retrieve the
	 * entire report. This mode will truncate longer reports.
	 * If this is set 1 in the start operation, the firmware will
	 * report the full size of the report (up to the firmware's limit),
	 * permit retrieve operations to hold the buffer using the config
	 * defer_close, and honour the data_offset value so later data
	 * in the report can be retrieved.
	 */
	#define HWRM_PORT_DSC_DUMP_INPUT_DSC_DUMP_CONFIG_BIG_BUFFER	UINT32_C(0x2)
	/*
	 * Set 0 on the last 'retrieve' to release the firmware buffer
	 * Set 1 on the other 'retrieve' to hold the firmware buffer
	 * This only affects retrieve operations.
	 * In big_buffer mode, this allows the driver or tool to tell
	 * the firmware to keep the report around, as it intends to read
	 * more of it in. The final read must set this to zero, to tell
	 * the firmware the report buffer can be released.
	 * This only works if the start request specified big_buffer as
	 * one; it is ignored otherwise.
	 */
	#define HWRM_PORT_DSC_DUMP_INPUT_DSC_DUMP_CONFIG_DEFER_CLOSE	UINT32_C(0x4)
} hwrm_port_dsc_dump_input_t, *phwrm_port_dsc_dump_input_t;

/* hwrm_port_dsc_dump_output (size:128b/16B) */

typedef struct hwrm_port_dsc_dump_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Total length of stored data; if big_buffer is one, this
	 * only contains the lower 16 bits of the total length.
	 * In legacy buffer mode, this is zero in the 'start' response.
	 * In big buffer mode, this has the size of the report even
	 * in the 'start' response.
	 * In both modes, this contains the number of bytes written
	 * to the host in 'retrieve' responses.
	 */
	uint16_t	total_data_len;
	/*
	 * The upper 16 bits of the total length of stored data.
	 * In legacy buffer mode, this will always be zero.
	 * In big buffer mode, this will be populated even in the
	 * 'start' response.
	 * This is always zero for 'retrieve' responses.
	 */
	uint16_t	total_data_len_high;
	uint8_t	unused_1[2];
	/* Result information bits. */
	uint8_t	flags;
	/*
	 * Set according to the start request's input big_buffer.
	 * If this is zero, it indicates the function is acting per
	 * legacy behaviour -- it will report a buffer size up to almost
	 * 64KiB, and allow only one retrieval request before releasing
	 * the firmware buffer containing the report (total_data_len_high
	 * will be zero). The request's data_offset field and defer_close
	 * and use_offset config flags are ignored.
	 * If this is one, it indicates support for (and request of)
	 * support for larger reports. The full 32b report size (up to the
	 * firmware buffer limit) is provided by the start response in
	 * total_data_len (low 16b) and total_data_len_high (high 16b),
	 * and retrieve requests may keep the buffer using the defer_close
	 * flag, and retrieve the later parts of the report using the
	 * data_offset field.
	 */
	#define HWRM_PORT_DSC_DUMP_OUTPUT_FLAGS_BIG_BUFFER	UINT32_C(0x1)
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_dsc_dump_output_t, *phwrm_port_dsc_dump_output_t;

/******************************
 * hwrm_port_sfp_sideband_cfg *
 ******************************/


/* hwrm_port_sfp_sideband_cfg_input (size:256b/32B) */

typedef struct hwrm_port_sfp_sideband_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
	/*
	 * This bitfield is used to specify which bits from the 'flags'
	 * fields are being configured by the caller.
	 */
	uint32_t	enables;
	/* This bit must be '1' for rs0 to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RS0	UINT32_C(0x1)
	/* This bit must be '1' for rs1 to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RS1	UINT32_C(0x2)
	/* This bit must be '1' for tx_disable to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_TX_DIS	UINT32_C(0x4)
	/*
	 * This bit must be '1' for mod_sel to be configured.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_MOD_SEL	UINT32_C(0x8)
	/* This bit must be '1' for reset_l to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RESET_L	UINT32_C(0x10)
	/* This bit must be '1' for lp_mode to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_LP_MODE	UINT32_C(0x20)
	/* This bit must be '1' for pwr_disable to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_PWR_DIS	UINT32_C(0x40)
	/*
	 * Only bits that have corresponding bits in the 'enables'
	 * bitfield are processed by the firmware, all other bits
	 * of 'flags' are ignored.
	 */
	uint32_t	flags;
	/*
	 * This bit along with rs1 configures the current speed of the dual
	 * rate module. If these pins are GNDed then the speed can be changed
	 * by directly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RS0	UINT32_C(0x1)
	/*
	 * This bit along with rs0 configures the current speed of the dual
	 * rate module. If these pins are GNDed then the speed can be changed
	 * by directly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RS1	UINT32_C(0x2)
	/*
	 * When this bit is set to '1', tx_disable is set.
	 * On a 1G BASE-T module, if this bit is set,
	 * module PHY registers will not be accessible.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_TX_DIS	UINT32_C(0x4)
	/*
	 * When this bit is set to '1', this module is selected.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_MOD_SEL	UINT32_C(0x8)
	/*
	 * If reset_l is set to 0, Module will be taken out of reset
	 * and other signals will be set to their requested state once
	 * the module is out of reset.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RESET_L	UINT32_C(0x10)
	/*
	 * When this bit is set to '1', the module will be configured
	 * in low power mode.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_LP_MODE	UINT32_C(0x20)
	/* When this bit is set to '1', the module will be powered down. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_PWR_DIS	UINT32_C(0x40)
} hwrm_port_sfp_sideband_cfg_input_t, *phwrm_port_sfp_sideband_cfg_input_t;

/* hwrm_port_sfp_sideband_cfg_output (size:128b/16B) */

typedef struct hwrm_port_sfp_sideband_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_sfp_sideband_cfg_output_t, *phwrm_port_sfp_sideband_cfg_output_t;

/*******************************
 * hwrm_port_sfp_sideband_qcfg *
 *******************************/


/* hwrm_port_sfp_sideband_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_sfp_sideband_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_sfp_sideband_qcfg_input_t, *phwrm_port_sfp_sideband_qcfg_input_t;

/* hwrm_port_sfp_sideband_qcfg_output (size:192b/24B) */

typedef struct hwrm_port_sfp_sideband_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bitmask indicating which sideband signals are valid.
	 * This is based on the board and nvm cfg that is present on the board.
	 */
	uint32_t	supported_mask;
	uint32_t	sideband_signals;
	/* When this bit is set to '1', the Module is absent. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_MOD_ABS	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', there is no valid signal on RX.
	 * This signal is a filtered version of Signal Detect.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RX_LOS	UINT32_C(0x2)
	/*
	 * This bit along with rs1 indicates the current speed of the dual
	 * rate module.If these pins are grounded then the speed can be
	 * changed by directly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RS0	UINT32_C(0x4)
	/*
	 * This bit along with rs0 indicates the current speed of the dual
	 * rate module.If these pins are grounded then the speed can be
	 * changed by directly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RS1	UINT32_C(0x8)
	/*
	 * When this bit is set to '1', tx_disable is set.
	 * On a 1G BASE-T module, if this bit is set, module PHY
	 * registers will not be accessible.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_TX_DIS	UINT32_C(0x10)
	/* When this bit is set to '1', tx_fault is set. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_TX_FAULT	UINT32_C(0x20)
	/*
	 * When this bit is set to '1', module is selected.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_MOD_SEL	UINT32_C(0x40)
	/*
	 * When this bit is set to '0', the module is held in reset.
	 * if reset_l is set to 1,first module is taken out of reset
	 * and other signals will be set to their requested state.
	 * Valid only on QSFP modules.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RESET_L	UINT32_C(0x80)
	/*
	 * When this bit is set to '1', the module is in low power mode.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_LP_MODE	UINT32_C(0x100)
	/* When this bit is set to '1', module is in power down state. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_PWR_DIS	UINT32_C(0x200)
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_sfp_sideband_qcfg_output_t, *phwrm_port_sfp_sideband_qcfg_output_t;

/**********************************
 * hwrm_port_phy_mdio_bus_acquire *
 **********************************/


/* hwrm_port_phy_mdio_bus_acquire_input (size:192b/24B) */

typedef struct hwrm_port_phy_mdio_bus_acquire_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of the port. */
	uint16_t	port_id;
	/*
	 * client_id of the client requesting BUS access.
	 * Any value from 0x10 to 0xFFFF can be used.
	 * Client should make sure that the returned client_id
	 * in response matches the client_id in request.
	 * 0-0xF are reserved for internal use.
	 */
	uint16_t	client_id;
	/*
	 * Timeout in milliseconds, MDIO BUS will be released automatically
	 * after this time, if another mdio acquire command is not received
	 * within the timeout window from the same client.
	 * A 0xFFFF will hold the bus until this bus is released.
	 */
	uint16_t	mdio_bus_timeout;
	uint8_t	unused_0[2];
} hwrm_port_phy_mdio_bus_acquire_input_t, *phwrm_port_phy_mdio_bus_acquire_input_t;

/* hwrm_port_phy_mdio_bus_acquire_output (size:128b/16B) */

typedef struct hwrm_port_phy_mdio_bus_acquire_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	unused_0;
	/*
	 * client_id of the module holding the BUS.
	 * 0-0xF are reserved for internal use.
	 */
	uint16_t	client_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_mdio_bus_acquire_output_t, *phwrm_port_phy_mdio_bus_acquire_output_t;

/**********************************
 * hwrm_port_phy_mdio_bus_release *
 **********************************/


/* hwrm_port_phy_mdio_bus_release_input (size:192b/24B) */

typedef struct hwrm_port_phy_mdio_bus_release_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of the port. */
	uint16_t	port_id;
	/*
	 * client_id of the client requesting BUS release.
	 * A client should not release any other clients BUS.
	 */
	uint16_t	client_id;
	uint8_t	unused_0[4];
} hwrm_port_phy_mdio_bus_release_input_t, *phwrm_port_phy_mdio_bus_release_input_t;

/* hwrm_port_phy_mdio_bus_release_output (size:128b/16B) */

typedef struct hwrm_port_phy_mdio_bus_release_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	unused_0;
	/* The BUS is released if client_id matches the client_id in request. */
	uint16_t	clients_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_mdio_bus_release_output_t, *phwrm_port_phy_mdio_bus_release_output_t;

/************************
 * hwrm_port_tx_fir_cfg *
 ************************/


/* hwrm_port_tx_fir_cfg_input (size:320b/40B) */

typedef struct hwrm_port_tx_fir_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Modulation types of TX FIR: NRZ, PAM4. */
	uint8_t	mod_type;
	/* For NRZ */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_NRZ	UINT32_C(0x0)
	/* For PAM4 */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_PAM4	UINT32_C(0x1)
	/* For Optical NRZ */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_C2M_NRZ	UINT32_C(0x2)
	/* For Optical PAM4 */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_C2M_PAM4	UINT32_C(0x3)
	/* For DAC PAM4 112G */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_PAM4_112	UINT32_C(0x4)
	/* For Optical PAM4 112G */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_C2M_PAM4_112G UINT32_C(0x5)
	/* For LPO PAM4 112G */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_LPO_PAM4_112G UINT32_C(0x6)
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_LAST	HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_LPO_PAM4_112G
	/* The lane mask of the lane TX FIR will be configured. */
	uint8_t	lane_mask;
	uint8_t	unused_0[2];
	/* Value1 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_1;
	/* Value2 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_2;
	/* Value3 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_3;
	/* Value4 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_4;
	uint8_t	unused_1[4];
} hwrm_port_tx_fir_cfg_input_t, *phwrm_port_tx_fir_cfg_input_t;

/* hwrm_port_tx_fir_cfg_output (size:128b/16B) */

typedef struct hwrm_port_tx_fir_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_tx_fir_cfg_output_t, *phwrm_port_tx_fir_cfg_output_t;

/*************************
 * hwrm_port_tx_fir_qcfg *
 *************************/


/* hwrm_port_tx_fir_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_tx_fir_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Modulation types of TX FIR: NRZ, PAM4. */
	uint8_t	mod_type;
	/* For NRZ */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_NRZ	UINT32_C(0x0)
	/* For PAM4 56G */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_PAM4	UINT32_C(0x1)
	/* For Optical NRZ */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_C2M_NRZ	UINT32_C(0x2)
	/* For Optical PAM4 56G */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_C2M_PAM4	UINT32_C(0x3)
	/* For DAC PAM4 112G */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_PAM4_112	UINT32_C(0x4)
	/* For Optical PAM4 112G */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_C2M_PAM4_112 UINT32_C(0x5)
	/* For LPO PAM4 112G */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_LPO_PAM4_112 UINT32_C(0x6)
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_LAST	HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_LPO_PAM4_112
	/* The ID of the lane TX FIR will be queried. */
	uint8_t	lane_id;
	uint8_t	unused[6];
} hwrm_port_tx_fir_qcfg_input_t, *phwrm_port_tx_fir_qcfg_input_t;

/* hwrm_port_tx_fir_qcfg_output (size:256b/32B) */

typedef struct hwrm_port_tx_fir_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Value1 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_1;
	/* Value2 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_2;
	/* Value3 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_3;
	/* Value4 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_4;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_tx_fir_qcfg_output_t, *phwrm_port_tx_fir_qcfg_output_t;

/***********************
 * hwrm_port_ep_tx_cfg *
 ***********************/


/* hwrm_port_ep_tx_cfg_input (size:256b/32B) */

typedef struct hwrm_port_ep_tx_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/* When this bit is '1', the value in the ep0_min_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP0_MIN_BW	UINT32_C(0x1)
	/* When this bit is '1', the value in the ep0_max_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP0_MAX_BW	UINT32_C(0x2)
	/* When this bit is '1', the value in the ep1_min_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP1_MIN_BW	UINT32_C(0x4)
	/* When this bit is '1', the value in the ep1_max_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP1_MAX_BW	UINT32_C(0x8)
	/* When this bit is '1', the value in the ep2_min_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP2_MIN_BW	UINT32_C(0x10)
	/* When this bit is '1', the value in the ep2_max_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP2_MAX_BW	UINT32_C(0x20)
	/* When this bit is '1', the value in the ep3_min_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP3_MIN_BW	UINT32_C(0x40)
	/* When this bit is '1', the value in the ep3_max_bw field is valid. */
	#define HWRM_PORT_EP_TX_CFG_INPUT_ENABLES_EP3_MAX_BW	UINT32_C(0x80)
	/* A port index, from 0 to the number of front panel ports, minus 1. */
	uint8_t	port_id;
	uint8_t	unused;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 0 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep0_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 0 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep0_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 1 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep1_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 1 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep1_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 2 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep2_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 2 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep2_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 3 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep3_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 3 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep3_max_bw;
	uint8_t	unused_1[4];
} hwrm_port_ep_tx_cfg_input_t, *phwrm_port_ep_tx_cfg_input_t;

/* hwrm_port_ep_tx_cfg_output (size:128b/16B) */

typedef struct hwrm_port_ep_tx_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_port_ep_tx_cfg_output_t, *phwrm_port_ep_tx_cfg_output_t;

/* hwrm_port_ep_tx_cfg_cmd_err (size:64b/8B) */

typedef struct hwrm_port_ep_tx_cfg_cmd_err {
	/*
	 * command specific error codes for the cmd_err field in
	 * hwrm_err_output
	 */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_UNKNOWN		UINT32_C(0x0)
	/* The port ID is invalid */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_PORT_ID_INVALID	UINT32_C(0x1)
	/* One of the PCIe endpoints configured is not active. */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_EP_INACTIVE	UINT32_C(0x2)
	/* A minimum bandwidth is out of range. */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_BW_RANGE	UINT32_C(0x3)
	/*
	 * One endpoint's minimum bandwidth is more than its maximum
	 * bandwidth.
	 */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_MORE_THAN_MAX  UINT32_C(0x4)
	/* The sum of the minimum bandwidths on the port is more than 100%. */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_BW_SUM	UINT32_C(0x5)
	/*
	 * The NIC does not support enforcement of a minimum guaranteed
	 * bandwidth for an endpoint.
	 */
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_BW_UNSUPPORTED UINT32_C(0x6)
	#define HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_LAST		HWRM_PORT_EP_TX_CFG_CMD_ERR_CODE_MIN_BW_UNSUPPORTED
	uint8_t	unused_0[7];
} hwrm_port_ep_tx_cfg_cmd_err_t, *phwrm_port_ep_tx_cfg_cmd_err_t;

/************************
 * hwrm_port_ep_tx_qcfg *
 ************************/


/* hwrm_port_ep_tx_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_ep_tx_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The port whose endpoint rate limits are queried. */
	uint8_t	port_id;
	uint8_t	unused[7];
} hwrm_port_ep_tx_qcfg_input_t, *phwrm_port_ep_tx_qcfg_input_t;

/* hwrm_port_ep_tx_qcfg_output (size:192b/24B) */

typedef struct hwrm_port_ep_tx_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 0 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep0_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 0 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep0_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 1 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep1_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 1 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep1_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 2 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep2_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 2 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep2_max_bw;
	/*
	 * Specifies a minimum guaranteed bandwidth, as a percentage of the
	 * port bandwidth, for the set of PFs and VFs on PCIe endpoint 3 for
	 * the specified port. The range is 0 to 100. A value of 0 indicates no
	 * minimum rate. The endpoint's min_bw must be less than or equal to
	 * max_bw. The sum of all configured minimum bandwidths for a port must
	 * be less than or equal to 100.
	 */
	uint8_t	ep3_min_bw;
	/*
	 * Specifies the maximum portion of the port's bandwidth that the set
	 * of PFs and VFs on PCIe endpoint 3 may use. The value is a percentage
	 * of the link bandwidth, from 0 to 100. A value of 0 indicates no
	 * maximum rate.
	 */
	uint8_t	ep3_max_bw;
	uint8_t	unused_0[7];
	/*
	 * This field is used in output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_port_ep_tx_qcfg_output_t, *phwrm_port_ep_tx_qcfg_output_t;

/*****************
 * hwrm_port_cfg *
 *****************/


/* hwrm_port_cfg_input (size:256b/32B) */

typedef struct hwrm_port_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the tx_rate_limit field to
	 * be configured.
	 */
	#define HWRM_PORT_CFG_INPUT_ENABLES_TX_RATE_LIMIT	UINT32_C(0x1)
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	uint16_t	unused_0;
	/*
	 * Requested setting of TX rate limit in Mbps.
	 * tx_rate_limit = 0 will cancel the rate limit if any.
	 * This field is valid only when tx_rate_limit bit in 'enables'
	 * field is '1'.
	 */
	uint32_t	tx_rate_limit;
} hwrm_port_cfg_input_t, *phwrm_port_cfg_input_t;

/* hwrm_port_cfg_output (size:128b/16B) */

typedef struct hwrm_port_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_cfg_output_t, *phwrm_port_cfg_output_t;

/******************
 * hwrm_port_qcfg *
 ******************/


/* hwrm_port_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_qcfg_input_t, *phwrm_port_qcfg_input_t;

/* hwrm_port_qcfg_output (size:192b/24B) */

typedef struct hwrm_port_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	supported;
	/*
	 * If set to '1', then this bit indicates that TX rate limit
	 * could be configured via hwrm_port_cfg command.
	 */
	#define HWRM_PORT_QCFG_OUTPUT_SUPPORTED_TX_RATE_LIMIT	UINT32_C(0x1)
	uint32_t	enabled;
	/*
	 * If set to '1', then this bit indicates that TX rate limit
	 * is enabled and could be found in tx_rate_limit field.
	 */
	#define HWRM_PORT_QCFG_OUTPUT_ENABLED_TX_RATE_LIMIT	UINT32_C(0x1)
	/*
	 * Current setting of TX rate limit in Mbps.
	 * This field is valid only when tx_rate_limit bit in 'enabled'
	 * field is '1'.
	 */
	uint32_t	tx_rate_limit;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_qcfg_output_t, *phwrm_port_qcfg_output_t;

/***********************
 * hwrm_port_mac_qcaps *
 ***********************/


/* hwrm_port_mac_qcaps_input (size:192b/24B) */

typedef struct hwrm_port_mac_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_mac_qcaps_input_t, *phwrm_port_mac_qcaps_input_t;

/* hwrm_port_mac_qcaps_output (size:128b/16B) */

typedef struct hwrm_port_mac_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* MAC capability flags */
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates that the
	 * MAC does not support local loopback.
	 */
	#define HWRM_PORT_MAC_QCAPS_OUTPUT_FLAGS_LOCAL_LPBK_NOT_SUPPORTED	UINT32_C(0x1)
	/*
	 * If set to 1, then this field indicates that the
	 * MAC is capable of supporting remote loopback.
	 */
	#define HWRM_PORT_MAC_QCAPS_OUTPUT_FLAGS_REMOTE_LPBK_SUPPORTED	UINT32_C(0x2)
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_mac_qcaps_output_t, *phwrm_port_mac_qcaps_output_t;

/*********************
 * hwrm_port_poe_cfg *
 *********************/


/* hwrm_port_poe_cfg_input (size:192b/24B) */

typedef struct hwrm_port_poe_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Expander port index for which PoE has to be enabled/disabled */
	uint8_t	exp_port_idx;
	/* PoE enable/disable flag */
	uint8_t	flags;
	/* This field indicates that the PoE has to be enabled. */
	#define HWRM_PORT_POE_CFG_INPUT_FLAGS_ENABLE_POE	UINT32_C(0x1)
	uint8_t	unused_0[6];
} hwrm_port_poe_cfg_input_t, *phwrm_port_poe_cfg_input_t;

/* hwrm_port_poe_cfg_output (size:128b/16B) */

typedef struct hwrm_port_poe_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_poe_cfg_output_t, *phwrm_port_poe_cfg_output_t;

/**********************
 * hwrm_port_poe_qcfg *
 **********************/


/* hwrm_port_poe_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_poe_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Expander port which is queried */
	uint8_t	exp_port_idx;
	uint8_t	unused_0[7];
} hwrm_port_poe_qcfg_input_t, *phwrm_port_poe_qcfg_input_t;

/* hwrm_port_poe_qcfg_output (size:128b/16B) */

typedef struct hwrm_port_poe_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This field indicates if the PoE is enabled/disabled */
	uint8_t	status;
	/* This field indicates that the PoE is enabled. */
	#define HWRM_PORT_POE_QCFG_OUTPUT_STATUS_POE_ENABLED	UINT32_C(0x1)
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_poe_qcfg_output_t, *phwrm_port_poe_qcfg_output_t;

/***********************
 * hwrm_queue_qportcfg *
 ***********************/


/* hwrm_queue_qportcfg_input (size:192b/24B) */

typedef struct hwrm_queue_qportcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_LAST HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_RX
	/*
	 * Port ID of port for which the queue configuration is being
	 * queried. This field is only required when sent by IPC.
	 */
	uint16_t	port_id;
	/*
	 * Drivers will set this capability when it can use
	 * queue_idx_service_profile to map the queues to application.
	 */
	uint8_t	drv_qmap_cap;
	/* disabled */
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_DISABLED UINT32_C(0x0)
	/* enabled */
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_ENABLED  UINT32_C(0x1)
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_LAST	HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_ENABLED
	uint8_t	unused_0;
} hwrm_queue_qportcfg_input_t, *phwrm_queue_qportcfg_input_t;

/* hwrm_queue_qportcfg_output (size:1344b/168B) */

typedef struct hwrm_queue_qportcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The maximum number of queues that can be configured on this
	 * port.
	 * Valid values range from 1 through 8.
	 */
	uint8_t	max_configurable_queues;
	/*
	 * The maximum number of lossless queues that can be configured
	 * on this port.
	 * Valid values range from 0 through 8.
	 */
	uint8_t	max_configurable_lossless_queues;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_cfg command shall return error when trying to
	 * configure a queue not configurable.
	 */
	uint8_t	queue_cfg_allowed;
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the queues are
	 * configured asymmetrically on TX and RX sides.
	 * If this flag is set to '0', then the queues are
	 * configured symmetrically on TX and RX sides. For
	 * symmetric configuration, the queue configuration
	 * including queue ids and service profiles on the
	 * TX side is the same as the corresponding queue
	 * configuration on the RX side.
	 */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG		UINT32_C(0x1)
	/*
	 * If this flag is set to '1', then service_profile will carry
	 * either lossy/lossless type and the new service_profile_type
	 * field will be used to determine if the queue is for L2/ROCE/CNP.
	 */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_CFG_INFO_USE_PROFILE_TYPE	UINT32_C(0x2)
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pfcenable_cfg command.
	 *
	 * Each bit represents a specific priority where bit 0 represents
	 * priority 0 and bit 7 represents priority 7.
	 * # A value of 0 indicates that the priority is not configurable by
	 * the hwrm_queue_pfcenable_cfg command.
	 * # A value of 1 indicates that the priority is configurable.
	 * # A hwrm_queue_pfcenable_cfg command shall return error when
	 * trying to configure a priority that is not configurable.
	 */
	uint8_t	queue_pfcenable_cfg_allowed;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pri2cos_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_pri2cos_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_pri2cos_cfg command shall return error when
	 * trying to configure a queue that is not configurable.
	 */
	uint8_t	queue_pri2cos_cfg_allowed;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pri2cos_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_pri2cos_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_pri2cos_cfg command shall return error when
	 * trying to configure a queue not configurable.
	 */
	uint8_t	queue_cos2bw_cfg_allowed;
	/*
	 * ID of CoS Queue 0.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id0;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id0_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 1.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id1;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id1_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 2.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id2;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id2_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 3.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id3;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id3_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 4.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id4;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id4_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 5.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id5;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id5_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 6.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id6;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id6_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 7.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id7;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id7_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_UNKNOWN
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id0_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * Up to 16 bytes of null padded ASCII string describing this queue.
	 * The queue name includes a CoS queue index and, in some cases, text
	 * that distinguishes the queue from other queues in the group.
	 */
	char	qid0_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid1_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid2_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid3_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid4_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid5_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid6_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid7_name[16];
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id1_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id2_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id3_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id4_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id5_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id6_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id7_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_qportcfg_output_t, *phwrm_queue_qportcfg_output_t;

/*******************
 * hwrm_queue_qcfg *
 *******************/


/* hwrm_queue_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_LAST HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_RX
	/* Queue ID of the queue. */
	uint32_t	queue_id;
} hwrm_queue_qcfg_input_t, *phwrm_queue_qcfg_input_t;

/* hwrm_queue_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value is the estimate packet length used in the
	 * TX arbiter.
	 */
	uint32_t	queue_len;
	/* This value is applicable to CoS queues only. */
	uint8_t	service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LOSSLESS UINT32_C(0x1)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_UNKNOWN  UINT32_C(0xff)
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LAST	HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_UNKNOWN
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the queue is
	 * configured asymmetrically on TX and RX sides.
	 * If this flag is set to '0', then this queue is
	 * configured symmetrically on TX and RX sides.
	 */
	#define HWRM_QUEUE_QCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG	UINT32_C(0x1)
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_qcfg_output_t, *phwrm_queue_qcfg_output_t;

/******************
 * hwrm_queue_cfg *
 ******************/


/* hwrm_queue_cfg_input (size:320b/40B) */

typedef struct hwrm_queue_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX, or both directions applicable to
	 * the resource. This enumeration is used for resources that are
	 * similar for both TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_MASK UINT32_C(0x3)
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_SFT  0
	/* tx path */
		#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
	/* Bi-directional (Symmetrically applicable to TX and RX paths) */
		#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_BIDIR  UINT32_C(0x2)
		#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_LAST  HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_BIDIR
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dflt_len field to be
	 * configured.
	 */
	#define HWRM_QUEUE_CFG_INPUT_ENABLES_DFLT_LEN		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the service_profile field to be
	 * configured.
	 */
	#define HWRM_QUEUE_CFG_INPUT_ENABLES_SERVICE_PROFILE	UINT32_C(0x2)
	/* Queue ID of queue that is to be configured by this function. */
	uint32_t	queue_id;
	/*
	 * This value is a the estimate packet length used in the
	 * TX arbiter.
	 * Set to 0xFF... (All Fs) to not adjust this value.
	 */
	uint32_t	dflt_len;
	/* This value is applicable to CoS queues only. */
	uint8_t	service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LOSSLESS UINT32_C(0x1)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_UNKNOWN  UINT32_C(0xff)
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LAST	HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_UNKNOWN
	uint8_t	unused_0[7];
} hwrm_queue_cfg_input_t, *phwrm_queue_cfg_input_t;

/* hwrm_queue_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_cfg_output_t, *phwrm_queue_cfg_output_t;

/*****************************
 * hwrm_queue_pfcenable_qcfg *
 *****************************/


/* hwrm_queue_pfcenable_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_pfcenable_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_queue_pfcenable_qcfg_input_t, *phwrm_queue_pfcenable_qcfg_input_t;

/* hwrm_queue_pfcenable_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_pfcenable_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* If set to 1, then PFC is enabled on PRI 0. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI0_PFC_ENABLED		UINT32_C(0x1)
	/* If set to 1, then PFC is enabled on PRI 1. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI1_PFC_ENABLED		UINT32_C(0x2)
	/* If set to 1, then PFC is enabled on PRI 2. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI2_PFC_ENABLED		UINT32_C(0x4)
	/* If set to 1, then PFC is enabled on PRI 3. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI3_PFC_ENABLED		UINT32_C(0x8)
	/* If set to 1, then PFC is enabled on PRI 4. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI4_PFC_ENABLED		UINT32_C(0x10)
	/* If set to 1, then PFC is enabled on PRI 5. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI5_PFC_ENABLED		UINT32_C(0x20)
	/* If set to 1, then PFC is enabled on PRI 6. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI6_PFC_ENABLED		UINT32_C(0x40)
	/* If set to 1, then PFC is enabled on PRI 7. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI7_PFC_ENABLED		UINT32_C(0x80)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI0. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI0_PFC_WATCHDOG_ENABLED	UINT32_C(0x100)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI1. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI1_PFC_WATCHDOG_ENABLED	UINT32_C(0x200)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI2. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI2_PFC_WATCHDOG_ENABLED	UINT32_C(0x400)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI3. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI3_PFC_WATCHDOG_ENABLED	UINT32_C(0x800)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI4. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI4_PFC_WATCHDOG_ENABLED	UINT32_C(0x1000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI5. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI5_PFC_WATCHDOG_ENABLED	UINT32_C(0x2000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI6. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI6_PFC_WATCHDOG_ENABLED	UINT32_C(0x4000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI7. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI7_PFC_WATCHDOG_ENABLED	UINT32_C(0x8000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pfcenable_qcfg_output_t, *phwrm_queue_pfcenable_qcfg_output_t;

/****************************
 * hwrm_queue_pfcenable_cfg *
 ****************************/


/* hwrm_queue_pfcenable_cfg_input (size:192b/24B) */

typedef struct hwrm_queue_pfcenable_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If set to 1, then PFC is requested to be enabled on PRI 0. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI0_PFC_ENABLED		UINT32_C(0x1)
	/* If set to 1, then PFC is requested to be enabled on PRI 1. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI1_PFC_ENABLED		UINT32_C(0x2)
	/* If set to 1, then PFC is requested to be enabled on PRI 2. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI2_PFC_ENABLED		UINT32_C(0x4)
	/* If set to 1, then PFC is requested to be enabled on PRI 3. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI3_PFC_ENABLED		UINT32_C(0x8)
	/* If set to 1, then PFC is requested to be enabled on PRI 4. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI4_PFC_ENABLED		UINT32_C(0x10)
	/* If set to 1, then PFC is requested to be enabled on PRI 5. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI5_PFC_ENABLED		UINT32_C(0x20)
	/* If set to 1, then PFC is requested to be enabled on PRI 6. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI6_PFC_ENABLED		UINT32_C(0x40)
	/* If set to 1, then PFC is requested to be enabled on PRI 7. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI7_PFC_ENABLED		UINT32_C(0x80)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI0. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI0_PFC_WATCHDOG_ENABLED	UINT32_C(0x100)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI1. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI1_PFC_WATCHDOG_ENABLED	UINT32_C(0x200)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI2. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI2_PFC_WATCHDOG_ENABLED	UINT32_C(0x400)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI3. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI3_PFC_WATCHDOG_ENABLED	UINT32_C(0x800)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI4. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI4_PFC_WATCHDOG_ENABLED	UINT32_C(0x1000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI5. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI5_PFC_WATCHDOG_ENABLED	UINT32_C(0x2000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI6. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI6_PFC_WATCHDOG_ENABLED	UINT32_C(0x4000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI7. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI7_PFC_WATCHDOG_ENABLED	UINT32_C(0x8000)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[2];
} hwrm_queue_pfcenable_cfg_input_t, *phwrm_queue_pfcenable_cfg_input_t;

/* hwrm_queue_pfcenable_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_pfcenable_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pfcenable_cfg_output_t, *phwrm_queue_pfcenable_cfg_output_t;

/***************************
 * hwrm_queue_pri2cos_qcfg *
 ***************************/


/* hwrm_queue_pri2cos_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_pri2cos_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_LAST  HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_RX
	/*
	 * When this bit is set to '0', the query is
	 * for PRI from tunnel headers.
	 * When this bit is set to '1', the query is
	 * for PRI from inner packet headers.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_IVLAN	UINT32_C(0x2)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
} hwrm_queue_pri2cos_qcfg_input_t, *phwrm_queue_pri2cos_qcfg_input_t;

/* hwrm_queue_pri2cos_qcfg_output (size:192b/24B) */

typedef struct hwrm_queue_pri2cos_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * CoS Queue assigned to priority 0. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri0_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 1. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri1_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 2. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri2_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 3. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri3_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 4. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri4_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 5. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri5_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 6. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri6_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 7. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri7_cos_queue_id;
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the PRI to CoS
	 * configuration is asymmetric on TX and RX sides.
	 * If this flag is set to '0', then PRI to CoS configuration
	 * is symmetric on TX and RX sides.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG	UINT32_C(0x1)
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pri2cos_qcfg_output_t, *phwrm_queue_pri2cos_qcfg_output_t;

/**************************
 * hwrm_queue_pri2cos_cfg *
 **************************/


/* hwrm_queue_pri2cos_cfg_input (size:320b/40B) */

typedef struct hwrm_queue_pri2cos_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX, or both directions applicable to
	 * the resource. This enumeration is used for resources that are
	 * similar for both TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_MASK UINT32_C(0x3)
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_SFT  0
	/* tx path */
		#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
	/* Bi-directional (Symmetrically applicable to TX and RX paths) */
		#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_BIDIR  UINT32_C(0x2)
		#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_LAST  HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_BIDIR
	/*
	 * When this bit is set to '0', the mapping is requested
	 * for PRI from tunnel headers.
	 * When this bit is set to '1', the mapping is requested
	 * for PRI from inner packet headers.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_IVLAN	UINT32_C(0x4)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pri0_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI0_COS_QUEUE_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pri1_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI1_COS_QUEUE_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the pri2_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI2_COS_QUEUE_ID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the pri3_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI3_COS_QUEUE_ID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the pri4_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI4_COS_QUEUE_ID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the pri5_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI5_COS_QUEUE_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the pri6_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI6_COS_QUEUE_ID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the pri7_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI7_COS_QUEUE_ID	UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	/*
	 * CoS Queue assigned to priority 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri0_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri1_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 2. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri2_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri3_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri4_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri5_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri6_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri7_cos_queue_id;
	uint8_t	unused_0[7];
} hwrm_queue_pri2cos_cfg_input_t, *phwrm_queue_pri2cos_cfg_input_t;

/* hwrm_queue_pri2cos_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_pri2cos_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pri2cos_cfg_output_t, *phwrm_queue_pri2cos_cfg_output_t;

/**************************
 * hwrm_queue_cos2bw_qcfg *
 **************************/


/* hwrm_queue_cos2bw_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_cos2bw_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure TC BW assignment on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_queue_cos2bw_qcfg_input_t, *phwrm_queue_cos2bw_qcfg_input_t;

/* hwrm_queue_cos2bw_qcfg_output (size:896b/112B) */

typedef struct hwrm_queue_cos2bw_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* ID of CoS Queue 0. */
	uint8_t	queue_id0;
	uint8_t	unused_0;
	uint16_t	unused_1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id0_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id0_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id0_bw_weight;
	/* ID of CoS Queue 1. */
	uint8_t	queue_id1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id1_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id1_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id1_bw_weight;
	/* ID of CoS Queue 2. */
	uint8_t	queue_id2;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id2_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id2_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id2_bw_weight;
	/* ID of CoS Queue 3. */
	uint8_t	queue_id3;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id3_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id3_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id3_bw_weight;
	/* ID of CoS Queue 4. */
	uint8_t	queue_id4;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id4_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id4_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id4_bw_weight;
	/* ID of CoS Queue 5. */
	uint8_t	queue_id5;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id5_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id5_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id5_bw_weight;
	/* ID of CoS Queue 6. */
	uint8_t	queue_id6;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id6_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id6_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id6_bw_weight;
	/* ID of CoS Queue 7. */
	uint8_t	queue_id7;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id7_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id7_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id7_bw_weight;
	uint8_t	unused_2[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_cos2bw_qcfg_output_t, *phwrm_queue_cos2bw_qcfg_output_t;

/*************************
 * hwrm_queue_cos2bw_cfg *
 *************************/


/* hwrm_queue_cos2bw_cfg_input (size:1024b/128B) */

typedef struct hwrm_queue_cos2bw_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * If this bit is set to 1, then all queue_id0 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID0_VALID	UINT32_C(0x1)
	/*
	 * If this bit is set to 1, then all queue_id1 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID1_VALID	UINT32_C(0x2)
	/*
	 * If this bit is set to 1, then all queue_id2 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID2_VALID	UINT32_C(0x4)
	/*
	 * If this bit is set to 1, then all queue_id3 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID3_VALID	UINT32_C(0x8)
	/*
	 * If this bit is set to 1, then all queue_id4 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID4_VALID	UINT32_C(0x10)
	/*
	 * If this bit is set to 1, then all queue_id5 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID5_VALID	UINT32_C(0x20)
	/*
	 * If this bit is set to 1, then all queue_id6 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID6_VALID	UINT32_C(0x40)
	/*
	 * If this bit is set to 1, then all queue_id7 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID7_VALID	UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure TC BW assignment on this port.
	 */
	uint16_t	port_id;
	/* ID of CoS Queue 0. */
	uint8_t	queue_id0;
	uint8_t	unused_0;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id0_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id0_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id0_bw_weight;
	/* ID of CoS Queue 1. */
	uint8_t	queue_id1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id1_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id1_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id1_bw_weight;
	/* ID of CoS Queue 2. */
	uint8_t	queue_id2;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id2_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id2_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id2_bw_weight;
	/* ID of CoS Queue 3. */
	uint8_t	queue_id3;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id3_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id3_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id3_bw_weight;
	/* ID of CoS Queue 4. */
	uint8_t	queue_id4;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id4_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id4_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id4_bw_weight;
	/* ID of CoS Queue 5. */
	uint8_t	queue_id5;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id5_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id5_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id5_bw_weight;
	/* ID of CoS Queue 6. */
	uint8_t	queue_id6;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id6_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id6_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id6_bw_weight;
	/* ID of CoS Queue 7. */
	uint8_t	queue_id7;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id7_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id7_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id7_bw_weight;
	uint8_t	unused_1[5];
} hwrm_queue_cos2bw_cfg_input_t, *phwrm_queue_cos2bw_cfg_input_t;

/* hwrm_queue_cos2bw_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_cos2bw_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_cos2bw_cfg_output_t, *phwrm_queue_cos2bw_cfg_output_t;

/*************************
 * hwrm_queue_dscp_qcaps *
 *************************/


/* hwrm_queue_dscp_qcaps_input (size:192b/24B) */

typedef struct hwrm_queue_dscp_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_dscp_qcaps_input_t, *phwrm_queue_dscp_qcaps_input_t;

/* hwrm_queue_dscp_qcaps_output (size:128b/16B) */

typedef struct hwrm_queue_dscp_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of bits provided by the hardware for the DSCP value. */
	uint8_t	num_dscp_bits;
	uint8_t	unused_0;
	/* Max number of DSCP-MASK-PRI entries supported. */
	uint16_t	max_entries;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_dscp_qcaps_output_t, *phwrm_queue_dscp_qcaps_output_t;

/****************************
 * hwrm_queue_dscp2pri_qcfg *
 ****************************/


/* hwrm_queue_dscp2pri_qcfg_input (size:256b/32B) */

typedef struct hwrm_queue_dscp2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where the 24-bits DSCP-MASK-PRI
	 * tuple(s) will be copied to.
	 */
	uint64_t	dest_data_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0;
	/* Size of the buffer pointed to by dest_data_addr. */
	uint16_t	dest_data_buffer_size;
	uint8_t	unused_1[4];
} hwrm_queue_dscp2pri_qcfg_input_t, *phwrm_queue_dscp2pri_qcfg_input_t;

/* hwrm_queue_dscp2pri_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_dscp2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * A count of the number of DSCP-MASK-PRI tuple(s) pointed to
	 * by the dest_data_addr.
	 */
	uint16_t	entry_cnt;
	/*
	 * This is the default PRI which un-initialized DSCP values are
	 * mapped to.
	 */
	uint8_t	default_pri;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_dscp2pri_qcfg_output_t, *phwrm_queue_dscp2pri_qcfg_output_t;

/***************************
 * hwrm_queue_dscp2pri_cfg *
 ***************************/


/* hwrm_queue_dscp2pri_cfg_input (size:320b/40B) */

typedef struct hwrm_queue_dscp2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where the 24-bits DSCP-MASK-PRI tuple
	 * will be copied from. A non-zero mask "adds" a tuple, while
	 * a mask equal to 0 triggers the firmware to remove a tuple.
	 * Only tuples with unique DSCP values are stored. On chips
	 * prior to Thor a mask can be 0 - 0x3f, while on Thor it can
	 * be 0 or 0x3f.
	 */
	uint64_t	src_data_addr;
	uint32_t	flags;
	/* use_hw_default_pri is 1 b */
	#define HWRM_QUEUE_DSCP2PRI_CFG_INPUT_FLAGS_USE_HW_DEFAULT_PRI	UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the default_pri field to be
	 * configured.
	 */
	#define HWRM_QUEUE_DSCP2PRI_CFG_INPUT_ENABLES_DEFAULT_PRI	UINT32_C(0x1)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	/*
	 * This is the default PRI which un-initialized DSCP values will be
	 * mapped to.
	 */
	uint8_t	default_pri;
	/*
	 * A count of the number of DSCP-MASK-PRI tuple(s) in the data pointed
	 * to by src_data_addr.
	 */
	uint16_t	entry_cnt;
	uint8_t	unused_0[4];
} hwrm_queue_dscp2pri_cfg_input_t, *phwrm_queue_dscp2pri_cfg_input_t;

/* hwrm_queue_dscp2pri_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_dscp2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_dscp2pri_cfg_output_t, *phwrm_queue_dscp2pri_cfg_output_t;

/*************************
 * hwrm_queue_mpls_qcaps *
 *************************/


/* hwrm_queue_mpls_qcaps_input (size:192b/24B) */

typedef struct hwrm_queue_mpls_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP) to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_mpls_qcaps_input_t, *phwrm_queue_mpls_qcaps_input_t;

/* hwrm_queue_mpls_qcaps_output (size:128b/16B) */

typedef struct hwrm_queue_mpls_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_mplstc2pri_cfg command.
	 *
	 * Each bit represents a specific pri where bit 0 represents
	 * pri 0 and bit 7 represents pri 7.
	 * # A value of 0 indicates that the pri is not configurable
	 * by the hwrm_queue_mplstc2pri_cfg command.
	 * # A value of 1 indicates that the pri is configurable.
	 * # A hwrm_queue_mplstc2pri_cfg command shall return error when
	 * trying to configure a pri that is not configurable.
	 */
	uint8_t	queue_mplstc2pri_cfg_allowed;
	/*
	 * This is the default PRI which un-initialized MPLS values will be
	 * mapped to.
	 */
	uint8_t	hw_default_pri;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_mpls_qcaps_output_t, *phwrm_queue_mpls_qcaps_output_t;

/******************************
 * hwrm_queue_mplstc2pri_qcfg *
 ******************************/


/* hwrm_queue_mplstc2pri_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_mplstc2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP) to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_mplstc2pri_qcfg_input_t, *phwrm_queue_mplstc2pri_qcfg_input_t;

/* hwrm_queue_mplstc2pri_qcfg_output (size:192b/24B) */

typedef struct hwrm_queue_mplstc2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * pri assigned to MPLS TC(EXP) 0. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 0.
	 */
	uint8_t	tc0_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 1. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 1.
	 */
	uint8_t	tc1_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 2. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 2.
	 */
	uint8_t	tc2_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 3. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 3.
	 */
	uint8_t	tc3_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 4. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 4.
	 */
	uint8_t	tc4_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 5. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 5.
	 */
	uint8_t	tc5_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 6. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 6.
	 */
	uint8_t	tc6_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 7. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 7.
	 */
	uint8_t	tc7_pri_queue_id;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_mplstc2pri_qcfg_output_t, *phwrm_queue_mplstc2pri_qcfg_output_t;

/*****************************
 * hwrm_queue_mplstc2pri_cfg *
 *****************************/


/* hwrm_queue_mplstc2pri_cfg_input (size:256b/32B) */

typedef struct hwrm_queue_mplstc2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mplstc0_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC0_PRI_QUEUE_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mplstc1_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC1_PRI_QUEUE_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the mplstc2_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC2_PRI_QUEUE_ID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the mplstc3_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC3_PRI_QUEUE_ID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the mplstc4_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC4_PRI_QUEUE_ID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the mplstc5_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC5_PRI_QUEUE_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the mplstc6_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC6_PRI_QUEUE_ID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the mplstc7_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC7_PRI_QUEUE_ID	UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP)to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
	/*
	 * pri assigned to MPLS TC(EXP) 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc0_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc1_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 2. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc2_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc3_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc4_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc5_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc6_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc7_pri_queue_id;
} hwrm_queue_mplstc2pri_cfg_input_t, *phwrm_queue_mplstc2pri_cfg_input_t;

/* hwrm_queue_mplstc2pri_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_mplstc2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_mplstc2pri_cfg_output_t, *phwrm_queue_mplstc2pri_cfg_output_t;

/****************************
 * hwrm_queue_vlanpri_qcaps *
 ****************************/


/* hwrm_queue_vlanpri_qcaps_input (size:192b/24B) */

typedef struct hwrm_queue_vlanpri_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_vlanpri_qcaps_input_t, *phwrm_queue_vlanpri_qcaps_input_t;

/* hwrm_queue_vlanpri_qcaps_output (size:128b/16B) */

typedef struct hwrm_queue_vlanpri_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the default user priority which all VLAN priority values
	 * are mapped to if there is no VLAN priority to user priority mapping.
	 */
	uint8_t	hw_default_pri;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_vlanpri_qcaps_output_t, *phwrm_queue_vlanpri_qcaps_output_t;

/*******************************
 * hwrm_queue_vlanpri2pri_qcfg *
 *******************************/


/* hwrm_queue_vlanpri2pri_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_vlanpri2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_vlanpri2pri_qcfg_input_t, *phwrm_queue_vlanpri2pri_qcfg_input_t;

/* hwrm_queue_vlanpri2pri_qcfg_output (size:192b/24B) */

typedef struct hwrm_queue_vlanpri2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * User priority assigned to VLAN priority 0. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri0_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 1. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri1_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 2. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri2_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 3. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri3_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 4. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri4_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 5. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri5_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 6. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri6_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 7. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri7_user_pri_id;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_vlanpri2pri_qcfg_output_t, *phwrm_queue_vlanpri2pri_qcfg_output_t;

/******************************
 * hwrm_queue_vlanpri2pri_cfg *
 ******************************/


/* hwrm_queue_vlanpri2pri_cfg_input (size:256b/32B) */

typedef struct hwrm_queue_vlanpri2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vlanpri0_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI0_USER_PRI_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the vlanpri1_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI1_USER_PRI_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the vlanpri2_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI2_USER_PRI_ID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vlanpri3_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI3_USER_PRI_ID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the vlanpri4_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI4_USER_PRI_ID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the vlanpri5_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI5_USER_PRI_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the vlanpri6_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI6_USER_PRI_ID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the vlanpri7_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI7_USER_PRI_ID	UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
	/*
	 * User priority assigned to VLAN priority 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri0_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri1_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 2. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri2_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri3_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri4_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri5_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri6_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri7_user_pri_id;
} hwrm_queue_vlanpri2pri_cfg_input_t, *phwrm_queue_vlanpri2pri_cfg_input_t;

/* hwrm_queue_vlanpri2pri_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_vlanpri2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_vlanpri2pri_cfg_output_t, *phwrm_queue_vlanpri2pri_cfg_output_t;

/*************************
 * hwrm_queue_global_cfg *
 *************************/


/* hwrm_queue_global_cfg_input (size:192b/24B) */

typedef struct hwrm_queue_global_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Configuration mode for rx cos queues, configuring whether they
	 * use one shared buffer pool (across ports or PCIe endpoints) or
	 * independent per port or per endpoint buffer pools.
	 */
	uint8_t	mode;
	/* One shared buffer pool to be used by all RX CoS queues */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_SHARED	UINT32_C(0x0)
	/*
	 * Each port or PCIe endpoint to use an independent buffer pool
	 * for its RX CoS queues
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_INDEPENDENT UINT32_C(0x1)
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_LAST	HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_INDEPENDENT
	uint8_t	unused_0;
	uint16_t	enables;
	/* This bit must be '1' when the mode field is configured. */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_MODE	UINT32_C(0x1)
	/*
	 * This bit must be '1' when the maximum bandwidth for queue group 0
	 * (g0_max_bw) is configured.
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_G0_MAX_BW	UINT32_C(0x2)
	/*
	 * This bit must be '1' when the maximum bandwidth for queue group 1
	 * (g1_max_bw) is configured.
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_G1_MAX_BW	UINT32_C(0x4)
	/*
	 * This bit must be '1' when the maximum bandwidth for queue group 2
	 * (g2_max_bw) is configured.
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_G2_MAX_BW	UINT32_C(0x8)
	/*
	 * This bit must be '1' when the maximum bandwidth for queue group 3
	 * (g3_max_bw) is configured.
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_ENABLES_G3_MAX_BW	UINT32_C(0x10)
	/*
	 * Specifies the maximum receive rate, as a percentage of total link
	 * bandwidth, of the receive traffic through queue group 0. A value
	 * of 0 indicates no rate limit.
	 *
	 * A queue group is a set of queues, one per traffic class. In
	 * single-host mode, each panel port has its own queue group, and thus,
	 * this rate limit shapes the traffic received on a port, in this case,
	 * through port 0. In multi-root or multi-host mode, each PCIe endpoint
	 * on the NIC has its own queue group. In these cases, the rate limit
	 * shapes the traffic sent to the host through one of the PCIe
	 * endpoints, in this case endpoint 0.
	 */
	uint8_t	g0_max_bw;
	/*
	 * Specifies the maximum rate of the traffic through receive CoS queue
	 * group 1 (for port 1 or PCIe endpoint 1). The rate is a percentage of
	 * total link bandwidth (the sum of the bandwidths of all links). A
	 * value of 0 indicates no rate limit.
	 */
	uint8_t	g1_max_bw;
	/*
	 * Specifies the maximum rate of the traffic through receive CoS queue
	 * group 2 (for port 2 or PCIe endpoint 2). The rate is a percentage of
	 * total link bandwidth (the sum of the bandwidths of all links). A
	 * value of 0 indicates no rate limit.
	 */
	uint8_t	g2_max_bw;
	/*
	 * Specifies the maximum receive rate, in Mbps, of the receive traffic
	 * through queue group 3 (for port 3 or PCIe endpoint 3). A value of 0
	 * indicates no rate limit.
	 */
	uint8_t	g3_max_bw;
} hwrm_queue_global_cfg_input_t, *phwrm_queue_global_cfg_input_t;

/* hwrm_queue_global_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_global_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_global_cfg_output_t, *phwrm_queue_global_cfg_output_t;

/**************************
 * hwrm_queue_global_qcfg *
 **************************/


/* hwrm_queue_global_qcfg_input (size:128b/16B) */

typedef struct hwrm_queue_global_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_global_qcfg_input_t, *phwrm_queue_global_qcfg_input_t;

/* hwrm_queue_global_qcfg_output (size:320b/40B) */

typedef struct hwrm_queue_global_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Port or PCIe endpoint id to be mapped for buffer pool 0. */
	uint8_t	buffer_pool_id0_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 1. */
	uint8_t	buffer_pool_id1_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 2. */
	uint8_t	buffer_pool_id2_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 3. */
	uint8_t	buffer_pool_id3_map;
	/* Size of buffer pool 0 (KBytes). */
	uint32_t	buffer_pool_id0_size;
	/* Size of buffer pool 1 (KBytes). */
	uint32_t	buffer_pool_id1_size;
	/* Size of buffer pool 2 (KBytes). */
	uint32_t	buffer_pool_id2_size;
	/* Size of buffer pool 3 (KBytes). */
	uint32_t	buffer_pool_id3_size;
	uint16_t	flags;
	/*
	 * Enumeration denoting whether the rx buffer pool mapping is
	 * per port or per PCIe endpoint
	 */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING			UINT32_C(0x1)
	/*
	 * The buffer_pool_id[0-3]_map field represents mapping of rx
	 * buffer pools to a port.
	 */
		#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_PORT	UINT32_C(0x0)
	/*
	 * The buffer_pool_id[0-3]_map field represents mapping of rx
	 * buffer pools to a PCIe endpoint.
	 */
		#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_ENDPOINT  UINT32_C(0x1)
		#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_LAST		HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_ENDPOINT
	/*
	 * Configuration mode for rx cos queues, configuring whether they
	 * use one shared buffer pool (across ports or PCIe endpoints) or
	 * independent per port or per endpoint buffer pools.
	 */
	uint8_t	mode;
	/* One shared buffer pool to be used by all RX CoS queues */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_SHARED	UINT32_C(0x0)
	/*
	 * Each port or PCIe endpoint to use an independent buffer pool
	 * for its RX CoS queues
	 */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_INDEPENDENT UINT32_C(0x1)
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_LAST	HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_INDEPENDENT
	uint8_t	unused_0;
	/*
	 * Reports the rate limit applied to traffic through receive CoS queue
	 * group 0. The rate limit is a percentage of total link bandwidth. A
	 * value of 0 indicates no rate limit.
	 *
	 * A queue group is a set of queues, one per traffic class. In
	 * single-host mode, each panel port has its own queue group, and thus,
	 * this rate limit shapes the traffic received on a port, in this case,
	 * through port 0. In multi-root or multi-host mode, each PCIe endpoint
	 * on the NIC has its own queue group. In these cases, the rate limit
	 * shapes the traffic sent to the host through one of the PCIe
	 * endpoints, in this case endpoint 0.
	 */
	uint8_t	g0_max_bw;
	/*
	 * Reports the rate limit applied to traffic through receive CoS queue
	 * group 1 (for port 1 or PCIe endpoint 1). The rate limit is a
	 * percentage of total link bandwidth. A value of 0 indicates no rate
	 * limit.
	 */
	uint8_t	g1_max_bw;
	/*
	 * Reports the rate limit applied to traffic through receive CoS queue
	 * group 2 (for port 2 or PCIe endpoint 2). The rate limit is a
	 * percentage of total link bandwidth. A value of 0 indicates no rate
	 * limit.
	 */
	uint8_t	g2_max_bw;
	/*
	 * Reports the rate limit applied to traffic through receive CoS queue
	 * group 3 (for port 3 or PCIe endpoint 3). The rate limit is a
	 * percentage of total link bandwidth. A value of 0 indicates no rate
	 * limit.
	 */
	uint8_t	g3_max_bw;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_global_qcfg_output_t, *phwrm_queue_global_qcfg_output_t;

/****************************************
 * hwrm_queue_adptv_qos_rx_feature_qcfg *
 ****************************************/


/* hwrm_queue_adptv_qos_rx_feature_qcfg_input (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_rx_feature_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_adptv_qos_rx_feature_qcfg_input_t, *phwrm_queue_adptv_qos_rx_feature_qcfg_input_t;

/* hwrm_queue_adptv_qos_rx_feature_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_rx_feature_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bitmask indicating which RX CoS queues are enabled or disabled.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * A value of 0 indicates that the queue is not enabled.
	 * A value of 1 indicates that the queue is enabled.
	 */
	uint8_t	queue_enable;
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE	UINT32_C(0x1)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE_DISABLED  UINT32_C(0x0)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE_ENABLED   UINT32_C(0x1)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE	UINT32_C(0x2)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE_DISABLED  (UINT32_C(0x0) << 1)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE_ENABLED   (UINT32_C(0x1) << 1)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE	UINT32_C(0x4)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE_DISABLED  (UINT32_C(0x0) << 2)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE_ENABLED   (UINT32_C(0x1) << 2)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE	UINT32_C(0x8)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE_DISABLED  (UINT32_C(0x0) << 3)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE_ENABLED   (UINT32_C(0x1) << 3)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE	UINT32_C(0x10)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE_DISABLED  (UINT32_C(0x0) << 4)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE_ENABLED   (UINT32_C(0x1) << 4)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE	UINT32_C(0x20)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE_DISABLED  (UINT32_C(0x0) << 5)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE_ENABLED   (UINT32_C(0x1) << 5)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE	UINT32_C(0x40)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE_DISABLED  (UINT32_C(0x0) << 6)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE_ENABLED   (UINT32_C(0x1) << 6)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE	UINT32_C(0x80)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE_DISABLED  (UINT32_C(0x0) << 7)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE_ENABLED   (UINT32_C(0x1) << 7)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE_ENABLED
	/*
	 * Bitmask indicating which CoS queues are lossy or lossless.
	 * This setting is kept same across Rx and Tx directions, despite
	 * the name mentioning only Rx. Each bit represents a specific queue
	 * where bit 0 represents queue 0 and bit 7 represents queue 7.
	 * A value of 0 indicates that the queue is lossy.
	 * A value of 1 indicates that the queue is lossless.
	 */
	uint8_t	queue_mode;
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID0_MODE	UINT32_C(0x1)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID0_MODE_LOSSY	UINT32_C(0x0)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID0_MODE_LOSSLESS  UINT32_C(0x1)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID0_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID0_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID1_MODE	UINT32_C(0x2)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID1_MODE_LOSSY	(UINT32_C(0x0) << 1)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID1_MODE_LOSSLESS  (UINT32_C(0x1) << 1)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID1_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID1_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID2_MODE	UINT32_C(0x4)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID2_MODE_LOSSY	(UINT32_C(0x0) << 2)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID2_MODE_LOSSLESS  (UINT32_C(0x1) << 2)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID2_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID2_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID3_MODE	UINT32_C(0x8)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID3_MODE_LOSSY	(UINT32_C(0x0) << 3)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID3_MODE_LOSSLESS  (UINT32_C(0x1) << 3)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID3_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID3_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID4_MODE	UINT32_C(0x10)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID4_MODE_LOSSY	(UINT32_C(0x0) << 4)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID4_MODE_LOSSLESS  (UINT32_C(0x1) << 4)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID4_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID4_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID5_MODE	UINT32_C(0x20)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID5_MODE_LOSSY	(UINT32_C(0x0) << 5)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID5_MODE_LOSSLESS  (UINT32_C(0x1) << 5)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID5_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID5_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID6_MODE	UINT32_C(0x40)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID6_MODE_LOSSY	(UINT32_C(0x0) << 6)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID6_MODE_LOSSLESS  (UINT32_C(0x1) << 6)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID6_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID6_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID7_MODE	UINT32_C(0x80)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID7_MODE_LOSSY	(UINT32_C(0x0) << 7)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID7_MODE_LOSSLESS  (UINT32_C(0x1) << 7)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID7_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_QCFG_OUTPUT_QUEUE_MODE_QID7_MODE_LOSSLESS
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_adptv_qos_rx_feature_qcfg_output_t, *phwrm_queue_adptv_qos_rx_feature_qcfg_output_t;

/***************************************
 * hwrm_queue_adptv_qos_rx_feature_cfg *
 ***************************************/


/* hwrm_queue_adptv_qos_rx_feature_cfg_input (size:192b/24B) */

typedef struct hwrm_queue_adptv_qos_rx_feature_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/* This bit must be '1' for the queue_enable field to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_ENABLES_QUEUE_ENABLE	UINT32_C(0x1)
	/* This bit must be '1' for the queue_mode field to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_ENABLES_QUEUE_MODE	UINT32_C(0x2)
	/*
	 * Bitmask indicating which RX CoS queues are enabled or disabled.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * A value of 0 indicates that the queue is not enabled.
	 * A value of 1 indicates that the queue is enabled.
	 */
	uint8_t	queue_enable;
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE	UINT32_C(0x1)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE_DISABLED  UINT32_C(0x0)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE_ENABLED   UINT32_C(0x1)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE	UINT32_C(0x2)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE_DISABLED  (UINT32_C(0x0) << 1)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE_ENABLED   (UINT32_C(0x1) << 1)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE	UINT32_C(0x4)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE_DISABLED  (UINT32_C(0x0) << 2)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE_ENABLED   (UINT32_C(0x1) << 2)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE	UINT32_C(0x8)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE_DISABLED  (UINT32_C(0x0) << 3)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE_ENABLED   (UINT32_C(0x1) << 3)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE	UINT32_C(0x10)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE_DISABLED  (UINT32_C(0x0) << 4)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE_ENABLED   (UINT32_C(0x1) << 4)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE	UINT32_C(0x20)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE_DISABLED  (UINT32_C(0x0) << 5)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE_ENABLED   (UINT32_C(0x1) << 5)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE	UINT32_C(0x40)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE_DISABLED  (UINT32_C(0x0) << 6)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE_ENABLED   (UINT32_C(0x1) << 6)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE	UINT32_C(0x80)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE_DISABLED  (UINT32_C(0x0) << 7)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE_ENABLED   (UINT32_C(0x1) << 7)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE_ENABLED
	/*
	 * Bitmask indicating which CoS queues are lossy or lossless.
	 * This setting is kept symmetric (or same) across Tx and Rx.
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * A value of 0 indicates that the queue is lossy.
	 * A value of 1 indicates that the queue is lossless.
	 */
	uint8_t	queue_mode;
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID0_MODE	UINT32_C(0x1)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID0_MODE_LOSSY	UINT32_C(0x0)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID0_MODE_LOSSLESS  UINT32_C(0x1)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID0_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID0_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID1_MODE	UINT32_C(0x2)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID1_MODE_LOSSY	(UINT32_C(0x0) << 1)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID1_MODE_LOSSLESS  (UINT32_C(0x1) << 1)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID1_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID1_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID2_MODE	UINT32_C(0x4)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID2_MODE_LOSSY	(UINT32_C(0x0) << 2)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID2_MODE_LOSSLESS  (UINT32_C(0x1) << 2)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID2_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID2_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID3_MODE	UINT32_C(0x8)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID3_MODE_LOSSY	(UINT32_C(0x0) << 3)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID3_MODE_LOSSLESS  (UINT32_C(0x1) << 3)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID3_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID3_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID4_MODE	UINT32_C(0x10)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID4_MODE_LOSSY	(UINT32_C(0x0) << 4)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID4_MODE_LOSSLESS  (UINT32_C(0x1) << 4)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID4_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID4_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID5_MODE	UINT32_C(0x20)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID5_MODE_LOSSY	(UINT32_C(0x0) << 5)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID5_MODE_LOSSLESS  (UINT32_C(0x1) << 5)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID5_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID5_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID6_MODE	UINT32_C(0x40)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID6_MODE_LOSSY	(UINT32_C(0x0) << 6)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID6_MODE_LOSSLESS  (UINT32_C(0x1) << 6)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID6_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID6_MODE_LOSSLESS
	/* If set to 0, then the queue is lossy, else lossless. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID7_MODE	UINT32_C(0x80)
	/* Lossy (best-effort). */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID7_MODE_LOSSY	(UINT32_C(0x0) << 7)
	/* Lossless. */
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID7_MODE_LOSSLESS  (UINT32_C(0x1) << 7)
		#define HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID7_MODE_LAST	HWRM_QUEUE_ADPTV_QOS_RX_FEATURE_CFG_INPUT_QUEUE_MODE_QID7_MODE_LOSSLESS
	uint8_t	unused_0[2];
} hwrm_queue_adptv_qos_rx_feature_cfg_input_t, *phwrm_queue_adptv_qos_rx_feature_cfg_input_t;

/* hwrm_queue_adptv_qos_rx_feature_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_rx_feature_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_adptv_qos_rx_feature_cfg_output_t, *phwrm_queue_adptv_qos_rx_feature_cfg_output_t;

/****************************************
 * hwrm_queue_adptv_qos_tx_feature_qcfg *
 ****************************************/


/* hwrm_queue_adptv_qos_tx_feature_qcfg_input (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_tx_feature_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_adptv_qos_tx_feature_qcfg_input_t, *phwrm_queue_adptv_qos_tx_feature_qcfg_input_t;

/* hwrm_queue_adptv_qos_tx_feature_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_tx_feature_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bitmask indicating which TX CoS queues are enabled or disabled.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * A value of 0 indicates that the queue is not enabled.
	 * A value of 1 indicates that the queue is enabled.
	 */
	uint8_t	queue_enable;
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE	UINT32_C(0x1)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE_DISABLED  UINT32_C(0x0)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE_ENABLED   UINT32_C(0x1)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID0_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE	UINT32_C(0x2)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE_DISABLED  (UINT32_C(0x0) << 1)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE_ENABLED   (UINT32_C(0x1) << 1)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID1_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE	UINT32_C(0x4)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE_DISABLED  (UINT32_C(0x0) << 2)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE_ENABLED   (UINT32_C(0x1) << 2)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID2_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE	UINT32_C(0x8)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE_DISABLED  (UINT32_C(0x0) << 3)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE_ENABLED   (UINT32_C(0x1) << 3)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID3_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE	UINT32_C(0x10)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE_DISABLED  (UINT32_C(0x0) << 4)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE_ENABLED   (UINT32_C(0x1) << 4)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID4_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE	UINT32_C(0x20)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE_DISABLED  (UINT32_C(0x0) << 5)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE_ENABLED   (UINT32_C(0x1) << 5)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID5_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE	UINT32_C(0x40)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE_DISABLED  (UINT32_C(0x0) << 6)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE_ENABLED   (UINT32_C(0x1) << 6)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID6_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE	UINT32_C(0x80)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE_DISABLED  (UINT32_C(0x0) << 7)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE_ENABLED   (UINT32_C(0x1) << 7)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_QCFG_OUTPUT_QUEUE_ENABLE_QID7_ENABLE_ENABLED
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_adptv_qos_tx_feature_qcfg_output_t, *phwrm_queue_adptv_qos_tx_feature_qcfg_output_t;

/***************************************
 * hwrm_queue_adptv_qos_tx_feature_cfg *
 ***************************************/


/* hwrm_queue_adptv_qos_tx_feature_cfg_input (size:192b/24B) */

typedef struct hwrm_queue_adptv_qos_tx_feature_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/* This bit must be '1' for the queue_enable field to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_ENABLES_QUEUE_ENABLE	UINT32_C(0x1)
	/*
	 * Bitmask indicating which TX CoS queues are enabled or disabled.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * A value of 0 indicates that the queue is not enabled.
	 * A value of 1 indicates that the queue is enabled.
	 */
	uint8_t	queue_enable;
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE	UINT32_C(0x1)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE_DISABLED  UINT32_C(0x0)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE_ENABLED   UINT32_C(0x1)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID0_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE	UINT32_C(0x2)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE_DISABLED  (UINT32_C(0x0) << 1)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE_ENABLED   (UINT32_C(0x1) << 1)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID1_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE	UINT32_C(0x4)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE_DISABLED  (UINT32_C(0x0) << 2)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE_ENABLED   (UINT32_C(0x1) << 2)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID2_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE	UINT32_C(0x8)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE_DISABLED  (UINT32_C(0x0) << 3)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE_ENABLED   (UINT32_C(0x1) << 3)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID3_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE	UINT32_C(0x10)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE_DISABLED  (UINT32_C(0x0) << 4)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE_ENABLED   (UINT32_C(0x1) << 4)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID4_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE	UINT32_C(0x20)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE_DISABLED  (UINT32_C(0x0) << 5)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE_ENABLED   (UINT32_C(0x1) << 5)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID5_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE	UINT32_C(0x40)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE_DISABLED  (UINT32_C(0x0) << 6)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE_ENABLED   (UINT32_C(0x1) << 6)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID6_ENABLE_ENABLED
	/* If set to 1, then the queue is enabled. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE	UINT32_C(0x80)
	/* Queue is disabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE_DISABLED  (UINT32_C(0x0) << 7)
	/* Queue is enabled. */
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE_ENABLED   (UINT32_C(0x1) << 7)
		#define HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE_LAST	HWRM_QUEUE_ADPTV_QOS_TX_FEATURE_CFG_INPUT_QUEUE_ENABLE_QID7_ENABLE_ENABLED
	uint8_t	unused_0[3];
} hwrm_queue_adptv_qos_tx_feature_cfg_input_t, *phwrm_queue_adptv_qos_tx_feature_cfg_input_t;

/* hwrm_queue_adptv_qos_tx_feature_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_tx_feature_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_adptv_qos_tx_feature_cfg_output_t, *phwrm_queue_adptv_qos_tx_feature_cfg_output_t;

/********************
 * hwrm_queue_qcaps *
 ********************/


/* hwrm_queue_qcaps_input (size:128b/16B) */

typedef struct hwrm_queue_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_qcaps_input_t, *phwrm_queue_qcaps_input_t;

/* hwrm_queue_qcaps_output (size:256b/32B) */

typedef struct hwrm_queue_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Adaptive QoS RX feature parameter capability flags. */
	uint32_t	rx_feature_params;
	/*
	 * When this bit is '1' the capability to configure queue_enable
	 * is supported.
	 * If set to '0', then the capability to configure queue_enable
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_FEATURE_PARAMS_QUEUE_ENABLE_CAP	UINT32_C(0x1)
	/*
	 * When this bit is '1' the capability to configure queue_mode
	 * is supported.
	 * If set to '0', then the capability to configure queue_mode
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_FEATURE_PARAMS_QUEUE_MODE_CAP	UINT32_C(0x2)
	/* Adaptive QoS TX feature parameter capability flags. */
	uint32_t	tx_feature_params;
	/*
	 * When this bit is '1' the capability to configure queue_enable
	 * is supported.
	 * If set to '0', then the capability to configure queue_enable
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_FEATURE_PARAMS_QUEUE_ENABLE_CAP	UINT32_C(0x1)
	/*
	 * The maximum number of queues that can be configured on this device.
	 * Valid values range from 1 through 8.
	 */
	uint8_t	max_configurable_queues;
	uint8_t	unused_0[3];
	/* Adaptive QoS RX tuning parameter capability flags. */
	uint32_t	rx_tuning_params;
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_WFQ_COST_CAP			UINT32_C(0x1)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_WFQ_UPPER_FACTOR_CAP		UINT32_C(0x2)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_HYST_WINDOW_SIZE_FACTOR_CAP	UINT32_C(0x4)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_PCIE_BW_EFF_CAP		UINT32_C(0x8)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_XOFF_HEADROOM_FACTOR_CAP	UINT32_C(0x10)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_L2_MIN_LATENCY_CAP		UINT32_C(0x20)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_L2_MAX_LATENCY_CAP		UINT32_C(0x40)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_ROCE_MIN_LATENCY_CAP		UINT32_C(0x80)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_ROCE_MAX_LATENCY_CAP		UINT32_C(0x100)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_L2_PIPE_COS_LATENCY_CAP	UINT32_C(0x200)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_ROCE_PIPE_COS_LATENCY_CAP	UINT32_C(0x400)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_COS_SHARED_MIN_RATIO_CAP	UINT32_C(0x800)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_RSVD_CELLS_LIMIT_RATIO_CAP	UINT32_C(0x1000)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_RX_TUNING_PARAMS_SHAPER_REFILL_TIMER_CAP	UINT32_C(0x2000)
	/* Adaptive QoS TX tuning parameter capability flags. */
	uint32_t	tx_tuning_params;
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_WFQ_COST_CAP			UINT32_C(0x1)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_WFQ_UPPER_FACTOR_CAP		UINT32_C(0x2)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_HYST_WINDOW_SIZE_FACTOR_CAP	UINT32_C(0x4)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_RSVD_CELLS_LIMIT_RATIO_CAP	UINT32_C(0x8)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_L2_MIN_LATENCY_CAP		UINT32_C(0x10)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_L2_MAX_LATENCY_CAP		UINT32_C(0x20)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_ROCE_MIN_LATENCY_CAP		UINT32_C(0x40)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_ROCE_MAX_LATENCY_CAP		UINT32_C(0x80)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_MAX_TBM_CELLS_PRERESERVED_CAP	UINT32_C(0x100)
	/*
	 * When this bit is '1' the capability to configure the option
	 * is supported.
	 * If set to '0', then the capability to configure the option
	 * is not supported.
	 */
	#define HWRM_QUEUE_QCAPS_OUTPUT_TX_TUNING_PARAMS_SHAPER_REFILL_TIMER_CAP	UINT32_C(0x200)
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_qcaps_output_t, *phwrm_queue_qcaps_output_t;

/***************************************
 * hwrm_queue_adptv_qos_rx_tuning_qcfg *
 ***************************************/


/* hwrm_queue_adptv_qos_rx_tuning_qcfg_input (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_rx_tuning_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_adptv_qos_rx_tuning_qcfg_input_t, *phwrm_queue_adptv_qos_rx_tuning_qcfg_input_t;

/* hwrm_queue_adptv_qos_rx_tuning_qcfg_output (size:576b/72B) */

typedef struct hwrm_queue_adptv_qos_rx_tuning_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Indicates max credit as required by hardware. */
	uint32_t	wfq_cost;
	/*
	 * Specifies a factor that determines the upper bound for each
	 * cos_wfq_credit_weight.
	 */
	uint32_t	wfq_upper_factor;
	/*
	 * The algorithm multiplies this factor by the MRU size to compute the
	 * hysteresis window size which in turn is used in deassert
	 * threshold calculations.
	 */
	uint32_t	hyst_window_size_factor;
	/*
	 * Specifies PCIe BW efficiency in the range of 0-100%. System
	 * characterization determines the value of this parameter. A value of
	 * less than 100% accounts for internal PCIe over-subscription. The
	 * algorithm uses this parameter to determine the PCIe BW available
	 * for transferring received packets to the host.
	 */
	uint32_t	pcie_bw_eff;
	/* Scales the number of cells for xoff. */
	uint32_t	xoff_headroom_factor;
	/*
	 * It is used to calculate the number of reserved cells for cos queues
	 * configured for L2. Its value is derived from system
	 * characterization.
	 */
	uint32_t	l2_min_latency;
	/*
	 * It is used to calculate the number of shared cells for cos queues
	 * configured for L2. Its value is derived from system
	 * characterization.
	 */
	uint32_t	l2_max_latency;
	/*
	 * It is used to calculate the number of reserved cells for cos queues
	 * configured for RoCE. Its value is derived from system
	 * characterization.
	 */
	uint32_t	roce_min_latency;
	/*
	 * It is used to calculate the number of shared cells for cos queues
	 * configured for RoCE. Its value is derived from system
	 * characterization.
	 */
	uint32_t	roce_max_latency;
	/*
	 * The algorithm uses this parameter to calculate the number of cells
	 * to be excluded from the total buffer pool to account for the
	 * latency of pipeline post RE_DEC to PCIe block. Its value is derived
	 * from system characterization.
	 */
	uint32_t	l2_pipe_cos_latency;
	/*
	 * The algorithm uses this parameter to calculate the number of cells
	 * to be excluded from the total buffer pool to account for the
	 * latency of pipeline post RE_DEC to PCIe block. Its value is derived
	 * from system characterization.
	 */
	uint32_t	roce_pipe_cos_latency;
	/* Sets the minimum number of shared cells each cos queue can have. */
	uint32_t	cos_shared_min_ratio;
	/*
	 * The parameter limits the total reserved cells. If the computed
	 * total reserved cells becomes larger than rsvd_cells_limit_ratio x
	 * port_cells_avail, then the reserved cells are set to the limit
	 * value. Its range of values is 0-50%.
	 */
	uint32_t	rsvd_cells_limit_ratio;
	/*
	 * This parameter is used to compute the time interval for
	 * replenishing the shaper credit buckets for all RX cos queues.
	 */
	uint32_t	shaper_refill_timer;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_adptv_qos_rx_tuning_qcfg_output_t, *phwrm_queue_adptv_qos_rx_tuning_qcfg_output_t;

/**************************************
 * hwrm_queue_adptv_qos_rx_tuning_cfg *
 **************************************/


/* hwrm_queue_adptv_qos_rx_tuning_cfg_input (size:640b/80B) */

typedef struct hwrm_queue_adptv_qos_rx_tuning_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_WFQ_COST			UINT32_C(0x1)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_WFQ_UPPER_FACTOR		UINT32_C(0x2)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_HYST_WINDOW_SIZE_FACTOR	UINT32_C(0x4)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_PCIE_BW_EFF		UINT32_C(0x8)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_XOFF_HEADROOM_FACTOR	UINT32_C(0x10)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_L2_MIN_LATENCY		UINT32_C(0x20)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_L2_MAX_LATENCY		UINT32_C(0x40)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_ROCE_MIN_LATENCY		UINT32_C(0x80)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_ROCE_MAX_LATENCY		UINT32_C(0x100)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_L2_PIPE_COS_LATENCY	UINT32_C(0x200)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_ROCE_PIPE_COS_LATENCY	UINT32_C(0x400)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_COS_SHARED_MIN_RATIO	UINT32_C(0x800)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_RSVD_CELLS_LIMIT_RATIO	UINT32_C(0x1000)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_RX_TUNING_CFG_INPUT_ENABLES_SHAPER_REFILL_TIMER	UINT32_C(0x2000)
	/* Indicates max credit as required by hardware. */
	uint32_t	wfq_cost;
	/*
	 * Specifies a factor that determines the upper bound for each
	 * cos_wfq_credit_weight.
	 */
	uint32_t	wfq_upper_factor;
	/*
	 * The algorithm multiplies this factor by the MRU size to compute the
	 * hysteresis window size which in turn is used in deassert
	 * threshold calculations.
	 */
	uint32_t	hyst_window_size_factor;
	/*
	 * Specifies PCIe BW efficiency in the range of 0-100%. System
	 * characterization determines the value of this parameter. A value of
	 * less than 100% accounts for internal PCIe over-subscription. The
	 * algorithm uses this parameter to determine the PCIe BW available
	 * for transferring received packets to the host.
	 */
	uint32_t	pcie_bw_eff;
	/* Scales the number of cells for xoff. */
	uint32_t	xoff_headroom_factor;
	/*
	 * It is used to calculate the number of reserved cells for cos queues
	 * configured for L2. Its value is derived from system
	 * characterization.
	 */
	uint32_t	l2_min_latency;
	/*
	 * It is used to calculate the number of shared cells for cos queues
	 * configured for L2. Its value is derived from system
	 * characterization.
	 */
	uint32_t	l2_max_latency;
	/*
	 * It is used to calculate the number of reserved cells for cos queues
	 * configured for RoCE. Its value is derived from system
	 * characterization.
	 */
	uint32_t	roce_min_latency;
	/*
	 * It is used to calculate the number of shared cells for cos queues
	 * configured for RoCE. Its value is derived from system
	 * characterization.
	 */
	uint32_t	roce_max_latency;
	/*
	 * The algorithm uses this parameter to calculate the number of cells
	 * to be excluded from the total buffer pool to account for the
	 * latency of pipeline post RE_DEC to PCIe block. Its value is derived
	 * from system characterization.
	 */
	uint32_t	l2_pipe_cos_latency;
	/*
	 * The algorithm uses this parameter to calculate the number of cells
	 * to be excluded from the total buffer pool to account for the
	 * latency of pipeline post RE_DEC to PCIe block. Its value is derived
	 * from system characterization.
	 */
	uint32_t	roce_pipe_cos_latency;
	/* Sets the minimum number of shared cells each cos queue can have. */
	uint32_t	cos_shared_min_ratio;
	/*
	 * The parameter limits the total reserved cells. If the computed
	 * total reserved cells becomes larger than rsvd_cells_limit_ratio x
	 * port_cells_avail, then the reserved cells are set to the limit
	 * value. Its range of values is 0-50%.
	 */
	uint32_t	rsvd_cells_limit_ratio;
	/*
	 * This parameter is used to compute the time interval for
	 * replenishing the shaper credit buckets for all RX cos queues.
	 */
	uint32_t	shaper_refill_timer;
	uint8_t	unused_0[4];
} hwrm_queue_adptv_qos_rx_tuning_cfg_input_t, *phwrm_queue_adptv_qos_rx_tuning_cfg_input_t;

/* hwrm_queue_adptv_qos_rx_tuning_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_rx_tuning_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_adptv_qos_rx_tuning_cfg_output_t, *phwrm_queue_adptv_qos_rx_tuning_cfg_output_t;

/***************************************
 * hwrm_queue_adptv_qos_tx_tuning_qcfg *
 ***************************************/


/* hwrm_queue_adptv_qos_tx_tuning_qcfg_input (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_tx_tuning_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_adptv_qos_tx_tuning_qcfg_input_t, *phwrm_queue_adptv_qos_tx_tuning_qcfg_input_t;

/* hwrm_queue_adptv_qos_tx_tuning_qcfg_output (size:448b/56B) */

typedef struct hwrm_queue_adptv_qos_tx_tuning_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Indicates max credit as required by hardware. */
	uint32_t	wfq_cost;
	/*
	 * Specifies a factor that determines the upper bound for each
	 * cos_wfq_credit_weight.
	 */
	uint32_t	wfq_upper_factor;
	/*
	 * The algorithm multiplies this factor by the MRU size to compute the
	 * hysteresis window size which in turn is used in deassert
	 * threshold calculations.
	 */
	uint32_t	hyst_window_size_factor;
	/*
	 * The parameter limits the total reserved cells. If the computed
	 * total reserved cells becomes larger than rsvd_cells_limit_ratio x
	 * port_cells_avail, then the reserved cells are set to the limit
	 * value. Its range of values is 0-50%.
	 */
	uint32_t	rsvd_cells_limit_ratio;
	/*
	 * It is used to calculate the number of reserved cells for cos queues
	 * configured for L2. Its value is derived from system
	 * characterization.
	 */
	uint32_t	l2_min_latency;
	/*
	 * It is used to calculate the number of shared cells for cos queues
	 * configured for L2. Its value is derived from system
	 * characterization.
	 */
	uint32_t	l2_max_latency;
	/*
	 * It is used to calculate the number of reserved cells for cos queues
	 * configured for RoCE. Its value is derived from system
	 * characterization.
	 */
	uint32_t	roce_min_latency;
	/*
	 * It is used to calculate the number of shared cells for cos queues
	 * configured for RoCE. Its value is derived from system
	 * characterization.
	 */
	uint32_t	roce_max_latency;
	/* Specifies the number of reserved cells TRP requires per cos queue. */
	uint32_t	max_tbm_cells_prereserved;
	/*
	 * This parameter is used to compute the time interval for
	 * replenishing the shaper credit buckets for all TX cos queues.
	 */
	uint32_t	shaper_refill_timer;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_adptv_qos_tx_tuning_qcfg_output_t, *phwrm_queue_adptv_qos_tx_tuning_qcfg_output_t;

/**************************************
 * hwrm_queue_adptv_qos_tx_tuning_cfg *
 **************************************/


/* hwrm_queue_adptv_qos_tx_tuning_cfg_input (size:512b/64B) */

typedef struct hwrm_queue_adptv_qos_tx_tuning_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_WFQ_COST			UINT32_C(0x1)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_WFQ_UPPER_FACTOR		UINT32_C(0x2)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_HYST_WINDOW_SIZE_FACTOR	UINT32_C(0x4)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_RSVD_CELLS_LIMIT_RATIO	UINT32_C(0x8)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_L2_MIN_LATENCY		UINT32_C(0x10)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_L2_MAX_LATENCY		UINT32_C(0x20)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_ROCE_MIN_LATENCY		UINT32_C(0x40)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_ROCE_MAX_LATENCY		UINT32_C(0x80)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_MAX_TBM_CELLS_PRERESERVED	UINT32_C(0x100)
	/* This bit must be '1' for the option to be configured. */
	#define HWRM_QUEUE_ADPTV_QOS_TX_TUNING_CFG_INPUT_ENABLES_SHAPER_REFILL_TIMER	UINT32_C(0x200)
	/* Indicates max credit as required by hardware. */
	uint32_t	wfq_cost;
	/*
	 * Specifies a factor that determines the upper bound for each
	 * cos_wfq_credit_weight.
	 */
	uint32_t	wfq_upper_factor;
	/*
	 * The algorithm multiplies this factor by the MRU size to compute the
	 * hysteresis window size which in turn is used in deassert
	 * threshold calculations.
	 */
	uint32_t	hyst_window_size_factor;
	/*
	 * The parameter limits the total reserved cells. If the computed
	 * total reserved cells becomes larger than rsvd_cells_limit_ratio x
	 * port_cells_avail, then the reserved cells are set to the limit
	 * value. Its range of values is 0-50%.
	 */
	uint32_t	rsvd_cells_limit_ratio;
	/*
	 * It is used to calculate the number of reserved cells for cos queues
	 * configured for L2. Its value is derived from system
	 * characterization.
	 */
	uint32_t	l2_min_latency;
	/*
	 * It is used to calculate the number of shared cells for cos queues
	 * configured for L2. Its value is derived from system
	 * characterization.
	 */
	uint32_t	l2_max_latency;
	/*
	 * It is used to calculate the number of reserved cells for cos queues
	 * configured for RoCE. Its value is derived from system
	 * characterization.
	 */
	uint32_t	roce_min_latency;
	/*
	 * It is used to calculate the number of shared cells for cos queues
	 * configured for RoCE. Its value is derived from system
	 * characterization.
	 */
	uint32_t	roce_max_latency;
	/* Specifies the number of reserved cells TRP requires per cos queue. */
	uint32_t	max_tbm_cells_prereserved;
	/*
	 * This parameter is used to compute the time interval for
	 * replenishing the shaper credit buckets for all TX cos queues.
	 */
	uint32_t	shaper_refill_timer;
	uint8_t	unused_0[4];
} hwrm_queue_adptv_qos_tx_tuning_cfg_input_t, *phwrm_queue_adptv_qos_tx_tuning_cfg_input_t;

/* hwrm_queue_adptv_qos_tx_tuning_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_adptv_qos_tx_tuning_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_adptv_qos_tx_tuning_cfg_output_t, *phwrm_queue_adptv_qos_tx_tuning_cfg_output_t;

/**********************************
 * hwrm_queue_pfcwd_timeout_qcaps *
 **********************************/


/* hwrm_queue_pfcwd_timeout_qcaps_input (size:128b/16B) */

typedef struct hwrm_queue_pfcwd_timeout_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_pfcwd_timeout_qcaps_input_t, *phwrm_queue_pfcwd_timeout_qcaps_input_t;

/* hwrm_queue_pfcwd_timeout_qcaps_output (size:128b/16B) */

typedef struct hwrm_queue_pfcwd_timeout_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Max configurable pfc watchdog timeout value in msec. */
	uint16_t	max_pfcwd_timeout;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pfcwd_timeout_qcaps_output_t, *phwrm_queue_pfcwd_timeout_qcaps_output_t;

/********************************
 * hwrm_queue_pfcwd_timeout_cfg *
 ********************************/


/* hwrm_queue_pfcwd_timeout_cfg_input (size:192b/24B) */

typedef struct hwrm_queue_pfcwd_timeout_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * pfc watchdog timeout value in msec.
	 * A value of 0 means firmware will disable the PFC watchdog.
	 * A value of 0xffff means firmware will reset the timeout
	 * value to Hardware defaults. Anywhere between 0 to 0xffff is
	 * valid range for timeout value depending on the Hardware
	 * capability.
	 */
	uint16_t	pfcwd_timeout_value;
	uint8_t	unused_0[6];
} hwrm_queue_pfcwd_timeout_cfg_input_t, *phwrm_queue_pfcwd_timeout_cfg_input_t;

/* hwrm_queue_pfcwd_timeout_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_pfcwd_timeout_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pfcwd_timeout_cfg_output_t, *phwrm_queue_pfcwd_timeout_cfg_output_t;

/*********************************
 * hwrm_queue_pfcwd_timeout_qcfg *
 *********************************/


/* hwrm_queue_pfcwd_timeout_qcfg_input (size:128b/16B) */

typedef struct hwrm_queue_pfcwd_timeout_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_pfcwd_timeout_qcfg_input_t, *phwrm_queue_pfcwd_timeout_qcfg_input_t;

/* hwrm_queue_pfcwd_timeout_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_pfcwd_timeout_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Current configured pfc watchdog timeout value in msec.
	 * A value of 0 means PFC watchdog functionality is disabled.
	 */
	uint16_t	pfcwd_timeout_value;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pfcwd_timeout_qcfg_output_t, *phwrm_queue_pfcwd_timeout_qcfg_output_t;

/*******************
 * hwrm_vnic_alloc *
 *******************/


/* hwrm_vnic_alloc_input (size:192b/24B) */

typedef struct hwrm_vnic_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', this VNIC is requested to
	 * be the default VNIC for this function.
	 */
	#define HWRM_VNIC_ALLOC_INPUT_FLAGS_DEFAULT		UINT32_C(0x1)
	/*
	 * When this bit is '1', proxy VEE PF is requesting
	 * allocation of a default VNIC on behalf of virtio-net
	 * function given in virtio_net_fid field.
	 */
	#define HWRM_VNIC_ALLOC_INPUT_FLAGS_VIRTIO_NET_FID_VALID	UINT32_C(0x2)
	/*
	 * Virtio-net function's FID.
	 * This virtio-net function is requesting allocation of default
	 * VNIC through proxy VEE PF.
	 */
	uint16_t	virtio_net_fid;
	uint8_t	unused_0[2];
} hwrm_vnic_alloc_input_t, *phwrm_vnic_alloc_input_t;

/* hwrm_vnic_alloc_output (size:128b/16B) */

typedef struct hwrm_vnic_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_alloc_output_t, *phwrm_vnic_alloc_output_t;

/********************
 * hwrm_vnic_update *
 ********************/


/* hwrm_vnic_update_input (size:256b/32B) */

typedef struct hwrm_vnic_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vnic_state field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_VNIC_STATE_VALID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_MRU_VALID			UINT32_C(0x2)
	/*
	 * This bit must be '1' for the metadata_format_type field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_METADATA_FORMAT_TYPE_VALID	UINT32_C(0x4)
	/*
	 * This will update the context variable with the same name if
	 * the corresponding enable is set.
	 */
	uint8_t	vnic_state;
	/* Normal operation state for the VNIC. */
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_NORMAL UINT32_C(0x0)
	/* All packets are dropped in this state. */
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_DROP   UINT32_C(0x1)
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_LAST  HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_DROP
	/*
	 * The metadata format type used in all the RX packet completions
	 * going through this VNIC. This value is product specific. Refer to
	 * the L2 HSI completion ring structures for the detailed
	 * descriptions. For Thor and Thor2, it corresponds to 'meta_format'
	 * in 'rx_pkt_cmpl_hi' and 'rx_pkt_v3_cmpl_hi', respectively.
	 */
	uint8_t	metadata_format_type;
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_0 UINT32_C(0x0)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_1 UINT32_C(0x1)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_2 UINT32_C(0x2)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_3 UINT32_C(0x3)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_4 UINT32_C(0x4)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_LAST HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_4
	/*
	 * The maximum receive unit of the vnic.
	 * Each vnic is associated with a function.
	 * The vnic mru value overwrites the mru setting of the
	 * associated function.
	 * The HWRM shall make sure that vnic mru does not exceed
	 * the mru of the port the function is associated with.
	 */
	uint16_t	mru;
	uint8_t	unused_1[4];
} hwrm_vnic_update_input_t, *phwrm_vnic_update_input_t;

/* hwrm_vnic_update_output (size:128b/16B) */

typedef struct hwrm_vnic_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_vnic_update_output_t, *phwrm_vnic_update_output_t;

/******************
 * hwrm_vnic_free *
 ******************/


/* hwrm_vnic_free_input (size:192b/24B) */

typedef struct hwrm_vnic_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[4];
} hwrm_vnic_free_input_t, *phwrm_vnic_free_input_t;

/* hwrm_vnic_free_output (size:128b/16B) */

typedef struct hwrm_vnic_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_free_output_t, *phwrm_vnic_free_output_t;

/*****************
 * hwrm_vnic_cfg *
 *****************/


/* hwrm_vnic_cfg_input (size:384b/48B) */

typedef struct hwrm_vnic_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is requested to
	 * be the default VNIC for the function.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_DEFAULT				UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * strip VLAN in the RX path.
	 * If set to '0', then VLAN stripping is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_VLAN_STRIP_MODE			UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * buffer receive packets in the hardware until the host
	 * posts new receive buffers.
	 * If set to '0', then bd_stall is being configured to be
	 * disabled on this VNIC.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_BD_STALL_MODE			UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * receive both RoCE and non-RoCE traffic.
	 * If set to '0', then this VNIC is not configured to be
	 * operating in dual VNIC mode.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_DUAL_VNIC_MODE		UINT32_C(0x8)
	/*
	 * When this flag is set to '1', the VNIC is requested to
	 * be configured to receive only RoCE traffic.
	 * If this flag is set to '0', then this flag shall be
	 * ignored by the HWRM.
	 * If roce_dual_vnic_mode flag is set to '1'
	 * or roce_mirroring_capable_vnic_mode flag to 1,
	 * then the HWRM client shall not set this flag to '1'.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_ONLY_VNIC_MODE		UINT32_C(0x10)
	/*
	 * When a VNIC uses one destination ring group for certain
	 * application (e.g. Receive Flow Steering) where
	 * exact match is used to direct packets to a VNIC with one
	 * destination ring group only, there is no need to configure
	 * RSS indirection table for that VNIC as only one destination
	 * ring group is used.
	 *
	 * This flag is used to enable a mode where
	 * RSS is enabled in the VNIC using a RSS context
	 * for computing RSS hash but the RSS indirection table is
	 * not configured using hwrm_vnic_rss_cfg.
	 *
	 * If this mode is enabled, then the driver should not program
	 * RSS indirection table for the RSS context that is used for
	 * computing RSS hash only.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_RSS_DFLT_CR_MODE			UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * receive both RoCE and non-RoCE traffic, but forward only the
	 * RoCE traffic further. Also, RoCE traffic can be mirrored to
	 * L2 driver.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_MODE	UINT32_C(0x40)
	/*
	 * When this bit is '1' it enables ring selection using the incoming
	 * spif and lcos for the packet.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_PORTCOS_MAPPING_MODE		UINT32_C(0x80)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dflt_ring_grp field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DFLT_RING_GRP		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the rss_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_RSS_RULE		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cos_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_COS_RULE		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the lb_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_LB_RULE		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_MRU			UINT32_C(0x10)
	/*
	 * This bit must be '1' for the default_rx_ring_id field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DEFAULT_RX_RING_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the default_cmpl_ring_id field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DEFAULT_CMPL_RING_ID	UINT32_C(0x40)
	/* This bit must be '1' for the queue_id field to be configured. */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_QUEUE_ID		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the rx_csum_v2_mode field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_RX_CSUM_V2_MODE	UINT32_C(0x100)
	/* This bit must be '1' for the l2_cqe_mode field to be configured. */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_L2_CQE_MODE		UINT32_C(0x200)
	/* Logical vnic ID */
	uint16_t	vnic_id;
	/*
	 * Default Completion ring for the VNIC. This ring will
	 * be chosen if packet does not match any RSS rules and if
	 * there is no COS rule.
	 */
	uint16_t	dflt_ring_grp;
	/*
	 * RSS ID for RSS rule/table structure. 0xFF... (All Fs) if
	 * there is no RSS rule.
	 */
	uint16_t	rss_rule;
	/*
	 * RSS ID for COS rule/table structure. 0xFF... (All Fs) if
	 * there is no COS rule.
	 */
	uint16_t	cos_rule;
	/*
	 * RSS ID for load balancing rule/table structure.
	 * 0xFF... (All Fs) if there is no LB rule.
	 */
	uint16_t	lb_rule;
	/*
	 * The maximum receive unit of the vnic.
	 * Each vnic is associated with a function.
	 * The vnic mru value overwrites the mru setting of the
	 * associated function.
	 * The HWRM shall make sure that vnic mru does not exceed
	 * the mru of the port the function is associated with.
	 */
	uint16_t	mru;
	/*
	 * Default Rx ring for the VNIC. This ring will
	 * be chosen if packet does not match any RSS rules.
	 * The aggregation ring associated with the Rx ring is
	 * implied based on the Rx ring specified when the
	 * aggregation ring was allocated.
	 */
	uint16_t	default_rx_ring_id;
	/*
	 * Default completion ring for the VNIC. This ring will
	 * be chosen if packet does not match any RSS rules.
	 */
	uint16_t	default_cmpl_ring_id;
	/*
	 * When specified, only incoming packets classified to the specified
	 * CoS queue ID will be arriving on this VNIC. Packet priority to CoS
	 * mapping rules can be specified using HWRM_QUEUE_PRI2COS_CFG. In this
	 * mode, ntuple filters with VNIC destination specified are invalid
	 * since they conflict with the CoS to VNIC steering rules in this
	 * mode.
	 *
	 * If this field is not specified, packet to VNIC steering will be
	 * subject to the standard L2 filter rules and any additional ntuple
	 * filter rules with destination VNIC specified.
	 */
	uint16_t	queue_id;
	/*
	 * If the device supports the RX V2 and RX TPA start V2 completion
	 * records as indicated by the HWRM_VNIC_QCAPS command, this field is
	 * used to specify the two RX checksum modes supported by these
	 * completion records.
	 */
	uint8_t	rx_csum_v2_mode;
	/*
	 * When configured with this checksum mode, the number of header
	 * groups in the delivered packet with a valid IP checksum and
	 * the number of header groups in the delivered packet with a valid
	 * L4 checksum are reported. Valid checksums are counted from the
	 * outermost header group to the innermost header group, stopping at
	 * the first error. This is the default checksum mode supported if
	 * the driver doesn't explicitly configure the RX checksum mode.
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_DEFAULT UINT32_C(0x0)
	/*
	 * When configured with this checksum mode, the checksum status is
	 * reported using 'all ok' mode. In the RX completion record, one
	 * bit indicates if the IP checksum is valid for all the parsed
	 * header groups with an IP checksum. Another bit indicates if the
	 * L4 checksum is valid for all the parsed header groups with an L4
	 * checksum. The number of header groups that were parsed by the
	 * chip and passed in the delivered packet is also reported.
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_ALL_OK  UINT32_C(0x1)
	/*
	 * Any rx_csum_v2_mode value larger than or equal to this is not
	 * valid
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_MAX	UINT32_C(0x2)
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_LAST   HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_MAX
	/*
	 * If the device supports different L2 RX CQE modes, as indicated by
	 * the HWRM_VNIC_QCAPS command, this field is used to configure the
	 * CQE mode.
	 */
	uint8_t	l2_cqe_mode;
	/*
	 * When configured with this cqe mode, A normal (32B) CQE
	 * will be generated. This is the default mode.
	 */
	#define HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_DEFAULT	UINT32_C(0x0)
	/*
	 * When configured with this cqe mode, A compressed (16B) CQE
	 * will be generated. In this mode TPA and HDS are not supported.
	 * Host drivers should not configure the TPA and HDS along with
	 * compressed mode, per VNIC. FW returns error, if host drivers
	 * try to configure the VNIC with compressed mode and (TPA or HDS).
	 * The compressed completion does not include PTP data. Host
	 * drivers should not use this mode to receive the PTP data.
	 */
	#define HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_COMPRESSED UINT32_C(0x1)
	/*
	 * When configured with this cqe mode, HW generates either a 32B
	 * completion or a 16B completion depending on use case within a
	 * VNIC. For ex. a simple L2 packet could use the compressed form
	 * while a PTP packet on the same VNIC would use the 32B form.
	 */
	#define HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_MIXED	UINT32_C(0x2)
	#define HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_LAST	HWRM_VNIC_CFG_INPUT_L2_CQE_MODE_MIXED
	uint8_t	unused0[4];
} hwrm_vnic_cfg_input_t, *phwrm_vnic_cfg_input_t;

/* hwrm_vnic_cfg_output (size:128b/16B) */

typedef struct hwrm_vnic_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_cfg_output_t, *phwrm_vnic_cfg_output_t;

/******************
 * hwrm_vnic_qcfg *
 ******************/


/* hwrm_vnic_qcfg_input (size:256b/32B) */

typedef struct hwrm_vnic_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_QCFG_INPUT_ENABLES_VF_ID_VALID	UINT32_C(0x1)
	/* Logical vnic ID */
	uint32_t	vnic_id;
	/* ID of Virtual Function whose VNIC resource is being queried. */
	uint16_t	vf_id;
	uint8_t	unused_0[6];
} hwrm_vnic_qcfg_input_t, *phwrm_vnic_qcfg_input_t;

/* hwrm_vnic_qcfg_output (size:256b/32B) */

typedef struct hwrm_vnic_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Default Completion ring for the VNIC. */
	uint16_t	dflt_ring_grp;
	/*
	 * RSS ID for RSS rule/table structure. 0xFF... (All Fs) if
	 * there is no RSS rule.
	 */
	uint16_t	rss_rule;
	/*
	 * RSS ID for COS rule/table structure. 0xFF... (All Fs) if
	 * there is no COS rule.
	 */
	uint16_t	cos_rule;
	/*
	 * RSS ID for load balancing rule/table structure.
	 * 0xFF... (All Fs) if there is no LB rule.
	 */
	uint16_t	lb_rule;
	/* The maximum receive unit of the vnic. */
	uint16_t	mru;
	uint8_t	unused_0[2];
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is the default VNIC for
	 * the function.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_DEFAULT				UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * strip VLAN in the RX path.
	 * If set to '0', then VLAN stripping is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_VLAN_STRIP_MODE			UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * buffer receive packets in the hardware until the host
	 * posts new receive buffers.
	 * If set to '0', then bd_stall is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_BD_STALL_MODE			UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * receive both RoCE and non-RoCE traffic.
	 * If set to '0', then this VNIC is not configured to
	 * operate in dual VNIC mode.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_DUAL_VNIC_MODE		UINT32_C(0x8)
	/*
	 * When this flag is set to '1', the VNIC is configured to
	 * receive only RoCE traffic.
	 * When this flag is set to '0', the VNIC is not configured
	 * to receive only RoCE traffic.
	 * If roce_dual_vnic_mode flag and this flag both are set
	 * to '1', then it is an invalid configuration of the
	 * VNIC. The HWRM should not allow that type of
	 * mis-configuration by HWRM clients.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_ONLY_VNIC_MODE		UINT32_C(0x10)
	/*
	 * When a VNIC uses one destination ring group for certain
	 * application (e.g. Receive Flow Steering) where
	 * exact match is used to direct packets to a VNIC with one
	 * destination ring group only, there is no need to configure
	 * RSS indirection table for that VNIC as only one destination
	 * ring group is used.
	 *
	 * When this bit is set to '1', then the VNIC is enabled in a
	 * mode where RSS is enabled in the VNIC using a RSS context
	 * for computing RSS hash but the RSS indirection table is
	 * not configured.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_RSS_DFLT_CR_MODE			UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * receive both RoCE and non-RoCE traffic, but forward only
	 * RoCE traffic further. Also RoCE traffic can be mirrored to
	 * L2 driver.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_MODE	UINT32_C(0x40)
	/*
	 * When this bit is '0', VNIC is in normal operation state.
	 * When this bit is '1', VNIC drops all the received packets.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_OPERATION_STATE			UINT32_C(0x80)
	/* When this bit is '1' it indicates port cos_mapping_mode enabled. */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_PORTCOS_MAPPING_MODE		UINT32_C(0x100)
	/*
	 * When returned with a valid CoS Queue id, the CoS Queue/VNIC
	 * association is valid. Otherwise it will return 0xFFFF to indicate no
	 * VNIC/CoS queue association.
	 */
	uint16_t	queue_id;
	/*
	 * If the device supports the RX V2 and RX TPA start V2 completion
	 * records as indicated by the HWRM_VNIC_QCAPS command, this field is
	 * used to specify the current RX checksum mode configured for all the
	 * RX rings of a VNIC.
	 */
	uint8_t	rx_csum_v2_mode;
	/*
	 * This value indicates that the VNIC is configured to use the
	 * default RX checksum mode for all the rings associated with this
	 * VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_DEFAULT UINT32_C(0x0)
	/*
	 * This value indicates that the VNIC is configured to use the RX
	 * checksum 'all_ok' mode for all the rings associated with this
	 * VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_ALL_OK  UINT32_C(0x1)
	/*
	 * Any rx_csum_v2_mode value larger than or equal to this is not
	 * valid
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_MAX	UINT32_C(0x2)
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_LAST   HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_MAX
	/*
	 * If the device supports different L2 RX CQE modes, as indicated by
	 * the HWRM_VNIC_QCAPS command, this field is used to convey the
	 * configured CQE mode.
	 */
	uint8_t	l2_cqe_mode;
	/*
	 * This value indicates that the VNIC is configured with normal
	 * (32B) CQE mode.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_DEFAULT	UINT32_C(0x0)
	/*
	 * This value indicates that the VNIC is configured with compressed
	 * (16B) CQE mode.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_COMPRESSED UINT32_C(0x1)
	/*
	 * This value indicates that the VNIC is configured with mixed
	 * CQE mode. HW generates either a 32B completion or a 16B
	 * completion depending on use case within a VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_MIXED	UINT32_C(0x2)
	#define HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_LAST	HWRM_VNIC_QCFG_OUTPUT_L2_CQE_MODE_MIXED
	/*
	 * This field conveys the metadata format type that has been
	 * configured. This value is product specific. Refer to the L2 HSI
	 * completion ring structures for the detailed descriptions. For Thor
	 * and Thor2, it corresponds to 'meta_format' in 'rx_pkt_cmpl_hi' and
	 * 'rx_pkt_v3_cmpl_hi', respectively.
	 */
	uint8_t	metadata_format_type;
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_0 UINT32_C(0x0)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_1 UINT32_C(0x1)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_2 UINT32_C(0x2)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_3 UINT32_C(0x3)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_4 UINT32_C(0x4)
	#define HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_LAST HWRM_VNIC_QCFG_OUTPUT_METADATA_FORMAT_TYPE_4
	/* This field conveys the VNIC operation state. */
	uint8_t	vnic_state;
	/* Normal operation state. */
	#define HWRM_VNIC_QCFG_OUTPUT_VNIC_STATE_NORMAL UINT32_C(0x0)
	/* Drop all packets. */
	#define HWRM_VNIC_QCFG_OUTPUT_VNIC_STATE_DROP   UINT32_C(0x1)
	#define HWRM_VNIC_QCFG_OUTPUT_VNIC_STATE_LAST  HWRM_VNIC_QCFG_OUTPUT_VNIC_STATE_DROP
	uint8_t	unused_1;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_qcfg_output_t, *phwrm_vnic_qcfg_output_t;

/*******************
 * hwrm_vnic_qcaps *
 *******************/


/* hwrm_vnic_qcaps_input (size:192b/24B) */

typedef struct hwrm_vnic_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	uint8_t	unused_0[4];
} hwrm_vnic_qcaps_input_t, *phwrm_vnic_qcaps_input_t;

/* hwrm_vnic_qcaps_output (size:192b/24B) */

typedef struct hwrm_vnic_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The maximum receive unit that is settable on a vnic. */
	uint16_t	mru;
	uint8_t	unused_0[2];
	uint32_t	flags;
	/* Unused. */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_UNUSED				UINT32_C(0x1)
	/*
	 * When this bit is '1', the capability of stripping VLAN in
	 * the RX path is supported on VNIC(s).
	 * If set to '0', then VLAN stripping capability is
	 * not supported on VNIC(s).
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VLAN_STRIP_CAP			UINT32_C(0x2)
	/*
	 * When this bit is '1', the capability to buffer receive
	 * packets in the hardware until the host posts new receive buffers
	 * is supported on VNIC(s).
	 * If set to '0', then bd_stall capability is not supported
	 * on VNIC(s).
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_BD_STALL_CAP				UINT32_C(0x4)
	/*
	 * When this bit is '1', the capability to
	 * receive both RoCE and non-RoCE traffic on VNIC(s) is
	 * supported.
	 * If set to '0', then the capability to receive
	 * both RoCE and non-RoCE traffic on VNIC(s) is
	 * not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_DUAL_VNIC_CAP			UINT32_C(0x8)
	/*
	 * When this bit is set to '1', the capability to configure
	 * a VNIC to receive only RoCE traffic is supported.
	 * When this flag is set to '0', the VNIC capability to
	 * configure to receive only RoCE traffic is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_ONLY_VNIC_CAP			UINT32_C(0x10)
	/*
	 * When this bit is set to '1', then the capability to enable
	 * a VNIC in a mode where RSS context without configuring
	 * RSS indirection table is supported (for RSS hash computation).
	 * When this bit is set to '0', then a VNIC can not be configured
	 * with a mode to enable RSS context without configuring RSS
	 * indirection table.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_DFLT_CR_CAP			UINT32_C(0x20)
	/*
	 * When this bit is '1', the capability to
	 * mirror the RoCE traffic is supported.
	 * If set to '0', then the capability to mirror the
	 * RoCE traffic is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_CAP	UINT32_C(0x40)
	/*
	 * When this bit is '1', the outermost RSS hashing capability
	 * is supported. If set to '0', then the outermost RSS hashing
	 * capability is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_OUTERMOST_RSS_CAP			UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that firmware supports the
	 * ability to steer incoming packets from one CoS queue to one
	 * VNIC. This optional feature can then be enabled
	 * using HWRM_VNIC_CFG on any VNIC. This feature is only
	 * available when NVM option 'enable_cos_classification' is set
	 * to 1. If set to '0', firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_COS_ASSIGNMENT_CAP			UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that HW and firmware supports
	 * the use of RX V2 and RX TPA start V2 completion records for all
	 * the RX rings of a VNIC. Once set, this feature is mandatory to
	 * be used for the RX rings of the VNIC. Additionally, two new RX
	 * checksum features supported by these completion records can be
	 * configured using the HWRM_VNIC_CFG on a VNIC. If set to '0', the
	 * HW and the firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RX_CMPL_V2_CAP			UINT32_C(0x200)
	/*
	 * When this bit is '1', it indicates that HW and firmware support
	 * vnic state change. Host drivers can change the vnic state using
	 * HWRM_VNIC_UPDATE. If set to '0', the HW and firmware do not
	 * support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VNIC_STATE_CAP			UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates that firmware supports
	 * virtio-net functions default VNIC allocation using
	 * HWRM_VNIC_ALLOC.
	 * This capability is available only on Proxy VEE PF. If set to '0',
	 * firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VIRTIO_NET_VNIC_ALLOC_CAP		UINT32_C(0x800)
	/*
	 * When this bit is set '1', then the capability to configure the
	 * metadata format in the RX completion is supported for the VNIC.
	 * When this bit is set to '0', then the capability to configure
	 * the metadata format in the RX completion is not supported for
	 * the VNIC.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_METADATA_FORMAT_CAP			UINT32_C(0x1000)
	/*
	 * When this bit is set '1', it indicates that firmware returns
	 * INVALID_PARAM error, if host drivers choose invalid hash type
	 * bit combinations in vnic_rss_cfg.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_STRICT_HASH_TYPE_CAP		UINT32_C(0x2000)
	/*
	 * When this bit is set '1', it indicates that firmware supports
	 * the hash_type include and exclude flags in hwrm_vnic_rss_cfg.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_HASH_TYPE_DELTA_CAP		UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates that HW is capable of using
	 * Toeplitz algorithm. This mode uses Toeplitz algorithm and
	 * provided Toeplitz hash key to hash the packets according to the
	 * configured hash type and hash mode. The Toeplitz hash results and
	 * the provided Toeplitz RSS indirection table are used to determine
	 * the RSS rings.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RING_SELECT_MODE_TOEPLITZ_CAP	UINT32_C(0x8000)
	/*
	 * When this bit is '1', it indicates that HW is capable of using
	 * XOR algorithm. This mode uses 'XOR' algorithm to hash the packets
	 * according to the configured hash type and hash mode. The XOR
	 * hash results and the provided XOR RSS indirection table are
	 * used to determine the RSS rings. Host drivers provided hash key
	 * is not honored in this mode.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RING_SELECT_MODE_XOR_CAP		UINT32_C(0x10000)
	/*
	 * When this bit is '1', it indicates that HW is capable of using
	 * checksum algorithm. In this mode, HW uses inner packets checksum
	 * algorithm to distribute the packets across the rings and Toeplitz
	 * algorithm to calculate the hash to convey it in the RX
	 * completions. Host drivers should provide Toeplitz hash key.
	 * As HW uses innermost packets checksum to distribute the packets
	 * across the rings, host drivers can't convey hash mode to choose
	 * outer headers to calculate Toeplitz hash. FW will fail such
	 * configuration.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RING_SELECT_MODE_TOEPLITZ_CHKSM_CAP	UINT32_C(0x20000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPV6 flow labels.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPV6_FLOW_LABEL_CAP		UINT32_C(0x40000)
	/*
	 * When this bit is '1', it indicates that HW and firmware supports
	 * the use of RX V3 and RX TPA start V3 completion records for all
	 * the RX rings of a VNIC. Once set, this feature is mandatory to
	 * be used for the RX rings of the VNIC. If set to '0', the
	 * HW and the firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RX_CMPL_V3_CAP			UINT32_C(0x80000)
	/*
	 * When this bit is '1' HW supports different RX CQE record types.
	 * Host drivers can choose the mode based on their application
	 * requirements like performance, TPA, HDS and PTP.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_L2_CQE_MODE_CAP			UINT32_C(0x100000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPv4 IPSEC AH SPI field.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPSEC_AH_SPI_IPV4_CAP		UINT32_C(0x200000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPv4 IPSEC ESP SPI field.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPSEC_ESP_SPI_IPV4_CAP		UINT32_C(0x400000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPv6 IPSEC AH SPI field.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPSEC_AH_SPI_IPV6_CAP		UINT32_C(0x800000)
	/*
	 * When this bit is '1' HW supports hash calculation
	 * based on IPv6 IPSEC ESP SPI field.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_IPSEC_ESP_SPI_IPV6_CAP		UINT32_C(0x1000000)
	/*
	 * When outermost_rss_cap is '1' and this bit is '1', the outermost
	 * RSS hash mode may be set on a PF or trusted VF.
	 * When outermost_rss_cap is '1' and this bit is '0', the outermost
	 * RSS hash mode may be set on a PF.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_OUTERMOST_RSS_TRUSTED_VF_CAP		UINT32_C(0x2000000)
	/*
	 * When this bit is '1' it indicates HW is capable of enabling ring
	 * selection using the incoming spif and lcos for the packet.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_PORTCOS_MAPPING_MODE			UINT32_C(0x4000000)
	/*
	 * When this bit is '1', it indicates controller enabled
	 * RSS profile TCAM mode.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_PROF_TCAM_MODE_ENABLED		UINT32_C(0x8000000)
	/* When this bit is '1' FW supports VNIC hash mode. */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VNIC_RSS_HASH_MODE_CAP		UINT32_C(0x10000000)
	/* When this bit is set to '1', hardware supports tunnel TPA. */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_HW_TUNNEL_TPA_CAP			UINT32_C(0x20000000)
	/*
	 * This field advertises the maximum concurrent TPA aggregations
	 * supported by the VNIC on new devices that support TPA v2 or v3.
	 * '0' means that both the TPA v2 and v3 are not supported.
	 */
	uint16_t	max_aggs_supported;
	uint8_t	unused_1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_qcaps_output_t, *phwrm_vnic_qcaps_output_t;

/*********************
 * hwrm_vnic_tpa_cfg *
 *********************/


/* hwrm_vnic_tpa_cfg_input (size:384b/48B) */

typedef struct hwrm_vnic_tpa_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) of
	 * non-tunneled TCP packets.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_TPA			UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) of
	 * tunneled TCP packets.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_ENCAP_TPA		UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) according
	 * to Windows Receive Segment Coalescing (RSC) rules.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_RSC_WND_UPDATE		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) according
	 * to Linux Generic Receive Offload (GRO) rules.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO			UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for TCP
	 * packets with IP ECN set to non-zero.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_WITH_ECN		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * GRE tunneled TCP packets only if all packets have the
	 * same GRE sequence.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_WITH_SAME_GRE_SEQ	UINT32_C(0x20)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * TCP/IPv4 packets with consecutively increasing IPIDs.
	 * In other words, the last packet that is being
	 * aggregated to an already existing aggregation context
	 * shall have IPID 1 more than the IPID of the last packet
	 * that was aggregated in that aggregation context.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO_IPID_CHECK		UINT32_C(0x40)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * TCP packets with the same TTL (IPv4) or Hop limit (IPv6)
	 * value.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO_TTL_CHECK		UINT32_C(0x80)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall DMA payload data using GRO rules.
	 * When this bit is '0', the VNIC shall DMA payload data
	 * using the more efficient LRO rules of filling all
	 * aggregation buffers.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_PACK_AS_GRO	UINT32_C(0x100)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the max_agg_segs field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGG_SEGS	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the max_aggs field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGGS	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the max_agg_timer field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGG_TIMER	UINT32_C(0x4)
	/* deprecated bit. Do not use!!! */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MIN_AGG_LEN	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the tnl_tpa_en_bitmap field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_TNL_TPA_EN	UINT32_C(0x10)
	/* Logical vnic ID */
	uint16_t	vnic_id;
	/*
	 * This is the maximum number of TCP segments that can
	 * be aggregated (unit is Log2). Max value is 31. On new
	 * devices supporting TPA v2, the unit is multiples of 4 and
	 * valid values are > 0 and <= 63.
	 */
	uint16_t	max_agg_segs;
	/* 1 segment */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_1   UINT32_C(0x0)
	/* 2 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_2   UINT32_C(0x1)
	/* 4 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_4   UINT32_C(0x2)
	/* 8 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_8   UINT32_C(0x3)
	/* Any segment size larger than this is not valid */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_MAX UINT32_C(0x1f)
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_LAST HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_MAX
	/*
	 * This is the maximum number of aggregations this VNIC is
	 * allowed (unit is Log2). Max value is 7. On new devices
	 * supporting TPA v2, this is in unit of 1 and must be > 0
	 * and <= max_aggs_supported in the hwrm_vnic_qcaps response
	 * to enable TPA v2.
	 */
	uint16_t	max_aggs;
	/* 1 aggregation */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_1   UINT32_C(0x0)
	/* 2 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_2   UINT32_C(0x1)
	/* 4 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_4   UINT32_C(0x2)
	/* 8 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_8   UINT32_C(0x3)
	/* 16 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_16  UINT32_C(0x4)
	/* Any aggregation size larger than this is not valid */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_MAX UINT32_C(0x7)
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_LAST HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_MAX
	uint8_t	unused_0[2];
	/*
	 * This is the maximum amount of time allowed for
	 * an aggregation context to complete after it was initiated.
	 */
	uint32_t	max_agg_timer;
	/*
	 * This is the minimum amount of payload length required to
	 * start an aggregation context. This field is deprecated and
	 * should be set to 0. The minimum length is set by firmware
	 * and can be queried using hwrm_vnic_tpa_qcfg.
	 */
	uint32_t	min_agg_len;
	/*
	 * If the device supports hardware tunnel TPA feature, as indicated by
	 * the HWRM_VNIC_QCAPS command, this field is used to configure the
	 * tunnel types to be enabled. Each bit corresponds to a specific
	 * tunnel type. If a bit is set to '1', then the associated tunnel
	 * type is enabled; otherwise, it is disabled.
	 */
	uint32_t	tnl_tpa_en_bitmap;
	/*
	 * When this bit is '1', enable VXLAN encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_VXLAN	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', enable GENEVE encapsulated packets
	 * for aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_GENEVE	UINT32_C(0x2)
	/*
	 * When this bit is set to '1', enable NVGRE encapsulated packets
	 * for aggregation..
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_NVGRE	UINT32_C(0x4)
	/*
	 * When this bit is set to '1', enable GRE encapsulated packets
	 * for aggregation..
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_GRE		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', enable IPV4 encapsulated packets
	 * for aggregation..
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_IPV4		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', enable IPV6 encapsulated packets
	 * for aggregation..
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_IPV6		UINT32_C(0x20)
	/*
	 * When this bit is '1', enable VXLAN_GPE encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_VXLAN_GPE	UINT32_C(0x40)
	/*
	 * When this bit is '1', enable VXLAN_CUSTOMER1 encapsulated packets
	 * for aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_VXLAN_CUST1	UINT32_C(0x80)
	/*
	 * When this bit is '1', enable GRE_CUSTOMER1 encapsulated packets
	 * for aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_GRE_CUST1	UINT32_C(0x100)
	/*
	 * When this bit is '1', enable UPAR1 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_UPAR1	UINT32_C(0x200)
	/*
	 * When this bit is '1', enable UPAR2 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_UPAR2	UINT32_C(0x400)
	/*
	 * When this bit is '1', enable UPAR3 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_UPAR3	UINT32_C(0x800)
	/*
	 * When this bit is '1', enable UPAR4 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_UPAR4	UINT32_C(0x1000)
	/*
	 * When this bit is '1', enable UPAR5 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_UPAR5	UINT32_C(0x2000)
	/*
	 * When this bit is '1', enable UPAR6 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_UPAR6	UINT32_C(0x4000)
	/*
	 * When this bit is '1', enable UPAR7 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_UPAR7	UINT32_C(0x8000)
	/*
	 * When this bit is '1', enable UPAR8 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_TNL_TPA_EN_BITMAP_UPAR8	UINT32_C(0x10000)
	uint8_t	unused_1[4];
} hwrm_vnic_tpa_cfg_input_t, *phwrm_vnic_tpa_cfg_input_t;

/* hwrm_vnic_tpa_cfg_output (size:128b/16B) */

typedef struct hwrm_vnic_tpa_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_tpa_cfg_output_t, *phwrm_vnic_tpa_cfg_output_t;

/**********************
 * hwrm_vnic_tpa_qcfg *
 **********************/


/* hwrm_vnic_tpa_qcfg_input (size:192b/24B) */

typedef struct hwrm_vnic_tpa_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint16_t	vnic_id;
	uint8_t	unused_0[6];
} hwrm_vnic_tpa_qcfg_input_t, *phwrm_vnic_tpa_qcfg_input_t;

/* hwrm_vnic_tpa_qcfg_output (size:256b/32B) */

typedef struct hwrm_vnic_tpa_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is configured to
	 * perform transparent packet aggregation (TPA) of
	 * non-tunneled TCP packets.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_TPA			UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * perform transparent packet aggregation (TPA) of
	 * tunneled TCP packets.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_ENCAP_TPA		UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * perform transparent packet aggregation (TPA) according
	 * to Windows Receive Segment Coalescing (RSC) rules.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_RSC_WND_UPDATE		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * perform transparent packet aggregation (TPA) according
	 * to Linux Generic Receive Offload (GRO) rules.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_GRO			UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * perform transparent packet aggregation (TPA) for TCP
	 * packets with IP ECN set to non-zero.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_AGG_WITH_ECN		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * perform transparent packet aggregation (TPA) for
	 * GRE tunneled TCP packets only if all packets have the
	 * same GRE sequence.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_AGG_WITH_SAME_GRE_SEQ	UINT32_C(0x20)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC is configured to
	 * perform transparent packet aggregation (TPA) for
	 * TCP/IPv4 packets with consecutively increasing IPIDs.
	 * In other words, the last packet that is being
	 * aggregated to an already existing aggregation context
	 * shall have IPID 1 more than the IPID of the last packet
	 * that was aggregated in that aggregation context.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_GRO_IPID_CHECK		UINT32_C(0x40)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC is configured to
	 * perform transparent packet aggregation (TPA) for
	 * TCP packets with the same TTL (IPv4) or Hop limit (IPv6)
	 * value.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_GRO_TTL_CHECK		UINT32_C(0x80)
	/*
	 * This is the maximum number of TCP segments that can
	 * be aggregated (unit is Log2). Max value is 31.
	 */
	uint16_t	max_agg_segs;
	/* 1 segment */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_1   UINT32_C(0x0)
	/* 2 segments */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_2   UINT32_C(0x1)
	/* 4 segments */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_4   UINT32_C(0x2)
	/* 8 segments */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_8   UINT32_C(0x3)
	/* Any segment size larger than this is not valid */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_MAX UINT32_C(0x1f)
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_LAST HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_MAX
	/*
	 * This is the maximum number of aggregations this VNIC is
	 * allowed (unit is Log2). Max value is 7
	 */
	uint16_t	max_aggs;
	/* 1 aggregation */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_1   UINT32_C(0x0)
	/* 2 aggregations */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_2   UINT32_C(0x1)
	/* 4 aggregations */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_4   UINT32_C(0x2)
	/* 8 aggregations */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_8   UINT32_C(0x3)
	/* 16 aggregations */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_16  UINT32_C(0x4)
	/* Any aggregation size larger than this is not valid */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_MAX UINT32_C(0x7)
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_LAST HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_MAX
	/*
	 * This is the maximum amount of time allowed for
	 * an aggregation context to complete after it was initiated.
	 */
	uint32_t	max_agg_timer;
	/*
	 * This is the minimum amount of payload length required to
	 * start an aggregation context.
	 */
	uint32_t	min_agg_len;
	/*
	 * If the device supports hardware tunnel TPA feature, as indicated by
	 * the HWRM_VNIC_QCAPS command, this field conveys the bitmap of the
	 * tunnel types that have been configured. Each bit corresponds to a
	 * specific tunnel type. If a bit is set to '1', then the associated
	 * tunnel type is enabled; otherwise, it is disabled.
	 */
	uint32_t	tnl_tpa_en_bitmap;
	/*
	 * When this bit is '1', enable VXLAN encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_VXLAN	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', enable GENEVE encapsulated packets
	 * for aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_GENEVE	UINT32_C(0x2)
	/*
	 * When this bit is set to '1', enable NVGRE encapsulated packets
	 * for aggregation..
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_NVGRE	UINT32_C(0x4)
	/*
	 * When this bit is set to '1', enable GRE encapsulated packets
	 * for aggregation..
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_GRE		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', enable IPV4 encapsulated packets
	 * for aggregation..
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_IPV4		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', enable IPV6 encapsulated packets
	 * for aggregation..
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_IPV6		UINT32_C(0x20)
	/*
	 * When this bit is '1', enable VXLAN_GPE encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_VXLAN_GPE	UINT32_C(0x40)
	/*
	 * When this bit is '1', enable VXLAN_CUSTOMER1 encapsulated packets
	 * for aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_VXLAN_CUST1	UINT32_C(0x80)
	/*
	 * When this bit is '1', enable GRE_CUSTOMER1 encapsulated packets
	 * for aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_GRE_CUST1	UINT32_C(0x100)
	/*
	 * When this bit is '1', enable UPAR1 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_UPAR1	UINT32_C(0x200)
	/*
	 * When this bit is '1', enable UPAR2 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_UPAR2	UINT32_C(0x400)
	/*
	 * When this bit is '1', enable UPAR3 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_UPAR3	UINT32_C(0x800)
	/*
	 * When this bit is '1', enable UPAR4 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_UPAR4	UINT32_C(0x1000)
	/*
	 * When this bit is '1', enable UPAR5 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_UPAR5	UINT32_C(0x2000)
	/*
	 * When this bit is '1', enable UPAR6 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_UPAR6	UINT32_C(0x4000)
	/*
	 * When this bit is '1', enable UPAR7 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_UPAR7	UINT32_C(0x8000)
	/*
	 * When this bit is '1', enable UPAR8 encapsulated packets for
	 * aggregation.
	 */
	#define HWRM_VNIC_TPA_QCFG_OUTPUT_TNL_TPA_EN_BITMAP_UPAR8	UINT32_C(0x10000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_tpa_qcfg_output_t, *phwrm_vnic_tpa_qcfg_output_t;

/*********************
 * hwrm_vnic_rss_cfg *
 *********************/


/* hwrm_vnic_rss_cfg_input (size:384b/48B) */

typedef struct hwrm_vnic_rss_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV4		UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_TCP_IPV4		UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_UDP_IPV4		UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv6 addresses of IPv6
	 * packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV6		UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_TCP_IPV6		UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_UDP_IPV6		UINT32_C(0x20)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source, destination IPv6 addresses and flow label of IPv6
	 * packets. Hash type ipv6 and ipv6_flow_label are mutually
	 * exclusive. HW does not include the flow_label in hash
	 * calculation for the packets that are matching tcp_ipv6 and
	 * udp_ipv6 hash types. Host drivers should set this bit based on
	 * rss_ipv6_flow_label_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV6_FLOW_LABEL	UINT32_C(0x40)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv4 addresses and IPSEC AH SPI field of IPSEC
	 * AH/IPv4 packets. Host drivers should set this bit based on
	 * rss_ipsec_ah_spi_ipv4_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_AH_SPI_IPV4	UINT32_C(0x80)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv4 addresses and IPSEC ESP SPI field of IPSEC
	 * ESP/IPv4 packets. Host drivers should set this bit based on
	 * rss_ipsec_esp_spi_ipv4_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_ESP_SPI_IPV4	UINT32_C(0x100)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv6 addresses and IPSEC AH SPI field of IPSEC
	 * AH/IPv6 packets. Host drivers should set this bit based on
	 * rss_ipsec_ah_spi_ipv6_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_AH_SPI_IPV6	UINT32_C(0x200)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv6 addresses and IPSEC ESP SPI field of IPSEC
	 * ESP/IPv6 packets. Host drivers should set this bit based on
	 * rss_ipsec_esp_spi_ipv6_cap.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_ESP_SPI_IPV6	UINT32_C(0x400)
	/* VNIC ID of VNIC associated with RSS table being configured. */
	uint16_t	vnic_id;
	/*
	 * Specifies which VNIC ring table pair to configure.
	 * Valid values range from 0 to 7.
	 */
	uint8_t	ring_table_pair_index;
	/*
	 * Flags to specify different RSS hash modes. Global RSS hash mode is
	 * indicated when vnic_id and rss_ctx_idx fields are set to value of
	 * 0xffff. Only PF can initiate global RSS hash mode setting changes.
	 * VNIC RSS hash mode is indicated with valid vnic_id and rss_ctx_idx,
	 * if FW is VNIC_RSS_HASH_MODE capable. FW configures the mode based
	 * on first come first serve order. Global RSS hash mode and VNIC RSS
	 * hash modes are mutually exclusive. FW returns invalid error
	 * if FW receives conflicting requests. To change the current hash
	 * mode, the mode associated drivers need to be unloaded and apply
	 * the new configuration.
	 */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1' and FW is VNIC_RSS_HASH_MODE capable,
	 * innermost_4 and innermost_2 hash modes are used to configure
	 * the tuple mode. When this bit is '1' and FW is not
	 * VNIC_RSS_HASH_MODE capable, It indicates using current RSS hash
	 * mode setting configured in the device otherwise.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_DEFAULT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_4	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_4	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_2	UINT32_C(0x10)
	/* This is the address for rss ring group table */
	uint64_t	ring_grp_tbl_addr;
	/* This is the address for rss hash key table */
	uint64_t	hash_key_tbl_addr;
	/* Index to the rss indirection table. */
	uint16_t	rss_ctx_idx;
	uint8_t	flags;
	/*
	 * When this bit is '1', it indicates that the hash_type field is
	 * interpreted as a change relative the current configuration. Each
	 * '1' bit in hash_type represents a header to add to the current
	 * hash. Zeroes designate the hash_type state bits that should remain
	 * unchanged, if possible. If this constraint on the existing state
	 * cannot be satisfied, then the implementation should preference
	 * adding other headers so as to honor the request to add the
	 * specified headers. It is an error to set this flag concurrently
	 * with hash_type_exclude.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_FLAGS_HASH_TYPE_INCLUDE		UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that the hash_type field is
	 * interpreted as a change relative the current configuration. Each
	 * '1' bit in hash_type represents a header to remove from the
	 * current hash. Zeroes designate the hash_type state bits that
	 * should remain unchanged, if possible. If this constraint on the
	 * existing state cannot be satisfied, then the implementation should
	 * preference removing other headers so as to honor the request to
	 * remove the specified headers. It is an error to set this flag
	 * concurrently with hash_type_include.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_FLAGS_HASH_TYPE_EXCLUDE		UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that the support of setting
	 * ipsec hash_types by the host drivers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_FLAGS_IPSEC_HASH_TYPE_CFG_SUPPORT	UINT32_C(0x4)
	uint8_t	ring_select_mode;
	/*
	 * In this mode, HW uses Toeplitz algorithm and provided Toeplitz
	 * hash key to hash the packets according to the configured hash
	 * type and hash mode. The Toeplitz hash results and the provided
	 * Toeplitz RSS indirection table are used to determine the RSS
	 * rings.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_TOEPLITZ	UINT32_C(0x0)
	/*
	 * In this mode, HW uses XOR algorithm to hash the packets according
	 * to the configured hash type and hash mode. The XOR hash results
	 * and the provided XOR RSS indirection table are used to determine
	 * the RSS rings. Host drivers provided hash key is not honored in
	 * this mode.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_XOR		UINT32_C(0x1)
	/*
	 * In this mode, HW uses inner packets checksum algorithm to
	 * distribute the packets across the rings and Toeplitz algorithm
	 * to calculate the hash to convey it in the RX completions. Host
	 * drivers should provide Toeplitz hash key. As HW uses innermost
	 * packets checksum to distribute the packets across the rings,
	 * host drivers can't convey hash mode to choose outer headers to
	 * calculate Toeplitz hash. FW will fail such configuration.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_TOEPLITZ_CHECKSUM UINT32_C(0x2)
	#define HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_LAST		HWRM_VNIC_RSS_CFG_INPUT_RING_SELECT_MODE_TOEPLITZ_CHECKSUM
	uint8_t	unused_1[4];
} hwrm_vnic_rss_cfg_input_t, *phwrm_vnic_rss_cfg_input_t;

/* hwrm_vnic_rss_cfg_output (size:128b/16B) */

typedef struct hwrm_vnic_rss_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_rss_cfg_output_t, *phwrm_vnic_rss_cfg_output_t;

/* hwrm_vnic_rss_cfg_cmd_err (size:64b/8B) */

typedef struct hwrm_vnic_rss_cfg_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_UNKNOWN		UINT32_C(0x0)
	/*
	 * Unable to change global RSS mode to outer due to all active
	 * interfaces are not ready to support outer RSS hashing.
	 */
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_INTERFACE_NOT_READY UINT32_C(0x1)
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_LAST		HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_INTERFACE_NOT_READY
	uint8_t	unused_0[7];
} hwrm_vnic_rss_cfg_cmd_err_t, *phwrm_vnic_rss_cfg_cmd_err_t;

/**********************
 * hwrm_vnic_rss_qcfg *
 **********************/


/* hwrm_vnic_rss_qcfg_input (size:192b/24B) */

typedef struct hwrm_vnic_rss_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Index to the rss indirection table. This field is used as a lookup
	 * for chips before Thor - i.e. Cumulus and Whitney.
	 */
	uint16_t	rss_ctx_idx;
	/*
	 * VNIC ID of VNIC associated with RSS table being queried. This field
	 * is used as a lookup for Thor and later chips.
	 */
	uint16_t	vnic_id;
	uint8_t	unused_0[4];
} hwrm_vnic_rss_qcfg_input_t, *phwrm_vnic_rss_qcfg_input_t;

/* hwrm_vnic_rss_qcfg_output (size:512b/64B) */

typedef struct hwrm_vnic_rss_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV4		UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_TCP_IPV4		UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_UDP_IPV4		UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv6 addresses of IPv6
	 * packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV6		UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_TCP_IPV6		UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_UDP_IPV6		UINT32_C(0x20)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source, destination IPv6 addresses and flow label of IPv6
	 * packets. Hash type ipv6 and ipv6_flow_label are mutually
	 * exclusive. HW does not include the flow_label in hash
	 * calculation for the packets that are matching tcp_ipv6 and
	 * udp_ipv6 hash types. This bit will be '0' if
	 * rss_ipv6_flow_label_cap is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV6_FLOW_LABEL	UINT32_C(0x40)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv4 addresses and IPSEC AH SPI field of IPSEC
	 * AH/IPv4 packets. This bit will be '0' if rss_ipsec_ah_spi_ipv4_cap
	 * is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_AH_SPI_IPV4	UINT32_C(0x80)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv4 addresses and IPSEC ESP SPI field of IPSEC
	 * ESP/IPv4 packets. This bit will be '0' if
	 * rss_ipsec_esp_spi_ipv4_cap is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_ESP_SPI_IPV4	UINT32_C(0x100)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv6 addresses and IPSEC AH SPI field of IPSEC
	 * AH/IPv6 packets. This bit will be '0' if
	 * rss_ipsec_ah_spi_ipv6_cap is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_AH_SPI_IPV6	UINT32_C(0x200)
	/*
	 * When this bit is '1', the RSS hash shall be computed over
	 * source/destination IPv6 addresses and IPSEC ESP SPI field of IPSEC
	 * ESP/IPv6 packets. This bit will be '0' if
	 * rss_ipsec_esp_spi_ipv6_cap is '0'.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_ESP_SPI_IPV6	UINT32_C(0x400)
	uint8_t	unused_0[4];
	/* This is the value of rss hash key */
	uint32_t	hash_key[10];
	/*
	 * Flags to specify different RSS hash modes. Setting rss_ctx_idx to
	 * the value of 0xffff implies a global RSS configuration query.
	 * hash_mode_flags are only valid for global RSS configuration query.
	 * Only the PF can initiate a global RSS configuration query.
	 * The query request fails if any VNIC is configured with hash mode
	 * and rss_ctx_idx is 0xffff.
	 */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1' and FW is VNIC_RSS_HASH_MODE capable,
	 * it indicates VNIC's configured RSS hash mode.
	 * When this bit is '1' and FW is not VNIC_RSS_HASH_MODE capable,
	 * It indicates using current RSS hash mode setting configured in the
	 * device.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_DEFAULT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_4	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_4	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_2	UINT32_C(0x10)
	uint8_t	ring_select_mode;
	/*
	 * In this mode, HW uses Toeplitz algorithm and provided Toeplitz
	 * hash key to hash the packets according to the configured hash
	 * type and hash mode. The Toeplitz hash results and the provided
	 * Toeplitz RSS indirection table are used to determine the RSS
	 * rings.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_TOEPLITZ	UINT32_C(0x0)
	/*
	 * In this mode, HW uses XOR algorithm to hash the packets according
	 * to the configured hash type and hash mode. The XOR hash results
	 * and the provided XOR RSS indirection table are used to determine
	 * the RSS rings. Host drivers provided hash key is not honored in
	 * this mode.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_XOR		UINT32_C(0x1)
	/*
	 * In this mode, HW uses inner packets checksum algorithm to
	 * distribute the packets across the rings and Toeplitz algorithm
	 * to calculate the hash to convey it in the RX completions. Host
	 * drivers should provide Toeplitz hash key. As HW uses innermost
	 * packets checksum to distribute the packets across the rings,
	 * host drivers can't convey hash mode to choose outer headers to
	 * calculate Toeplitz hash. FW will fail such configuration.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_TOEPLITZ_CHECKSUM UINT32_C(0x2)
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_LAST		HWRM_VNIC_RSS_QCFG_OUTPUT_RING_SELECT_MODE_TOEPLITZ_CHECKSUM
	uint8_t	unused_1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_rss_qcfg_output_t, *phwrm_vnic_rss_qcfg_output_t;

/**************************
 * hwrm_vnic_plcmodes_cfg *
 **************************/


/* hwrm_vnic_plcmodes_cfg_input (size:320b/40B) */

typedef struct hwrm_vnic_plcmodes_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * use regular placement algorithm.
	 * By default, the regular placement algorithm shall be
	 * enabled on the VNIC.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_REGULAR_PLACEMENT	UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * use the jumbo placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_JUMBO_PLACEMENT	UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for IPv4 packets according
	 * to the following rules:
	 * # If the packet is identified as TCP/IPv4, then the
	 * packet is split at the beginning of the TCP payload.
	 * # If the packet is identified as UDP/IPv4, then the
	 * packet is split at the beginning of UDP payload.
	 * # If the packet is identified as non-TCP and non-UDP
	 * IPv4 packet, then the packet is split at the beginning
	 * of the upper layer protocol header carried in the IPv4
	 * packet.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_IPV4		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for IPv6 packets according
	 * to the following rules:
	 * # If the packet is identified as TCP/IPv6, then the
	 * packet is split at the beginning of the TCP payload.
	 * # If the packet is identified as UDP/IPv6, then the
	 * packet is split at the beginning of UDP payload.
	 * # If the packet is identified as non-TCP and non-UDP
	 * IPv6 packet, then the packet is split at the beginning
	 * of the upper layer protocol header carried in the IPv6
	 * packet.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_IPV6		UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for FCoE packets at the
	 * beginning of FC payload.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_FCOE		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for RoCE packets at the
	 * beginning of RoCE payload (after BTH/GRH headers).
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_ROCE		UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC shall be configured use the virtio
	 * placement algorithm. This feature can only be configured when
	 * proxy mode is supported on the function.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_VIRTIO_PLACEMENT	UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the jumbo_thresh_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_JUMBO_THRESH_VALID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the hds_offset_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_HDS_OFFSET_VALID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the hds_threshold_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_HDS_THRESHOLD_VALID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the max_bds_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_MAX_BDS_VALID	UINT32_C(0x8)
	/* Logical vnic ID */
	uint32_t	vnic_id;
	/*
	 * When jumbo placement algorithm is enabled, this value
	 * is used to determine the threshold for jumbo placement.
	 * Packets with length larger than this value will be
	 * placed according to the jumbo placement algorithm.
	 */
	uint16_t	jumbo_thresh;
	/*
	 * This value is used to determine the offset into
	 * packet buffer where the split data (payload) will be
	 * placed according to one of HDS placement algorithm.
	 *
	 * The lengths of packet buffers provided for split data
	 * shall be larger than this value.
	 */
	uint16_t	hds_offset;
	/*
	 * When one of the HDS placement algorithm is enabled, this
	 * value is used to determine the threshold for HDS
	 * placement.
	 * Packets with length larger than this value will be
	 * placed according to the HDS placement algorithm.
	 * This value shall be in multiple of 4 bytes.
	 */
	uint16_t	hds_threshold;
	/*
	 * When virtio placement algorithm is enabled, this
	 * value is used to determine the maximum number of BDs
	 * that can be used to place an Rx Packet.
	 * If an incoming packet does not fit in the buffers described
	 * by the max BDs, the packet will be dropped and an error
	 * will be reported in the completion. Valid values for this
	 * field are between 1 and 8. If the VNIC uses header-data-
	 * separation and/or TPA with buffer spanning enabled, valid
	 * values for this field are between 2 and 8.
	 * This feature can only be configured when proxy mode is
	 * supported on the function.
	 */
	uint16_t	max_bds;
	uint8_t	unused_0[4];
} hwrm_vnic_plcmodes_cfg_input_t, *phwrm_vnic_plcmodes_cfg_input_t;

/* hwrm_vnic_plcmodes_cfg_output (size:128b/16B) */

typedef struct hwrm_vnic_plcmodes_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_vnic_plcmodes_cfg_output_t, *phwrm_vnic_plcmodes_cfg_output_t;

/***************************
 * hwrm_vnic_plcmodes_qcfg *
 ***************************/


/* hwrm_vnic_plcmodes_qcfg_input (size:192b/24B) */

typedef struct hwrm_vnic_plcmodes_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[4];
} hwrm_vnic_plcmodes_qcfg_input_t, *phwrm_vnic_plcmodes_qcfg_input_t;

/* hwrm_vnic_plcmodes_qcfg_output (size:192b/24B) */

typedef struct hwrm_vnic_plcmodes_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is configured to
	 * use regular placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_REGULAR_PLACEMENT	UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * use the jumbo placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_JUMBO_PLACEMENT	UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for IPv4 packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_IPV4		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for IPv6 packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_IPV6		UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for FCoE packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_FCOE		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for RoCE packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_ROCE		UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to be the default VNIC of the requesting function.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_DFLT_VNIC		UINT32_C(0x40)
	/*
	 * When this bit is '1', the VNIC is configured to use the virtio
	 * placement algorithm. This feature can only be configured when
	 * proxy mode is supported on the function.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_VIRTIO_PLACEMENT	UINT32_C(0x80)
	/*
	 * When jumbo placement algorithm is enabled, this value
	 * is used to determine the threshold for jumbo placement.
	 * Packets with length larger than this value will be
	 * placed according to the jumbo placement algorithm.
	 */
	uint16_t	jumbo_thresh;
	/*
	 * This value is used to determine the offset into
	 * packet buffer where the split data (payload) will be
	 * placed according to one of HDS placement algorithm.
	 *
	 * The lengths of packet buffers provided for split data
	 * shall be larger than this value.
	 */
	uint16_t	hds_offset;
	/*
	 * When one of the HDS placement algorithm is enabled, this
	 * value is used to determine the threshold for HDS
	 * placement.
	 * Packets with length larger than this value will be
	 * placed according to the HDS placement algorithm.
	 * This value shall be in multiple of 4 bytes.
	 */
	uint16_t	hds_threshold;
	/*
	 * When virtio placement algorithm is enabled, this
	 * value is used to determine the maximum number of BDs
	 * that can be used to place an Rx Packet.
	 * If an incoming packet does not fit in the buffers described
	 * by the max BDs, the packet will be dropped and an error
	 * will be reported in the completion. Valid values for this
	 * field are between 1 and 8. If the VNIC uses header-data-
	 * separation and/or TPA with buffer spanning enabled, valid
	 * values for this field are between 2 and 8.
	 * This feature can only be configured when proxy mode is supported
	 * on the function
	 */
	uint16_t	max_bds;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_vnic_plcmodes_qcfg_output_t, *phwrm_vnic_plcmodes_qcfg_output_t;

/**********************************
 * hwrm_vnic_rss_cos_lb_ctx_alloc *
 **********************************/


/* hwrm_vnic_rss_cos_lb_ctx_alloc_input (size:128b/16B) */

typedef struct hwrm_vnic_rss_cos_lb_ctx_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_vnic_rss_cos_lb_ctx_alloc_input_t, *phwrm_vnic_rss_cos_lb_ctx_alloc_input_t;

/* hwrm_vnic_rss_cos_lb_ctx_alloc_output (size:128b/16B) */

typedef struct hwrm_vnic_rss_cos_lb_ctx_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* rss_cos_lb_ctx_id is 16 b */
	uint16_t	rss_cos_lb_ctx_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_rss_cos_lb_ctx_alloc_output_t, *phwrm_vnic_rss_cos_lb_ctx_alloc_output_t;

/*********************************
 * hwrm_vnic_rss_cos_lb_ctx_free *
 *********************************/


/* hwrm_vnic_rss_cos_lb_ctx_free_input (size:192b/24B) */

typedef struct hwrm_vnic_rss_cos_lb_ctx_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* rss_cos_lb_ctx_id is 16 b */
	uint16_t	rss_cos_lb_ctx_id;
	uint8_t	unused_0[6];
} hwrm_vnic_rss_cos_lb_ctx_free_input_t, *phwrm_vnic_rss_cos_lb_ctx_free_input_t;

/* hwrm_vnic_rss_cos_lb_ctx_free_output (size:128b/16B) */

typedef struct hwrm_vnic_rss_cos_lb_ctx_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_rss_cos_lb_ctx_free_output_t, *phwrm_vnic_rss_cos_lb_ctx_free_output_t;

/*******************
 * hwrm_ring_alloc *
 *******************/


/* hwrm_ring_alloc_input (size:704b/88B) */

typedef struct hwrm_ring_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ring_arb_cfg field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RING_ARB_CFG	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the stat_ctx_id_valid field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_STAT_CTX_ID_VALID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the max_bw_valid field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_MAX_BW_VALID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the rx_ring_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RX_RING_ID_VALID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the nq_ring_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_NQ_RING_ID_VALID	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the rx_buf_size field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RX_BUF_SIZE_VALID	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the schq_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_SCHQ_ID		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the mpc_chnls_type field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_MPC_CHNLS_TYPE	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the steering_tag field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_STEERING_TAG_VALID	UINT32_C(0x800)
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_L2_CMPL   UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_TX	UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_RX	UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_ROCE_CMPL UINT32_C(0x3)
	/* RX Aggregation Ring */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_RX_AGG	UINT32_C(0x4)
	/* Notification Queue */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_NQ	UINT32_C(0x5)
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_LAST	HWRM_RING_ALLOC_INPUT_RING_TYPE_NQ
	/*
	 * This field controls the number of packets transmitted before a TX
	 * completion is generated. Non-zero values for the field are only
	 * valid if HWRM_FUNC_QCAPS indicates that the TX coalesced completion
	 * records capability is supported.
	 */
	uint8_t	cmpl_coal_cnt;
	/* Generates a legacy TX completion on every packet. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_OFF UINT32_C(0x0)
	/* Generates a TX coalesced completion for up to 4 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_4   UINT32_C(0x1)
	/* Generates a TX coalesced completion for up to 8 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_8   UINT32_C(0x2)
	/* Generates a TX coalesced completion for up to 12 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_12  UINT32_C(0x3)
	/* Generates a TX coalesced completion for up to 16 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_16  UINT32_C(0x4)
	/* Generates a TX coalesced completion for up to 24 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_24  UINT32_C(0x5)
	/* Generates a TX coalesced completion for up to 32 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_32  UINT32_C(0x6)
	/* Generates a TX coalesced completion for up to 48 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_48  UINT32_C(0x7)
	/* Generates a TX coalesced completion for up to 64 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_64  UINT32_C(0x8)
	/* Generates a TX coalesced completion for up to 96 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_96  UINT32_C(0x9)
	/* Generates a TX coalesced completion for up to 128 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_128 UINT32_C(0xa)
	/* Generates a TX coalesced completion for up to 192 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_192 UINT32_C(0xb)
	/* Generates a TX coalesced completion for up to 256 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_256 UINT32_C(0xc)
	/* Generates a TX coalesced completion for up to 320 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_320 UINT32_C(0xd)
	/* Generates a TX coalesced completion for up to 384 TX packets. */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_384 UINT32_C(0xe)
	/* Generates a TX coalesced completion up to the last packet. (Maximum coalescing). */
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_MAX UINT32_C(0xf)
	#define HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_LAST	HWRM_RING_ALLOC_INPUT_CMPL_COAL_CNT_COAL_MAX
	/* Ring allocation flags. */
	uint16_t	flags;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B or 2B offset from the start of the Rx packet buffer. When
	 * '1', the received packet will be padded with 2B of zeros at the
	 * front of the packet. Note that this flag is only used for
	 * Rx rings and is ignored for all other rings included Rx
	 * Aggregation rings.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_RX_SOP_PAD			UINT32_C(0x1)
	/*
	 * When the HW Doorbell Drop Recovery feature is enabled,
	 * HW can flag false CQ overflow when CQ consumer index
	 * doorbells are dropped when there really wasn't any overflow.
	 * The CQE values could have already been processed by the driver,
	 * but HW doesn't know about this because of the doorbell drop.
	 * To avoid false detection of CQ overflow events,
	 * it is recommended that CQ overflow detection is disabled
	 * by the driver when HW based doorbell recovery is enabled.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_DISABLE_CQ_OVERFLOW_DETECTION	UINT32_C(0x2)
	/*
	 * Used with enhanced Doorbell Pacing feature, when set to '1'
	 * this flag indicates that the NQ id that's allocated should be
	 * used for DBR pacing notifications.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_NQ_DBR_PACING			UINT32_C(0x4)
	/*
	 * Host driver should set this flag bit to '1' to enable
	 * two-completion TX packet timestamp feature. By enabling this
	 * per QP flag and enabling stamp bit in TX BD lflags, host drivers
	 * expect two completions, one for regular TX completion and the
	 * other completion with timestamp. For a QP with both completion
	 * coalescing and timestamp completion features enabled, completion
	 * coalescing takes place on regular TX completions. The timestamp
	 * completions are not coalesced and a separate timestamp completion
	 * is generated for each packet with stamp bit set in the TX BD
	 * lflags.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_TX_PKT_TS_CMPL_ENABLE		UINT32_C(0x8)
	/*
	 * This value is a pointer to the page table for the
	 * Ring.
	 */
	uint64_t	page_tbl_addr;
	/* First Byte Offset of the first entry in the first page. */
	uint32_t	fbo;
	/*
	 * Actual page size in 2^page_size. The supported range is increments
	 * in powers of 2 from 16 bytes to 1GB.
	 * - 4 = 16 B
	 *	Page size is 16 B.
	 * - 12 = 4 KB
	 *	Page size is 4 KB.
	 * - 13 = 8 KB
	 *	Page size is 8 KB.
	 * - 16 = 64 KB
	 *	Page size is 64 KB.
	 * - 21 = 2 MB
	 *	Page size is 2 MB.
	 * - 22 = 4 MB
	 *	Page size is 4 MB.
	 * - 30 = 1 GB
	 *	Page size is 1 GB.
	 */
	uint8_t	page_size;
	/*
	 * This value indicates the depth of page table.
	 * For this version of the specification, value other than 0 or
	 * 1 shall be considered as an invalid value.
	 * When the page_tbl_depth = 0, then it is treated as a
	 * special case with the following.
	 * 1. FBO and page size fields are not valid.
	 * 2. page_tbl_addr is the physical address of the first
	 *	element of the ring.
	 */
	uint8_t	page_tbl_depth;
	/* Used by a PF driver to associate a SCHQ with one of its TX rings. */
	uint16_t	schq_id;
	/*
	 * Number of 16B units in the ring. Minimum size for
	 * a ring is 16 16B entries.
	 */
	uint32_t	length;
	/*
	 * Logical ring number for the ring to be allocated.
	 * This value determines the position in the doorbell
	 * area where the update to the ring will be made.
	 *
	 * For completion rings, this value is also the MSI-X
	 * vector number for the function the completion ring is
	 * associated with.
	 */
	uint16_t	logical_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This value indicates what completion ring the TX ring
	 * is associated with.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This value indicates what CoS queue the TX ring
	 * is associated with.
	 */
	uint16_t	queue_id;
	/*
	 * When allocating a Rx ring or Rx aggregation ring, this field
	 * specifies the size of the buffer descriptors posted to the ring.
	 */
	uint16_t	rx_buf_size;
	/*
	 * When allocating an Rx aggregation ring, this field
	 * specifies the associated Rx ring ID.
	 */
	uint16_t	rx_ring_id;
	/*
	 * When allocating a completion ring, this field
	 * specifies the associated NQ ring ID.
	 */
	uint16_t	nq_ring_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This field is used to configure arbitration related
	 * parameters for a TX ring.
	 */
	uint16_t	ring_arb_cfg;
	/* Arbitration policy used for the ring. */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_MASK	UINT32_C(0xf)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_SFT	0
	/*
	 * Use strict priority for the TX ring.
	 * Priority value is specified in arb_policy_param
	 */
		#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_SP	UINT32_C(0x1)
	/*
	 * Use weighted fair queue arbitration for the TX ring.
	 * Weight is specified in arb_policy_param
	 */
		#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_WFQ	UINT32_C(0x2)
		#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_LAST	HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_WFQ
	/* Reserved field. */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_RSVD_MASK		UINT32_C(0xf0)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_RSVD_SFT		4
	/*
	 * Arbitration policy specific parameter.
	 * # For strict priority arbitration policy, this field
	 * represents a priority value. If set to 0, then the priority
	 * is not specified and the HWRM is allowed to select
	 * any priority for this TX ring.
	 * # For weighted fair queue arbitration policy, this field
	 * represents a weight value. If set to 0, then the weight
	 * is not specified and the HWRM is allowed to select
	 * any weight for this TX ring.
	 */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_PARAM_MASK UINT32_C(0xff00)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_PARAM_SFT 8
	/* Steering tag to use for memory transactions. */
	uint16_t	steering_tag;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved3;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This input indicates what statistics context this ring
	 * should be associated with.
	 */
	uint32_t	stat_ctx_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved4;
	/*
	 * This field is used only when ring_type is a TX ring
	 * to specify maximum BW allocated to the TX ring.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this ring inside the device.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_LAST		HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * This field is used only when ring_type is a Completion ring.
	 * This value indicates what interrupt mode should be used
	 * on this completion ring.
	 * Note: In the legacy interrupt mode, no more than 16
	 * completion rings are allowed.
	 */
	uint8_t	int_mode;
	/* Legacy INTA (deprecated) */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_LEGACY UINT32_C(0x0)
	/* Reserved */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_RSVD   UINT32_C(0x1)
	/* MSI-X */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_MSIX   UINT32_C(0x2)
	/* No Interrupt - Polled mode */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_POLL   UINT32_C(0x3)
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_LAST  HWRM_RING_ALLOC_INPUT_INT_MODE_POLL
	/* Midpath channel type */
	uint8_t	mpc_chnls_type;
	/*
	 * Indicate the TX ring alloc MPC channel type is a MPC channel
	 * with destination to the TX crypto engine block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_TCE	UINT32_C(0x0)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the RX crypto engine block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_RCE	UINT32_C(0x1)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the TX configurable flow processing block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_TE_CFA  UINT32_C(0x2)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the RX configurable flow processing block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_RE_CFA  UINT32_C(0x3)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the primate processor block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_PRIMATE UINT32_C(0x4)
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_LAST   HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_PRIMATE
	uint8_t	unused_4[2];
	/*
	 * The cq_handle is specified when allocating a completion ring. For
	 * devices that support NQs, this cq_handle will be included in the
	 * NQE to specify which CQ should be read to retrieve the completion
	 * record.
	 */
	uint64_t	cq_handle;
} hwrm_ring_alloc_input_t, *phwrm_ring_alloc_input_t;

/* hwrm_ring_alloc_output (size:128b/16B) */

typedef struct hwrm_ring_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Physical number of ring allocated.
	 * This value shall be unique for a ring type.
	 */
	uint16_t	ring_id;
	/* Logical number of ring allocated. */
	uint16_t	logical_ring_id;
	/*
	 * This field will tell whether to use ping or pong buffer
	 * for first push operation.
	 */
	uint8_t	push_buffer_index;
	/* Start push from ping buffer index */
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PING_BUFFER UINT32_C(0x0)
	/* Start push from pong buffer index */
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER UINT32_C(0x1)
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_LAST	HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER
	uint8_t	unused_0[2];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_alloc_output_t, *phwrm_ring_alloc_output_t;

/******************
 * hwrm_ring_free *
 ******************/


/* hwrm_ring_free_input (size:256b/32B) */

typedef struct hwrm_ring_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_L2_CMPL   UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_TX	UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_RX	UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_ROCE_CMPL UINT32_C(0x3)
	/* RX Aggregation Ring */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_RX_AGG	UINT32_C(0x4)
	/* Notification Queue */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_NQ	UINT32_C(0x5)
	#define HWRM_RING_FREE_INPUT_RING_TYPE_LAST	HWRM_RING_FREE_INPUT_RING_TYPE_NQ
	uint8_t	flags;
	/*
	 * If this bit is set to '1', ring_id in this command belongs to
	 * virtio function. prod_idx in this command corresponds to doorbell
	 * producer index. opaque field in this command needs to be inserted
	 * by firmware in VEE_FLUSH completion record.
	 * Firmware will poll the corresponding ring context to reach the
	 * given producer index before sending successful response. It will
	 * finish the completion using VEE_FLUSH completion record.
	 *
	 * If this bit is '0', firmware will not treat ring_id as virtio
	 * ring and ignore prod_idx, opaque fields.
	 *
	 * This feature is not applicable for L2 or RoCE.
	 */
	#define HWRM_RING_FREE_INPUT_FLAGS_VIRTIO_RING_VALID UINT32_C(0x1)
	#define HWRM_RING_FREE_INPUT_FLAGS_LAST		HWRM_RING_FREE_INPUT_FLAGS_VIRTIO_RING_VALID
	/* Physical number of ring allocated. */
	uint16_t	ring_id;
	/*
	 * Ring BD producer index posted by the virtio block.
	 * This field is valid if virtio_ring_valid flag is set.
	 */
	uint32_t	prod_idx;
	/*
	 * User defined opaque field to be inserted into VEE_FLUSH completion
	 * record. This field is valid if virtio_ring_valid flag is set.
	 */
	uint32_t	opaque;
	uint32_t	unused_1;
} hwrm_ring_free_input_t, *phwrm_ring_free_input_t;

/* hwrm_ring_free_output (size:128b/16B) */

typedef struct hwrm_ring_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_free_output_t, *phwrm_ring_free_output_t;

/*******************
 * hwrm_ring_reset *
 *******************/


/* hwrm_ring_reset_input (size:192b/24B) */

typedef struct hwrm_ring_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_L2_CMPL	UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_TX	UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_RX	UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_ROCE_CMPL   UINT32_C(0x3)
	/*
	 * Rx Ring Group. This is to reset rx and aggregation in an atomic
	 * operation. Completion ring associated with this ring group is
	 * not reset.
	 */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_RX_RING_GRP UINT32_C(0x6)
	#define HWRM_RING_RESET_INPUT_RING_TYPE_LAST	HWRM_RING_RESET_INPUT_RING_TYPE_RX_RING_GRP
	uint8_t	unused_0;
	/*
	 * Physical number of the ring. When ring type is rx_ring_grp, ring id
	 * actually refers to ring group id.
	 */
	uint16_t	ring_id;
	uint8_t	unused_1[4];
} hwrm_ring_reset_input_t, *phwrm_ring_reset_input_t;

/* hwrm_ring_reset_output (size:128b/16B) */

typedef struct hwrm_ring_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field will tell whether to use ping or pong buffer
	 * for first push operation.
	 */
	uint8_t	push_buffer_index;
	/* Start push from ping buffer index */
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PING_BUFFER UINT32_C(0x0)
	/* Start push from pong buffer index */
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER UINT32_C(0x1)
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_LAST	HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER
	uint8_t	unused_0[3];
	/* Position of consumer index after ring reset completes. */
	uint8_t	consumer_idx[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_reset_output_t, *phwrm_ring_reset_output_t;

/*****************
 * hwrm_ring_cfg *
 *****************/


/* hwrm_ring_cfg_input (size:320b/40B) */

typedef struct hwrm_ring_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* TX Ring (TR) */
	#define HWRM_RING_CFG_INPUT_RING_TYPE_TX UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_CFG_INPUT_RING_TYPE_RX UINT32_C(0x2)
	#define HWRM_RING_CFG_INPUT_RING_TYPE_LAST HWRM_RING_CFG_INPUT_RING_TYPE_RX
	uint8_t	unused_0;
	/* Physical number of the ring. */
	uint16_t	ring_id;
	/* Ring config enable bits. */
	uint16_t	enables;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B, 2B, 10B or 12B offset from the start of the Rx packet
	 * buffer.
	 * When '1', the received packet will be padded with 2B, 10B or 12B
	 * of zeros at the front of the packet. The exact offset is specified
	 * by rx_sop_pad_bytes parameter.
	 * When '0', the received packet will not be padded.
	 * Note that this flag is only used for Rx rings and is ignored
	 * for all other rings included Rx Aggregation rings.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_RX_SOP_PAD_ENABLE		UINT32_C(0x1)
	/*
	 * Proxy mode enable, for Tx, Rx and Rx aggregation rings only.
	 * When rings are allocated, the PCI function on which driver issues
	 * HWRM_RING_CFG command is assumed to own the rings. Hardware takes
	 * the buffer descriptors (BDs) from those rings is assumed to issue
	 * packet payload DMA using same PCI function. When proxy mode is
	 * enabled, hardware can perform payload DMA using another PCI
	 * function on same or different host.
	 * When set to '0', the PCI function on which driver issues
	 * HWRM_RING_CFG command is used for host payload DMA operation.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used for host payload DMA operation.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_PROXY_MODE_ENABLE		UINT32_C(0x2)
	/*
	 * Tx ring packet source interface override, for Tx rings only.
	 * When TX rings are allocated, the PCI function on which driver
	 * issues HWRM_RING_CFG is assumed to be source interface of
	 * packets sent from TX ring.
	 * When set to '1', the host PCI function specified by proxy_fid
	 * is used as source interface of the transmitted packets.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_TX_PROXY_SRC_INTF_OVERRIDE	UINT32_C(0x4)
	/* The schq_id field is valid */
	#define HWRM_RING_CFG_INPUT_ENABLES_SCHQ_ID			UINT32_C(0x8)
	/* Update completion ring ID associated with Tx or Rx ring. */
	#define HWRM_RING_CFG_INPUT_ENABLES_CMPL_RING_ID_UPDATE		UINT32_C(0x10)
	/*
	 * When set to '1', metadata value provided by tx_metadata
	 * field in this command is inserted in the lb_header_metadata
	 * QP context field. When set to '0', no change done to metadata.
	 * Firmware rejects the tx ring metadata programming with
	 * HWRM_ERR_CODE_UNSUPPORTED error if the per function CFA BD
	 * metadata feature is not disabled.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_TX_METADATA			UINT32_C(0x20)
	/*
	 * Proxy function FID value.
	 * This value is only used when either proxy_mode_enable flag or
	 * tx_proxy_svif_override is set to '1'.
	 * When proxy_mode_enable is set to '1', it identifies a host PCI
	 * function used for host payload DMA operations.
	 * When tx_proxy_src_intf is set to '1', it identifies a host PCI
	 * function as source interface for all transmitted packets from
	 * the TX ring.
	 */
	uint16_t	proxy_fid;
	/*
	 * Identifies the new scheduler queue (SCHQ) to associate with the
	 * ring. Only valid for Tx rings.
	 * A value of zero indicates that the Tx ring should be associated
	 * with the default scheduler queue (SCHQ).
	 */
	uint16_t	schq_id;
	/*
	 * This field is valid for TX or Rx rings. This value identifies the
	 * new completion ring ID to associate with the TX or Rx ring.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * Rx SOP padding amount in bytes.
	 * This value is only used when rx_sop_pad_enable flag is set to '1'.
	 */
	uint8_t	rx_sop_pad_bytes;
	uint8_t	unused_1[3];
	/*
	 * When tx_metadata enable bit is set, value specified in this field
	 * is copied to lb_header_metadata in the QP context.
	 */
	uint32_t	tx_metadata;
	uint8_t	unused_2[4];
} hwrm_ring_cfg_input_t, *phwrm_ring_cfg_input_t;

/* hwrm_ring_cfg_output (size:128b/16B) */

typedef struct hwrm_ring_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_ring_cfg_output_t, *phwrm_ring_cfg_output_t;

/******************
 * hwrm_ring_qcfg *
 ******************/


/* hwrm_ring_qcfg_input (size:192b/24B) */

typedef struct hwrm_ring_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* TX Ring (TR) */
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_TX UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_RX UINT32_C(0x2)
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_LAST HWRM_RING_QCFG_INPUT_RING_TYPE_RX
	uint8_t	unused_0[5];
	/* Physical number of the ring. */
	uint16_t	ring_id;
} hwrm_ring_qcfg_input_t, *phwrm_ring_qcfg_input_t;

/* hwrm_ring_qcfg_output (size:256b/32B) */

typedef struct hwrm_ring_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Ring config enable bits. */
	uint16_t	enables;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B, 2B, 10B or 12B offset from the start of the Rx packet
	 * buffer.
	 * When '1', the received packet will be padded with 2B, 10B or 12B
	 * of zeros at the front of the packet. The exact offset is specified
	 * by rx_sop_pad_bytes parameter.
	 * When '0', the received packet will not be padded.
	 * Note that this flag is only used for Rx rings and is ignored
	 * for all other rings included Rx Aggregation rings.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_RX_SOP_PAD_ENABLE		UINT32_C(0x1)
	/*
	 * Proxy mode enable, for Tx, Rx and Rx aggregation rings only.
	 * When rings are allocated, the PCI function on which driver issues
	 * HWRM_RING_CFG command is assumed to own the rings. Hardware takes
	 * the buffer descriptors (BDs) from those rings is assumed to issue
	 * packet payload DMA using same PCI function. When proxy mode is
	 * enabled, hardware can perform payload DMA using another PCI
	 * function on same or different host.
	 * When set to '0', the PCI function on which driver issues
	 * HWRM_RING_CFG command is used for host payload DMA operation.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used for host payload DMA operation.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_PROXY_MODE_ENABLE		UINT32_C(0x2)
	/*
	 * Tx ring packet source interface override, for Tx rings only.
	 * When TX rings are allocated, the PCI function on which driver
	 * issues HWRM_RING_CFG is assumed to be source interface of
	 * packets sent from TX ring.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used as source interface of the transmitted packets.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_TX_PROXY_SRC_INTF_OVERRIDE	UINT32_C(0x4)
	/*
	 * Proxy function FID value.
	 * This value is only used when either proxy_mode_enable flag or
	 * tx_proxy_svif_override is set to '1'.
	 * When proxy_mode_enable is set to '1', it identifies a host PCI
	 * function used for host payload DMA operations.
	 * When tx_proxy_src_intf is set to '1', it identifies a host PCI
	 * function as source interface for all transmitted packets from the TX
	 * ring.
	 */
	uint16_t	proxy_fid;
	/*
	 * Identifies the new scheduler queue (SCHQ) to associate with the
	 * ring. Only valid for Tx rings.
	 * A value of zero indicates that the Tx ring should be associated with
	 * the default scheduler queue (SCHQ).
	 */
	uint16_t	schq_id;
	/*
	 * This field is used when ring_type is a TX or Rx ring.
	 * This value indicates what completion ring the TX or Rx ring
	 * is associated with.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * Rx SOP padding amount in bytes.
	 * This value is only used when rx_sop_pad_enable flag is set to '1'.
	 */
	uint8_t	rx_sop_pad_bytes;
	uint8_t	unused_0[3];
	/* lb_header_metadata in the QP context is copied to this field. */
	uint32_t	tx_metadata;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_ring_qcfg_output_t, *phwrm_ring_qcfg_output_t;

/**************************
 * hwrm_ring_aggint_qcaps *
 **************************/


/* hwrm_ring_aggint_qcaps_input (size:128b/16B) */

typedef struct hwrm_ring_aggint_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_ring_aggint_qcaps_input_t, *phwrm_ring_aggint_qcaps_input_t;

/* hwrm_ring_aggint_qcaps_output (size:384b/48B) */

typedef struct hwrm_ring_aggint_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	cmpl_params;
	/*
	 * When this bit is set to '1', int_lat_tmr_min can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_INT_LAT_TMR_MIN		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', int_lat_tmr_max can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_INT_LAT_TMR_MAX		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', timer_reset can be enabled
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_TIMER_RESET			UINT32_C(0x4)
	/*
	 * When this bit is set to '1', ring_idle can be enabled
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_RING_IDLE			UINT32_C(0x8)
	/*
	 * When this bit is set to '1', num_cmpl_dma_aggr can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_DMA_AGGR		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', num_cmpl_dma_aggr_during_int can be
	 * configured on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_DMA_AGGR_DURING_INT	UINT32_C(0x20)
	/*
	 * When this bit is set to '1', cmpl_aggr_dma_tmr can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_CMPL_AGGR_DMA_TMR		UINT32_C(0x40)
	/*
	 * When this bit is set to '1', cmpl_aggr_dma_tmr_during_int can be
	 * configured on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_CMPL_AGGR_DMA_TMR_DURING_INT	UINT32_C(0x80)
	/*
	 * When this bit is set to '1', num_cmpl_aggr_int can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_AGGR_INT		UINT32_C(0x100)
	uint32_t	nq_params;
	/*
	 * When this bit is set to '1', int_lat_tmr_min can be configured
	 * on notification queues.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_NQ_PARAMS_INT_LAT_TMR_MIN	UINT32_C(0x1)
	/* Minimum value for num_cmpl_dma_aggr */
	uint16_t	num_cmpl_dma_aggr_min;
	/* Maximum value for num_cmpl_dma_aggr */
	uint16_t	num_cmpl_dma_aggr_max;
	/* Minimum value for num_cmpl_dma_aggr_during_int */
	uint16_t	num_cmpl_dma_aggr_during_int_min;
	/* Maximum value for num_cmpl_dma_aggr_during_int */
	uint16_t	num_cmpl_dma_aggr_during_int_max;
	/* Minimum value for cmpl_aggr_dma_tmr */
	uint16_t	cmpl_aggr_dma_tmr_min;
	/* Maximum value for cmpl_aggr_dma_tmr */
	uint16_t	cmpl_aggr_dma_tmr_max;
	/* Minimum value for cmpl_aggr_dma_tmr_during_int */
	uint16_t	cmpl_aggr_dma_tmr_during_int_min;
	/* Maximum value for cmpl_aggr_dma_tmr_during_int */
	uint16_t	cmpl_aggr_dma_tmr_during_int_max;
	/* Minimum value for int_lat_tmr_min */
	uint16_t	int_lat_tmr_min_min;
	/* Maximum value for int_lat_tmr_min */
	uint16_t	int_lat_tmr_min_max;
	/* Minimum value for int_lat_tmr_max */
	uint16_t	int_lat_tmr_max_min;
	/* Maximum value for int_lat_tmr_max */
	uint16_t	int_lat_tmr_max_max;
	/* Minimum value for num_cmpl_aggr_int */
	uint16_t	num_cmpl_aggr_int_min;
	/* Maximum value for num_cmpl_aggr_int */
	uint16_t	num_cmpl_aggr_int_max;
	/* The units for timer parameters, in nanoseconds. */
	uint16_t	timer_units;
	uint8_t	unused_0[1];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_aggint_qcaps_output_t, *phwrm_ring_aggint_qcaps_output_t;

/**************************************
 * hwrm_ring_cmpl_ring_qaggint_params *
 **************************************/


/* hwrm_ring_cmpl_ring_qaggint_params_input (size:192b/24B) */

typedef struct hwrm_ring_cmpl_ring_qaggint_params_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Physical number of completion ring. */
	uint16_t	ring_id;
	uint16_t	flags;
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_UNUSED_0_MASK UINT32_C(0x3)
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_UNUSED_0_SFT 0
	/*
	 * Set this flag to 1 when querying parameters on a notification
	 * queue. Set this flag to 0 when querying parameters on a
	 * completion queue or completion ring.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_IS_NQ	UINT32_C(0x4)
	uint8_t	unused_0[4];
} hwrm_ring_cmpl_ring_qaggint_params_input_t, *phwrm_ring_cmpl_ring_qaggint_params_input_t;

/* hwrm_ring_cmpl_ring_qaggint_params_output (size:256b/32B) */

typedef struct hwrm_ring_cmpl_ring_qaggint_params_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/*
	 * When this bit is set to '1', interrupt max
	 * timer is reset whenever a completion is received.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_OUTPUT_FLAGS_TIMER_RESET	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', ring idle mode
	 * aggregation will be enabled.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_OUTPUT_FLAGS_RING_IDLE	UINT32_C(0x2)
	/*
	 * Number of completions to aggregate before DMA
	 * during the normal mode.
	 */
	uint16_t	num_cmpl_dma_aggr;
	/*
	 * Number of completions to aggregate before DMA
	 * during the interrupt mode.
	 */
	uint16_t	num_cmpl_dma_aggr_during_int;
	/*
	 * Timer used to aggregate completions before
	 * DMA during the normal mode (not in interrupt mode).
	 */
	uint16_t	cmpl_aggr_dma_tmr;
	/*
	 * Timer used to aggregate completions before
	 * DMA when in interrupt mode.
	 */
	uint16_t	cmpl_aggr_dma_tmr_during_int;
	/* Minimum time between two interrupts. */
	uint16_t	int_lat_tmr_min;
	/*
	 * Maximum wait time spent aggregating
	 * completions before signaling the interrupt after the
	 * interrupt is enabled.
	 */
	uint16_t	int_lat_tmr_max;
	/*
	 * Minimum number of completions aggregated before signaling
	 * an interrupt.
	 */
	uint16_t	num_cmpl_aggr_int;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_cmpl_ring_qaggint_params_output_t, *phwrm_ring_cmpl_ring_qaggint_params_output_t;

/*****************************************
 * hwrm_ring_cmpl_ring_cfg_aggint_params *
 *****************************************/


/* hwrm_ring_cmpl_ring_cfg_aggint_params_input (size:320b/40B) */

typedef struct hwrm_ring_cmpl_ring_cfg_aggint_params_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Physical number of completion ring. */
	uint16_t	ring_id;
	uint16_t	flags;
	/*
	 * When this bit is set to '1', interrupt latency max
	 * timer is reset whenever a completion is received.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_TIMER_RESET	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', ring idle mode
	 * aggregation will be enabled.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_RING_IDLE	UINT32_C(0x2)
	/*
	 * Set this flag to 1 when configuring parameters on a
	 * notification queue. Set this flag to 0 when configuring
	 * parameters on a completion queue or completion ring.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_IS_NQ	UINT32_C(0x4)
	/*
	 * Number of completions to aggregate before DMA
	 * during the normal mode.
	 */
	uint16_t	num_cmpl_dma_aggr;
	/*
	 * Number of completions to aggregate before DMA
	 * during the interrupt mode.
	 */
	uint16_t	num_cmpl_dma_aggr_during_int;
	/*
	 * Timer used to aggregate completions before
	 * DMA during the normal mode (not in interrupt mode).
	 */
	uint16_t	cmpl_aggr_dma_tmr;
	/*
	 * Timer used to aggregate completions before
	 * DMA while in interrupt mode.
	 */
	uint16_t	cmpl_aggr_dma_tmr_during_int;
	/* Minimum time between two interrupts. */
	uint16_t	int_lat_tmr_min;
	/*
	 * Maximum wait time spent aggregating
	 * completions before signaling the interrupt after the
	 * interrupt is enabled.
	 */
	uint16_t	int_lat_tmr_max;
	/*
	 * Minimum number of completions aggregated before signaling
	 * an interrupt.
	 */
	uint16_t	num_cmpl_aggr_int;
	/*
	 * Bitfield that indicates which parameters are to be applied. Only
	 * required when configuring devices with notification queues, and
	 * used in that case to set certain parameters on completion queues
	 * and others on notification queues.
	 */
	uint16_t	enables;
	/*
	 * This bit must be '1' for the num_cmpl_dma_aggr field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_DMA_AGGR		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the num_cmpl_dma_aggr_during_int field to
	 * be configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_DMA_AGGR_DURING_INT	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cmpl_aggr_dma_tmr field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_CMPL_AGGR_DMA_TMR		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the int_lat_tmr_min field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_INT_LAT_TMR_MIN		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the int_lat_tmr_max field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_INT_LAT_TMR_MAX		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_cmpl_aggr_int field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_AGGR_INT		UINT32_C(0x20)
	uint8_t	unused_0[4];
} hwrm_ring_cmpl_ring_cfg_aggint_params_input_t, *phwrm_ring_cmpl_ring_cfg_aggint_params_input_t;

/* hwrm_ring_cmpl_ring_cfg_aggint_params_output (size:128b/16B) */

typedef struct hwrm_ring_cmpl_ring_cfg_aggint_params_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_cmpl_ring_cfg_aggint_params_output_t, *phwrm_ring_cmpl_ring_cfg_aggint_params_output_t;

/***********************
 * hwrm_ring_grp_alloc *
 ***********************/


/* hwrm_ring_grp_alloc_input (size:192b/24B) */

typedef struct hwrm_ring_grp_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value identifies the CR associated with the ring
	 * group.
	 */
	uint16_t	cr;
	/*
	 * This value identifies the main RR associated with the ring
	 * group.
	 */
	uint16_t	rr;
	/*
	 * This value identifies the aggregation RR associated with
	 * the ring group. If this value is 0xFF... (All Fs), then no
	 * Aggregation ring will be set.
	 */
	uint16_t	ar;
	/*
	 * This value identifies the statistics context associated
	 * with the ring group.
	 */
	uint16_t	sc;
} hwrm_ring_grp_alloc_input_t, *phwrm_ring_grp_alloc_input_t;

/* hwrm_ring_grp_alloc_output (size:128b/16B) */

typedef struct hwrm_ring_grp_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the ring group ID value. Use this value to program
	 * the default ring group for the VNIC or as table entries
	 * in an RSS/COS context.
	 */
	uint32_t	ring_group_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_grp_alloc_output_t, *phwrm_ring_grp_alloc_output_t;

/**********************
 * hwrm_ring_grp_free *
 **********************/


/* hwrm_ring_grp_free_input (size:192b/24B) */

typedef struct hwrm_ring_grp_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This is the ring group ID value. */
	uint32_t	ring_group_id;
	uint8_t	unused_0[4];
} hwrm_ring_grp_free_input_t, *phwrm_ring_grp_free_input_t;

/* hwrm_ring_grp_free_output (size:128b/16B) */

typedef struct hwrm_ring_grp_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_grp_free_output_t, *phwrm_ring_grp_free_output_t;

/************************
 * hwrm_ring_schq_alloc *
 ************************/


/* hwrm_ring_schq_alloc_input (size:1088b/136B) */

typedef struct hwrm_ring_schq_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING0	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING1	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING2	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING3	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING4	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING5	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING6	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING7	UINT32_C(0x80)
	/* Reserved for future use. */
	uint32_t	reserved;
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_1G
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/*
	 * Number of TQM ring 0 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring0_num_entries;
	/*
	 * Number of TQM ring 1 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring1_num_entries;
	/*
	 * Number of TQM ring 2 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring2_num_entries;
	/*
	 * Number of TQM ring 3 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring3_num_entries;
	/*
	 * Number of TQM ring 4 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring4_num_entries;
	/*
	 * Number of TQM ring 5 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring5_num_entries;
	/*
	 * Number of TQM ring 6 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring6_num_entries;
	/*
	 * Number of TQM ring 7 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring7_num_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tqm_entry_size;
	uint8_t	unused_0[6];
} hwrm_ring_schq_alloc_input_t, *phwrm_ring_schq_alloc_input_t;

/* hwrm_ring_schq_alloc_output (size:128b/16B) */

typedef struct hwrm_ring_schq_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is an identifier for the SCHQ to be used in other HWRM commands
	 * that need to reference this SCHQ. This value is greater than zero
	 * (i.e. a schq_id of zero references the default SCHQ).
	 */
	uint16_t	schq_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_schq_alloc_output_t, *phwrm_ring_schq_alloc_output_t;

/**********************
 * hwrm_ring_schq_cfg *
 **********************/


/* hwrm_ring_schq_cfg_input (size:768b/96B) */

typedef struct hwrm_ring_schq_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Identifies the SCHQ being configured. A schq_id of zero refers to
	 * the default SCHQ.
	 */
	uint16_t	schq_id;
	/*
	 * This field is an 8 bit bitmap that indicates which TCs are enabled
	 * in this SCHQ. Bit 0 represents traffic class 0 and bit 7 represents
	 * traffic class 7.
	 */
	uint8_t	tc_enabled;
	uint8_t	unused_0;
	uint32_t	flags;
	/* The tc_max_bw array and the max_bw parameters are valid */
	#define HWRM_RING_SCHQ_CFG_INPUT_FLAGS_TC_MAX_BW_ENABLED	UINT32_C(0x1)
	/* The tc_bw_reservation array is valid */
	#define HWRM_RING_SCHQ_CFG_INPUT_FLAGS_TC_RESERVATION_ENABLED	UINT32_C(0x2)
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc0;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc1;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc2;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc3;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc4;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc5;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc6;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc7;
	/*
	 * Bandwidth reservation for the traffic class, specified in percent.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	tc_bw_reservation0;
	/*
	 * Bandwidth reservation for the traffic class, specified in percent.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	tc_bw_reservation1;
	/*
	 * Bandwidth reservation for the traffic class, specified in percent.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	tc_bw_reservation2;
	/*
	 * Bandwidth reservation for the traffic class, specified in percent.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	tc_bw_reservation3;
	/*
	 * Bandwidth reservation for the traffic class, specified in percent.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	tc_bw_reservation4;
	/*
	 * Bandwidth reservation for the traffic class, specified in percent.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	tc_bw_reservation5;
	/*
	 * Bandwidth reservation for the traffic class, specified in percent.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	tc_bw_reservation6;
	/*
	 * Bandwidth reservation for the traffic class, specified in percent.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	tc_bw_reservation7;
	/*
	 * Indicates the max bandwidth for all enabled traffic classes in
	 * this SCHQ, specified in Mbps.
	 */
	uint32_t	max_bw;
	uint8_t	unused_1[4];
} hwrm_ring_schq_cfg_input_t, *phwrm_ring_schq_cfg_input_t;

/* hwrm_ring_schq_cfg_output (size:128b/16B) */

typedef struct hwrm_ring_schq_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_schq_cfg_output_t, *phwrm_ring_schq_cfg_output_t;

/***********************
 * hwrm_ring_schq_free *
 ***********************/


/* hwrm_ring_schq_free_input (size:192b/24B) */

typedef struct hwrm_ring_schq_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Identifies the SCHQ being freed. */
	uint16_t	schq_id;
	uint8_t	unused_0[6];
} hwrm_ring_schq_free_input_t, *phwrm_ring_schq_free_input_t;

/* hwrm_ring_schq_free_output (size:128b/16B) */

typedef struct hwrm_ring_schq_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_schq_free_output_t, *phwrm_ring_schq_free_output_t;

/*
 * special reserved flow ID to identify per function default
 * flows for vSwitch offload
 */
#define DEFAULT_FLOW_ID 0xFFFFFFFFUL
/*
 * special reserved flow ID to identify per function RoCEv1
 * flows
 */
#define ROCEV1_FLOW_ID 0xFFFFFFFEUL
/*
 * special reserved flow ID to identify per function RoCEv2
 * flows
 */
#define ROCEV2_FLOW_ID 0xFFFFFFFDUL
/*
 * special reserved flow ID to identify per function RoCEv2
 * CNP flows
 */
#define ROCEV2_CNP_FLOW_ID 0xFFFFFFFCUL

/****************************
 * hwrm_cfa_l2_filter_alloc *
 ****************************/


/* hwrm_cfa_l2_filter_alloc_input (size:768b/96B) */

typedef struct hwrm_cfa_l2_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH		UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_TX		UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_RX		UINT32_C(0x1)
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_LAST	HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK	UINT32_C(0x2)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_DROP		UINT32_C(0x4)
	/*
	 * If this flag is set, all t_l2_* fields are invalid
	 * and they should not be specified.
	 * If this flag is set, then l2_* fields refer to
	 * fields of outermost L2 header.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_OUTERMOST	UINT32_C(0x8)
	/*
	 * Enumeration denoting NO_ROCE_L2 to support old drivers.
	 * New driver L2 for only L2 traffic, ROCE for roce and l2 traffic
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_MASK	UINT32_C(0x30)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_SFT	4
	/* To support old drivers */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_NO_ROCE_L2  (UINT32_C(0x0) << 4)
	/* Only L2 traffic */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_L2	(UINT32_C(0x1) << 4)
	/* Roce & L2 traffic */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_ROCE	(UINT32_C(0x2) << 4)
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_LAST	HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_ROCE
	/*
	 * Setting of this flag indicates that no XDP filter is created with
	 * L2 filter.
	 * 0 - legacy behavior, XDP filter is created with L2 filter
	 * 1 - XDP filter won't be created with L2 filter
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_XDP_DISABLE	UINT32_C(0x40)
	/*
	 * Setting this flag to 1 indicate the L2 fields in this command
	 * pertain to source fields. Setting this flag to 0 indicate the
	 * L2 fields in this command pertain to the destination fields
	 * and this is the default/legacy behavior.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_SOURCE_VALID	UINT32_C(0x80)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the l2_addr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR_MASK	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the l2_ovlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_OVLAN		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the l2_ovlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_OVLAN_MASK	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the l2_ivlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN_MASK	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_ADDR	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the t_l2_addr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_ADDR_MASK	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the t_l2_ovlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_OVLAN	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the t_l2_ovlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_OVLAN_MASK	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the t_l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_IVLAN	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the t_l2_ivlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_IVLAN_MASK	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the src_type field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_SRC_TYPE		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the src_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_SRC_ID		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the num_vlans field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_NUM_VLANS	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the t_num_vlans field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_NUM_VLANS	UINT32_C(0x40000)
	/*
	 * This value sets the match value for the L2 MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	l2_addr[6];
	/* This value sets the match value for the number of VLANs. */
	uint8_t	num_vlans;
	/*
	 * This value sets the match value for the number of VLANs
	 * in the tunnel headers.
	 */
	uint8_t	t_num_vlans;
	/*
	 * This value sets the mask value for the L2 address.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint8_t	l2_addr_mask[6];
	/* This value sets VLAN ID value for outer VLAN. */
	uint16_t	l2_ovlan;
	/*
	 * This value sets the mask value for the ovlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	l2_ovlan_mask;
	/* This value sets VLAN ID value for inner VLAN. */
	uint16_t	l2_ivlan;
	/*
	 * This value sets the mask value for the ivlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	l2_ivlan_mask;
	uint8_t	unused_1[2];
	/*
	 * This value sets the match value for the tunnel
	 * L2 MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	t_l2_addr[6];
	uint8_t	unused_2[2];
	/*
	 * This value sets the mask value for the tunnel L2
	 * address.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint8_t	t_l2_addr_mask[6];
	/* This value sets VLAN ID value for tunnel outer VLAN. */
	uint16_t	t_l2_ovlan;
	/*
	 * This value sets the mask value for the tunnel ovlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	t_l2_ovlan_mask;
	/* This value sets VLAN ID value for tunnel inner VLAN. */
	uint16_t	t_l2_ivlan;
	/*
	 * This value sets the mask value for the tunnel ivlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	t_l2_ivlan_mask;
	/* This value identifies the type of source of the packet. */
	uint8_t	src_type;
	/* Network port */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_NPORT UINT32_C(0x0)
	/* Physical function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_PF	UINT32_C(0x1)
	/* Virtual function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_VF	UINT32_C(0x2)
	/* Virtual NIC of a function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_VNIC  UINT32_C(0x3)
	/* Embedded processor for CFA management */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_KONG  UINT32_C(0x4)
	/* Embedded processor for OOB management */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_APE   UINT32_C(0x5)
	/* Embedded processor for RoCE */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_BONO  UINT32_C(0x6)
	/* Embedded processor for network proxy functions */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_TANG  UINT32_C(0x7)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_LAST HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_TANG
	uint8_t	unused_3;
	/*
	 * This value is the id of the source.
	 * For a network port, it represents port_id.
	 * For a physical function, it represents fid.
	 * For a virtual function, it represents vf_id.
	 * For a vnic, it represents vnic_id.
	 * For embedded processors, this id is not valid.
	 *
	 * Notes:
	 * 1. The function ID is implied if it src_id is
	 *	not provided for a src_type that is either
	 */
	uint32_t	src_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_4;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	/*
	 * This hint is provided to help in placing
	 * the filter in the filter table.
	 */
	uint8_t	pri_hint;
	/* No preference */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_NO_PREFER	UINT32_C(0x0)
	/* Above the given filter */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_ABOVE_FILTER UINT32_C(0x1)
	/* Below the given filter */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_BELOW_FILTER UINT32_C(0x2)
	/* As high as possible */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MAX	UINT32_C(0x3)
	/* As low as possible */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MIN	UINT32_C(0x4)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_LAST	HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MIN
	uint8_t	unused_5;
	uint32_t	unused_6;
	/*
	 * This is the ID of the filter that goes along with
	 * the pri_hint.
	 *
	 * This field is valid only for the following values.
	 * 1 - Above the given filter
	 * 2 - Below the given filter
	 */
	uint64_t	l2_filter_id_hint;
} hwrm_cfa_l2_filter_alloc_input_t, *phwrm_cfa_l2_filter_alloc_input_t;

/* hwrm_cfa_l2_filter_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_l2_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_l2_filter_alloc_output_t, *phwrm_cfa_l2_filter_alloc_output_t;

/***************************
 * hwrm_cfa_l2_filter_free *
 ***************************/


/* hwrm_cfa_l2_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_l2_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
} hwrm_cfa_l2_filter_free_input_t, *phwrm_cfa_l2_filter_free_input_t;

/* hwrm_cfa_l2_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_l2_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_l2_filter_free_output_t, *phwrm_cfa_l2_filter_free_output_t;

/**************************
 * hwrm_cfa_l2_filter_cfg *
 **************************/


/* hwrm_cfa_l2_filter_cfg_input (size:384b/48B) */

typedef struct hwrm_cfa_l2_filter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH		UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_TX		UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_RX		UINT32_C(0x1)
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_LAST		HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_DROP		UINT32_C(0x2)
	/*
	 * Enumeration denoting NO_ROCE_L2 to support old drivers.
	 * New driver L2 for only L2 traffic, ROCE for roce and l2 traffic
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_MASK	UINT32_C(0xc)
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_SFT	2
	/* To support old drivers */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_NO_ROCE_L2	(UINT32_C(0x0) << 2)
	/* Only L2 traffic */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_L2		(UINT32_C(0x1) << 2)
	/* Roce & L2 traffic */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_ROCE		(UINT32_C(0x2) << 2)
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_LAST	HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_ROCE
	/*
	 * Enumeration denoting how the L2 Context TCAM remap operation is
	 * updated.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_REMAP_OP_MASK	UINT32_C(0x30)
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_REMAP_OP_SFT	4
	/* No change to remap opcode */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_REMAP_OP_NO_UPDATE	(UINT32_C(0x0) << 4)
	/* Bypass CFA Lookup */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_REMAP_OP_BYPASS_LKUP	(UINT32_C(0x1) << 4)
	/* Enable CFA Lookup */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_REMAP_OP_ENABLE_LKUP	(UINT32_C(0x2) << 4)
	/*
	 * Restore the remap opcode originally programmed by firmware flow
	 * manager
	 */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_REMAP_OP_RESTORE_FW_OP  (UINT32_C(0x3) << 4)
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_REMAP_OP_LAST	HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_REMAP_OP_RESTORE_FW_OP
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_DST_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the new_mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the prof_func field to be configured in
	 * the remap entry.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_PROF_FUNC		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the l2_context_id field to be configured
	 * in the remap entry.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_L2_CONTEXT_ID	UINT32_C(0x8)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint32_t	dst_id;
	/*
	 * New Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	new_mirror_vnic_id;
	/*
	 * Profile function value to be programmed into the L2 context entry's
	 * remap. This will be used by the host application to program the CFA
	 * Profile TCAM entry for further classification. A value of 0xFFFFFFFF
	 * indicates that the profile function should be restored to the value
	 * originally programmed by the firmware flow manager.
	 */
	uint32_t	prof_func;
	/*
	 * L2 context ID value to be programmed into the L2 context entry's
	 * remap. This will be used by the host application to program the CFA
	 * Lookup entry for further classification. A value of 0xFFFFFFFF
	 * indicates that the profile function should be restored to the value
	 * originally programmed by the firmware flow manager.
	 */
	uint32_t	l2_context_id;
} hwrm_cfa_l2_filter_cfg_input_t, *phwrm_cfa_l2_filter_cfg_input_t;

/* hwrm_cfa_l2_filter_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_l2_filter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_l2_filter_cfg_output_t, *phwrm_cfa_l2_filter_cfg_output_t;

/***************************
 * hwrm_cfa_l2_set_rx_mask *
 ***************************/


/* hwrm_cfa_l2_set_rx_mask_input (size:448b/56B) */

typedef struct hwrm_cfa_l2_set_rx_mask_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VNIC ID */
	uint32_t	vnic_id;
	uint32_t	mask;
	/*
	 * When this bit is '1', the function is requested to accept
	 * multi-cast packets specified by the multicast addr table.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_MCAST		UINT32_C(0x2)
	/*
	 * When this bit is '1', the function is requested to accept
	 * all multi-cast packets.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_ALL_MCAST	UINT32_C(0x4)
	/*
	 * When this bit is '1', the function is requested to accept
	 * broadcast packets.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_BCAST		UINT32_C(0x8)
	/*
	 * When this bit is '1', the function is requested to be
	 * put in the promiscuous mode.
	 *
	 * The HWRM should accept any function to set up
	 * promiscuous mode.
	 *
	 * The HWRM shall follow the semantics below for the
	 * promiscuous mode support.
	 * # When partitioning is not enabled on a port
	 * (i.e. single PF on the port), then the PF shall
	 * be allowed to be in the promiscuous mode. When the
	 * PF is in the promiscuous mode, then it shall
	 * receive all host bound traffic on that port.
	 * # When partitioning is enabled on a port
	 * (i.e. multiple PFs per port) and a PF on that
	 * port is in the promiscuous mode, then the PF
	 * receives all traffic within that partition as
	 * identified by a unique identifier for the
	 * PF (e.g. S-Tag). If a unique outer VLAN
	 * for the PF is specified, then the setting of
	 * promiscuous mode on that PF shall result in the
	 * PF receiving all host bound traffic with matching
	 * outer VLAN.
	 * # A VF shall can be set in the promiscuous mode.
	 * In the promiscuous mode, the VF does not receive any
	 * traffic unless a unique outer VLAN for the
	 * VF is specified. If a unique outer VLAN
	 * for the VF is specified, then the setting of
	 * promiscuous mode on that VF shall result in the
	 * VF receiving all host bound traffic with the
	 * matching outer VLAN.
	 * # The HWRM shall allow the setting of promiscuous
	 * mode on a function independently from the
	 * promiscuous mode settings on other functions.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_PROMISCUOUS	UINT32_C(0x10)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for the outermost Layer 2 destination MAC
	 * address field.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_OUTERMOST	UINT32_C(0x20)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for the VLAN-tagged packets that match the
	 * TPID and VID fields of VLAN tags in the VLAN tag
	 * table specified in this command.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_VLANONLY		UINT32_C(0x40)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for non-VLAN tagged packets and VLAN-tagged
	 * packets that match the TPID and VID fields of VLAN
	 * tags in the VLAN tag table specified in this command.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_VLAN_NONVLAN	UINT32_C(0x80)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for non-VLAN tagged packets and VLAN-tagged
	 * packets matching any VLAN tag.
	 *
	 * If this flag is set, then the HWRM shall ignore
	 * VLAN tags specified in vlan_tag_tbl.
	 *
	 * If none of vlanonly, vlan_nonvlan, and anyvlan_nonvlan
	 * flags is set, then the HWRM shall ignore
	 * VLAN tags specified in vlan_tag_tbl.
	 *
	 * The HWRM client shall set at most one flag out of
	 * vlanonly, vlan_nonvlan, and anyvlan_nonvlan.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_ANYVLAN_NONVLAN	UINT32_C(0x100)
	/* This is the address for mcast address tbl. */
	uint64_t	mc_tbl_addr;
	/*
	 * This value indicates how many entries in mc_tbl are valid.
	 * Each entry is 6 bytes.
	 */
	uint32_t	num_mc_entries;
	uint8_t	unused_0[4];
	/*
	 * This is the address for VLAN tag table.
	 * Each VLAN entry in the table is 4 bytes of a VLAN tag
	 * including TPID, PCP, DEI, and VID fields in network byte
	 * order.
	 */
	uint64_t	vlan_tag_tbl_addr;
	/*
	 * This value indicates how many entries in vlan_tag_tbl are
	 * valid. Each entry is 4 bytes.
	 */
	uint32_t	num_vlan_tags;
	uint8_t	unused_1[4];
} hwrm_cfa_l2_set_rx_mask_input_t, *phwrm_cfa_l2_set_rx_mask_input_t;

/* hwrm_cfa_l2_set_rx_mask_output (size:128b/16B) */

typedef struct hwrm_cfa_l2_set_rx_mask_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_l2_set_rx_mask_output_t, *phwrm_cfa_l2_set_rx_mask_output_t;

/* hwrm_cfa_l2_set_rx_mask_cmd_err (size:64b/8B) */

typedef struct hwrm_cfa_l2_set_rx_mask_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_UNKNOWN			UINT32_C(0x0)
	/* Unable to complete operation due to conflict with Ntuple Filter */
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_NTUPLE_FILTER_CONFLICT_ERR UINT32_C(0x1)
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_LAST			HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_NTUPLE_FILTER_CONFLICT_ERR
	uint8_t	unused_0[7];
} hwrm_cfa_l2_set_rx_mask_cmd_err_t, *phwrm_cfa_l2_set_rx_mask_cmd_err_t;

/*******************************
 * hwrm_cfa_vlan_antispoof_cfg *
 *******************************/


/* hwrm_cfa_vlan_antispoof_cfg_input (size:256b/32B) */

typedef struct hwrm_cfa_vlan_antispoof_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being configured.
	 * Only valid for a VF FID configured by the PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/* Number of VLAN entries in the vlan_tag_mask_tbl. */
	uint32_t	num_vlan_entries;
	/*
	 * The vlan_tag_mask_tbl_addr is the DMA address of the VLAN
	 * antispoof table. Each table entry contains the 16-bit TPID
	 * (0x8100 or 0x88a8 only), 16-bit VLAN ID, and a 16-bit mask,
	 * all in network order to match hwrm_cfa_l2_set_rx_mask.
	 * For an individual VLAN entry, the mask value should be 0xfff
	 * for the 12-bit VLAN ID.
	 */
	uint64_t	vlan_tag_mask_tbl_addr;
} hwrm_cfa_vlan_antispoof_cfg_input_t, *phwrm_cfa_vlan_antispoof_cfg_input_t;

/* hwrm_cfa_vlan_antispoof_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_vlan_antispoof_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vlan_antispoof_cfg_output_t, *phwrm_cfa_vlan_antispoof_cfg_output_t;

/********************************
 * hwrm_cfa_vlan_antispoof_qcfg *
 ********************************/


/* hwrm_cfa_vlan_antispoof_qcfg_input (size:256b/32B) */

typedef struct hwrm_cfa_vlan_antispoof_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * Only valid for a VF FID queried by the PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/*
	 * Maximum number of VLAN entries the firmware is allowed to DMA
	 * to vlan_tag_mask_tbl.
	 */
	uint32_t	max_vlan_entries;
	/*
	 * The vlan_tag_mask_tbl_addr is the DMA address of the VLAN
	 * antispoof table to which firmware will DMA to. Each table
	 * entry will contain the 16-bit TPID (0x8100 or 0x88a8 only),
	 * 16-bit VLAN ID, and a 16-bit mask, all in network order to
	 * match hwrm_cfa_l2_set_rx_mask. For an individual VLAN entry,
	 * the mask value should be 0xfff for the 12-bit VLAN ID.
	 */
	uint64_t	vlan_tag_mask_tbl_addr;
} hwrm_cfa_vlan_antispoof_qcfg_input_t, *phwrm_cfa_vlan_antispoof_qcfg_input_t;

/* hwrm_cfa_vlan_antispoof_qcfg_output (size:128b/16B) */

typedef struct hwrm_cfa_vlan_antispoof_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of valid entries DMAd by firmware to vlan_tag_mask_tbl. */
	uint32_t	num_vlan_entries;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vlan_antispoof_qcfg_output_t, *phwrm_cfa_vlan_antispoof_qcfg_output_t;

/********************************
 * hwrm_cfa_tunnel_filter_alloc *
 ********************************/


/* hwrm_cfa_tunnel_filter_alloc_input (size:704b/88B) */

typedef struct hwrm_cfa_tunnel_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK	UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the l3_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L3_ADDR		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the l3_addr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L3_ADDR_TYPE	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the t_l3_addr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_T_L3_ADDR_TYPE	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_l3_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_T_L3_ADDR	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the vni field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_VNI		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dst_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_DST_VNIC_ID	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x400)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * This value sets the match value for the inner L2
	 * MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	l2_addr[6];
	/*
	 * This value sets VLAN ID value for inner VLAN.
	 * Only 12-bits of VLAN ID are used in setting the filter.
	 */
	uint16_t	l2_ivlan;
	/*
	 * The value of inner destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	l3_addr[4];
	/*
	 * The value of tunnel destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	t_l3_addr[4];
	/*
	 * This value indicates the type of inner IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	l3_addr_type;
	/*
	 * This value indicates the type of tunnel IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	t_l3_addr_type;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/*
	 * tunnel_flags allows the user to indicate the tunnel tag detection
	 * for the tunnel type specified in tunnel_type.
	 */
	uint8_t	tunnel_flags;
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to match the geneve OAM packet.
	 * If the tunnel_type is nvgre or gre, then this bit indicates if
	 * we need to detect checksum present bit in geneve header.
	 * If the tunnel_type is mpls, then this bit indicates if we need
	 * to match mpls packet with explicit IPV4/IPV6 null header.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_OAM_CHECKSUM_EXPLHDR	UINT32_C(0x1)
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to detect the critical option bit set in the oam packet.
	 * If the tunnel_type is nvgre or gre, then this bit indicates
	 * if we need to match nvgre packets with key present bit set in
	 * gre header.
	 * If the tunnel_type is mpls, then this bit indicates if we
	 * need to match mpls packet with S bit from inner/second label.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_CRITICAL_OPT_S1	UINT32_C(0x2)
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to match geneve packet with extended header bit set in
	 * geneve header.
	 * If the tunnel_type is nvgre or gre, then this bit indicates
	 * if we need to match nvgre packets with sequence number
	 * present bit set in gre header.
	 * If the tunnel_type is mpls, then this bit indicates if we
	 * need to match mpls packet with S bit from out/first label.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_EXTHDR_SEQNUM_S0	UINT32_C(0x4)
	/*
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	vni;
	/* Logical VNIC ID of the destination VNIC. */
	uint32_t	dst_vnic_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	mirror_vnic_id;
} hwrm_cfa_tunnel_filter_alloc_input_t, *phwrm_cfa_tunnel_filter_alloc_input_t;

/* hwrm_cfa_tunnel_filter_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_tunnel_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tunnel_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tunnel_filter_alloc_output_t, *phwrm_cfa_tunnel_filter_alloc_output_t;

/*******************************
 * hwrm_cfa_tunnel_filter_free *
 *******************************/


/* hwrm_cfa_tunnel_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_tunnel_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tunnel_filter_id;
} hwrm_cfa_tunnel_filter_free_input_t, *phwrm_cfa_tunnel_filter_free_input_t;

/* hwrm_cfa_tunnel_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_tunnel_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tunnel_filter_free_output_t, *phwrm_cfa_tunnel_filter_free_output_t;

/***************************************
 * hwrm_cfa_redirect_tunnel_type_alloc *
 ***************************************/


/* hwrm_cfa_redirect_tunnel_type_alloc_input (size:192b/24B) */

typedef struct hwrm_cfa_redirect_tunnel_type_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/* Tunnel alloc flags. */
	uint8_t	flags;
	/*
	 * Setting of this flag indicates modify existing redirect tunnel
	 * to new destination function ID.
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_FLAGS_MODIFY_DST	UINT32_C(0x1)
	uint8_t	unused_0[4];
} hwrm_cfa_redirect_tunnel_type_alloc_input_t, *phwrm_cfa_redirect_tunnel_type_alloc_input_t;

/* hwrm_cfa_redirect_tunnel_type_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_redirect_tunnel_type_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_redirect_tunnel_type_alloc_output_t, *phwrm_cfa_redirect_tunnel_type_alloc_output_t;

/**************************************
 * hwrm_cfa_redirect_tunnel_type_free *
 **************************************/


/* hwrm_cfa_redirect_tunnel_type_free_input (size:192b/24B) */

typedef struct hwrm_cfa_redirect_tunnel_type_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[5];
} hwrm_cfa_redirect_tunnel_type_free_input_t, *phwrm_cfa_redirect_tunnel_type_free_input_t;

/* hwrm_cfa_redirect_tunnel_type_free_output (size:128b/16B) */

typedef struct hwrm_cfa_redirect_tunnel_type_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_redirect_tunnel_type_free_output_t, *phwrm_cfa_redirect_tunnel_type_free_output_t;

/**************************************
 * hwrm_cfa_redirect_tunnel_type_info *
 **************************************/


/* hwrm_cfa_redirect_tunnel_type_info_input (size:192b/24B) */

typedef struct hwrm_cfa_redirect_tunnel_type_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The source function id. */
	uint16_t	src_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[5];
} hwrm_cfa_redirect_tunnel_type_info_input_t, *phwrm_cfa_redirect_tunnel_type_info_input_t;

/* hwrm_cfa_redirect_tunnel_type_info_output (size:128b/16B) */

typedef struct hwrm_cfa_redirect_tunnel_type_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_redirect_tunnel_type_info_output_t, *phwrm_cfa_redirect_tunnel_type_info_output_t;

/* hwrm_vxlan_ipv4_hdr (size:128b/16B) */

typedef struct hwrm_vxlan_ipv4_hdr {
	/* IPv4 version and header length. */
	uint8_t	ver_hlen;
	/* IPv4 header length */
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_HEADER_LENGTH_MASK UINT32_C(0xf)
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_HEADER_LENGTH_SFT 0
	/* Version */
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_VERSION_MASK	UINT32_C(0xf0)
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_VERSION_SFT	4
	/* IPv4 type of service. */
	uint8_t	tos;
	/* IPv4 identification. */
	uint16_t	ip_id;
	/* IPv4 flags and offset. */
	uint16_t	flags_frag_offset;
	/* IPv4 TTL. */
	uint8_t	ttl;
	/* IPv4 protocol. */
	uint8_t	protocol;
	/* IPv4 source address. */
	uint32_t	src_ip_addr;
	/* IPv4 destination address. */
	uint32_t	dest_ip_addr;
} hwrm_vxlan_ipv4_hdr_t, *phwrm_vxlan_ipv4_hdr_t;

/* hwrm_vxlan_ipv6_hdr (size:320b/40B) */

typedef struct hwrm_vxlan_ipv6_hdr {
	/* IPv6 version, traffic class and flow label. */
	uint32_t	ver_tc_flow_label;
	/* IPv6 version shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_VER_SFT	UINT32_C(0x1c)
	/* IPv6 version mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_VER_MASK	UINT32_C(0xf0000000)
	/* IPv6 TC shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_TC_SFT	UINT32_C(0x14)
	/* IPv6 TC mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_TC_MASK	UINT32_C(0xff00000)
	/* IPv6 flow label shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_SFT  UINT32_C(0x0)
	/* IPv6 flow label mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_MASK UINT32_C(0xfffff)
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_LAST	HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_MASK
	/* IPv6 payload length. */
	uint16_t	payload_len;
	/* IPv6 next header. */
	uint8_t	next_hdr;
	/* IPv6 TTL. */
	uint8_t	ttl;
	/* IPv6 source address. */
	uint32_t	src_ip_addr[4];
	/* IPv6 destination address. */
	uint32_t	dest_ip_addr[4];
} hwrm_vxlan_ipv6_hdr_t, *phwrm_vxlan_ipv6_hdr_t;

/* hwrm_cfa_encap_data_vxlan (size:640b/80B) */

typedef struct hwrm_cfa_encap_data_vxlan {
	/* Source MAC address. */
	uint8_t	src_mac_addr[6];
	/* reserved. */
	uint16_t	unused_0;
	/* Destination MAC address. */
	uint8_t	dst_mac_addr[6];
	/* Number of VLAN tags. */
	uint8_t	num_vlan_tags;
	/* reserved. */
	uint8_t	unused_1;
	/* Outer VLAN TPID. */
	uint16_t	ovlan_tpid;
	/* Outer VLAN TCI. */
	uint16_t	ovlan_tci;
	/* Inner VLAN TPID. */
	uint16_t	ivlan_tpid;
	/* Inner VLAN TCI. */
	uint16_t	ivlan_tci;
	/* L3 header fields. */
	uint32_t	l3[10];
	/* IP version mask. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_MASK UINT32_C(0xf)
	/* IP version 4. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV4 UINT32_C(0x4)
	/* IP version 6. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV6 UINT32_C(0x6)
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_LAST	HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV6
	/* UDP source port. */
	uint16_t	src_port;
	/* UDP destination port. */
	uint16_t	dst_port;
	/* VXLAN Network Identifier. */
	uint32_t	vni;
	/*
	 * 3 bytes VXLAN header reserve fields from 1st dword of the VXLAN
	 * header.
	 */
	uint8_t	hdr_rsvd0[3];
	/* 1 byte VXLAN header reserve field from 2nd dword of the VXLAN header. */
	uint8_t	hdr_rsvd1;
	/* VXLAN header flags field. */
	uint8_t	hdr_flags;
	uint8_t	unused[3];
} hwrm_cfa_encap_data_vxlan_t, *phwrm_cfa_encap_data_vxlan_t;

/*******************************
 * hwrm_cfa_encap_record_alloc *
 *******************************/


/* hwrm_cfa_encap_record_alloc_input (size:832b/104B) */

typedef struct hwrm_cfa_encap_record_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_FLAGS_LOOPBACK	UINT32_C(0x1)
	/*
	 * Setting of this flag indicates this encap record is external
	 * encap record. Resetting of this flag indicates this flag is
	 * internal encap record and this is the default setting.
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_FLAGS_EXTERNAL	UINT32_C(0x2)
	/* Encapsulation Type. */
	uint8_t	encap_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) after inside Ethernet payload */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_MPLS	UINT32_C(0x6)
	/* VLAN */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VLAN	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_GPE	UINT32_C(0x10)
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_LAST	HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_GPE
	uint8_t	unused_0[3];
	/* This value is encap data used for the given encap type. */
	uint32_t	encap_data[20];
} hwrm_cfa_encap_record_alloc_input_t, *phwrm_cfa_encap_record_alloc_input_t;

/* hwrm_cfa_encap_record_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_encap_record_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	encap_record_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_encap_record_alloc_output_t, *phwrm_cfa_encap_record_alloc_output_t;

/******************************
 * hwrm_cfa_encap_record_free *
 ******************************/


/* hwrm_cfa_encap_record_free_input (size:192b/24B) */

typedef struct hwrm_cfa_encap_record_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	encap_record_id;
	uint8_t	unused_0[4];
} hwrm_cfa_encap_record_free_input_t, *phwrm_cfa_encap_record_free_input_t;

/* hwrm_cfa_encap_record_free_output (size:128b/16B) */

typedef struct hwrm_cfa_encap_record_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_encap_record_free_output_t, *phwrm_cfa_encap_record_free_output_t;

/********************************
 * hwrm_cfa_ntuple_filter_alloc *
 ********************************/


/* hwrm_cfa_ntuple_filter_alloc_input (size:1024b/128B) */

typedef struct hwrm_cfa_ntuple_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK		UINT32_C(0x1)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DROP		UINT32_C(0x2)
	/*
	 * Setting of this flag indicates that a meter is expected to be
	 * attached to this flow. This hint can be used when choosing the
	 * action record format required for the flow.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_METER		UINT32_C(0x4)
	/*
	 * Setting of this flag indicates that the dst_id field contains
	 * function ID. If this is not set it indicates dest_id is VNIC
	 * or VPORT.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DEST_FID		UINT32_C(0x8)
	/*
	 * Setting of this flag indicates match on arp reply when ethertype
	 * is 0x0806. If this is not set it indicates no specific arp opcode
	 * matching.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_ARP_REPLY		UINT32_C(0x10)
	/*
	 * Setting of this flag indicates that the dst_id field contains RFS
	 * ring table index. If this is not set it indicates dst_id is VNIC
	 * or VPORT or function ID. Note dest_fid and dest_rfs_ring_idx
	 * can't be set at the same time. Updated drivers should pass ring
	 * idx in the rfs_ring_tbl_idx field if the firmware indicates
	 * support for the new field in the HWRM_CFA_ADV_FLOW_MGMT_QCAPS
	 * response.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DEST_RFS_RING_IDX	UINT32_C(0x20)
	/*
	 * Setting of this flag indicates that when the ntuple filter is
	 * created, the L2 context should not be used in the filter. This
	 * allows packet from different L2 contexts to match and be directed
	 * to the same destination.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_NO_L2_CONTEXT	UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_MACADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the src_ipaddr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR_MASK	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the dst_ipaddr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR_MASK	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the src_port_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT_MASK	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_PORT		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the dst_port_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_PORT_MASK	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the pri_hint field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_PRI_HINT		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the ntuple_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_NTUPLE_FILTER_ID	UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x10000)
	/* This flag is deprecated. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_MACADDR	UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the rfs_ring_tbl_idx field to
	 * be configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_RFS_RING_TBL_IDX	UINT32_C(0x80000)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4	UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6	UINT32_C(0x6)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_LAST   HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol field in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 * 1 - ICMP
	 * 58 - ICMPV6
	 * 255 - RSVD
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP	UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP	UINT32_C(0x11)
	/* ICMP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_ICMP	UINT32_C(0x1)
	/* ICMPV6 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_ICMPV6  UINT32_C(0x3a)
	/* RSVD */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_RSVD	UINT32_C(0xff)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_LAST   HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_RSVD
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * If set, this value shall represent the ring table
	 * index for receive flow steering. Note that this offset
	 * was formerly used for the mirror_vnic_id field, which
	 * is no longer supported.
	 */
	uint16_t	rfs_ring_tbl_idx;
	/*
	 * This value indicates the tunnel type for this filter.
	 * If this field is not specified, then the filter shall
	 * apply to both non-tunneled and tunneled packets.
	 * If this field conflicts with the tunnel_type specified
	 * in the l2_filter_id, then the HWRM shall return an
	 * error for this command.
	 */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/*
	 * This hint is provided to help in placing
	 * the filter in the filter table.
	 */
	uint8_t	pri_hint;
	/* No preference */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_NO_PREFER UINT32_C(0x0)
	/* Above the given filter */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_ABOVE	UINT32_C(0x1)
	/* Below the given filter */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_BELOW	UINT32_C(0x2)
	/* As high as possible */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_HIGHEST   UINT32_C(0x3)
	/* As low as possible */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LOWEST	UINT32_C(0x4)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LAST	HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LOWEST
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * The value of source IP address mask to be used in
	 * filtering.
	 * For IPv4, first four bytes represent the IP address mask.
	 */
	uint32_t	src_ipaddr_mask[4];
	/*
	 * The value of destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of destination IP address mask to be used in
	 * filtering.
	 * For IPv4, first four bytes represent the IP address mask.
	 */
	uint32_t	dst_ipaddr_mask[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of source port mask to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port_mask;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * The value of destination port mask to be used in
	 * filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port_mask;
	/*
	 * This is the ID of the filter that goes along with
	 * the pri_hint.
	 */
	uint64_t	ntuple_filter_id_hint;
} hwrm_cfa_ntuple_filter_alloc_input_t, *phwrm_cfa_ntuple_filter_alloc_input_t;

/* hwrm_cfa_ntuple_filter_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_ntuple_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ntuple_filter_alloc_output_t, *phwrm_cfa_ntuple_filter_alloc_output_t;

/* hwrm_cfa_ntuple_filter_alloc_cmd_err (size:64b/8B) */

typedef struct hwrm_cfa_ntuple_filter_alloc_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_UNKNOWN		UINT32_C(0x0)
	/* Unable to complete operation due to conflict with Rx Mask VLAN */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_RX_MASK_VLAN_CONFLICT_ERR UINT32_C(0x1)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_LAST			HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_RX_MASK_VLAN_CONFLICT_ERR
	uint8_t	unused_0[7];
} hwrm_cfa_ntuple_filter_alloc_cmd_err_t, *phwrm_cfa_ntuple_filter_alloc_cmd_err_t;

/*******************************
 * hwrm_cfa_ntuple_filter_free *
 *******************************/


/* hwrm_cfa_ntuple_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_ntuple_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
} hwrm_cfa_ntuple_filter_free_input_t, *phwrm_cfa_ntuple_filter_free_input_t;

/* hwrm_cfa_ntuple_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_ntuple_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ntuple_filter_free_output_t, *phwrm_cfa_ntuple_filter_free_output_t;

/******************************
 * hwrm_cfa_ntuple_filter_cfg *
 ******************************/


/* hwrm_cfa_ntuple_filter_cfg_input (size:384b/48B) */

typedef struct hwrm_cfa_ntuple_filter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the new_dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_DST_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the new_mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the new_meter_instance_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_METER_INSTANCE_ID	UINT32_C(0x4)
	uint32_t	flags;
	/*
	 * Setting this bit to 1 indicates that dest_id field contains FID.
	 * Setting this to 0 indicates that dest_id field contains VNIC or
	 * VPORT.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_FLAGS_DEST_FID		UINT32_C(0x1)
	/*
	 * Setting of this flag indicates that the new_dst_id field contains
	 * RFS ring table index. If this is not set it indicates new_dst_id
	 * is VNIC or VPORT or function ID. Note dest_fid and
	 * dest_rfs_ring_idx can't be set at the same time.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_FLAGS_DEST_RFS_RING_IDX	UINT32_C(0x2)
	/*
	 * Setting of this flag indicates that when the ntuple filter is
	 * created, the L2 context should not be used in the filter. This
	 * allows packet from different L2 contexts to match and be directed
	 * to the same destination.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_FLAGS_NO_L2_CONTEXT	UINT32_C(0x4)
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
	/*
	 * If set, this value shall represent the new
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and new network port id of the destination port for
	 * the TX path.
	 */
	uint32_t	new_dst_id;
	/*
	 * New Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	new_mirror_vnic_id;
	/*
	 * New meter to attach to the flow. Specifying the
	 * invalid instance ID is used to remove any existing
	 * meter from the flow.
	 */
	uint16_t	new_meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_LAST   HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID
	uint8_t	unused_1[6];
} hwrm_cfa_ntuple_filter_cfg_input_t, *phwrm_cfa_ntuple_filter_cfg_input_t;

/* hwrm_cfa_ntuple_filter_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_ntuple_filter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ntuple_filter_cfg_output_t, *phwrm_cfa_ntuple_filter_cfg_output_t;

/**************************
 * hwrm_cfa_em_flow_alloc *
 **************************/


/* hwrm_cfa_em_flow_alloc_input (size:896b/112B) */

typedef struct hwrm_cfa_em_flow_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_LAST	HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates enabling of a byte counter for a
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_BYTE_CTR	UINT32_C(0x2)
	/*
	 * Setting of this flag indicates enabling of a packet counter for a
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PKT_CTR	UINT32_C(0x4)
	/*
	 * Setting of this flag indicates de-capsulation action for the
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_DECAP	UINT32_C(0x8)
	/*
	 * Setting of this flag indicates encapsulation action for the
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_ENCAP	UINT32_C(0x10)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_DROP	UINT32_C(0x20)
	/*
	 * Setting of this flag indicates that a meter is expected to be
	 * attached to this flow. This hint can be used when choosing the
	 * action record format required for the flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_METER	UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_L2_FILTER_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tunnel_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_TUNNEL_ID		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_MACADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_MACADDR	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_OVLAN_VID		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IVLAN_VID		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_ETHERTYPE		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_IPADDR		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_IPADDR		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IPADDR_TYPE	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IP_PROTOCOL	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_PORT		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_PORT		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the encap_record_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_ENCAP_RECORD_ID	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the meter_instance_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_METER_INSTANCE_ID	UINT32_C(0x20000)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[3];
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	tunnel_id;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	/* The meter instance to attach to the flow. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_LAST   HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_INVALID
	/*
	 * This value indicates the destination MAC address in
	 * the Ethernet header.
	 */
	uint8_t	dst_macaddr[6];
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ivlan_vid;
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV4	UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV6	UINT32_C(0x6)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_LAST   HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol field in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_TCP	UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UDP	UINT32_C(0x11)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_LAST   HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UDP
	uint8_t	unused_1[2];
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * big_endian = True
	 *	The value of destination IP address to be used in filtering.
	 *	For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	/* Logical ID of the encapsulation record. */
	uint32_t	encap_record_id;
	uint8_t	unused_2[4];
} hwrm_cfa_em_flow_alloc_input_t, *phwrm_cfa_em_flow_alloc_input_t;

/* hwrm_cfa_em_flow_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_em_flow_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	em_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_em_flow_alloc_output_t, *phwrm_cfa_em_flow_alloc_output_t;

/*************************
 * hwrm_cfa_em_flow_free *
 *************************/


/* hwrm_cfa_em_flow_free_input (size:192b/24B) */

typedef struct hwrm_cfa_em_flow_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	em_filter_id;
} hwrm_cfa_em_flow_free_input_t, *phwrm_cfa_em_flow_free_input_t;

/* hwrm_cfa_em_flow_free_output (size:128b/16B) */

typedef struct hwrm_cfa_em_flow_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_em_flow_free_output_t, *phwrm_cfa_em_flow_free_output_t;

/************************
 * hwrm_cfa_em_flow_cfg *
 ************************/


/* hwrm_cfa_em_flow_cfg_input (size:384b/48B) */

typedef struct hwrm_cfa_em_flow_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the new_dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_CFG_INPUT_ENABLES_NEW_DST_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the new_mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the new_meter_instance_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_CFG_INPUT_ENABLES_NEW_METER_INSTANCE_ID	UINT32_C(0x4)
	uint8_t	unused_0[4];
	/* This value is an opaque id into CFA data structures. */
	uint64_t	em_filter_id;
	/*
	 * If set, this value shall represent the new
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint32_t	new_dst_id;
	/*
	 * New Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	new_mirror_vnic_id;
	/*
	 * New meter to attach to the flow. Specifying the
	 * invalid instance ID is used to remove any existing
	 * meter from the flow.
	 */
	uint16_t	new_meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_EM_FLOW_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_EM_FLOW_CFG_INPUT_NEW_METER_INSTANCE_ID_LAST   HWRM_CFA_EM_FLOW_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID
	uint8_t	unused_1[6];
} hwrm_cfa_em_flow_cfg_input_t, *phwrm_cfa_em_flow_cfg_input_t;

/* hwrm_cfa_em_flow_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_em_flow_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_em_flow_cfg_output_t, *phwrm_cfa_em_flow_cfg_output_t;

/************************
 * hwrm_cfa_meter_qcaps *
 ************************/


/* hwrm_cfa_meter_qcaps_input (size:128b/16B) */

typedef struct hwrm_cfa_meter_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cfa_meter_qcaps_input_t, *phwrm_cfa_meter_qcaps_input_t;

/* hwrm_cfa_meter_qcaps_output (size:320b/40B) */

typedef struct hwrm_cfa_meter_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * Enumeration denoting the clock at which the Meter is running
	 * with. This enumeration is used for resources that are similar
	 * for both TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_MASK  UINT32_C(0xf)
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_SFT   0
	/* 375 MHz */
		#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_375MHZ  UINT32_C(0x0)
	/* 625 MHz */
		#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_625MHZ  UINT32_C(0x1)
		#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_LAST   HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_625MHZ
	uint8_t	unused_0[4];
	/*
	 * The minimum guaranteed number of tx meter profiles supported
	 * for this function.
	 */
	uint16_t	min_tx_profile;
	/*
	 * The maximum non-guaranteed number of tx meter profiles supported
	 * for this function.
	 */
	uint16_t	max_tx_profile;
	/*
	 * The minimum guaranteed number of rx meter profiles supported
	 * for this function.
	 */
	uint16_t	min_rx_profile;
	/*
	 * The maximum non-guaranteed number of rx meter profiles supported
	 * for this function.
	 */
	uint16_t	max_rx_profile;
	/*
	 * The minimum guaranteed number of tx meter instances supported
	 * for this function.
	 */
	uint16_t	min_tx_instance;
	/*
	 * The maximum non-guaranteed number of tx meter instances supported
	 * for this function.
	 */
	uint16_t	max_tx_instance;
	/*
	 * The minimum guaranteed number of rx meter instances supported
	 * for this function.
	 */
	uint16_t	min_rx_instance;
	/*
	 * The maximum non-guaranteed number of rx meter instances supported
	 * for this function.
	 */
	uint16_t	max_rx_instance;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_qcaps_output_t, *phwrm_cfa_meter_qcaps_output_t;

/********************************
 * hwrm_cfa_meter_profile_alloc *
 ********************************/


/* hwrm_cfa_meter_profile_alloc_input (size:320b/40B) */

typedef struct hwrm_cfa_meter_profile_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_RX
	/* The meter algorithm type. */
	uint8_t	meter_type;
	/* RFC 2697 (srTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC2697 UINT32_C(0x0)
	/* RFC 2698 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC2698 UINT32_C(0x1)
	/* RFC 4115 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC4115 UINT32_C(0x2)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_LAST   HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC4115
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved1;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved2;
	/* A meter rate specified in bytes-per-second. */
	uint32_t	commit_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_LAST		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Raw value */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	commit_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_LAST		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid value */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
	/* A meter rate specified in bytes-per-second. */
	uint32_t	excess_peak_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_LAST		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Raw unit */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	excess_peak_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_LAST		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
} hwrm_cfa_meter_profile_alloc_input_t, *phwrm_cfa_meter_profile_alloc_input_t;

/* hwrm_cfa_meter_profile_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_profile_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_profile_alloc_output_t, *phwrm_cfa_meter_profile_alloc_output_t;

/*******************************
 * hwrm_cfa_meter_profile_free *
 *******************************/


/* hwrm_cfa_meter_profile_free_input (size:192b/24B) */

typedef struct hwrm_cfa_meter_profile_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_1[4];
} hwrm_cfa_meter_profile_free_input_t, *phwrm_cfa_meter_profile_free_input_t;

/* hwrm_cfa_meter_profile_free_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_profile_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_profile_free_output_t, *phwrm_cfa_meter_profile_free_output_t;

/******************************
 * hwrm_cfa_meter_profile_cfg *
 ******************************/


/* hwrm_cfa_meter_profile_cfg_input (size:320b/40B) */

typedef struct hwrm_cfa_meter_profile_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_RX
	/* The meter algorithm type. */
	uint8_t	meter_type;
	/* RFC 2697 (srTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC2697 UINT32_C(0x0)
	/* RFC 2698 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC2698 UINT32_C(0x1)
	/* RFC 4115 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC4115 UINT32_C(0x2)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_LAST   HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC4115
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_INVALID
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved;
	/* A meter rate specified in bytes-per-second. */
	uint32_t	commit_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_LAST		HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Raw value */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	commit_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_LAST		HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid value */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
	/* A meter rate specified in bytes-per-second. */
	uint32_t	excess_peak_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_LAST		HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Raw unit */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	excess_peak_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_LAST		HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
} hwrm_cfa_meter_profile_cfg_input_t, *phwrm_cfa_meter_profile_cfg_input_t;

/* hwrm_cfa_meter_profile_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_profile_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_profile_cfg_output_t, *phwrm_cfa_meter_profile_cfg_output_t;

/*********************************
 * hwrm_cfa_meter_instance_alloc *
 *********************************/


/* hwrm_cfa_meter_instance_alloc_input (size:192b/24B) */

typedef struct hwrm_cfa_meter_instance_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_1[4];
} hwrm_cfa_meter_instance_alloc_input_t, *phwrm_cfa_meter_instance_alloc_input_t;

/* hwrm_cfa_meter_instance_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_instance_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value identifies a meter instance in CFA. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_LAST   HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_INVALID
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_instance_alloc_output_t, *phwrm_cfa_meter_instance_alloc_output_t;

/*******************************
 * hwrm_cfa_meter_instance_cfg *
 *******************************/


/* hwrm_cfa_meter_instance_cfg_input (size:192b/24B) */

typedef struct hwrm_cfa_meter_instance_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/*
	 * This value identifies a new meter profile to be associated with
	 * the meter instance specified in this command.
	 */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_INVALID
	/*
	 * This value identifies the ID of a meter instance that needs to be
	 * updated with a new meter profile specified in this command.
	 */
	uint16_t	meter_instance_id;
	uint8_t	unused_1[2];
} hwrm_cfa_meter_instance_cfg_input_t, *phwrm_cfa_meter_instance_cfg_input_t;

/* hwrm_cfa_meter_instance_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_instance_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_instance_cfg_output_t, *phwrm_cfa_meter_instance_cfg_output_t;

/********************************
 * hwrm_cfa_meter_instance_free *
 ********************************/


/* hwrm_cfa_meter_instance_free_input (size:192b/24B) */

typedef struct hwrm_cfa_meter_instance_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter instance in CFA. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_LAST   HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_INVALID
	uint8_t	unused_1[4];
} hwrm_cfa_meter_instance_free_input_t, *phwrm_cfa_meter_instance_free_input_t;

/* hwrm_cfa_meter_instance_free_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_instance_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_instance_free_output_t, *phwrm_cfa_meter_instance_free_output_t;

/*******************************
 * hwrm_cfa_decap_filter_alloc *
 *******************************/


/* hwrm_cfa_decap_filter_alloc_input (size:832b/104B) */

typedef struct hwrm_cfa_decap_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* ovs_tunnel is 1 b */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_FLAGS_OVS_TUNNEL	UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tunnel_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_MACADDR	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_MACADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_OVLAN_VID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IVLAN_VID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_T_OVLAN_VID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the t_ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_T_IVLAN_VID	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL	UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_PORT	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x10000)
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	tunnel_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0;
	uint16_t	unused_1;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	uint8_t	unused_2[2];
	/*
	 * This value indicates the destination MAC address in
	 * the Ethernet header.
	 */
	uint8_t	dst_macaddr[6];
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ivlan_vid;
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the tunnel Ethernet header.
	 */
	uint16_t	t_ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the tunnel Ethernet header.
	 */
	uint16_t	t_ivlan_vid;
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4	UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6	UINT32_C(0x6)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_LAST   HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol field in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP	UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP	UINT32_C(0x11)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_LAST   HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP
	uint16_t	unused_3;
	uint32_t	unused_4;
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * The value of destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path.
	 */
	uint16_t	dst_id;
	/*
	 * If set, this value shall represent the L2 context that matches the
	 * L2 information of the decap filter.
	 */
	uint16_t	l2_ctxt_ref_id;
} hwrm_cfa_decap_filter_alloc_input_t, *phwrm_cfa_decap_filter_alloc_input_t;

/* hwrm_cfa_decap_filter_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_decap_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	decap_filter_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_decap_filter_alloc_output_t, *phwrm_cfa_decap_filter_alloc_output_t;

/******************************
 * hwrm_cfa_decap_filter_free *
 ******************************/


/* hwrm_cfa_decap_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_decap_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	decap_filter_id;
	uint8_t	unused_0[4];
} hwrm_cfa_decap_filter_free_input_t, *phwrm_cfa_decap_filter_free_input_t;

/* hwrm_cfa_decap_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_decap_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_decap_filter_free_output_t, *phwrm_cfa_decap_filter_free_output_t;

/***********************
 * hwrm_cfa_flow_alloc *
 ***********************/


/* hwrm_cfa_flow_alloc_input (size:1024b/128B) */

typedef struct hwrm_cfa_flow_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* tunnel is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_TUNNEL		UINT32_C(0x1)
	/* num_vlan is 2 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_MASK	UINT32_C(0x6)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_SFT	1
	/* no tags */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_NONE		(UINT32_C(0x0) << 1)
	/* 1 tag */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_ONE		(UINT32_C(0x1) << 1)
	/* 2 tags */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_TWO		(UINT32_C(0x2) << 1)
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_LAST	HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_TWO
	/* Enumeration denoting the Flow Type. */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_MASK	UINT32_C(0x38)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_SFT	3
	/* L2 flow */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_L2		(UINT32_C(0x0) << 3)
	/* IPV4 flow */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV4		(UINT32_C(0x1) << 3)
	/* IPV6 flow */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV6		(UINT32_C(0x2) << 3)
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_LAST	HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV6
	/*
	 * when set to 1, indicates TX flow offload for function specified
	 * in src_fid and the dst_fid should be set to invalid value. To
	 * indicate a VM to VM flow, both of the path_tx and path_rx flags
	 * need to be set. For virtio vSwitch offload case, the src_fid and
	 * dst_fid is set to the same fid value. For the SRIOV vSwitch
	 * offload case, the src_fid and dst_fid must be set to the same VF
	 * FID belong to the children VFs of the same PF to indicate VM to
	 * VM flow.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_PATH_TX		UINT32_C(0x40)
	/*
	 * when set to 1, indicates RX flow offload for function specified
	 * in dst_fid and the src_fid should be set to invalid value.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_PATH_RX		UINT32_C(0x80)
	/*
	 * Set to 1 to indicate matching of VXLAN VNI from the custom vxlan
	 * header is required and the VXLAN VNI value is stored in the first
	 * 24 bits of the dmac field. This flag is only valid when the flow
	 * direction is RX.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_MATCH_VXLAN_IP_VNI	UINT32_C(0x100)
	/*
	 * Set to 1 to indicate vhost_id is specified in the outer_vlan_tci
	 * field.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_VHOST_ID_USE_VLAN	UINT32_C(0x200)
	/*
	 * Tx Flow: vf fid.
	 * Rx Flow: pf fid.
	 */
	uint16_t	src_fid;
	/* Tunnel handle valid when tunnel flag is set. */
	uint32_t	tunnel_handle;
	uint16_t	action_flags;
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_FWD			UINT32_C(0x1)
	/* recycle is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_RECYCLE		UINT32_C(0x2)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_DROP			UINT32_C(0x4)
	/* meter is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_METER			UINT32_C(0x8)
	/* tunnel is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TUNNEL			UINT32_C(0x10)
	/* nat_src is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_SRC		UINT32_C(0x20)
	/* nat_dest is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_DEST		UINT32_C(0x40)
	/* nat_ipv4_address is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_IPV4_ADDRESS	UINT32_C(0x80)
	/* l2_header_rewrite is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_L2_HEADER_REWRITE	UINT32_C(0x100)
	/* ttl_decrement is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TTL_DECREMENT		UINT32_C(0x200)
	/*
	 * If set to 1 and flow direction is TX, it indicates decap of L2
	 * header and encap of tunnel header. If set to 1 and flow direction
	 * is RX, it indicates decap of tunnel header and encap L2 header.
	 * The type of tunnel is specified in the tunnel_type field.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TUNNEL_IP		UINT32_C(0x400)
	/* If set to 1, flow aging is enabled for this flow. */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_FLOW_AGING_ENABLED	UINT32_C(0x800)
	/*
	 * If set to 1 an attempt will be made to try to offload this flow
	 * to the most optimal flow table resource. If set to 0, the flow
	 * will be placed to the default flow table resource.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_PRI_HINT		UINT32_C(0x1000)
	/*
	 * If set to 1 there will be no attempt to allocate an on-chip try
	 * to offload this flow. If set to 0, which will keep compatibility
	 * with the older drivers, will cause the FW to attempt to allocate
	 * an on-chip flow counter for the newly created flow. This will
	 * keep the existing behavior with EM flows which always had an
	 * associated flow counter.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NO_FLOW_COUNTER_ALLOC	UINT32_C(0x2000)
	/*
	 * Tx Flow: pf or vf fid.
	 * Rx Flow: vf fid.
	 */
	uint16_t	dst_fid;
	/* VLAN tpid, valid when push_vlan flag is set. */
	uint16_t	l2_rewrite_vlan_tpid;
	/* VLAN tci, valid when push_vlan flag is set. */
	uint16_t	l2_rewrite_vlan_tci;
	/* Meter id, valid when meter flag is set. */
	uint16_t	act_meter_id;
	/* Flow with the same l2 context tcam key. */
	uint16_t	ref_flow_handle;
	/* This value sets the match value for the ethertype. */
	uint16_t	ethertype;
	/* valid when num tags is 1 or 2. */
	uint16_t	outer_vlan_tci;
	/* This value sets the match value for the Destination MAC address. */
	uint16_t	dmac[3];
	/* valid when num tags is 2. */
	uint16_t	inner_vlan_tci;
	/* This value sets the match value for the Source MAC address. */
	uint16_t	smac[3];
	/* The bit length of destination IP address mask. */
	uint8_t	ip_dst_mask_len;
	/* The bit length of source IP address mask. */
	uint8_t	ip_src_mask_len;
	/* The value of destination IPv4/IPv6 address. */
	uint32_t	ip_dst[4];
	/* The source IPv4/IPv6 address. */
	uint32_t	ip_src[4];
	/*
	 * The value of source port.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_src_port;
	/*
	 * The value of source port mask.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_src_port_mask;
	/*
	 * The value of destination port.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_dst_port;
	/*
	 * The value of destination port mask.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_dst_port_mask;
	/*
	 * NAT IPv4/6 address based on address type flag.
	 * 0 values are ignored.
	 */
	uint32_t	nat_ip_address[4];
	/* L2 header re-write Destination MAC address. */
	uint16_t	l2_rewrite_dmac[3];
	/*
	 * The NAT source/destination port based on direction flag.
	 * Applies to UDP and TCP traffic.
	 * 0 values are ignored.
	 */
	uint16_t	nat_port;
	/* L2 header re-write Source MAC address. */
	uint16_t	l2_rewrite_smac[3];
	/* The value of ip protocol. */
	uint8_t	ip_proto;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
} hwrm_cfa_flow_alloc_input_t, *phwrm_cfa_flow_alloc_input_t;

/* hwrm_cfa_flow_alloc_output (size:256b/32B) */

typedef struct hwrm_cfa_flow_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint8_t	unused_0[2];
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
	uint32_t	flow_counter_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_alloc_output_t, *phwrm_cfa_flow_alloc_output_t;

/* hwrm_cfa_flow_alloc_cmd_err (size:64b/8B) */

typedef struct hwrm_cfa_flow_alloc_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* No more L2 Context TCAM */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_L2_CONTEXT_TCAM UINT32_C(0x1)
	/* No more action records */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_ACTION_RECORD   UINT32_C(0x2)
	/* No more flow counters */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_COUNTER	UINT32_C(0x3)
	/* No more wild-card TCAM */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_WILD_CARD_TCAM  UINT32_C(0x4)
	/* Hash collision in exact match tables */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_HASH_COLLISION  UINT32_C(0x5)
	/* Key is already installed */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_KEY_EXISTS	UINT32_C(0x6)
	/* Flow Context DB is out of resource */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_CTXT_DB	UINT32_C(0x7)
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_LAST	HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_CTXT_DB
	uint8_t	unused_0[7];
} hwrm_cfa_flow_alloc_cmd_err_t, *phwrm_cfa_flow_alloc_cmd_err_t;

/**********************
 * hwrm_cfa_flow_free *
 **********************/


/* hwrm_cfa_flow_free_input (size:256b/32B) */

typedef struct hwrm_cfa_flow_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint16_t	unused_0;
	/* Flow counter id to be freed. */
	uint32_t	flow_counter_id;
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} hwrm_cfa_flow_free_input_t, *phwrm_cfa_flow_free_input_t;

/* hwrm_cfa_flow_free_output (size:256b/32B) */

typedef struct hwrm_cfa_flow_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* packet is 64 b */
	uint64_t	packet;
	/* byte is 64 b */
	uint64_t	byte;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_free_output_t, *phwrm_cfa_flow_free_output_t;

/* hwrm_cfa_flow_action_data (size:960b/120B) */

typedef struct hwrm_cfa_flow_action_data {
	uint16_t	action_flags;
	/* Setting of this flag indicates accept action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_FWD			UINT32_C(0x1)
	/* Setting of this flag indicates recycle action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_RECYCLE		UINT32_C(0x2)
	/* Setting of this flag indicates drop action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_DROP		UINT32_C(0x4)
	/* Setting of this flag indicates meter action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_METER		UINT32_C(0x8)
	/* Setting of this flag indicates tunnel action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TUNNEL		UINT32_C(0x10)
	/*
	 * If set to 1 and flow direction is TX, it indicates decap of L2
	 * header and encap of tunnel header. If set to 1 and flow direction
	 * is RX, it indicates decap of tunnel header and encap L2 header.
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TUNNEL_IP		UINT32_C(0x20)
	/* Setting of this flag indicates ttl decrement action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TTL_DECREMENT	UINT32_C(0x40)
	/* If set to 1, flow aging is enabled for this flow. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_FLOW_AGING_ENABLED	UINT32_C(0x80)
	/* Setting of this flag indicates encap action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_ENCAP		UINT32_C(0x100)
	/* Setting of this flag indicates decap action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_DECAP		UINT32_C(0x200)
	/* Meter id. */
	uint16_t	act_meter_id;
	/* VNIC id. */
	uint16_t	vnic_id;
	/* vport number. */
	uint16_t	vport_id;
	/* The NAT source/destination. */
	uint16_t	nat_port;
	uint16_t	unused_0[3];
	/* NAT IPv4/IPv6 address. */
	uint32_t	nat_ip_address[4];
	/* Encapsulation Type. */
	uint8_t	encap_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) after inside Ethernet payload */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_MPLS	UINT32_C(0x6)
	/* VLAN */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VLAN	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_GPE	UINT32_C(0x10)
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_LAST	HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_GPE
	uint8_t	unused[7];
	/* This value is encap data for the associated encap type. */
	uint32_t	encap_data[20];
} hwrm_cfa_flow_action_data_t, *phwrm_cfa_flow_action_data_t;

/* hwrm_cfa_flow_tunnel_hdr_data (size:64b/8B) */

typedef struct hwrm_cfa_flow_tunnel_hdr_data {
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Any tunneled traffic */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_LAST	HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused[3];
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI).
	 */
	uint32_t	tunnel_id;
} hwrm_cfa_flow_tunnel_hdr_data_t, *phwrm_cfa_flow_tunnel_hdr_data_t;

/* hwrm_cfa_flow_l4_key_data (size:64b/8B) */

typedef struct hwrm_cfa_flow_l4_key_data {
	/* The value of source port. */
	uint16_t	l4_src_port;
	/* The value of destination port. */
	uint16_t	l4_dst_port;
	uint32_t	unused;
} hwrm_cfa_flow_l4_key_data_t, *phwrm_cfa_flow_l4_key_data_t;

/* hwrm_cfa_flow_l3_key_data (size:512b/64B) */

typedef struct hwrm_cfa_flow_l3_key_data {
	/* The value of ip protocol. */
	uint8_t	ip_protocol;
	uint8_t	unused_0[7];
	/* The value of destination IPv4/IPv6 address. */
	uint32_t	ip_dst[4];
	/* The source IPv4/IPv6 address. */
	uint32_t	ip_src[4];
	/* NAT IPv4/IPv6 address. */
	uint32_t	nat_ip_address[4];
	uint64_t	unused;
} hwrm_cfa_flow_l3_key_data_t, *phwrm_cfa_flow_l3_key_data_t;

/* hwrm_cfa_flow_l2_key_data (size:448b/56B) */

typedef struct hwrm_cfa_flow_l2_key_data {
	/* Destination MAC address. */
	uint16_t	dmac[3];
	uint16_t	unused_0;
	/* Source MAC address. */
	uint16_t	smac[3];
	uint16_t	unused_1;
	/* L2 header re-write Destination MAC address. */
	uint16_t	l2_rewrite_dmac[3];
	uint16_t	unused_2;
	/* L2 header re-write Source MAC address. */
	uint16_t	l2_rewrite_smac[3];
	/* Ethertype. */
	uint16_t	ethertype;
	/* Number of VLAN tags. */
	uint16_t	num_vlan_tags;
	/* VLAN tpid. */
	uint16_t	l2_rewrite_vlan_tpid;
	/* VLAN tci. */
	uint16_t	l2_rewrite_vlan_tci;
	uint8_t	unused_3[2];
	/* Outer VLAN TPID. */
	uint16_t	ovlan_tpid;
	/* Outer VLAN TCI. */
	uint16_t	ovlan_tci;
	/* Inner VLAN TPID. */
	uint16_t	ivlan_tpid;
	/* Inner VLAN TCI. */
	uint16_t	ivlan_tci;
	uint8_t	unused[8];
} hwrm_cfa_flow_l2_key_data_t, *phwrm_cfa_flow_l2_key_data_t;

/* hwrm_cfa_flow_key_data (size:4160b/520B) */

typedef struct hwrm_cfa_flow_key_data {
	/* Flow associated tunnel L2 header key info. */
	uint32_t	t_l2_key_data[14];
	/* Flow associated tunnel L2 header mask info. */
	uint32_t	t_l2_key_mask[14];
	/* Flow associated tunnel L3 header key info. */
	uint32_t	t_l3_key_data[16];
	/* Flow associated tunnel L3 header mask info. */
	uint32_t	t_l3_key_mask[16];
	/* Flow associated tunnel L4 header key info. */
	uint64_t	t_l4_key_data;
	/* Flow associated tunnel L4 header mask info. */
	uint64_t	t_l4_key_mask;
	/* Flow associated tunnel header info. */
	uint64_t	tunnel_hdr;
	/* Flow associated L2 header key info. */
	uint32_t	l2_key_data[14];
	/* Flow associated L2 header mask info. */
	uint32_t	l2_key_mask[14];
	/* Flow associated L3 header key info. */
	uint32_t	l3_key_data[16];
	/* Flow associated L3 header mask info. */
	uint32_t	l3_key_mask[16];
	/* Flow associated L4 header key info. */
	uint64_t	l4_key_data;
	/* Flow associated L4 header mask info. */
	uint64_t	l4_key_mask;
} hwrm_cfa_flow_key_data_t, *phwrm_cfa_flow_key_data_t;

/**********************
 * hwrm_cfa_flow_info *
 **********************/


/* hwrm_cfa_flow_info_input (size:256b/32B) */

typedef struct hwrm_cfa_flow_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	/* Max flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_MAX_MASK	UINT32_C(0xfff)
	/* CNP flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_CNP_CNT	UINT32_C(0x1000)
	/* RoCEv1 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV1_CNT	UINT32_C(0x2000)
	/* NIC flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_NIC_TX	UINT32_C(0x3000)
	/* RoCEv2 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV2_CNT	UINT32_C(0x4000)
	/* Direction rx = 1 */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_DIR_RX	UINT32_C(0x8000)
	/* CNP flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_CNP_CNT_RX	UINT32_C(0x9000)
	/* RoCEv1 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV1_CNT_RX UINT32_C(0xa000)
	/* NIC flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_NIC_RX	UINT32_C(0xb000)
	/* RoCEv2 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV2_CNT_RX UINT32_C(0xc000)
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_LAST	HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV2_CNT_RX
	uint8_t	unused_0[6];
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} hwrm_cfa_flow_info_input_t, *phwrm_cfa_flow_info_input_t;

/* hwrm_cfa_flow_info_output (size:5632b/704B) */

typedef struct hwrm_cfa_flow_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_FLOW_INFO_OUTPUT_FLAGS_PATH_TX	UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_FLOW_INFO_OUTPUT_FLAGS_PATH_RX	UINT32_C(0x2)
	/* profile is 8 b */
	uint8_t	profile;
	/* src_fid is 16 b */
	uint16_t	src_fid;
	/* dst_fid is 16 b */
	uint16_t	dst_fid;
	/* l2_ctxt_id is 16 b */
	uint16_t	l2_ctxt_id;
	/* em_info is 64 b */
	uint64_t	em_info;
	/* tcam_info is 64 b */
	uint64_t	tcam_info;
	/* vfp_tcam_info is 64 b */
	uint64_t	vfp_tcam_info;
	/* ar_id is 16 b */
	uint16_t	ar_id;
	/* flow_handle is 16 b */
	uint16_t	flow_handle;
	/* tunnel_handle is 32 b */
	uint32_t	tunnel_handle;
	/* The flow aging timer for the flow, the unit is 100 milliseconds */
	uint16_t	flow_timer;
	uint8_t	unused_0[6];
	/* Flow associated L2, L3 and L4 headers info. */
	uint32_t	flow_key_data[130];
	/* Flow associated action record info. */
	uint32_t	flow_action_info[30];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_info_output_t, *phwrm_cfa_flow_info_output_t;

/***********************
 * hwrm_cfa_flow_flush *
 ***********************/


/* hwrm_cfa_flow_flush_input (size:256b/32B) */

typedef struct hwrm_cfa_flow_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* flags is 32 b */
	uint32_t	flags;
	/*
	 * Set to 1 to indicate the page size, page layers, and
	 * flow_handle_table_dma_addr fields are valid. The flow flush
	 * operation should only flush the flows from the flow table
	 * specified. This flag is set to 0 by older driver. For older
	 * firmware, setting this flag has no effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_TABLE_VALID			UINT32_C(0x1)
	/*
	 * Set to 1 to indicate flow flush operation to cleanup all the
	 * flows, meters, CFA context memory tables etc. This flag is set to
	 * 0 by older driver. For older firmware, setting this flag has no
	 * effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_RESET_ALL			UINT32_C(0x2)
	/*
	 * Set to 1 to indicate flow flush operation to cleanup all the
	 * flows by the caller. This flag is set to 0 by older driver. For
	 * older firmware, setting this flag has no effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_RESET_PORT			UINT32_C(0x4)
	/*
	 * Set to 1 to indicate the flow counter IDs are included in the
	 * flow table.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_INCL_FC		UINT32_C(0x8000000)
	/*
	 * This specifies the size of flow handle entries provided by the
	 * driver in the flow table specified below. Only two flow handle
	 * size enums are defined.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_MASK	UINT32_C(0xc0000000)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_SFT	30
	/* The flow handle is 16bit */
		#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_16BIT  (UINT32_C(0x0) << 30)
	/* The flow handle is 64bit */
		#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_64BIT  (UINT32_C(0x1) << 30)
		#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_LAST	HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_64BIT
	/* Specify page size of the flow table memory. */
	uint8_t	page_size;
	/* The page size is 4K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* The page size is 8K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* The page size is 64K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* The page size is 256K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* The page size is 1M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* The page size is 2M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* The page size is 4M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* The page size is 1G */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_LAST HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1G
	/* FLow table memory indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LAST HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_2
	/* number of flows in the flow table */
	uint16_t	num_flows;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
} hwrm_cfa_flow_flush_input_t, *phwrm_cfa_flow_flush_input_t;

/* hwrm_cfa_flow_flush_output (size:128b/16B) */

typedef struct hwrm_cfa_flow_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_flush_output_t, *phwrm_cfa_flow_flush_output_t;

/***********************
 * hwrm_cfa_flow_stats *
 ***********************/


/* hwrm_cfa_flow_stats_input (size:640b/80B) */

typedef struct hwrm_cfa_flow_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Number of valid flows in this command. */
	uint16_t	num_flows;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_0 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_0;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_1 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_1;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_2 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_2;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_3 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_3;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_4 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_4;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_5 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_5;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_6 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_6;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_7 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_7;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_8 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_8;
	/*
	 * Flow handle.
	 * For a listing of applicable flow_handle_9 values, see enumeration
	 * in hwrm_cfa_flow_info_input.
	 */
	uint16_t	flow_handle_9;
	uint8_t	unused_0[2];
	/* Flow ID of a flow. */
	uint32_t	flow_id_0;
	/* Flow ID of a flow. */
	uint32_t	flow_id_1;
	/* Flow ID of a flow. */
	uint32_t	flow_id_2;
	/* Flow ID of a flow. */
	uint32_t	flow_id_3;
	/* Flow ID of a flow. */
	uint32_t	flow_id_4;
	/* Flow ID of a flow. */
	uint32_t	flow_id_5;
	/* Flow ID of a flow. */
	uint32_t	flow_id_6;
	/* Flow ID of a flow. */
	uint32_t	flow_id_7;
	/* Flow ID of a flow. */
	uint32_t	flow_id_8;
	/* Flow ID of a flow. */
	uint32_t	flow_id_9;
} hwrm_cfa_flow_stats_input_t, *phwrm_cfa_flow_stats_input_t;

/* hwrm_cfa_flow_stats_output (size:1408b/176B) */

typedef struct hwrm_cfa_flow_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* packet_0 is 64 b */
	uint64_t	packet_0;
	/* packet_1 is 64 b */
	uint64_t	packet_1;
	/* packet_2 is 64 b */
	uint64_t	packet_2;
	/* packet_3 is 64 b */
	uint64_t	packet_3;
	/* packet_4 is 64 b */
	uint64_t	packet_4;
	/* packet_5 is 64 b */
	uint64_t	packet_5;
	/* packet_6 is 64 b */
	uint64_t	packet_6;
	/* packet_7 is 64 b */
	uint64_t	packet_7;
	/* packet_8 is 64 b */
	uint64_t	packet_8;
	/* packet_9 is 64 b */
	uint64_t	packet_9;
	/* byte_0 is 64 b */
	uint64_t	byte_0;
	/* byte_1 is 64 b */
	uint64_t	byte_1;
	/* byte_2 is 64 b */
	uint64_t	byte_2;
	/* byte_3 is 64 b */
	uint64_t	byte_3;
	/* byte_4 is 64 b */
	uint64_t	byte_4;
	/* byte_5 is 64 b */
	uint64_t	byte_5;
	/* byte_6 is 64 b */
	uint64_t	byte_6;
	/* byte_7 is 64 b */
	uint64_t	byte_7;
	/* byte_8 is 64 b */
	uint64_t	byte_8;
	/* byte_9 is 64 b */
	uint64_t	byte_9;
	/*
	 * If a flow has been hit, the bit representing the flow will be 1.
	 * Likewise, if a flow has not, the bit representing the flow
	 * will be 0. Mapping will match flow numbers where bitX is for flowX
	 * (ex: bit 0 is flow0). This only applies for NIC flows. Upon
	 * reading of the flow, the bit will be cleared for the flow and only
	 * set again when traffic is received by the flow.
	 */
	uint16_t	flow_hits;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_stats_output_t, *phwrm_cfa_flow_stats_output_t;

/***********************************
 * hwrm_cfa_flow_aging_timer_reset *
 ***********************************/


/* hwrm_cfa_flow_aging_timer_reset_input (size:256b/32B) */

typedef struct hwrm_cfa_flow_aging_timer_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint8_t	unused_0[2];
	/*
	 * New flow timer value for the flow specified in the ext_flow_handle.
	 * The flow timer unit is 100ms.
	 */
	uint32_t	flow_timer;
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} hwrm_cfa_flow_aging_timer_reset_input_t, *phwrm_cfa_flow_aging_timer_reset_input_t;

/* hwrm_cfa_flow_aging_timer_reset_output (size:128b/16B) */

typedef struct hwrm_cfa_flow_aging_timer_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_aging_timer_reset_output_t, *phwrm_cfa_flow_aging_timer_reset_output_t;

/***************************
 * hwrm_cfa_flow_aging_cfg *
 ***************************/


/* hwrm_cfa_flow_aging_cfg_input (size:384b/48B) */

typedef struct hwrm_cfa_flow_aging_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The bit field to enable per flow aging configuration. */
	uint16_t	enables;
	/*
	 * This bit must be '1' for the tcp flow timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_TCP_FLOW_TIMER	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tcp finish timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_TCP_FIN_TIMER	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the udp flow timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_UDP_FLOW_TIMER	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the eem dma interval field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_DMA_INTERVAL	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the eem notice interval field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_NOTICE_INTERVAL	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the eem context memory maximum entries
	 * field to be configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_MAX_ENTRIES	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the eem context memory ID field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_ID		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the eem context memory type field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_MEM_TYPE	UINT32_C(0x80)
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_LAST   HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_RX
	/*
	 * Enumeration denoting the enable, disable eem flow aging
	 * configuration.
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM	UINT32_C(0x2)
	/* tx path */
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_DISABLE  (UINT32_C(0x0) << 1)
	/* rx path */
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_ENABLE   (UINT32_C(0x1) << 1)
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_LAST	HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_ENABLE
	uint8_t	unused_0;
	/*
	 * The flow aging timer for all TCP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	tcp_flow_timer;
	/*
	 * The TCP finished timer for all TCP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	tcp_fin_timer;
	/*
	 * The flow aging timer for all UDP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	udp_flow_timer;
	/*
	 * The interval to dma eem ejection data to host memory, the unit is
	 * milliseconds.
	 */
	uint16_t	eem_dma_interval;
	/*
	 * The interval to notify driver to read the eem ejection data, the
	 * unit is milliseconds.
	 */
	uint16_t	eem_notice_interval;
	/* The maximum entries number in the eem context memory. */
	uint32_t	eem_ctx_max_entries;
	/* The context memory ID for eem flow aging. */
	uint16_t	eem_ctx_id;
	uint16_t	eem_ctx_mem_type;
	/*
	 * The content of context memory is eem ejection data, the size of
	 * each entry is 4 bytes.
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_EJECTION_DATA UINT32_C(0x0)
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_LAST	HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_EJECTION_DATA
	uint8_t	unused_1[4];
} hwrm_cfa_flow_aging_cfg_input_t, *phwrm_cfa_flow_aging_cfg_input_t;

/* hwrm_cfa_flow_aging_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_flow_aging_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_aging_cfg_output_t, *phwrm_cfa_flow_aging_cfg_output_t;

/****************************
 * hwrm_cfa_flow_aging_qcfg *
 ****************************/


/* hwrm_cfa_flow_aging_qcfg_input (size:192b/24B) */

typedef struct hwrm_cfa_flow_aging_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The direction for the flow aging configuration, 1 is rx path, 2 is
	 * tx path.
	 */
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_LAST HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0[7];
} hwrm_cfa_flow_aging_qcfg_input_t, *phwrm_cfa_flow_aging_qcfg_input_t;

/* hwrm_cfa_flow_aging_qcfg_output (size:320b/40B) */

typedef struct hwrm_cfa_flow_aging_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The current flow aging timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	tcp_flow_timer;
	/*
	 * The current TCP finished timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	tcp_fin_timer;
	/*
	 * The current flow aging timer for all UDP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	udp_flow_timer;
	/*
	 * The interval to dma eem ejection data to host memory, the unit is
	 * milliseconds.
	 */
	uint16_t	eem_dma_interval;
	/*
	 * The interval to notify driver to read the eem ejection data, the
	 * unit is milliseconds.
	 */
	uint16_t	eem_notice_interval;
	/* The maximum entries number in the eem context memory. */
	uint32_t	eem_ctx_max_entries;
	/* The context memory ID for eem flow aging. */
	uint16_t	eem_ctx_id;
	/* The context memory type for eem flow aging. */
	uint16_t	eem_ctx_mem_type;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_aging_qcfg_output_t, *phwrm_cfa_flow_aging_qcfg_output_t;

/*****************************
 * hwrm_cfa_flow_aging_qcaps *
 *****************************/


/* hwrm_cfa_flow_aging_qcaps_input (size:192b/24B) */

typedef struct hwrm_cfa_flow_aging_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The direction for the flow aging configuration, 1 is rx path, 2 is
	 * tx path.
	 */
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_LAST HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0[7];
} hwrm_cfa_flow_aging_qcaps_input_t, *phwrm_cfa_flow_aging_qcaps_input_t;

/* hwrm_cfa_flow_aging_qcaps_output (size:256b/32B) */

typedef struct hwrm_cfa_flow_aging_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The maximum flow aging timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_tcp_flow_timer;
	/*
	 * The maximum TCP finished timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_tcp_fin_timer;
	/*
	 * The maximum flow aging timer for all UDP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_udp_flow_timer;
	/* The maximum aging flows that HW can support. */
	uint32_t	max_aging_flows;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_aging_qcaps_output_t, *phwrm_cfa_flow_aging_qcaps_output_t;

/**********************************
 * hwrm_cfa_tcp_flag_process_qcfg *
 **********************************/


/* hwrm_cfa_tcp_flag_process_qcfg_input (size:128b/16B) */

typedef struct hwrm_cfa_tcp_flag_process_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cfa_tcp_flag_process_qcfg_input_t, *phwrm_cfa_tcp_flag_process_qcfg_input_t;

/* hwrm_cfa_tcp_flag_process_qcfg_output (size:192b/24B) */

typedef struct hwrm_cfa_tcp_flag_process_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The port 0 RX mirror action record ID. */
	uint16_t	rx_ar_id_port0;
	/* The port 1 RX mirror action record ID. */
	uint16_t	rx_ar_id_port1;
	/*
	 * The port 0 RX action record ID for TX TCP flag packets from
	 * loopback path.
	 */
	uint16_t	tx_ar_id_port0;
	/*
	 * The port 1 RX action record ID for TX TCP flag packets from
	 * loopback path.
	 */
	uint16_t	tx_ar_id_port1;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tcp_flag_process_qcfg_output_t, *phwrm_cfa_tcp_flag_process_qcfg_output_t;

/**************************
 * hwrm_cfa_vf_pair_alloc *
 **************************/


/* hwrm_cfa_vf_pair_alloc_input (size:448b/56B) */

typedef struct hwrm_cfa_vf_pair_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_a_id;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_b_id;
	uint8_t	unused_0[4];
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
} hwrm_cfa_vf_pair_alloc_input_t, *phwrm_cfa_vf_pair_alloc_input_t;

/* hwrm_cfa_vf_pair_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_vf_pair_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vf_pair_alloc_output_t, *phwrm_cfa_vf_pair_alloc_output_t;

/*************************
 * hwrm_cfa_vf_pair_free *
 *************************/


/* hwrm_cfa_vf_pair_free_input (size:384b/48B) */

typedef struct hwrm_cfa_vf_pair_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
} hwrm_cfa_vf_pair_free_input_t, *phwrm_cfa_vf_pair_free_input_t;

/* hwrm_cfa_vf_pair_free_output (size:128b/16B) */

typedef struct hwrm_cfa_vf_pair_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vf_pair_free_output_t, *phwrm_cfa_vf_pair_free_output_t;

/*************************
 * hwrm_cfa_vf_pair_info *
 *************************/


/* hwrm_cfa_vf_pair_info_input (size:448b/56B) */

typedef struct hwrm_cfa_vf_pair_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If this flag is set, lookup by name else lookup by index. */
	#define HWRM_CFA_VF_PAIR_INFO_INPUT_FLAGS_LOOKUP_TYPE	UINT32_C(0x1)
	/* vf pair table index. */
	uint16_t	vf_pair_index;
	uint8_t	unused_0[2];
	/* VF Pair name (32 byte string). */
	char	vf_pair_name[32];
} hwrm_cfa_vf_pair_info_input_t, *phwrm_cfa_vf_pair_info_input_t;

/* hwrm_cfa_vf_pair_info_output (size:512b/64B) */

typedef struct hwrm_cfa_vf_pair_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* vf pair table index. */
	uint16_t	next_vf_pair_index;
	/* vf pair member a's vf_fid. */
	uint16_t	vf_a_fid;
	/* vf pair member a's Linux logical VF number. */
	uint16_t	vf_a_index;
	/* vf pair member b's vf_fid. */
	uint16_t	vf_b_fid;
	/* vf pair member a's Linux logical VF number. */
	uint16_t	vf_b_index;
	/* vf pair state. */
	uint8_t	pair_state;
	/* Pair has been allocated */
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ALLOCATED UINT32_C(0x1)
	/* Both pair members are active */
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE	UINT32_C(0x2)
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_LAST	HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE
	uint8_t	unused_0[5];
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vf_pair_info_output_t, *phwrm_cfa_vf_pair_info_output_t;

/***********************
 * hwrm_cfa_pair_alloc *
 ***********************/


/* hwrm_cfa_pair_alloc_input (size:576b/72B) */

typedef struct hwrm_cfa_pair_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair,
	 *		5-rep2fn_mod, 6-rep2fn_modall, 7-rep2fn_truflow).
	 */
	uint16_t	pair_mode;
	/*
	 * Pair between VF on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_VF2FN	UINT32_C(0x0)
	/*
	 * Pair between REP on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN	UINT32_C(0x1)
	/*
	 * Pair between REP on local host with REP on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2REP	UINT32_C(0x2)
	/* Pair for the proxy interface. (deprecated) */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_PROXY	UINT32_C(0x3)
	/* Pair for the PF interface. (deprecated) */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_PFPAIR	UINT32_C(0x4)
	/* Modify existing rep2fn pair and move pair to new PF. (deprecated) */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_MOD	UINT32_C(0x5)
	/*
	 * Modify existing rep2fn pairs paired with same PF and move pairs
	 * to new PF. (deprecated)
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_MODALL  UINT32_C(0x6)
	/*
	 * Truflow pair between REP on local host with PF or VF on specified
	 * host.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_TRUFLOW UINT32_C(0x7)
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_LAST	HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_TRUFLOW
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_a_id;
	/* Logical Host (0xff-local host). */
	uint8_t	host_b_id;
	/* Logical PF (0xff-PF for command channel). */
	uint8_t	pf_b_id;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_b_id;
	/* Loopback port (0xff-internal loopback), valid for mode-3. */
	uint8_t	port_id;
	/* Priority used for encap of loopback packets valid for mode-3. */
	uint8_t	pri;
	/* New PF for rep2fn modify, valid for mode 5. */
	uint16_t	new_pf_fid;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the q_ab field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_Q_AB_VALID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the q_ba field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_Q_BA_VALID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the fc_ab field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_FC_AB_VALID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the fc_ba field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_FC_BA_VALID	UINT32_C(0x8)
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	/*
	 * The q_ab value specifies the logical index of the TX/RX CoS
	 * queue to be assigned for traffic in the A to B direction of
	 * the interface pair. The default value is 0.
	 */
	uint8_t	q_ab;
	/*
	 * The q_ba value specifies the logical index of the TX/RX CoS
	 * queue to be assigned for traffic in the B to A direction of
	 * the interface pair. The default value is 1.
	 */
	uint8_t	q_ba;
	/*
	 * Specifies whether RX ring flow control is disabled (0) or enabled
	 * (1) in the A to B direction. The default value is 0, meaning that
	 * packets will be dropped when the B-side RX rings are full.
	 */
	uint8_t	fc_ab;
	/*
	 * Specifies whether RX ring flow control is disabled (0) or enabled
	 * (1) in the B to A direction. The default value is 1, meaning that
	 * the RX CoS queue will be flow controlled when the A-side RX rings
	 * are full.
	 */
	uint8_t	fc_ba;
	uint8_t	unused_1[4];
} hwrm_cfa_pair_alloc_input_t, *phwrm_cfa_pair_alloc_input_t;

/* hwrm_cfa_pair_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_pair_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Only valid for modes 1 and 2. */
	uint16_t	rx_cfa_code_a;
	/* Only valid for modes 1 and 2. */
	uint16_t	tx_cfa_action_a;
	/* Only valid for mode 2. */
	uint16_t	rx_cfa_code_b;
	/* Only valid for mode 2. */
	uint16_t	tx_cfa_action_b;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_pair_alloc_output_t, *phwrm_cfa_pair_alloc_output_t;

/**********************
 * hwrm_cfa_pair_free *
 **********************/


/* hwrm_cfa_pair_free_input (size:448b/56B) */

typedef struct hwrm_cfa_pair_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	/* Logical PF (0xff-PF for command channel). */
	uint8_t	pf_b_id;
	uint8_t	unused_0[3];
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair,
	 *		5-rep2fn_mod, 6-rep2fn_modall, 7-rep2fn_truflow).
	 */
	uint16_t	pair_mode;
	/*
	 * Pair between VF on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_VF2FN	UINT32_C(0x0)
	/*
	 * Pair between REP on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN	UINT32_C(0x1)
	/*
	 * Pair between REP on local host with REP on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2REP	UINT32_C(0x2)
	/* Pair for the proxy interface. (deprecated) */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_PROXY	UINT32_C(0x3)
	/* Pair for the PF interface. (deprecated) */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_PFPAIR	UINT32_C(0x4)
	/* Modify existing rep2fn pair and move pair to new PF. (deprecated) */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_MOD	UINT32_C(0x5)
	/*
	 * Modify existing rep2fn pairs paired with same PF and move pairs
	 * to new PF. (deprecated)
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_MODALL  UINT32_C(0x6)
	/*
	 * Truflow pair between REP on local host with PF or VF on
	 * specified host.
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_TRUFLOW UINT32_C(0x7)
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_LAST	HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_TRUFLOW
} hwrm_cfa_pair_free_input_t, *phwrm_cfa_pair_free_input_t;

/* hwrm_cfa_pair_free_output (size:128b/16B) */

typedef struct hwrm_cfa_pair_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_pair_free_output_t, *phwrm_cfa_pair_free_output_t;

/**********************
 * hwrm_cfa_pair_info *
 **********************/


/* hwrm_cfa_pair_info_input (size:448b/56B) */

typedef struct hwrm_cfa_pair_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If this flag is set, lookup by name else lookup by index. */
	#define HWRM_CFA_PAIR_INFO_INPUT_FLAGS_LOOKUP_TYPE	UINT32_C(0x1)
	/* If this flag is set, lookup by PF id and VF id. */
	#define HWRM_CFA_PAIR_INFO_INPUT_FLAGS_LOOKUP_REPRE	UINT32_C(0x2)
	/* Pair table index. */
	uint16_t	pair_index;
	/* Pair pf index. */
	uint8_t	pair_pfid;
	/* Pair vf index. */
	uint8_t	pair_vfid;
	/* Pair name (32 byte string). */
	char	pair_name[32];
} hwrm_cfa_pair_info_input_t, *phwrm_cfa_pair_info_input_t;

/* hwrm_cfa_pair_info_output (size:576b/72B) */

typedef struct hwrm_cfa_pair_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Pair table index. */
	uint16_t	next_pair_index;
	/* Pair member a's fid. */
	uint16_t	a_fid;
	/* Logical host number. */
	uint8_t	host_a_index;
	/* Logical PF number. */
	uint8_t	pf_a_index;
	/* Pair member a's Linux logical VF number. */
	uint16_t	vf_a_index;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code_a;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action_a;
	/* Pair member b's fid. */
	uint16_t	b_fid;
	/* Logical host number. */
	uint8_t	host_b_index;
	/* Logical PF number. */
	uint8_t	pf_b_index;
	/* Pair member a's Linux logical VF number. */
	uint16_t	vf_b_index;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code_b;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action_b;
	/* Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair). */
	uint8_t	pair_mode;
	/*
	 * Pair between VF on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_VF2FN   UINT32_C(0x0)
	/*
	 * Pair between REP on local host with PF or VF on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_REP2FN  UINT32_C(0x1)
	/*
	 * Pair between REP on local host with REP on specified host.
	 * (deprecated)
	 */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_REP2REP UINT32_C(0x2)
	/* Pair for the proxy interface. (deprecated) */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PROXY   UINT32_C(0x3)
	/* Pair for the PF interface. (deprecated) */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PFPAIR  UINT32_C(0x4)
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_LAST   HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PFPAIR
	/* Pair state. */
	uint8_t	pair_state;
	/* Pair has been allocated */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ALLOCATED UINT32_C(0x1)
	/* Both pair members are active */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE	UINT32_C(0x2)
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_LAST	HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE
	/* Pair name (32 byte string). */
	char	pair_name[32];
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_pair_info_output_t, *phwrm_cfa_pair_info_output_t;

/**********************
 * hwrm_cfa_vfr_alloc *
 **********************/


/* hwrm_cfa_vfr_alloc_input (size:448b/56B) */

typedef struct hwrm_cfa_vfr_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved;
	uint8_t	unused_0[4];
	/* VF Representor name (32 byte string). */
	char	vfr_name[32];
} hwrm_cfa_vfr_alloc_input_t, *phwrm_cfa_vfr_alloc_input_t;

/* hwrm_cfa_vfr_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_vfr_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vfr_alloc_output_t, *phwrm_cfa_vfr_alloc_output_t;

/*********************
 * hwrm_cfa_vfr_free *
 *********************/


/* hwrm_cfa_vfr_free_input (size:448b/56B) */

typedef struct hwrm_cfa_vfr_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Representor name (32 byte string). */
	char	vfr_name[32];
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved;
	uint8_t	unused_0[4];
} hwrm_cfa_vfr_free_input_t, *phwrm_cfa_vfr_free_input_t;

/* hwrm_cfa_vfr_free_output (size:128b/16B) */

typedef struct hwrm_cfa_vfr_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vfr_free_output_t, *phwrm_cfa_vfr_free_output_t;

/***************************************
 * hwrm_cfa_redirect_query_tunnel_type *
 ***************************************/


/* hwrm_cfa_redirect_query_tunnel_type_input (size:192b/24B) */

typedef struct hwrm_cfa_redirect_query_tunnel_type_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The source function id. */
	uint16_t	src_fid;
	uint8_t	unused_0[6];
} hwrm_cfa_redirect_query_tunnel_type_input_t, *phwrm_cfa_redirect_query_tunnel_type_input_t;

/* hwrm_cfa_redirect_query_tunnel_type_output (size:128b/16B) */

typedef struct hwrm_cfa_redirect_query_tunnel_type_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Tunnel Mask. */
	uint32_t	tunnel_mask;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_NONTUNNEL	UINT32_C(0x1)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN		UINT32_C(0x2)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_NVGRE		UINT32_C(0x4)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_L2GRE		UINT32_C(0x8)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPIP		UINT32_C(0x10)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_GENEVE	UINT32_C(0x20)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_MPLS		UINT32_C(0x40)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_STT		UINT32_C(0x80)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPGRE		UINT32_C(0x100)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN_V4	UINT32_C(0x200)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPGRE_V1	UINT32_C(0x400)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_ANYTUNNEL	UINT32_C(0x800)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_L2_ETYPE	UINT32_C(0x1000)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN_GPE_V6	UINT32_C(0x2000)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN_GPE	UINT32_C(0x4000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_redirect_query_tunnel_type_output_t, *phwrm_cfa_redirect_query_tunnel_type_output_t;

/*************************
 * hwrm_cfa_ctx_mem_rgtr *
 *************************/


/* hwrm_cfa_ctx_mem_rgtr_input (size:256b/32B) */

typedef struct hwrm_cfa_ctx_mem_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LAST HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 256KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 1MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 1GB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_LAST HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1G
	uint32_t	unused_0;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
} hwrm_cfa_ctx_mem_rgtr_input_t, *phwrm_cfa_ctx_mem_rgtr_input_t;

/* hwrm_cfa_ctx_mem_rgtr_output (size:128b/16B) */

typedef struct hwrm_cfa_ctx_mem_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ctx_mem_rgtr_output_t, *phwrm_cfa_ctx_mem_rgtr_output_t;

/***************************
 * hwrm_cfa_ctx_mem_unrgtr *
 ***************************/


/* hwrm_cfa_ctx_mem_unrgtr_input (size:192b/24B) */

typedef struct hwrm_cfa_ctx_mem_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[6];
} hwrm_cfa_ctx_mem_unrgtr_input_t, *phwrm_cfa_ctx_mem_unrgtr_input_t;

/* hwrm_cfa_ctx_mem_unrgtr_output (size:128b/16B) */

typedef struct hwrm_cfa_ctx_mem_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ctx_mem_unrgtr_output_t, *phwrm_cfa_ctx_mem_unrgtr_output_t;

/*************************
 * hwrm_cfa_ctx_mem_qctx *
 *************************/


/* hwrm_cfa_ctx_mem_qctx_input (size:192b/24B) */

typedef struct hwrm_cfa_ctx_mem_qctx_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[6];
} hwrm_cfa_ctx_mem_qctx_input_t, *phwrm_cfa_ctx_mem_qctx_input_t;

/* hwrm_cfa_ctx_mem_qctx_output (size:256b/32B) */

typedef struct hwrm_cfa_ctx_mem_qctx_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LAST HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 256KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 1MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 1GB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_LAST HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1G
	uint8_t	unused_0[4];
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ctx_mem_qctx_output_t, *phwrm_cfa_ctx_mem_qctx_output_t;

/**************************
 * hwrm_cfa_ctx_mem_qcaps *
 **************************/


/* hwrm_cfa_ctx_mem_qcaps_input (size:128b/16B) */

typedef struct hwrm_cfa_ctx_mem_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cfa_ctx_mem_qcaps_input_t, *phwrm_cfa_ctx_mem_qcaps_input_t;

/* hwrm_cfa_ctx_mem_qcaps_output (size:128b/16B) */

typedef struct hwrm_cfa_ctx_mem_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Indicates the maximum number of context memory which can be
	 * registered.
	 */
	uint16_t	max_entries;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ctx_mem_qcaps_output_t, *phwrm_cfa_ctx_mem_qcaps_output_t;

/**************************
 * hwrm_cfa_counter_qcaps *
 **************************/


/* hwrm_cfa_counter_qcaps_input (size:128b/16B) */

typedef struct hwrm_cfa_counter_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cfa_counter_qcaps_input_t, *phwrm_cfa_counter_qcaps_input_t;

/* hwrm_cfa_counter_qcaps_output (size:576b/72B) */

typedef struct hwrm_cfa_counter_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* Enumeration denoting the supported CFA counter format. */
	#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT	UINT32_C(0x1)
	/* CFA counter types are not supported. */
		#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_NONE	UINT32_C(0x0)
	/* 64-bit packet counters followed by 64-bit byte counters format. */
		#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_64_BIT  UINT32_C(0x1)
		#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_LAST   HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_64_BIT
	uint32_t	unused_0;
	/*
	 * Minimum guaranteed number of flow counters supported for this
	 * function, in RX direction.
	 */
	uint32_t	min_rx_fc;
	/*
	 * Maximum non-guaranteed number of flow counters supported for this
	 * function, in RX direction.
	 */
	uint32_t	max_rx_fc;
	/*
	 * Minimum guaranteed number of flow counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	min_tx_fc;
	/*
	 * Maximum non-guaranteed number of flow counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	max_tx_fc;
	/*
	 * Minimum guaranteed number of extension flow counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	min_rx_efc;
	/*
	 * Maximum non-guaranteed number of extension flow counters supported
	 * for this function, in RX direction.
	 */
	uint32_t	max_rx_efc;
	/*
	 * Minimum guaranteed number of extension flow counters supported for
	 * this function, in TX direction.
	 */
	uint32_t	min_tx_efc;
	/*
	 * Maximum non-guaranteed number of extension flow counters supported
	 * for this function, in TX direction.
	 */
	uint32_t	max_tx_efc;
	/*
	 * Minimum guaranteed number of meter drop counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	min_rx_mdc;
	/*
	 * Maximum non-guaranteed number of meter drop counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	max_rx_mdc;
	/*
	 * Minimum guaranteed number of meter drop counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	min_tx_mdc;
	/*
	 * Maximum non-guaranteed number of meter drop counters supported for
	 * this function, in TX direction.
	 */
	uint32_t	max_tx_mdc;
	/*
	 * Maximum guaranteed number of flow counters which can be used during
	 * flow alloc.
	 */
	uint32_t	max_flow_alloc_fc;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_counter_qcaps_output_t, *phwrm_cfa_counter_qcaps_output_t;

/************************
 * hwrm_cfa_counter_cfg *
 ************************/


/* hwrm_cfa_counter_cfg_input (size:256b/32B) */

typedef struct hwrm_cfa_counter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Enumeration denoting the configuration mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE			UINT32_C(0x1)
	/* Disable the configuration mode. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_DISABLE		UINT32_C(0x0)
	/* Enable the configuration mode. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_ENABLE		UINT32_C(0x1)
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_LAST		HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_ENABLE
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH			UINT32_C(0x2)
	/* Tx path. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_TX			(UINT32_C(0x0) << 1)
	/* Rx path. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_RX			(UINT32_C(0x1) << 1)
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_LAST			HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_RX
	/* Enumeration denoting the data transfer mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_MASK	UINT32_C(0xc)
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_SFT	2
	/* Push mode. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PUSH	(UINT32_C(0x0) << 2)
	/* Pull mode. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL	(UINT32_C(0x1) << 2)
	/* Pull on async update. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL_ASYNC  (UINT32_C(0x2) << 2)
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_LAST	HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL_ASYNC
	uint16_t	counter_type;
	/* Flow counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_FC  UINT32_C(0x0)
	/* Extended flow counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_EFC UINT32_C(0x1)
	/* Meter drop counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_MDC UINT32_C(0x2)
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_LAST HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_MDC
	/* Ctx memory handle to be used for the counter. */
	uint16_t	ctx_id;
	/* Counter update cadence hint (only in Push mode). */
	uint16_t	update_tmr_ms;
	/* Total number of entries. */
	uint32_t	num_entries;
	uint32_t	unused_0;
} hwrm_cfa_counter_cfg_input_t, *phwrm_cfa_counter_cfg_input_t;

/* hwrm_cfa_counter_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_counter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_counter_cfg_output_t, *phwrm_cfa_counter_cfg_output_t;

/*************************
 * hwrm_cfa_counter_qcfg *
 *************************/


/* hwrm_cfa_counter_qcfg_input (size:192b/24B) */

typedef struct hwrm_cfa_counter_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_PATH			UINT32_C(0x1)
	/* Tx path. */
		#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_PATH_TX			UINT32_C(0x0)
	/* Rx path. */
		#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_PATH_RX			UINT32_C(0x1)
		#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_PATH_LAST			HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_PATH_RX
	/* Enumeration denoting the data transfer mode. */
	#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_DATA_TRANSFER_MODE_MASK	UINT32_C(0x6)
	#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_DATA_TRANSFER_MODE_SFT	1
	/* Push mode. */
		#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PUSH	(UINT32_C(0x0) << 1)
	/* Pull mode. */
		#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL	(UINT32_C(0x1) << 1)
	/* Pull on async update. */
		#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL_ASYNC  (UINT32_C(0x2) << 1)
		#define HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_DATA_TRANSFER_MODE_LAST	HWRM_CFA_COUNTER_QCFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL_ASYNC
	uint16_t	counter_type;
	uint32_t	unused_0;
} hwrm_cfa_counter_qcfg_input_t, *phwrm_cfa_counter_qcfg_input_t;

/* hwrm_cfa_counter_qcfg_output (size:192b/24B) */

typedef struct hwrm_cfa_counter_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	ctx_id;
	uint16_t	update_tmr_ms;
	uint32_t	num_entries;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_counter_qcfg_output_t, *phwrm_cfa_counter_qcfg_output_t;

/***************************
 * hwrm_cfa_counter_qstats *
 ***************************/


/* hwrm_cfa_counter_qstats_input (size:320b/40B) */

typedef struct hwrm_cfa_counter_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* Tx path. */
		#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* Rx path. */
		#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_LAST HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_RX
	uint16_t	counter_type;
	uint16_t	input_flow_ctx_id;
	uint16_t	num_entries;
	uint16_t	delta_time_ms;
	uint16_t	meter_instance_id;
	uint16_t	mdc_ctx_id;
	uint8_t	unused_0[2];
	uint64_t	expected_count;
} hwrm_cfa_counter_qstats_input_t, *phwrm_cfa_counter_qstats_input_t;

/* hwrm_cfa_counter_qstats_output (size:128b/16B) */

typedef struct hwrm_cfa_counter_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_counter_qstats_output_t, *phwrm_cfa_counter_qstats_output_t;

/**********************
 * hwrm_cfa_eem_qcaps *
 **********************/


/* hwrm_cfa_eem_qcaps_input (size:192b/24B) */

typedef struct hwrm_cfa_eem_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PATH_TX		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PATH_RX		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x4)
	uint32_t	unused_0;
} hwrm_cfa_eem_qcaps_input_t, *phwrm_cfa_eem_qcaps_input_t;

/* hwrm_cfa_eem_qcaps_output (size:320b/40B) */

typedef struct hwrm_cfa_eem_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_PATH_TX					UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_PATH_RX					UINT32_C(0x2)
	/*
	 * When set to 1, indicates the FW supports the Centralized
	 * Memory Model. The concept designates one entity for the
	 * memory allocation while all others 'subscribe' to it.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_CENTRALIZED_MEMORY_MODEL_SUPPORTED		UINT32_C(0x4)
	/*
	 * When set to 1, indicates the FW supports the Detached
	 * Centralized Memory Model. The memory is allocated and managed
	 * as a separate entity. All PFs and VFs will be granted direct
	 * or semi-direct access to the allocated memory while none of
	 * which can interfere with the management of the memory.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_DETACHED_CENTRALIZED_MEMORY_MODEL_SUPPORTED	UINT32_C(0x8)
	uint32_t	unused_0;
	uint32_t	supported;
	/*
	 * If set to 1, then EEM KEY0 table is supported using crc32 hash.
	 * If set to 0, EEM KEY0 table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_KEY0_TABLE			UINT32_C(0x1)
	/*
	 * If set to 1, then EEM KEY1 table is supported using lookup3 hash.
	 * If set to 0, EEM KEY1 table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_KEY1_TABLE			UINT32_C(0x2)
	/*
	 * If set to 1, then EEM External Record table is supported.
	 * If set to 0, EEM External Record table is not supported.
	 * (This table includes action record, EFC pointers, encap pointers)
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_RECORD_TABLE		UINT32_C(0x4)
	/*
	 * If set to 1, then EEM External Flow Counters table is supported.
	 * If set to 0, EEM External Flow Counters table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_FLOW_COUNTERS_TABLE	UINT32_C(0x8)
	/*
	 * If set to 1, then FID table used for implicit flow flush is
	 * supported.
	 * If set to 0, then FID table used for implicit flow flush is
	 * not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_FID_TABLE			UINT32_C(0x10)
	/*
	 * The maximum number of entries supported by EEM. When configuring
	 * the host memory, the number of numbers of entries that can
	 * supported are:
	 *	32k, 64k 128k, 256k, 512k, 1M, 2M, 4M, 8M, 32M, 64M, 128M
	 *	entries.
	 * Any value that are not these values, the FW will round down to the
	 * closest support number of entries.
	 */
	uint32_t	max_entries_supported;
	/* The entry size in bytes of each entry in the EEM KEY0/KEY1 tables. */
	uint16_t	key_entry_size;
	/* The entry size in bytes of each entry in the EEM RECORD tables. */
	uint16_t	record_entry_size;
	/* The entry size in bytes of each entry in the EEM EFC tables. */
	uint16_t	efc_entry_size;
	/* The FID size in bytes of each entry in the EEM FID tables. */
	uint16_t	fid_entry_size;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_eem_qcaps_output_t, *phwrm_cfa_eem_qcaps_output_t;

/********************
 * hwrm_cfa_eem_cfg *
 ********************/


/* hwrm_cfa_eem_cfg_input (size:384b/48B) */

typedef struct hwrm_cfa_eem_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PATH_TX		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PATH_RX		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x4)
	/* When set to 1, secondary, 0 means primary. */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_SECONDARY_PF	UINT32_C(0x8)
	/*
	 * Group_id which used by Firmware to identify memory pools belonging
	 * to certain group.
	 */
	uint16_t	group_id;
	uint16_t	unused_0;
	/*
	 * Configured EEM with the given number of entries. All the EEM tables
	 * KEY0, KEY1, RECORD, EFC all have the same number of entries and all
	 * tables will be configured using this value. Current minimum value
	 * is 32k. Current maximum value is 128M.
	 */
	uint32_t	num_entries;
	uint32_t	unused_1;
	/* Configured EEM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EEM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EEM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	uint16_t	unused_2;
	uint32_t	unused_3;
} hwrm_cfa_eem_cfg_input_t, *phwrm_cfa_eem_cfg_input_t;

/* hwrm_cfa_eem_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_eem_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_eem_cfg_output_t, *phwrm_cfa_eem_cfg_output_t;

/*********************
 * hwrm_cfa_eem_qcfg *
 *********************/


/* hwrm_cfa_eem_qcfg_input (size:192b/24B) */

typedef struct hwrm_cfa_eem_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_EEM_QCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_EEM_QCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x2)
	uint32_t	unused_0;
} hwrm_cfa_eem_qcfg_input_t, *phwrm_cfa_eem_qcfg_input_t;

/* hwrm_cfa_eem_qcfg_output (size:256b/32B) */

typedef struct hwrm_cfa_eem_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PATH_TX		UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PATH_RX		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x4)
	/* The number of entries the FW has configured for EEM. */
	uint32_t	num_entries;
	/* Configured EEM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EEM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EEM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	uint8_t	unused_2[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_eem_qcfg_output_t, *phwrm_cfa_eem_qcfg_output_t;

/*******************
 * hwrm_cfa_eem_op *
 *******************/


/* hwrm_cfa_eem_op_input (size:192b/24B) */

typedef struct hwrm_cfa_eem_op_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the host memory which is passed will be
	 * used for the TX flow offload function specified in fid.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_FLAGS_PATH_TX	UINT32_C(0x1)
	/*
	 * When set to 1, indicates the host memory which is passed will be
	 * used for the RX flow offload function specified in fid.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_FLAGS_PATH_RX	UINT32_C(0x2)
	uint16_t	unused_0;
	/* The number of EEM key table entries to be configured. */
	uint16_t	op;
	/* This value is reserved and should not be used. */
	#define HWRM_CFA_EEM_OP_INPUT_OP_RESERVED	UINT32_C(0x0)
	/*
	 * To properly stop EEM and ensure there are no DMA's, the caller
	 * must disable EEM for the given PF, using this call. This will
	 * safely disable EEM and ensure that all DMA'ed to the
	 * keys/records/efc have been completed.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_DISABLE UINT32_C(0x1)
	/*
	 * Once the EEM host memory has been configured, EEM options have
	 * been configured. Then the caller should enable EEM for the given
	 * PF. Note once this call has been made, then the EEM mechanism
	 * will be active and DMA's will occur as packets are processed.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_ENABLE  UINT32_C(0x2)
	/*
	 * Clear EEM settings for the given PF so that the register values
	 * are reset back to there initial state.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_CLEANUP UINT32_C(0x3)
	#define HWRM_CFA_EEM_OP_INPUT_OP_LAST	HWRM_CFA_EEM_OP_INPUT_OP_EEM_CLEANUP
} hwrm_cfa_eem_op_input_t, *phwrm_cfa_eem_op_input_t;

/* hwrm_cfa_eem_op_output (size:128b/16B) */

typedef struct hwrm_cfa_eem_op_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_eem_op_output_t, *phwrm_cfa_eem_op_output_t;

/********************************
 * hwrm_cfa_adv_flow_mgnt_qcaps *
 ********************************/


/* hwrm_cfa_adv_flow_mgnt_qcaps_input (size:256b/32B) */

typedef struct hwrm_cfa_adv_flow_mgnt_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	unused_0[4];
} hwrm_cfa_adv_flow_mgnt_qcaps_input_t, *phwrm_cfa_adv_flow_mgnt_qcaps_input_t;

/* hwrm_cfa_adv_flow_mgnt_qcaps_output (size:128b/16B) */

typedef struct hwrm_cfa_adv_flow_mgnt_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * Value of 1 to indicate firmware support 16-bit flow handle.
	 * Value of 0 to indicate firmware not support 16-bit flow handle.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_HND_16BIT_SUPPORTED			UINT32_C(0x1)
	/*
	 * Value of 1 to indicate firmware support 64-bit flow handle.
	 * Value of 0 to indicate firmware not support 64-bit flow handle.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_HND_64BIT_SUPPORTED			UINT32_C(0x2)
	/*
	 * Value of 1 to indicate firmware support flow batch delete
	 * operation through HWRM_CFA_FLOW_FLUSH command.
	 * Value of 0 to indicate that the firmware does not support flow
	 * batch delete operation. (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_BATCH_DELETE_SUPPORTED		UINT32_C(0x4)
	/*
	 * Value of 1 to indicate that the firmware support flow reset all
	 * operation through HWRM_CFA_FLOW_FLUSH command.
	 * Value of 0 indicates firmware does not support flow reset all
	 * operation. (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_RESET_ALL_SUPPORTED			UINT32_C(0x8)
	/*
	 * Value of 1 to indicate that firmware supports use of FID as
	 * dest_id in HWRM_CFA_NTUPLE_ALLOC/CFG commands.
	 * Value of 0 indicates firmware does not support use of FID as
	 * dest_id.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_DEST_FUNC_SUPPORTED		UINT32_C(0x10)
	/*
	 * Value of 1 to indicate that firmware supports TX EEM flows.
	 * Value of 0 indicates firmware does not support TX EEM flows.
	 * (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_TX_EEM_FLOW_SUPPORTED			UINT32_C(0x20)
	/*
	 * Value of 1 to indicate that firmware supports RX EEM flows.
	 * Value of 0 indicates firmware does not support RX EEM flows.
	 * (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RX_EEM_FLOW_SUPPORTED			UINT32_C(0x40)
	/*
	 * Value of 1 to indicate that firmware supports the dynamic
	 * allocation of an on-chip flow counter which can be used for EEM
	 * flows. Value of 0 indicates firmware does not support the dynamic
	 * allocation of an on-chip flow counter.
	 * (deprecated)
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_COUNTER_ALLOC_SUPPORTED		UINT32_C(0x80)
	/*
	 * Value of 1 to indicate that firmware supports setting of
	 * rfs_ring_tbl_idx in HWRM_CFA_NTUPLE_ALLOC command.
	 * Value of 0 indicates firmware does not support rfs_ring_tbl_idx.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RFS_RING_TBL_IDX_SUPPORTED		UINT32_C(0x100)
	/*
	 * Value of 1 to indicate that firmware supports untagged matching
	 * criteria on HWRM_CFA_L2_FILTER_ALLOC command. Value of 0
	 * indicates firmware does not support untagged matching.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_UNTAGGED_VLAN_SUPPORTED			UINT32_C(0x200)
	/*
	 * Value of 1 to indicate that firmware supports XDP filter. Value
	 * of 0 indicates firmware does not support XDP filter.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_XDP_SUPPORTED				UINT32_C(0x400)
	/*
	 * Value of 1 to indicate that the firmware support L2 header source
	 * fields matching criteria on HWRM_CFA_L2_FILTER_ALLOC command.
	 * Value of 0 indicates firmware does not support L2 header source
	 * fields matching.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_L2_HEADER_SOURCE_FIELDS_SUPPORTED		UINT32_C(0x800)
	/*
	 * If set to 1, firmware is capable of supporting ARP ethertype as
	 * matching criteria for HWRM_CFA_NTUPLE_FILTER_ALLOC command on the
	 * RX direction. By default, this flag should be 0 for older version
	 * of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_RX_ARP_SUPPORTED		UINT32_C(0x1000)
	/*
	 * Value of 1 to indicate that firmware supports setting of
	 * rfs_ring_tbl_idx in dst_id field of the HWRM_CFA_NTUPLE_ALLOC
	 * command. Value of 0 indicates firmware does not support
	 * rfs_ring_tbl_idx in dst_id field.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RFS_RING_TBL_IDX_V2_SUPPORTED		UINT32_C(0x2000)
	/*
	 * If set to 1, firmware is capable of supporting IPv4/IPv6 as
	 * ethertype in HWRM_CFA_NTUPLE_FILTER_ALLOC command on the RX
	 * direction. By default, this flag should be 0 for older version
	 * of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_RX_ETHERTYPE_IP_SUPPORTED	UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of TruFlow. Driver can restrict sending HWRM CFA_FLOW_XXX
	 * and CFA_ENCAP_XXX, CFA_DECAP_XXX commands.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_TRUFLOW_CAPABLE				UINT32_C(0x8000)
	/*
	 * If set to 1, firmware is capable of supporting L2/ROCE as
	 * traffic type in flags field of HWRM_CFA_L2_FILTER_ALLOC command.
	 * By default, this flag should be 0 for older version of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_L2_FILTER_TRAFFIC_TYPE_L2_ROCE_SUPPORTED	UINT32_C(0x10000)
	/*
	 * If set to 1, firmware is capable of HW LAG. This bit is only
	 * advertised if the calling function is a PAXC function.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_LAG_SUPPORTED				UINT32_C(0x20000)
	/*
	 * If set to 1, firmware is capable installing ntuple rules without
	 * additional classification on the L2 Context.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_NO_L2CTX_SUPPORTED		UINT32_C(0x40000)
	/*
	 * If set to 1, firmware is capable returning stats for nic flows
	 * in cfa_flow_stats command where flow_handle value 0xF000.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NIC_FLOW_STATS_SUPPORTED			UINT32_C(0x80000)
	/*
	 * If set to 1, firmware is capable of supporting these additional
	 * ip_protocols: ICMP, ICMPV6, RSVD for ntuple rules. By default,
	 * this flag should be 0 for older version of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_RX_EXT_IP_PROTO_SUPPORTED	UINT32_C(0x100000)
	/*
	 * Value of 1 to indicate that firmware supports setting of
	 * rfs_ring_tbl_idx (new offset) in HWRM_CFA_NTUPLE_ALLOC command.
	 * Value of 0 indicates ring tbl idx should be passed using dst_id.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RFS_RING_TBL_IDX_V3_SUPPORTED		UINT32_C(0x200000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_adv_flow_mgnt_qcaps_output_t, *phwrm_cfa_adv_flow_mgnt_qcaps_output_t;

/******************
 * hwrm_cfa_tflib *
 ******************/


/* hwrm_cfa_tflib_input (size:1024b/128B) */

typedef struct hwrm_cfa_tflib_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* TFLIB message type. */
	uint16_t	tf_type;
	/* TFLIB message subtype. */
	uint16_t	tf_subtype;
	/* unused. */
	uint8_t	unused0[4];
	/* TFLIB request data. */
	uint32_t	tf_req[26];
} hwrm_cfa_tflib_input_t, *phwrm_cfa_tflib_input_t;

/* hwrm_cfa_tflib_output (size:5632b/704B) */

typedef struct hwrm_cfa_tflib_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* TFLIB message type. */
	uint16_t	tf_type;
	/* TFLIB message subtype. */
	uint16_t	tf_subtype;
	/* TFLIB response code */
	uint32_t	tf_resp_code;
	/* TFLIB response data. */
	uint32_t	tf_resp[170];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tflib_output_t, *phwrm_cfa_tflib_output_t;

/**********************************
 * hwrm_cfa_lag_group_member_rgtr *
 **********************************/


/* hwrm_cfa_lag_group_member_rgtr_input (size:192b/24B) */

typedef struct hwrm_cfa_lag_group_member_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	mode;
	/*
	 * Transmit only on the active port. Automatically failover
	 * to backup port.
	 */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_ACTIVE_BACKUP UINT32_C(0x1)
	/*
	 * Transmit based on packet header ntuple hash. Packet with only
	 * layer 2 headers will hash using the destination MAC, source MAC
	 * and Ethertype fields. Packets with layer 3 (IP) headers will
	 * hash using the destination MAC, source MAC, IP protocol/next
	 * header, source IP address and destination IP address. Packets
	 * with layer 4 (TCP/UDP) headers will hash using the destination
	 * MAC, source MAC, IP protocol/next header, source IP address,
	 * destination IP address, source port and destination port fields.
	 */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BALANCE_XOR   UINT32_C(0x2)
	/* Transmit packets on all specified ports. */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BROADCAST	UINT32_C(0x3)
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_LAST	HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BROADCAST
	/*
	 * Supports up to 5 ports. bit0 = port 0, bit1 = port 1,
	 * bit2 = port 2, bit3 = port 4, bit4 = loopback port
	 */
	uint8_t	port_bitmap;
	/* Specify the active port when active-backup mode is specified */
	uint8_t	active_port;
	uint8_t	unused_0[5];
} hwrm_cfa_lag_group_member_rgtr_input_t, *phwrm_cfa_lag_group_member_rgtr_input_t;

/* hwrm_cfa_lag_group_member_rgtr_output (size:128b/16B) */

typedef struct hwrm_cfa_lag_group_member_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* lag group ID configured for the function */
	uint16_t	lag_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_lag_group_member_rgtr_output_t, *phwrm_cfa_lag_group_member_rgtr_output_t;

/************************************
 * hwrm_cfa_lag_group_member_unrgtr *
 ************************************/


/* hwrm_cfa_lag_group_member_unrgtr_input (size:192b/24B) */

typedef struct hwrm_cfa_lag_group_member_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* lag group ID configured for the function */
	uint16_t	lag_id;
	uint8_t	unused_0[6];
} hwrm_cfa_lag_group_member_unrgtr_input_t, *phwrm_cfa_lag_group_member_unrgtr_input_t;

/* hwrm_cfa_lag_group_member_unrgtr_output (size:128b/16B) */

typedef struct hwrm_cfa_lag_group_member_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_lag_group_member_unrgtr_output_t, *phwrm_cfa_lag_group_member_unrgtr_output_t;

/*****************************
 * hwrm_cfa_tls_filter_alloc *
 *****************************/


/* hwrm_cfa_tls_filter_alloc_input (size:768b/96B) */

typedef struct hwrm_cfa_tls_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	unused_0;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_DST_PORT		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the kid field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_KID			UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the quic_dst_connect_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_ENABLES_QUIC_DST_CONNECT_ID	UINT32_C(0x800)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	uint8_t	unused_1[6];
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4	UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6	UINT32_C(0x6)
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_LAST   HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol field in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP	UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP	UINT32_C(0x11)
	#define HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_LAST   HWRM_CFA_TLS_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	uint8_t	unused_2[2];
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * The value of destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * The Key Context Identifier (KID) for use with KTLS or QUIC.
	 * KID is limited to 20-bits.
	 */
	uint32_t	kid;
	/* The Destination Connection ID of QUIC. */
	uint64_t	quic_dst_connect_id;
} hwrm_cfa_tls_filter_alloc_input_t, *phwrm_cfa_tls_filter_alloc_input_t;

/* hwrm_cfa_tls_filter_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_tls_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tls_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_TLS_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tls_filter_alloc_output_t, *phwrm_cfa_tls_filter_alloc_output_t;

/****************************
 * hwrm_cfa_tls_filter_free *
 ****************************/


/* hwrm_cfa_tls_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_tls_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tls_filter_id;
} hwrm_cfa_tls_filter_free_input_t, *phwrm_cfa_tls_filter_free_input_t;

/* hwrm_cfa_tls_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_tls_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tls_filter_free_output_t, *phwrm_cfa_tls_filter_free_output_t;

/*****************************
 * hwrm_cfa_release_afm_func *
 *****************************/


/* hwrm_cfa_release_afm_func_input (size:256b/32B) */

typedef struct hwrm_cfa_release_afm_func_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Function identifier, may be of type efid, rfid or dfid. */
	uint16_t	fid;
	/* Representor function identifier. */
	uint16_t	rfid;
	/* Fid type. */
	uint8_t	type;
	/* Endpoint fid. */
	#define HWRM_CFA_RELEASE_AFM_FUNC_INPUT_TYPE_EFID UINT32_C(0x1)
	/* Representor fid. */
	#define HWRM_CFA_RELEASE_AFM_FUNC_INPUT_TYPE_RFID UINT32_C(0x2)
	/* Redirect fid. */
	#define HWRM_CFA_RELEASE_AFM_FUNC_INPUT_TYPE_DFID UINT32_C(0x3)
	#define HWRM_CFA_RELEASE_AFM_FUNC_INPUT_TYPE_LAST HWRM_CFA_RELEASE_AFM_FUNC_INPUT_TYPE_DFID
	uint8_t	unused_0[3];
	/*
	 * Flags used to control AFMs actions when releasing the function.
	 * Only used when type is dfid.
	 */
	uint32_t	flags;
	/* Remove broadcast. */
	#define HWRM_CFA_RELEASE_AFM_FUNC_INPUT_FLAGS_BC_REM	UINT32_C(0x1)
	/* Remove multicast. */
	#define HWRM_CFA_RELEASE_AFM_FUNC_INPUT_FLAGS_MC_REM	UINT32_C(0x2)
	/* Remove promiscuous. */
	#define HWRM_CFA_RELEASE_AFM_FUNC_INPUT_FLAGS_PROMISC_REM	UINT32_C(0x4)
	uint32_t	unused_1;
} hwrm_cfa_release_afm_func_input_t, *phwrm_cfa_release_afm_func_input_t;

/* hwrm_cfa_release_afm_func_output (size:128b/16B) */

typedef struct hwrm_cfa_release_afm_func_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_release_afm_func_output_t, *phwrm_cfa_release_afm_func_output_t;

/***********
 * hwrm_tf *
 ***********/


/* hwrm_tf_input (size:1024b/128B) */

typedef struct hwrm_tf_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* TF message type. */
	uint16_t	type;
	/* TF message subtype. */
	uint16_t	subtype;
	/* unused. */
	uint8_t	unused0[4];
	/* TF request data. */
	uint32_t	req[26];
} hwrm_tf_input_t, *phwrm_tf_input_t;

/* hwrm_tf_output (size:5632b/704B) */

typedef struct hwrm_tf_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* TF message type. */
	uint16_t	type;
	/* TF message subtype. */
	uint16_t	subtype;
	/* TF response code */
	uint32_t	resp_code;
	/* TF response data. */
	uint32_t	resp[170];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written. When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_output_t, *phwrm_tf_output_t;

/***********************
 * hwrm_tf_version_get *
 ***********************/


/* hwrm_tf_version_get_input (size:128b/16B) */

typedef struct hwrm_tf_version_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_tf_version_get_input_t, *phwrm_tf_version_get_input_t;

/* hwrm_tf_version_get_output (size:256b/32B) */

typedef struct hwrm_tf_version_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Version Major number. */
	uint8_t	major;
	/* Version Minor number. */
	uint8_t	minor;
	/* Version Update number. */
	uint8_t	update;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used to indicate device's capabilities and
	 * configurations.
	 */
	uint64_t	dev_caps_cfg;
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_version_get_output_t, *phwrm_tf_version_get_output_t;

/************************
 * hwrm_tf_session_open *
 ************************/


/* hwrm_tf_session_open_input (size:640b/80B) */

typedef struct hwrm_tf_session_open_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Name of the session. */
	uint8_t	session_name[64];
} hwrm_tf_session_open_input_t, *phwrm_tf_session_open_input_t;

/* hwrm_tf_session_open_output (size:192b/24B) */

typedef struct hwrm_tf_session_open_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint32_t	fw_session_id;
	/*
	 * Unique session client identifier for the first client on
	 * the newly created session.
	 */
	uint32_t	fw_session_client_id;
	/* This field is used to return the status of fw session to host. */
	uint32_t	flags;
	/*
	 * Indicates if the shared session has been created. Shared session
	 * should be the first session created ever. Its fw_rm_client_id
	 * should be 1. The AFM session's fw_rm_client_id is 0.
	 */
	#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION		UINT32_C(0x1)
	/*
	 * If this bit set to 0, then it indicates the shared session
	 * has been created by another session.
	 */
		#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_NOT_CREATOR  UINT32_C(0x0)
	/*
	 * If this bit is set to 1, then it indicates the shared session
	 * is created by this session.
	 */
		#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_CREATOR	UINT32_C(0x1)
		#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_LAST	HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_CREATOR
	/* unused. */
	uint8_t	unused1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_open_output_t, *phwrm_tf_session_open_output_t;

/****************************
 * hwrm_tf_session_register *
 ****************************/


/* hwrm_tf_session_register_input (size:704b/88B) */

typedef struct hwrm_tf_session_register_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session that the
	 * register request want to create a new client on. This
	 * value originates from the first open request.
	 * The fw_session_id of the attach session includes PCIe bus
	 * info to distinguish the PF and session info to identify
	 * the associated TruFlow session.
	 */
	uint32_t	fw_session_id;
	/* unused. */
	uint32_t	unused0;
	/* Name of the session client. */
	uint8_t	session_client_name[64];
} hwrm_tf_session_register_input_t, *phwrm_tf_session_register_input_t;

/* hwrm_tf_session_register_output (size:128b/16B) */

typedef struct hwrm_tf_session_register_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session client identifier for the session created
	 * by the firmware. It includes the session the client it
	 * attached to and session client info.
	 */
	uint32_t	fw_session_client_id;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_register_output_t, *phwrm_tf_session_register_output_t;

/******************************
 * hwrm_tf_session_unregister *
 ******************************/


/* hwrm_tf_session_unregister_input (size:192b/24B) */

typedef struct hwrm_tf_session_unregister_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session that the
	 * unregister request want to close a session client on.
	 */
	uint32_t	fw_session_id;
	/*
	 * Unique session client identifier for the session that the
	 * unregister request want to close.
	 */
	uint32_t	fw_session_client_id;
} hwrm_tf_session_unregister_input_t, *phwrm_tf_session_unregister_input_t;

/* hwrm_tf_session_unregister_output (size:128b/16B) */

typedef struct hwrm_tf_session_unregister_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_unregister_output_t, *phwrm_tf_session_unregister_output_t;

/*************************
 * hwrm_tf_session_close *
 *************************/


/* hwrm_tf_session_close_input (size:192b/24B) */

typedef struct hwrm_tf_session_close_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint8_t	unused0[4];
} hwrm_tf_session_close_input_t, *phwrm_tf_session_close_input_t;

/* hwrm_tf_session_close_output (size:128b/16B) */

typedef struct hwrm_tf_session_close_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_close_output_t, *phwrm_tf_session_close_output_t;

/************************
 * hwrm_tf_session_qcfg *
 ************************/


/* hwrm_tf_session_qcfg_input (size:192b/24B) */

typedef struct hwrm_tf_session_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint8_t	unused0[4];
} hwrm_tf_session_qcfg_input_t, *phwrm_tf_session_qcfg_input_t;

/* hwrm_tf_session_qcfg_output (size:128b/16B) */

typedef struct hwrm_tf_session_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* RX action control settings flags. */
	uint8_t	rx_act_flags;
	/*
	 * A value of 1 in this field indicates that Global Flow ID
	 * reporting into cfa_code and cfa_metadata is enabled.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_ABCR_GFID_EN		UINT32_C(0x1)
	/*
	 * A value of 1 in this field indicates that both inner and outer
	 * are stripped and inner tag is passed.
	 * Enabled.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_ABCR_VTAG_DLT_BOTH	UINT32_C(0x2)
	/*
	 * A value of 1 in this field indicates that the re-use of
	 * existing tunnel L2 header SMAC is enabled for
	 * Non-tunnel L2, L2-L3 and IP-IP tunnel.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_TECT_SMAC_OVR_RUTNSL2	UINT32_C(0x4)
	/* TX Action control settings flags. */
	uint8_t	tx_act_flags;
	/* Disabled. */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_ABCR_VEB_EN	UINT32_C(0x1)
	/*
	 * When set to 1 any GRE tunnels will include the
	 * optional Key field.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_GRE_SET_K	UINT32_C(0x2)
	/*
	 * When set to 1, for GRE tunnels, the IPV6 Traffic Class (TC)
	 * field of the outer header is inherited from the inner header
	 * (if present) or the fixed value as taken from the encap
	 * record.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_IPV6_TC_IH	UINT32_C(0x4)
	/*
	 * When set to 1, for GRE tunnels, the IPV4 Type Of Service (TOS)
	 * field of the outer header is inherited from the inner header
	 * (if present) or the fixed value as taken from the encap record.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_IPV4_TOS_IH	UINT32_C(0x8)
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_qcfg_output_t, *phwrm_tf_session_qcfg_output_t;

/******************************
 * hwrm_tf_session_resc_qcaps *
 ******************************/


/* hwrm_tf_session_resc_qcaps_input (size:256b/32B) */

typedef struct hwrm_tf_session_resc_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the size of the provided qcaps_addr array
	 * buffer. The size should be set to the Resource Manager
	 * provided max number of qcaps entries which is device
	 * specific. Resource Manager gets the max size from HCAPI
	 * RM.
	 */
	uint16_t	qcaps_size;
	/*
	 * This is the DMA address for the qcaps output data array
	 * buffer. Array is of tf_rm_resc_req_entry type and is
	 * device specific.
	 */
	uint64_t	qcaps_addr;
} hwrm_tf_session_resc_qcaps_input_t, *phwrm_tf_session_resc_qcaps_input_t;

/* hwrm_tf_session_resc_qcaps_output (size:192b/24B) */

typedef struct hwrm_tf_session_resc_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Control flags. */
	uint32_t	flags;
	/* Session reservation strategy. */
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_MASK  UINT32_C(0x3)
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_SFT   0
	/* Static partitioning. */
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_STATIC  UINT32_C(0x0)
	/* Strategy 1. */
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_1	UINT32_C(0x1)
	/* Strategy 2. */
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_2	UINT32_C(0x2)
	/* Strategy 3. */
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_3	UINT32_C(0x3)
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_LAST   HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_3
	/*
	 * Size of the returned qcaps_addr data array buffer. The
	 * value cannot exceed the size defined by the input msg,
	 * qcaps_size.
	 */
	uint16_t	size;
	/*
	 * SRAM profile number that sets the partition of SRAM memory
	 * between TF and AFM within the 4 internal memory banks (Thor).
	 */
	uint8_t	sram_profile;
	/* unused. */
	uint8_t	unused0;
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_qcaps_output_t, *phwrm_tf_session_resc_qcaps_output_t;

/******************************
 * hwrm_tf_session_resc_alloc *
 ******************************/


/* hwrm_tf_session_resc_alloc_input (size:320b/40B) */

typedef struct hwrm_tf_session_resc_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the array size of the provided req_addr and
	 * resv_addr array buffers. Should be set to the number of
	 * request entries.
	 */
	uint16_t	req_size;
	/*
	 * This is the DMA address for the request input data array
	 * buffer. Array is of tf_rm_resc_req_entry type. Size of the
	 * array buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	req_addr;
	/*
	 * This is the DMA address for the resc output data array
	 * buffer. Array is of tf_rm_resc_entry type. Size of the array
	 * buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	resc_addr;
} hwrm_tf_session_resc_alloc_input_t, *phwrm_tf_session_resc_alloc_input_t;

/* hwrm_tf_session_resc_alloc_output (size:128b/16B) */

typedef struct hwrm_tf_session_resc_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Size of the returned tf_rm_resc_entry data array. The value
	 * cannot exceed the req_size defined by the input msg. The data
	 * array is returned using the resv_addr specified DMA
	 * address also provided by the input msg.
	 */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_alloc_output_t, *phwrm_tf_session_resc_alloc_output_t;

/******************************
 * hwrm_tf_session_resc_flush *
 ******************************/


/* hwrm_tf_session_resc_flush_input (size:256b/32B) */

typedef struct hwrm_tf_session_resc_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the size, in bytes, of the provided flush_addr
	 * buffer.
	 */
	uint16_t	flush_size;
	/*
	 * This is the DMA address for the flush input data array
	 * buffer. Array of tf_rm_resc_entry type. Size of the
	 * buffer is provided by the 'flush_size' field in this
	 * message.
	 */
	uint64_t	flush_addr;
} hwrm_tf_session_resc_flush_input_t, *phwrm_tf_session_resc_flush_input_t;

/* hwrm_tf_session_resc_flush_output (size:128b/16B) */

typedef struct hwrm_tf_session_resc_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_flush_output_t, *phwrm_tf_session_resc_flush_output_t;

/*****************************
 * hwrm_tf_session_resc_info *
 *****************************/


/* hwrm_tf_session_resc_info_input (size:320b/40B) */

typedef struct hwrm_tf_session_resc_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the array size of the provided req_addr and
	 * resv_addr array buffers. Should be set to the number of
	 * request entries.
	 */
	uint16_t	req_size;
	/*
	 * This is the DMA address for the request input data array
	 * buffer. Array is of tf_rm_resc_req_entry type. Size of the
	 * array buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	req_addr;
	/*
	 * This is the DMA address for the resc output data array
	 * buffer. Array is of tf_rm_resc_entry type. Size of the array
	 * buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	resc_addr;
} hwrm_tf_session_resc_info_input_t, *phwrm_tf_session_resc_info_input_t;

/* hwrm_tf_session_resc_info_output (size:128b/16B) */

typedef struct hwrm_tf_session_resc_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Size of the returned tf_rm_resc_entry data array. The value
	 * cannot exceed the req_size defined by the input msg. The data
	 * array is returned using the resv_addr specified DMA
	 * address also provided by the input msg.
	 */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_info_output_t, *phwrm_tf_session_resc_info_output_t;

/* TruFlow RM capability of a resource. */
/* tf_rm_resc_req_entry (size:64b/8B) */

typedef struct tf_rm_resc_req_entry {
	/* Type of the resource, defined globally in HCAPI RM. */
	uint32_t	type;
	/* Minimum value. */
	uint16_t	min;
	/* Maximum value. */
	uint16_t	max;
} tf_rm_resc_req_entry_t, *ptf_rm_resc_req_entry_t;

/* TruFlow RM reservation information. */
/* tf_rm_resc_entry (size:64b/8B) */

typedef struct tf_rm_resc_entry {
	/* Type of the resource, defined globally in HCAPI RM. */
	uint32_t	type;
	/* Start offset. */
	uint16_t	start;
	/* Number of resources. */
	uint16_t	stride;
} tf_rm_resc_entry_t, *ptf_rm_resc_entry_t;

/**************************
 * hwrm_tf_tbl_type_alloc *
 **************************/


/* hwrm_tf_tbl_type_alloc_input (size:192b/24B) */

typedef struct hwrm_tf_tbl_type_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_FLAGS_DIR_LAST HWRM_TF_TBL_TYPE_ALLOC_INPUT_FLAGS_DIR_TX
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP gparse block type */
	#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE gparse block type */
	#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE gparse block type */
	#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TF_TBL_TYPE_ALLOC_INPUT_BLKTYPE_LAST		HWRM_TF_TBL_TYPE_ALLOC_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
	/*
	 * This field is blktype specific. For any of the UPAR types it is
	 * set to a non-zero value in case of a re-alloc, specifies a
	 * tunnel-type of dynamic UPAR tunnel.
	 */
	uint8_t	type;
} hwrm_tf_tbl_type_alloc_input_t, *phwrm_tf_tbl_type_alloc_input_t;

/* hwrm_tf_tbl_type_alloc_output (size:128b/16B) */

typedef struct hwrm_tf_tbl_type_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/*
	 * Table entry allocated by the firmware using the
	 * parameters above.
	 */
	uint16_t	idx_tbl_id;
	/* unused */
	uint8_t	unused0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tbl_type_alloc_output_t, *phwrm_tf_tbl_type_alloc_output_t;

/************************
 * hwrm_tf_tbl_type_get *
 ************************/


/* hwrm_tf_tbl_type_get_input (size:256b/32B) */

typedef struct hwrm_tf_tbl_type_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_RX		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_TX		UINT32_C(0x1)
		#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_LAST	HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_TX
	/*
	 * When set use the special access register access to clear
	 * the table entry on read.
	 */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_CLEAR_ON_READ	UINT32_C(0x2)
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP gparse block type */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE gparse block type */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE gparse block type */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TF_TBL_TYPE_GET_INPUT_BLKTYPE_LAST		HWRM_TF_TBL_TYPE_GET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
	/* unused. */
	uint8_t	unused0;
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
} hwrm_tf_tbl_type_get_input_t, *phwrm_tf_tbl_type_get_input_t;

/* hwrm_tf_tbl_type_get_output (size:2240b/280B) */

typedef struct hwrm_tf_tbl_type_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint16_t	unused0;
	/* Response data. */
	uint8_t	data[256];
	/* unused */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tbl_type_get_output_t, *phwrm_tf_tbl_type_get_output_t;

/************************
 * hwrm_tf_tbl_type_set *
 ************************/


/* hwrm_tf_tbl_type_set_input (size:1024b/128B) */

typedef struct hwrm_tf_tbl_type_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_TX
	/* Indicate table data is being sent via DMA. */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP gparse block type */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE gparse block type */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE gparse block type */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TF_TBL_TYPE_SET_INPUT_BLKTYPE_LAST		HWRM_TF_TBL_TYPE_SET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
	/* unused. */
	uint8_t	unused0;
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
	/* Size of the data to set. */
	uint16_t	size;
	/* unused */
	uint8_t	unused1[6];
	/* Data to be set. */
	uint8_t	data[88];
} hwrm_tf_tbl_type_set_input_t, *phwrm_tf_tbl_type_set_input_t;

/* hwrm_tf_tbl_type_set_output (size:128b/16B) */

typedef struct hwrm_tf_tbl_type_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tbl_type_set_output_t, *phwrm_tf_tbl_type_set_output_t;

/*************************
 * hwrm_tf_tbl_type_free *
 *************************/


/* hwrm_tf_tbl_type_free_input (size:256b/32B) */

typedef struct hwrm_tf_tbl_type_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_FREE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TBL_TYPE_FREE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TBL_TYPE_FREE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TBL_TYPE_FREE_INPUT_FLAGS_DIR_LAST HWRM_TF_TBL_TYPE_FREE_INPUT_FLAGS_DIR_TX
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TF_TBL_TYPE_FREE_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP gparse block type */
	#define HWRM_TF_TBL_TYPE_FREE_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE gparse block type */
	#define HWRM_TF_TBL_TYPE_FREE_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE gparse block type */
	#define HWRM_TF_TBL_TYPE_FREE_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TF_TBL_TYPE_FREE_INPUT_BLKTYPE_LAST		HWRM_TF_TBL_TYPE_FREE_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
	/* Unused */
	uint8_t	unused0;
	/*
	 * Table entry to be freed by the firmware using the parameters
	 * above.
	 */
	uint16_t	idx_tbl_id;
	/* Unused */
	uint8_t	unused1[6];
} hwrm_tf_tbl_type_free_input_t, *phwrm_tf_tbl_type_free_input_t;

/* hwrm_tf_tbl_type_free_output (size:128b/16B) */

typedef struct hwrm_tf_tbl_type_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* unused */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tbl_type_free_output_t, *phwrm_tf_tbl_type_free_output_t;

/*********************
 * hwrm_tf_em_insert *
 *********************/


/* hwrm_tf_em_insert_input (size:832b/104B) */

typedef struct hwrm_tf_em_insert_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware Session Id. */
	uint32_t	fw_session_id;
	/* Control Flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_LAST HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_TX
	/* Reported match strength. */
	uint16_t	strength;
	/* Index to action. */
	uint32_t	action_ptr;
	/* Index of EM record. */
	uint32_t	em_record_idx;
	/* EM Key value. */
	uint64_t	em_key[8];
	/* Number of bits in em_key. */
	uint16_t	em_key_bitlen;
	/* unused. */
	uint16_t	unused0[3];
} hwrm_tf_em_insert_input_t, *phwrm_tf_em_insert_input_t;

/* hwrm_tf_em_insert_output (size:128b/16B) */

typedef struct hwrm_tf_em_insert_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* EM record pointer index. */
	uint16_t	rptr_index;
	/* EM record offset 0~3. */
	uint8_t	rptr_entry;
	/* Number of word entries consumed by the key. */
	uint8_t	num_of_entries;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_em_insert_output_t, *phwrm_tf_em_insert_output_t;

/**************************
 * hwrm_tf_em_hash_insert *
 **************************/


/* hwrm_tf_em_hash_insert_input (size:1024b/128B) */

typedef struct hwrm_tf_em_hash_insert_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware Session Id. */
	uint32_t	fw_session_id;
	/* Control Flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_LAST HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_TX
	/* Indicates table data is being sent via DMA. */
	#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/* Number of bits in the EM record. */
	uint16_t	em_record_size_bits;
	/* CRC32 hash of key. */
	uint32_t	key0_hash;
	/* Lookup3 hash of key. */
	uint32_t	key1_hash;
	/* Index of EM record. */
	uint32_t	em_record_idx;
	/* Unused. */
	uint32_t	unused0;
	/* EM record. */
	uint64_t	em_record[11];
} hwrm_tf_em_hash_insert_input_t, *phwrm_tf_em_hash_insert_input_t;

/* hwrm_tf_em_hash_insert_output (size:128b/16B) */

typedef struct hwrm_tf_em_hash_insert_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* EM record pointer index. */
	uint16_t	rptr_index;
	/* EM record offset 0~3. */
	uint8_t	rptr_entry;
	/* Number of word entries consumed by the key. */
	uint8_t	num_of_entries;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_em_hash_insert_output_t, *phwrm_tf_em_hash_insert_output_t;

/*********************
 * hwrm_tf_em_delete *
 *********************/


/* hwrm_tf_em_delete_input (size:832b/104B) */

typedef struct hwrm_tf_em_delete_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session Id. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_LAST HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_TX
	/* Unused0 */
	uint16_t	unused0;
	/* EM internal flow handle. */
	uint64_t	flow_handle;
	/* EM Key value */
	uint64_t	em_key[8];
	/* Number of bits in em_key. */
	uint16_t	em_key_bitlen;
	/* unused. */
	uint16_t	unused1[3];
} hwrm_tf_em_delete_input_t, *phwrm_tf_em_delete_input_t;

/* hwrm_tf_em_delete_output (size:128b/16B) */

typedef struct hwrm_tf_em_delete_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Original stack allocation index. */
	uint16_t	em_index;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_em_delete_output_t, *phwrm_tf_em_delete_output_t;

/*******************
 * hwrm_tf_em_move *
 *******************/


/* hwrm_tf_em_move_input (size:320b/40B) */

typedef struct hwrm_tf_em_move_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session Id. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_LAST HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_TX
	/* Number of EM entry blocks */
	uint16_t	num_blocks;
	/* New index for entry */
	uint32_t	new_index;
	/* Unused */
	uint32_t	unused0;
	/* EM internal flow handle. */
	uint64_t	flow_handle;
} hwrm_tf_em_move_input_t, *phwrm_tf_em_move_input_t;

/* hwrm_tf_em_move_output (size:128b/16B) */

typedef struct hwrm_tf_em_move_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Index of old entry. */
	uint16_t	em_index;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_em_move_output_t, *phwrm_tf_em_move_output_t;

/********************
 * hwrm_tf_tcam_set *
 ********************/


/* hwrm_tf_tcam_set_input (size:1024b/128B) */

typedef struct hwrm_tf_tcam_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_TX
	/*
	 * Indicate device data is being sent via DMA, the device
	 * data is packing does not change.
	 */
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of TCAM entry. */
	uint16_t	idx;
	/* Number of bytes in the TCAM key. */
	uint8_t	key_size;
	/* Number of bytes in the TCAM result. */
	uint8_t	result_size;
	/*
	 * Offset from which the mask bytes start in the device data
	 * array, key offset is always 0.
	 */
	uint8_t	mask_offset;
	/* Offset from which the result bytes start in the device data array. */
	uint8_t	result_offset;
	/* unused. */
	uint8_t	unused0[6];
	/*
	 * TCAM key located at offset 0, mask located at mask_offset
	 * and result at result_offset for the device.
	 */
	uint8_t	dev_data[88];
} hwrm_tf_tcam_set_input_t, *phwrm_tf_tcam_set_input_t;

/* hwrm_tf_tcam_set_output (size:128b/16B) */

typedef struct hwrm_tf_tcam_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written. When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tcam_set_output_t, *phwrm_tf_tcam_set_output_t;

/********************
 * hwrm_tf_tcam_get *
 ********************/


/* hwrm_tf_tcam_get_input (size:256b/32B) */

typedef struct hwrm_tf_tcam_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of a TCAM entry. */
	uint16_t	idx;
	/* unused. */
	uint16_t	unused0;
} hwrm_tf_tcam_get_input_t, *phwrm_tf_tcam_get_input_t;

/* hwrm_tf_tcam_get_output (size:2368b/296B) */

typedef struct hwrm_tf_tcam_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of bytes in the TCAM key. */
	uint8_t	key_size;
	/* Number of bytes in the TCAM entry. */
	uint8_t	result_size;
	/* Offset from which the mask bytes start in the device data array. */
	uint8_t	mask_offset;
	/* Offset from which the result bytes start in the device data array. */
	uint8_t	result_offset;
	/* unused. */
	uint8_t	unused0[4];
	/*
	 * TCAM key located at offset 0, mask located at mask_offset
	 * and result at result_offset for the device.
	 */
	uint8_t	dev_data[272];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written. When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tcam_get_output_t, *phwrm_tf_tcam_get_output_t;

/*********************
 * hwrm_tf_tcam_move *
 *********************/


/* hwrm_tf_tcam_move_input (size:1024b/128B) */

typedef struct hwrm_tf_tcam_move_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_LAST HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Number of TCAM index pairs to be swapped for the device. */
	uint16_t	count;
	/* unused. */
	uint16_t	unused0;
	/* TCAM index pairs to be swapped for the device. */
	uint16_t	idx_pairs[48];
} hwrm_tf_tcam_move_input_t, *phwrm_tf_tcam_move_input_t;

/* hwrm_tf_tcam_move_output (size:128b/16B) */

typedef struct hwrm_tf_tcam_move_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written. When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tcam_move_output_t, *phwrm_tf_tcam_move_output_t;

/*********************
 * hwrm_tf_tcam_free *
 *********************/


/* hwrm_tf_tcam_free_input (size:1024b/128B) */

typedef struct hwrm_tf_tcam_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_LAST HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Number of TCAM index to be deleted for the device. */
	uint16_t	count;
	/* unused. */
	uint16_t	unused0;
	/* TCAM index list to be deleted for the device. */
	uint16_t	idx_list[48];
} hwrm_tf_tcam_free_input_t, *phwrm_tf_tcam_free_input_t;

/* hwrm_tf_tcam_free_output (size:128b/16B) */

typedef struct hwrm_tf_tcam_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written. When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tcam_free_output_t, *phwrm_tf_tcam_free_output_t;

/**************************
 * hwrm_tf_global_cfg_set *
 **************************/


/* hwrm_tf_global_cfg_set_input (size:448b/56B) */

typedef struct hwrm_tf_global_cfg_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_TX
	/* Indicate device data is being sent via DMA. */
	#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/* Global Cfg type */
	uint32_t	type;
	/* Offset of the type */
	uint32_t	offset;
	/* Size of the data to set in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
	/* Data to set */
	uint8_t	data[8];
	/* Mask of data to set, 0 indicates no mask */
	uint8_t	mask[8];
} hwrm_tf_global_cfg_set_input_t, *phwrm_tf_global_cfg_set_input_t;

/* hwrm_tf_global_cfg_set_output (size:128b/16B) */

typedef struct hwrm_tf_global_cfg_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written. When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_global_cfg_set_output_t, *phwrm_tf_global_cfg_set_output_t;

/**************************
 * hwrm_tf_global_cfg_get *
 **************************/


/* hwrm_tf_global_cfg_get_input (size:320b/40B) */

typedef struct hwrm_tf_global_cfg_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_TX
	/* Global Cfg type */
	uint32_t	type;
	/* Offset of the type */
	uint32_t	offset;
	/* Size of the data to set in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
} hwrm_tf_global_cfg_get_input_t, *phwrm_tf_global_cfg_get_input_t;

/* hwrm_tf_global_cfg_get_output (size:2240b/280B) */

typedef struct hwrm_tf_global_cfg_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Size of the data read in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
	/* Data to set */
	uint8_t	data[256];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_global_cfg_get_output_t, *phwrm_tf_global_cfg_get_output_t;

/**********************
 * hwrm_tf_if_tbl_get *
 **********************/


/* hwrm_tf_if_tbl_get_input (size:256b/32B) */

typedef struct hwrm_tf_if_tbl_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_TX
	/* Size of the data to set. */
	uint16_t	size;
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
} hwrm_tf_if_tbl_get_input_t, *phwrm_tf_if_tbl_get_input_t;

/* hwrm_tf_if_tbl_get_output (size:1216b/152B) */

typedef struct hwrm_tf_if_tbl_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint16_t	unused0;
	/* Response data. */
	uint8_t	data[128];
	/* unused */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_if_tbl_get_output_t, *phwrm_tf_if_tbl_get_output_t;

/***************************
 * hwrm_tf_if_tbl_type_set *
 ***************************/


/* hwrm_tf_if_tbl_set_input (size:1024b/128B) */

typedef struct hwrm_tf_if_tbl_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to set. */
	uint32_t	index;
	/* Size of the data to set. */
	uint16_t	size;
	/* unused */
	uint8_t	unused1[6];
	/* Data to be set. */
	uint8_t	data[88];
} hwrm_tf_if_tbl_set_input_t, *phwrm_tf_if_tbl_set_input_t;

/* hwrm_tf_if_tbl_set_output (size:128b/16B) */

typedef struct hwrm_tf_if_tbl_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_if_tbl_set_output_t, *phwrm_tf_if_tbl_set_output_t;

/*****************************
 * hwrm_tf_tbl_type_bulk_get *
 *****************************/


/* hwrm_tf_tbl_type_bulk_get_input (size:384b/48B) */

typedef struct hwrm_tf_tbl_type_bulk_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_RX		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_TX		UINT32_C(0x1)
		#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_LAST	HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_TX
	/*
	 * When set use the special access register access to clear
	 * the table entries on read.
	 */
	#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_CLEAR_ON_READ	UINT32_C(0x2)
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Starting index of the type to retrieve. */
	uint32_t	start_index;
	/* Number of entries to retrieve. */
	uint32_t	num_entries;
	/* Number of entries to retrieve. */
	uint32_t	unused1;
	/* Host memory where data will be stored. */
	uint64_t	host_addr;
} hwrm_tf_tbl_type_bulk_get_input_t, *phwrm_tf_tbl_type_bulk_get_input_t;

/* hwrm_tf_tbl_type_bulk_get_output (size:128b/16B) */

typedef struct hwrm_tf_tbl_type_bulk_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint8_t	unused0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tbl_type_bulk_get_output_t, *phwrm_tf_tbl_type_bulk_get_output_t;

/***********************************
 * hwrm_tf_session_hotup_state_set *
 ***********************************/


/* hwrm_tf_session_hotup_state_set_input (size:192b/24B) */

typedef struct hwrm_tf_session_hotup_state_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Shared session state. */
	uint16_t	state;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_HOTUP_STATE_SET_INPUT_FLAGS_DIR_TX
} hwrm_tf_session_hotup_state_set_input_t, *phwrm_tf_session_hotup_state_set_input_t;

/* hwrm_tf_session_hotup_state_set_output (size:128b/16B) */

typedef struct hwrm_tf_session_hotup_state_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_hotup_state_set_output_t, *phwrm_tf_session_hotup_state_set_output_t;

/***********************************
 * hwrm_tf_session_hotup_state_get *
 ***********************************/


/* hwrm_tf_session_hotup_state_get_input (size:192b/24B) */

typedef struct hwrm_tf_session_hotup_state_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_HOTUP_STATE_GET_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
} hwrm_tf_session_hotup_state_get_input_t, *phwrm_tf_session_hotup_state_get_input_t;

/* hwrm_tf_session_hotup_state_get_output (size:128b/16B) */

typedef struct hwrm_tf_session_hotup_state_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Shared session HA state. */
	uint16_t	state;
	/* Shared session HA reference count. */
	uint16_t	ref_cnt;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_hotup_state_get_output_t, *phwrm_tf_session_hotup_state_get_output_t;

/**************************
 * hwrm_tf_resc_usage_set *
 **************************/


/* hwrm_tf_resc_usage_set_input (size:1024b/128B) */

typedef struct hwrm_tf_resc_usage_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_RESC_USAGE_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_RESC_USAGE_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_RESC_USAGE_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_RESC_USAGE_SET_INPUT_FLAGS_DIR_TX
	/* Indicate table data is being sent via DMA. */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/* Types of the resource to set their usage state. */
	uint16_t	types;
	/* WC TCAM Pool */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_TYPES_WC_TCAM	UINT32_C(0x1)
	/* EM Internal Memory Pool */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_TYPES_EM		UINT32_C(0x2)
	/* Meter Instance */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_TYPES_METER		UINT32_C(0x4)
	/* Counter Record Table */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_TYPES_COUNTER	UINT32_C(0x8)
	/* Action Record Table */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_TYPES_ACTION		UINT32_C(0x10)
	/* ACT MODIFY/ENCAP Record Table */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_TYPES_ACT_MOD_ENCAP	UINT32_C(0x20)
	/* Source Property SMAC Record Table */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_TYPES_SP_SMAC	UINT32_C(0x40)
	/* All Resource Types */
	#define HWRM_TF_RESC_USAGE_SET_INPUT_TYPES_ALL		UINT32_C(0x80)
	/* Size of the data to set. */
	uint16_t	size;
	/* unused */
	uint8_t	unused1[6];
	/* Data to be set. */
	uint8_t	data[96];
} hwrm_tf_resc_usage_set_input_t, *phwrm_tf_resc_usage_set_input_t;

/* hwrm_tf_resc_usage_set_output (size:128b/16B) */

typedef struct hwrm_tf_resc_usage_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_resc_usage_set_output_t, *phwrm_tf_resc_usage_set_output_t;

/****************************
 * hwrm_tf_resc_usage_query *
 ****************************/


/* hwrm_tf_resc_usage_query_input (size:256b/32B) */

typedef struct hwrm_tf_resc_usage_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_RESC_USAGE_QUERY_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_RESC_USAGE_QUERY_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_RESC_USAGE_QUERY_INPUT_FLAGS_DIR_LAST HWRM_TF_RESC_USAGE_QUERY_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
	/* Types of the resource to retrieve their usage state. */
	uint16_t	types;
	/* WC TCAM Pool */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_TYPES_WC_TCAM	UINT32_C(0x1)
	/* EM Internal Memory Pool */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_TYPES_EM		UINT32_C(0x2)
	/* Meter Instance */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_TYPES_METER		UINT32_C(0x4)
	/* Counter Record Table */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_TYPES_COUNTER	UINT32_C(0x8)
	/* Action Record Table */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_TYPES_ACTION		UINT32_C(0x10)
	/* ACT MODIFY/ENCAP Record Table */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_TYPES_ACT_MOD_ENCAP	UINT32_C(0x20)
	/* Source Property SMAC Record Table */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_TYPES_SP_SMAC	UINT32_C(0x40)
	/* All Resource Types */
	#define HWRM_TF_RESC_USAGE_QUERY_INPUT_TYPES_ALL		UINT32_C(0x80)
	/* unused */
	uint8_t	unused1[6];
} hwrm_tf_resc_usage_query_input_t, *phwrm_tf_resc_usage_query_input_t;

/* hwrm_tf_resc_usage_query_output (size:960b/120B) */

typedef struct hwrm_tf_resc_usage_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint16_t	unused0;
	/* Response data. */
	uint8_t	data[96];
	/* unused */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_resc_usage_query_output_t, *phwrm_tf_resc_usage_query_output_t;

/****************************
 * hwrm_tfc_tbl_scope_qcaps *
 ****************************/


/*
 * TruFlow command to check if firmware is capable of
 * supporting table scopes.
 */
/* hwrm_tfc_tbl_scope_qcaps_input (size:128b/16B) */

typedef struct hwrm_tfc_tbl_scope_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_tfc_tbl_scope_qcaps_input_t, *phwrm_tfc_tbl_scope_qcaps_input_t;

/* hwrm_tfc_tbl_scope_qcaps_output (size:192b/24B) */

typedef struct hwrm_tfc_tbl_scope_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The maximum number of lookup records that a table scope can support.
	 * This field is only valid if tbl_scope_capable is not zero.
	 */
	uint32_t	max_lkup_rec_cnt;
	/*
	 * The maximum number of action records that a table scope can support.
	 * This field is only valid if tbl_scope_capable is not zero.
	 */
	uint32_t	max_act_rec_cnt;
	/* Not zero if firmware capable of table scopes. */
	uint8_t	tbl_scope_capable;
	/*
	 * log2 of the number of lookup static buckets that a table scope can
	 * support. This field is only valid if tbl_scope_capable is not zero.
	 */
	uint8_t	max_lkup_static_buckets_exp;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tbl_scope_qcaps_output_t, *phwrm_tfc_tbl_scope_qcaps_output_t;

/*******************************
 * hwrm_tfc_tbl_scope_id_alloc *
 *******************************/


/*
 * TruFlow command to allocate a table scope ID and create the pools.
 *
 * There is no corresponding free command since a table scope
 * ID will automatically be freed once the last FID is removed.
 * That is, when the hwrm_tfc_tbl_scope_fid_rem command returns
 * a fid_cnt of 0 that also means that the table scope ID has
 * been freed.
 */
/* hwrm_tfc_tbl_scope_id_alloc_input (size:256b/32B) */

typedef struct hwrm_tfc_tbl_scope_id_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/* The maximum number of pools for this table scope. */
	uint16_t	max_pools;
	/* Non-zero if this table scope is shared. */
	uint8_t	shared;
	/*
	 * The size of the lookup pools per direction expressed as
	 * log2(max_records/max_pools). That is, size=2^exp.
	 *
	 * Array is indexed by enum cfa_dir.
	 */
	uint8_t	lkup_pool_sz_exp[2];
	/*
	 * The size of the action pools per direction expressed as
	 * log2(max_records/max_pools). That is, size=2^exp.
	 *
	 * Array is indexed by enum cfa_dir.
	 */
	uint8_t	act_pool_sz_exp[2];
	/* Application type. 0 (AFM), 1 (TF) */
	uint8_t	app_type;
	/* unused. */
	uint8_t	unused0[6];
} hwrm_tfc_tbl_scope_id_alloc_input_t, *phwrm_tfc_tbl_scope_id_alloc_input_t;

/* hwrm_tfc_tbl_scope_id_alloc_output (size:128b/16B) */

typedef struct hwrm_tfc_tbl_scope_id_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The table scope ID that was allocated. */
	uint8_t	tsid;
	/*
	 * Non-zero if this is the first FID associated with this table scope
	 * ID.
	 */
	uint8_t	first;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tbl_scope_id_alloc_output_t, *phwrm_tfc_tbl_scope_id_alloc_output_t;

/*****************************
 * hwrm_tfc_tbl_scope_config *
 *****************************/


/* TruFlow command to configure the table scope memory. */
/* hwrm_tfc_tbl_scope_config_input (size:704b/88B) */

typedef struct hwrm_tfc_tbl_scope_config_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The base addresses for lookup memory.
	 * Array is indexed by enum cfa_dir.
	 */
	uint64_t	lkup_base_addr[2];
	/*
	 * The base addresses for action memory.
	 * Array is indexed by enum cfa_dir.
	 */
	uint64_t	act_base_addr[2];
	/*
	 * The number of minimum sized lkup records per direction.
	 * In this usage, records are the minimum lookup memory
	 * allocation unit in a table scope. This value is the total
	 * memory required for buckets and entries.
	 *
	 * Array is indexed by enum cfa_dir.
	 */
	uint64_t	lkup_rec_cnt;
	/*
	 * The number of minimum sized action records per direction.
	 * Similar to the lkup_rec_cnt, records are the minimum
	 * action memory allocation unit in a table scope.
	 *
	 * Array is indexed by enum cfa_dir.
	 */
	uint64_t	act_rec_cnt;
	/*
	 * The number of static lookup buckets in the table scope.
	 * Array is indexed by enum cfa_dir.
	 */
	uint64_t	lkup_static_bucket_cnt;
	/* The page size of the table scope. */
	uint32_t	pbl_page_sz;
	/*
	 * The PBL level for lookup memory.
	 * Array is indexed by enum cfa_dir.
	 */
	uint8_t	lkup_pbl_level[2];
	/*
	 * The PBL level for action memory.
	 * Array is indexed by enum cfa_dir.
	 */
	uint8_t	act_pbl_level[2];
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[7];
} hwrm_tfc_tbl_scope_config_input_t, *phwrm_tfc_tbl_scope_config_input_t;

/* hwrm_tfc_tbl_scope_config_output (size:128b/16B) */

typedef struct hwrm_tfc_tbl_scope_config_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tbl_scope_config_output_t, *phwrm_tfc_tbl_scope_config_output_t;

/*******************************
 * hwrm_tfc_tbl_scope_deconfig *
 *******************************/


/* TruFlow command to deconfigure the table scope memory. */
/* hwrm_tfc_tbl_scope_deconfig_input (size:192b/24B) */

typedef struct hwrm_tfc_tbl_scope_deconfig_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[7];
} hwrm_tfc_tbl_scope_deconfig_input_t, *phwrm_tfc_tbl_scope_deconfig_input_t;

/* hwrm_tfc_tbl_scope_deconfig_output (size:128b/16B) */

typedef struct hwrm_tfc_tbl_scope_deconfig_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tbl_scope_deconfig_output_t, *phwrm_tfc_tbl_scope_deconfig_output_t;

/******************************
 * hwrm_tfc_tbl_scope_fid_add *
 ******************************/


/* TruFlow command to add a FID to a table scope. */
/* hwrm_tfc_tbl_scope_fid_add_input (size:192b/24B) */

typedef struct hwrm_tfc_tbl_scope_fid_add_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[5];
} hwrm_tfc_tbl_scope_fid_add_input_t, *phwrm_tfc_tbl_scope_fid_add_input_t;

/* hwrm_tfc_tbl_scope_fid_add_output (size:128b/16B) */

typedef struct hwrm_tfc_tbl_scope_fid_add_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of FIDs currently in the table scope ID. */
	uint8_t	fid_cnt;
	/* unused. */
	uint8_t	unused0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tbl_scope_fid_add_output_t, *phwrm_tfc_tbl_scope_fid_add_output_t;

/******************************
 * hwrm_tfc_tbl_scope_fid_rem *
 ******************************/


/* TruFlow command to remove a FID from a table scope. */
/* hwrm_tfc_tbl_scope_fid_rem_input (size:192b/24B) */

typedef struct hwrm_tfc_tbl_scope_fid_rem_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[5];
} hwrm_tfc_tbl_scope_fid_rem_input_t, *phwrm_tfc_tbl_scope_fid_rem_input_t;

/* hwrm_tfc_tbl_scope_fid_rem_output (size:128b/16B) */

typedef struct hwrm_tfc_tbl_scope_fid_rem_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of FIDs remaining in the table scope ID. */
	uint16_t	fid_cnt;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tbl_scope_fid_rem_output_t, *phwrm_tfc_tbl_scope_fid_rem_output_t;

/*****************************
 * hwrm_tfc_session_id_alloc *
 *****************************/


/*
 * Allocate a TFC session. Requests the firmware to allocate a TFC
 * session identifier and associate a forwarding function with the
 * session. Though there's not an explicit matching free for a session
 * id alloc, dis-associating the last fid from a session id (fid_cnt goes
 * to 0), will result in this session id being freed automatically.
 */
/* hwrm_tfc_session_id_alloc_input (size:192b/24B) */

typedef struct hwrm_tfc_session_id_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/* Unused field */
	uint8_t	unused0[6];
} hwrm_tfc_session_id_alloc_input_t, *phwrm_tfc_session_id_alloc_input_t;

/* hwrm_tfc_session_id_alloc_output (size:128b/16B) */

typedef struct hwrm_tfc_session_id_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint16_t	sid;
	/* Unused field */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tfc_session_id_alloc_output_t, *phwrm_tfc_session_id_alloc_output_t;

/****************************
 * hwrm_tfc_session_fid_add *
 ****************************/


/*
 * Associate a TFC session id with a forwarding function. The target_fid
 * will be associated with the passed in sid.
 */
/* hwrm_tfc_session_fid_add_input (size:192b/24B) */

typedef struct hwrm_tfc_session_fid_add_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint16_t	sid;
	/* Unused field */
	uint8_t	unused0[4];
} hwrm_tfc_session_fid_add_input_t, *phwrm_tfc_session_fid_add_input_t;

/* hwrm_tfc_session_fid_add_output (size:128b/16B) */

typedef struct hwrm_tfc_session_fid_add_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of FIDs that share this session. */
	uint16_t	fid_cnt;
	/* Unused field */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tfc_session_fid_add_output_t, *phwrm_tfc_session_fid_add_output_t;

/****************************
 * hwrm_tfc_session_fid_rem *
 ****************************/


/*
 * Dis-associate a TFC session from the target_fid.
 * Though there's not an explicit matching free for a
 * session id alloc, dis-associating the last fid from a session id
 * (fid_cnt goes to 0), will result in this session id being freed
 * automatically.
 */
/* hwrm_tfc_session_fid_rem_input (size:192b/24B) */

typedef struct hwrm_tfc_session_fid_rem_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint16_t	sid;
	/* Unused field */
	uint8_t	unused0[4];
} hwrm_tfc_session_fid_rem_input_t, *phwrm_tfc_session_fid_rem_input_t;

/* hwrm_tfc_session_fid_rem_output (size:128b/16B) */

typedef struct hwrm_tfc_session_fid_rem_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of FIDs that share this session. */
	uint16_t	fid_cnt;
	/* Unused field */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tfc_session_fid_rem_output_t, *phwrm_tfc_session_fid_rem_output_t;

/************************
 * hwrm_tfc_ident_alloc *
 ************************/


/*
 * Allocate a TFC identifier. Requests the firmware to
 * allocate a TFC identifier. The session id and track_type are passed
 * in. The tracking_id is either the sid or target_fid depends on the
 * track_type. The resource subtype is passed in, an id corresponding
 * to all these is allocated and returned in the HWRM response.
 */
/* hwrm_tfc_ident_alloc_input (size:192b/24B) */

typedef struct hwrm_tfc_ident_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Unique session identifier for the session created by the
	 * firmware. Will be used to track this identifier.
	 */
	uint16_t	sid;
	/* Control flags. Direction. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR_LAST HWRM_TFC_IDENT_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Describes the type of tracking tag to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_SID	UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID	UINT32_C(0x2)
	#define HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_LAST		HWRM_TFC_IDENT_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Unused field */
	uint8_t	unused0;
} hwrm_tfc_ident_alloc_input_t, *phwrm_tfc_ident_alloc_input_t;

/* hwrm_tfc_ident_alloc_output (size:128b/16B) */

typedef struct hwrm_tfc_ident_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Resource identifier allocated by the firmware using
	 * parameters above.
	 */
	uint16_t	ident_id;
	/* Unused field */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tfc_ident_alloc_output_t, *phwrm_tfc_ident_alloc_output_t;

/***********************
 * hwrm_tfc_ident_free *
 ***********************/


/*
 * Requests the firmware to free a TFC resource identifier.
 * A resource subtype and session id are passed in.
 * An identifier (previously allocated) corresponding to all these is
 * freed, only after various sanity checks are completed.
 */
/* hwrm_tfc_ident_free_input (size:192b/24B) */

typedef struct hwrm_tfc_ident_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Unique session identifier for the session created by the
	 * firmware. Will be used to validate this request.
	 */
	uint16_t	sid;
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Control flags. Direction. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR_LAST HWRM_TFC_IDENT_FREE_INPUT_FLAGS_DIR_TX
	/* The resource identifier to be freed */
	uint16_t	ident_id;
} hwrm_tfc_ident_free_input_t, *phwrm_tfc_ident_free_input_t;

/* hwrm_tfc_ident_free_output (size:128b/16B) */

typedef struct hwrm_tfc_ident_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tfc_ident_free_output_t, *phwrm_tfc_ident_free_output_t;

/**************************
 * hwrm_tfc_idx_tbl_alloc *
 **************************/


/* hwrm_tfc_idx_tbl_alloc_input (size:192b/24B) */

typedef struct hwrm_tfc_idx_tbl_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Unique session id for the session created by the
	 * firmware. Will be used to track this index table entry
	 * only if track type is track_type_sid.
	 */
	uint16_t	sid;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR_LAST HWRM_TFC_IDX_TBL_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * This field is blktype specific.
	 * For blktype CFA - CFA resource subtype. For definitions,
	 * please see cfa_v3/include/cfa_resources.h.
	 * For blktype rxp, re_gparse, te_gparse -
	 * Tunnel Type. A value of zero (or unknown) means alloc. A known
	 * value (previously allocated dynamic UPAR for tunnel_type) means
	 * realloc. Will fail if a realloc is for previously allocated FID,
	 */
	uint8_t	subtype;
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_SID	UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID	UINT32_C(0x2)
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_LAST		HWRM_TFC_IDX_TBL_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP gparse block type */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE gparse block type */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE gparse block type */
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TFC_IDX_TBL_ALLOC_INPUT_BLKTYPE_LAST		HWRM_TFC_IDX_TBL_ALLOC_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
} hwrm_tfc_idx_tbl_alloc_input_t, *phwrm_tfc_idx_tbl_alloc_input_t;

/* hwrm_tfc_idx_tbl_alloc_output (size:128b/16B) */

typedef struct hwrm_tfc_idx_tbl_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Index table entry allocated by the firmware using the
	 * parameters above.
	 */
	uint16_t	idx_tbl_id;
	/* Reserved */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_idx_tbl_alloc_output_t, *phwrm_tfc_idx_tbl_alloc_output_t;

/******************************
 * hwrm_tfc_idx_tbl_alloc_set *
 ******************************/


/* hwrm_tfc_idx_tbl_alloc_set_input (size:1088b/136B) */

typedef struct hwrm_tfc_idx_tbl_alloc_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Unique session id for the session created by the
	 * firmware. Will be used to track this index table entry
	 * only if track type is track_type_sid.
	 */
	uint16_t	sid;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR_LAST HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DIR_TX
	/*
	 * Indicate device data is being sent via DMA, the device
	 * data packing does not change.
	 */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/*
	 * This field is blktype specific.
	 * For blktype CFA - CFA resource subtype. For definitions,
	 * please see cfa_v3/include/cfa_resources.h.
	 * For blktype rxp, re_gparse, te_gparse -
	 * Tunnel Type. A value of zero (or unknown) means alloc. A known
	 * value (previously allocated dynamic UPAR for tunnel_type) means
	 * realloc. Will fail if a realloc is for previously allocated FID,
	 */
	uint8_t	subtype;
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_SID	UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_FID	UINT32_C(0x2)
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_LAST		HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP gparse block type */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE gparse block type */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE gparse block type */
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_BLKTYPE_LAST		HWRM_TFC_IDX_TBL_ALLOC_SET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
	/* The size of the index table entry in bytes. */
	uint16_t	data_size;
	/* Reserved */
	uint8_t	unused1[6];
	/* The location of the dma buffer */
	uint64_t	dma_addr;
	/*
	 * Index table data located at offset 0. If dma bit is set,
	 * then this field contains the DMA buffer pointer.
	 */
	uint8_t	dev_data[96];
} hwrm_tfc_idx_tbl_alloc_set_input_t, *phwrm_tfc_idx_tbl_alloc_set_input_t;

/* hwrm_tfc_idx_tbl_alloc_set_output (size:128b/16B) */

typedef struct hwrm_tfc_idx_tbl_alloc_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Index table entry allocated by the firmware using the
	 * parameters above.
	 */
	uint16_t	idx_tbl_id;
	/* Reserved */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_idx_tbl_alloc_set_output_t, *phwrm_tfc_idx_tbl_alloc_set_output_t;

/************************
 * hwrm_tfc_idx_tbl_set *
 ************************/


/* hwrm_tfc_idx_tbl_set_input (size:1088b/136B) */

typedef struct hwrm_tfc_idx_tbl_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR_LAST HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DIR_TX
	/*
	 * Indicate device data is being sent via DMA, the device
	 * data packing does not change.
	 */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/*
	 * Index table index returned during alloc by the
	 * firmware.
	 */
	uint16_t	idx_tbl_id;
	/* The size of the index table entry in bytes. */
	uint16_t	data_size;
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP gparse block type */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE gparse block type */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE gparse block type */
	#define HWRM_TFC_IDX_TBL_SET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TFC_IDX_TBL_SET_INPUT_BLKTYPE_LAST		HWRM_TFC_IDX_TBL_SET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
	/* unused. */
	uint8_t	unused0[5];
	/* The location of the dma buffer */
	uint64_t	dma_addr;
	/*
	 * Index table data located at offset 0. If dma bit is set,
	 * then this field contains the DMA buffer pointer.
	 */
	uint8_t	dev_data[96];
} hwrm_tfc_idx_tbl_set_input_t, *phwrm_tfc_idx_tbl_set_input_t;

/* hwrm_tfc_idx_tbl_set_output (size:128b/16B) */

typedef struct hwrm_tfc_idx_tbl_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_idx_tbl_set_output_t, *phwrm_tfc_idx_tbl_set_output_t;

/************************
 * hwrm_tfc_idx_tbl_get *
 ************************/


/* hwrm_tfc_idx_tbl_get_input (size:320b/40B) */

typedef struct hwrm_tfc_idx_tbl_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR_RX		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR_TX		UINT32_C(0x1)
		#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR_LAST	HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_DIR_TX
	/*
	 * When set use the special access register access to clear
	 * the table entry on read.
	 */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_FLAGS_CLEAR_ON_READ	UINT32_C(0x2)
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/*
	 * Index table index returned during alloc by the
	 * firmware.
	 */
	uint16_t	idx_tbl_id;
	/* The size of the index table entry buffer in bytes. */
	uint16_t	buffer_size;
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP block type */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE gparse block type */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE gparse block type */
	#define HWRM_TFC_IDX_TBL_GET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TFC_IDX_TBL_GET_INPUT_BLKTYPE_LAST		HWRM_TFC_IDX_TBL_GET_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
	/* unused. */
	uint8_t	unused0[5];
	/* The location of the response dma buffer */
	uint64_t	dma_addr;
} hwrm_tfc_idx_tbl_get_input_t, *phwrm_tfc_idx_tbl_get_input_t;

/* hwrm_tfc_idx_tbl_get_output (size:128b/16B) */

typedef struct hwrm_tfc_idx_tbl_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of the index table buffer returned in device size bytes. */
	uint16_t	data_size;
	/* unused */
	uint8_t	unused1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_idx_tbl_get_output_t, *phwrm_tfc_idx_tbl_get_output_t;

/*************************
 * hwrm_tfc_idx_tbl_free *
 *************************/


/* hwrm_tfc_idx_tbl_free_input (size:256b/32B) */

typedef struct hwrm_tfc_idx_tbl_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR_LAST HWRM_TFC_IDX_TBL_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * CFA resource subtype. For definitions, please see
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/* Index table id to be freed by the firmware. */
	uint16_t	idx_tbl_id;
	/* Specifies which block this idx table alloc request is for */
	uint8_t	blktype;
	/* CFA block type */
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_BLKTYPE_BLKTYPE_CFA	UINT32_C(0x0)
	/* RXP block type */
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_BLKTYPE_BLKTYPE_RXP	UINT32_C(0x1)
	/* RE parse block type */
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_BLKTYPE_BLKTYPE_RE_GPARSE UINT32_C(0x2)
	/* TE parse block type */
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE UINT32_C(0x3)
	#define HWRM_TFC_IDX_TBL_FREE_INPUT_BLKTYPE_LAST		HWRM_TFC_IDX_TBL_FREE_INPUT_BLKTYPE_BLKTYPE_TE_GPARSE
	/* unused. */
	uint8_t	unused0[7];
} hwrm_tfc_idx_tbl_free_input_t, *phwrm_tfc_idx_tbl_free_input_t;

/* hwrm_tfc_idx_tbl_free_output (size:128b/16B) */

typedef struct hwrm_tfc_idx_tbl_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_idx_tbl_free_output_t, *phwrm_tfc_idx_tbl_free_output_t;

/* TruFlow resources request for a global id. */
/* tfc_global_id_hwrm_req (size:64b/8B) */

typedef struct tfc_global_id_hwrm_req {
	/* Type of the resource, defined in enum cfa_resource_type HCAPI RM. */
	uint16_t	rtype;
	/* Indicates the flow direction in type of cfa_dir. */
	uint16_t	dir;
	/* Subtype of the resource type. */
	uint16_t	subtype;
	/* Number of the type of resources. */
	uint16_t	cnt;
} tfc_global_id_hwrm_req_t, *ptfc_global_id_hwrm_req_t;

/* The reserved resources for the global id. */
/* tfc_global_id_hwrm_rsp (size:64b/8B) */

typedef struct tfc_global_id_hwrm_rsp {
	/* Type of the resource, defined in enum cfa_resource_type HCAPI RM. */
	uint16_t	rtype;
	/* Indicates the flow direction in type of cfa_dir. */
	uint16_t	dir;
	/* Subtype of the resource type. */
	uint16_t	subtype;
	/* The global id that the resources reserved for. */
	uint16_t	id;
} tfc_global_id_hwrm_rsp_t, *ptfc_global_id_hwrm_rsp_t;

/****************************
 * hwrm_tfc_global_id_alloc *
 ****************************/


/* hwrm_tfc_global_id_alloc_input (size:320b/40B) */

typedef struct hwrm_tfc_global_id_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint16_t	sid;
	/* Global domain id. */
	uint16_t	global_id;
	/*
	 * Defines the array size of the provided req_addr and
	 * resv_addr array buffers. Should be set to the number of
	 * request entries.
	 */
	uint16_t	req_cnt;
	/*
	 * This is the DMA address for the request input data array
	 * buffer. Array is of tfc_global_id_hwrm_req type. Size of the
	 * array buffer is provided by the 'req_cnt' field in this
	 * message.
	 */
	uint64_t	req_addr;
	/*
	 * This is the DMA address for the resc output data array
	 * buffer. Array is of tfc_global_id_hwrm_rsp type. Size of the array
	 * buffer is provided by the 'req_cnt' field in this
	 * message.
	 */
	uint64_t	resc_addr;
} hwrm_tfc_global_id_alloc_input_t, *phwrm_tfc_global_id_alloc_input_t;

/* hwrm_tfc_global_id_alloc_output (size:128b/16B) */

typedef struct hwrm_tfc_global_id_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Size of the returned hwrm_tfc_global_id_req data array. The value
	 * cannot exceed the req_cnt defined by the input msg. The data
	 * array is returned using the resv_addr specified DMA
	 * address also provided by the input msg.
	 */
	uint16_t	rsp_cnt;
	/* Non-zero if this is the first allocation for the global ID. */
	uint8_t	first;
	/* unused. */
	uint8_t	unused0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_global_id_alloc_output_t, *phwrm_tfc_global_id_alloc_output_t;

/*********************
 * hwrm_tfc_tcam_set *
 *********************/


/* hwrm_tfc_tcam_set_input (size:1088b/136B) */

typedef struct hwrm_tfc_tcam_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/* Logical TCAM ID. */
	uint16_t	tcam_id;
	/* Number of bytes in the TCAM key. */
	uint16_t	key_size;
	/* Number of bytes in the TCAM result. */
	uint16_t	result_size;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR_LAST HWRM_TFC_TCAM_SET_INPUT_FLAGS_DIR_TX
	/* Indicate device data is being sent via DMA. */
	#define HWRM_TFC_TCAM_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/*
	 * Subtype of TCAM resource. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* unused. */
	uint8_t	unused0[4];
	/* The location of the response dma buffer */
	uint64_t	dma_addr;
	/*
	 * TCAM key located at offset 0, mask located at mask_offset
	 * and result at result_offset for the device.
	 */
	uint8_t	dev_data[96];
} hwrm_tfc_tcam_set_input_t, *phwrm_tfc_tcam_set_input_t;

/* hwrm_tfc_tcam_set_output (size:128b/16B) */

typedef struct hwrm_tfc_tcam_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written. When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tcam_set_output_t, *phwrm_tfc_tcam_set_output_t;

/*********************
 * hwrm_tfc_tcam_get *
 *********************/


/* hwrm_tfc_tcam_get_input (size:192b/24B) */

typedef struct hwrm_tfc_tcam_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR_LAST HWRM_TFC_TCAM_GET_INPUT_FLAGS_DIR_TX
	/*
	 * Subtype of TCAM resource See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/* Logical TCAM ID. */
	uint16_t	tcam_id;
} hwrm_tfc_tcam_get_input_t, *phwrm_tfc_tcam_get_input_t;

/* hwrm_tfc_tcam_get_output (size:2368b/296B) */

typedef struct hwrm_tfc_tcam_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of bytes in the TCAM key. */
	uint16_t	key_size;
	/* Number of bytes in the TCAM result. */
	uint16_t	result_size;
	/* unused. */
	uint8_t	unused0[4];
	/*
	 * TCAM key located at offset 0, mask located at key_size
	 * and result at 2 * key_size for the device.
	 */
	uint8_t	dev_data[272];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written. When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tcam_get_output_t, *phwrm_tfc_tcam_get_output_t;

/***********************
 * hwrm_tfc_tcam_alloc *
 ***********************/


/* hwrm_tfc_tcam_alloc_input (size:256b/32B) */

typedef struct hwrm_tfc_tcam_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR_LAST HWRM_TFC_TCAM_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * Subtype of TCAM resource. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Unique session id for the session created by the
	 * firmware. Will be used to track this index table entry
	 * only if track type is track_type_sid.
	 */
	uint16_t	sid;
	/* Number of bytes in the TCAM key. */
	uint16_t	key_size;
	/* Entry priority. */
	uint16_t	priority;
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_SID	UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID	UINT32_C(0x2)
	#define HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_LAST		HWRM_TFC_TCAM_ALLOC_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Unused. */
	uint8_t	unused0[5];
} hwrm_tfc_tcam_alloc_input_t, *phwrm_tfc_tcam_alloc_input_t;

/* hwrm_tfc_tcam_alloc_output (size:128b/16B) */

typedef struct hwrm_tfc_tcam_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Index table entry allocated by the firmware using the
	 * parameters above.
	 */
	uint16_t	idx;
	/* Reserved */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tcam_alloc_output_t, *phwrm_tfc_tcam_alloc_output_t;

/***************************
 * hwrm_tfc_tcam_alloc_set *
 ***************************/


/* hwrm_tfc_tcam_alloc_set_input (size:1088b/136B) */

typedef struct hwrm_tfc_tcam_alloc_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR_LAST HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DIR_TX
	/* Indicate device data is being sent via DMA. */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/*
	 * Subtype of TCAM resource. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Unique session id for the session created by the
	 * firmware. Will be used to track this index table entry
	 * only if track type is track_type_sid.
	 */
	uint16_t	sid;
	/* Number of bytes in the TCAM key. */
	uint16_t	key_size;
	/* The size of the TCAM table entry in bytes. */
	uint16_t	result_size;
	/* Entry priority. */
	uint16_t	priority;
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_SID	UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_FID	UINT32_C(0x2)
	#define HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_LAST		HWRM_TFC_TCAM_ALLOC_SET_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Unused */
	uint8_t	unused[3];
	/* The location of the response dma buffer */
	uint64_t	dma_addr;
	/*
	 * Index table data located at offset 0. If dma bit is set,
	 * then this field contains the DMA buffer pointer.
	 */
	uint8_t	dev_data[96];
} hwrm_tfc_tcam_alloc_set_input_t, *phwrm_tfc_tcam_alloc_set_input_t;

/* hwrm_tfc_tcam_alloc_set_output (size:128b/16B) */

typedef struct hwrm_tfc_tcam_alloc_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Logical TCAM ID. */
	uint16_t	tcam_id;
	/* Reserved */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tcam_alloc_set_output_t, *phwrm_tfc_tcam_alloc_set_output_t;

/**********************
 * hwrm_tfc_tcam_free *
 **********************/


/* hwrm_tfc_tcam_free_input (size:192b/24B) */

typedef struct hwrm_tfc_tcam_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR_LAST HWRM_TFC_TCAM_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * Subtype of TCAM resource. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/*
	 * Function ID.
	 * If running on a trusted VF or PF, the fid field can be used to
	 * specify that the function is a non-trusted VF of the parent PF.
	 * If this command is used for the target_id itself, this field is
	 * set to 0xffff. A non-trusted VF cannot specify a valid FID in this
	 * field.
	 */
	uint16_t	fid;
	/*
	 * Session id associated with the firmware. Will be used
	 * for validation if the track type matches.
	 */
	uint16_t	sid;
	/* Logical TCAM ID. */
	uint16_t	tcam_id;
} hwrm_tfc_tcam_free_input_t, *phwrm_tfc_tcam_free_input_t;

/* hwrm_tfc_tcam_free_output (size:128b/16B) */

typedef struct hwrm_tfc_tcam_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tcam_free_output_t, *phwrm_tfc_tcam_free_output_t;

/***********************
 * hwrm_tfc_if_tbl_set *
 ***********************/


/* hwrm_tfc_if_tbl_set_input (size:960b/120B) */

typedef struct hwrm_tfc_if_tbl_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session identifier. */
	uint16_t	sid;
	/* Function identifier. */
	uint16_t	fid;
	/*
	 * Subtype identifying IF table type. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IF_TBL_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IF_TBL_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IF_TBL_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IF_TBL_SET_INPUT_FLAGS_DIR_LAST HWRM_TFC_IF_TBL_SET_INPUT_FLAGS_DIR_TX
	/* Table entry index. */
	uint16_t	index;
	/* Size of data in data field. */
	uint8_t	data_size;
	/* Reserved */
	uint8_t	unused0[7];
	/* Table data. */
	uint8_t	data[88];
} hwrm_tfc_if_tbl_set_input_t, *phwrm_tfc_if_tbl_set_input_t;

/* hwrm_tfc_if_tbl_set_output (size:128b/16B) */

typedef struct hwrm_tfc_if_tbl_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_if_tbl_set_output_t, *phwrm_tfc_if_tbl_set_output_t;

/***********************
 * hwrm_tfc_if_tbl_get *
 ***********************/


/* hwrm_tfc_if_tbl_get_input (size:256b/32B) */

typedef struct hwrm_tfc_if_tbl_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session identifier. */
	uint16_t	sid;
	/* Function identifier. */
	uint16_t	fid;
	/*
	 * Subtype identifying IF table type. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IF_TBL_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IF_TBL_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IF_TBL_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IF_TBL_GET_INPUT_FLAGS_DIR_LAST HWRM_TFC_IF_TBL_GET_INPUT_FLAGS_DIR_TX
	/* Table entry index. */
	uint16_t	index;
	/* Size of data in data field. */
	uint8_t	data_size;
	/* Reserved */
	uint8_t	unused0[7];
} hwrm_tfc_if_tbl_get_input_t, *phwrm_tfc_if_tbl_get_input_t;

/* hwrm_tfc_if_tbl_get_output (size:960b/120B) */

typedef struct hwrm_tfc_if_tbl_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Session identifier. */
	uint16_t	sid;
	/* Function identifier. */
	uint16_t	fid;
	/*
	 * Subtype identifying IF table type. See
	 * cfa_v3/include/cfa_resources.h.
	 */
	uint8_t	subtype;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_IF_TBL_GET_OUTPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_IF_TBL_GET_OUTPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_IF_TBL_GET_OUTPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_IF_TBL_GET_OUTPUT_FLAGS_DIR_LAST HWRM_TFC_IF_TBL_GET_OUTPUT_FLAGS_DIR_TX
	/* Table entry index. */
	uint16_t	index;
	/* Size of data in data field. */
	uint8_t	data_size;
	/* Reserved */
	uint8_t	unused0[7];
	/* Table data. */
	uint8_t	data[88];
	/* Reserved */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_if_tbl_get_output_t, *phwrm_tfc_if_tbl_get_output_t;

/*********************************
 * hwrm_tfc_tbl_scope_config_get *
 *********************************/


/* TruFlow command to return whether the table scope is fully configured. */
/* hwrm_tfc_tbl_scope_config_get_input (size:192b/24B) */

typedef struct hwrm_tfc_tbl_scope_config_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The table scope ID. */
	uint8_t	tsid;
	/* unused. */
	uint8_t	unused0[7];
} hwrm_tfc_tbl_scope_config_get_input_t, *phwrm_tfc_tbl_scope_config_get_input_t;

/* hwrm_tfc_tbl_scope_config_get_output (size:128b/16B) */

typedef struct hwrm_tfc_tbl_scope_config_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* If set to 1, the table scope is configured. */
	uint8_t	configured;
	/* unused. */
	uint8_t	unused0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_tbl_scope_config_get_output_t, *phwrm_tfc_tbl_scope_config_get_output_t;

/*****************************
 * hwrm_tfc_resc_usage_query *
 *****************************/


/* hwrm_tfc_resc_usage_query_input (size:256b/32B) */

typedef struct hwrm_tfc_resc_usage_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session identifier. */
	uint16_t	sid;
	/* Function identifier. */
	uint16_t	fid;
	/* Control flags. */
	uint8_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TFC_RESC_USAGE_QUERY_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TFC_RESC_USAGE_QUERY_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TFC_RESC_USAGE_QUERY_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TFC_RESC_USAGE_QUERY_INPUT_FLAGS_DIR_LAST HWRM_TFC_RESC_USAGE_QUERY_INPUT_FLAGS_DIR_TX
	/* Describes the type of tracking id to be used */
	uint8_t	track_type;
	/* Invalid track type */
	#define HWRM_TFC_RESC_USAGE_QUERY_INPUT_TRACK_TYPE_TRACK_TYPE_INVALID UINT32_C(0x0)
	/* Tracked by session id */
	#define HWRM_TFC_RESC_USAGE_QUERY_INPUT_TRACK_TYPE_TRACK_TYPE_SID	UINT32_C(0x1)
	/* Tracked by function id */
	#define HWRM_TFC_RESC_USAGE_QUERY_INPUT_TRACK_TYPE_TRACK_TYPE_FID	UINT32_C(0x2)
	#define HWRM_TFC_RESC_USAGE_QUERY_INPUT_TRACK_TYPE_LAST		HWRM_TFC_RESC_USAGE_QUERY_INPUT_TRACK_TYPE_TRACK_TYPE_FID
	/* Size of data in data field. */
	uint16_t	data_size;
	/* unused */
	uint8_t	unused1[8];
} hwrm_tfc_resc_usage_query_input_t, *phwrm_tfc_resc_usage_query_input_t;

/* hwrm_tfc_resc_usage_query_output (size:960b/120B) */

typedef struct hwrm_tfc_resc_usage_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Size of data in data field. */
	uint16_t	data_size;
	/* unused */
	uint16_t	unused0;
	/* Response data. */
	uint8_t	data[96];
	/* unused */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tfc_resc_usage_query_output_t, *phwrm_tfc_resc_usage_query_output_t;

/******************************
 * hwrm_tunnel_dst_port_query *
 ******************************/


/* hwrm_tunnel_dst_port_query_input (size:192b/24B) */

typedef struct hwrm_tunnel_dst_port_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN		UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_GENEVE		UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6	UINT32_C(0xc)
	/* Custom GRE uses UPAR to parse customized GRE packets */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_CUSTOM_GRE	UINT32_C(0xd)
	/* Enhanced Common Packet Radio Interface (eCPRI) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ECPRI		UINT32_C(0xe)
	/* IPv6 Segment Routing (SRv6) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_SRV6		UINT32_C(0xf)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Generic Routing Encapsulation */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_GRE		UINT32_C(0x11)
	/* ULP Dynamic UPAR tunnel */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR	UINT32_C(0x12)
	/* ULP Dynamic UPAR tunnel reserved 1 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES01 UINT32_C(0x13)
	/* ULP Dynamic UPAR tunnel reserved 2 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES02 UINT32_C(0x14)
	/* ULP Dynamic UPAR tunnel reserved 3 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES03 UINT32_C(0x15)
	/* ULP Dynamic UPAR tunnel reserved 4 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES04 UINT32_C(0x16)
	/* ULP Dynamic UPAR tunnel reserved 5 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES05 UINT32_C(0x17)
	/* ULP Dynamic UPAR tunnel reserved 6 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES06 UINT32_C(0x18)
	/* ULP Dynamic UPAR tunnel reserved 7 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES07 UINT32_C(0x19)
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_LAST		HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES07
	/*
	 * This field is used to specify the next protocol value defined in the
	 * corresponding RFC spec for the applicable tunnel type.
	 */
	uint8_t	tunnel_next_proto;
	uint8_t	unused_0[6];
} hwrm_tunnel_dst_port_query_input_t, *phwrm_tunnel_dst_port_query_input_t;

/* hwrm_tunnel_dst_port_query_output (size:128b/16B) */

typedef struct hwrm_tunnel_dst_port_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the identifier of L4 destination port
	 * used for the given tunnel type. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 */
	uint16_t	tunnel_dst_port_id;
	/*
	 * This field represents the value of L4 destination port
	 * identified by tunnel_dst_port_id. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 * This field is in network byte order.
	 *
	 * A value of 0 means that the destination port is not
	 * configured.
	 */
	uint16_t	tunnel_dst_port_val;
	/*
	 * This field represents the UPAR usage status.
	 * Available UPARs on wh+ are UPAR0 and UPAR1
	 * Available UPARs on Thor are UPAR0 to UPAR3
	 * Available UPARs on Thor2 are UPAR0 to UPAR7
	 */
	uint8_t	upar_in_use;
	/* This bit will be '1' when UPAR0 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR0	UINT32_C(0x1)
	/* This bit will be '1' when UPAR1 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR1	UINT32_C(0x2)
	/* This bit will be '1' when UPAR2 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR2	UINT32_C(0x4)
	/* This bit will be '1' when UPAR3 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR3	UINT32_C(0x8)
	/* This bit will be '1' when UPAR4 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR4	UINT32_C(0x10)
	/* This bit will be '1' when UPAR5 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR5	UINT32_C(0x20)
	/* This bit will be '1' when UPAR6 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR6	UINT32_C(0x40)
	/* This bit will be '1' when UPAR7 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_UPAR_IN_USE_UPAR7	UINT32_C(0x80)
	/*
	 * This field is used to convey the status of non udp port based
	 * tunnel parsing at chip level and at function level.
	 */
	uint8_t	status;
	/* This bit will be '1' when tunnel parsing is enabled globally. */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_STATUS_CHIP_LEVEL	UINT32_C(0x1)
	/*
	 * This bit will be '1' when tunnel parsing is enabled
	 * on the corresponding function.
	 */
	#define HWRM_TUNNEL_DST_PORT_QUERY_OUTPUT_STATUS_FUNC_LEVEL	UINT32_C(0x2)
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tunnel_dst_port_query_output_t, *phwrm_tunnel_dst_port_query_output_t;

/******************************
 * hwrm_tunnel_dst_port_alloc *
 ******************************/


/* hwrm_tunnel_dst_port_alloc_input (size:192b/24B) */

typedef struct hwrm_tunnel_dst_port_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN		UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_GENEVE		UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6	UINT32_C(0xc)
	/*
	 * Custom GRE uses UPAR to parse customized GRE packets. This is not
	 * supported.
	 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_CUSTOM_GRE	UINT32_C(0xd)
	/* Enhanced Common Packet Radio Interface (eCPRI) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ECPRI		UINT32_C(0xe)
	/* IPv6 Segment Routing (SRv6) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_SRV6		UINT32_C(0xf)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Generic Routing Encapsulation */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_GRE		UINT32_C(0x11)
	/* ULP Dynamic UPAR tunnel */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR	UINT32_C(0x12)
	/* ULP Dynamic UPAR tunnel reserved 1 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES01 UINT32_C(0x13)
	/* ULP Dynamic UPAR tunnel reserved 2 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES02 UINT32_C(0x14)
	/* ULP Dynamic UPAR tunnel reserved 3 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES03 UINT32_C(0x15)
	/* ULP Dynamic UPAR tunnel reserved 4 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES04 UINT32_C(0x16)
	/* ULP Dynamic UPAR tunnel reserved 5 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES05 UINT32_C(0x17)
	/* ULP Dynamic UPAR tunnel reserved 6 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES06 UINT32_C(0x18)
	/* ULP Dynamic UPAR tunnel reserved 7 */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES07 UINT32_C(0x19)
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_LAST		HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES07
	/*
	 * This field is used to specify the next protocol value defined in the
	 * corresponding RFC spec for the applicable tunnel type.
	 */
	uint8_t	tunnel_next_proto;
	/*
	 * This field represents the value of L4 destination port used
	 * for the given tunnel type. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 *
	 * This field is in network byte order.
	 *
	 * A value of 0 shall fail the command.
	 */
	uint16_t	tunnel_dst_port_val;
	uint8_t	unused_0[4];
} hwrm_tunnel_dst_port_alloc_input_t, *phwrm_tunnel_dst_port_alloc_input_t;

/* hwrm_tunnel_dst_port_alloc_output (size:128b/16B) */

typedef struct hwrm_tunnel_dst_port_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Identifier of a tunnel L4 destination port value. Only applies to
	 * tunnel types that has l4 destination port parameters.
	 */
	uint16_t	tunnel_dst_port_id;
	/* Error information */
	uint8_t	error_info;
	/* No error */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_SUCCESS	UINT32_C(0x0)
	/* Tunnel port is already allocated */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_ERR_ALLOCATED   UINT32_C(0x1)
	/* Out of resources error */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_ERR_NO_RESOURCE UINT32_C(0x2)
	/* Tunnel type is already enabled */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_ERR_ENABLED	UINT32_C(0x3)
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_LAST	HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_ERROR_INFO_ERR_ENABLED
	/*
	 * This field represents the UPAR usage status.
	 * Available UPARs on wh+ are UPAR0 and UPAR1
	 * Available UPARs on Thor are UPAR0 to UPAR3
	 * Available UPARs on Thor2 are UPAR0 to UPAR7
	 */
	uint8_t	upar_in_use;
	/* This bit will be '1' when UPAR0 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR0	UINT32_C(0x1)
	/* This bit will be '1' when UPAR1 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR1	UINT32_C(0x2)
	/* This bit will be '1' when UPAR2 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR2	UINT32_C(0x4)
	/* This bit will be '1' when UPAR3 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR3	UINT32_C(0x8)
	/* This bit will be '1' when UPAR4 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR4	UINT32_C(0x10)
	/* This bit will be '1' when UPAR5 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR5	UINT32_C(0x20)
	/* This bit will be '1' when UPAR6 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR6	UINT32_C(0x40)
	/* This bit will be '1' when UPAR7 is IN_USE */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_OUTPUT_UPAR_IN_USE_UPAR7	UINT32_C(0x80)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tunnel_dst_port_alloc_output_t, *phwrm_tunnel_dst_port_alloc_output_t;

/*****************************
 * hwrm_tunnel_dst_port_free *
 *****************************/


/* hwrm_tunnel_dst_port_free_input (size:192b/24B) */

typedef struct hwrm_tunnel_dst_port_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN		UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_GENEVE		UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6	UINT32_C(0xc)
	/*
	 * Custom GRE uses UPAR to parse customized GRE packets. This is not
	 * supported.
	 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_CUSTOM_GRE	UINT32_C(0xd)
	/* Enhanced Common Packet Radio Interface (eCPRI) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ECPRI		UINT32_C(0xe)
	/* IPv6 Segment Routing (SRv6) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_SRV6		UINT32_C(0xf)
	/* Generic Protocol Extension for VXLAN (VXLAN-GPE) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE	UINT32_C(0x10)
	/* Generic Routing Encapsulation */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_GRE		UINT32_C(0x11)
	/* ULP Dynamic UPAR tunnel */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR	UINT32_C(0x12)
	/* ULP Dynamic UPAR tunnel reserved 1 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES01 UINT32_C(0x13)
	/* ULP Dynamic UPAR tunnel reserved 2 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES02 UINT32_C(0x14)
	/* ULP Dynamic UPAR tunnel reserved 3 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES03 UINT32_C(0x15)
	/* ULP Dynamic UPAR tunnel reserved 4 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES04 UINT32_C(0x16)
	/* ULP Dynamic UPAR tunnel reserved 5 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES05 UINT32_C(0x17)
	/* ULP Dynamic UPAR tunnel reserved 6 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES06 UINT32_C(0x18)
	/* ULP Dynamic UPAR tunnel reserved 7 */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES07 UINT32_C(0x19)
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_LAST		HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_ULP_DYN_UPAR_RES07
	/*
	 * This field is used to specify the next protocol value defined in the
	 * corresponding RFC spec for the applicable tunnel type.
	 */
	uint8_t	tunnel_next_proto;
	/*
	 * Identifier of a tunnel L4 destination port value. Only applies to
	 * tunnel types that has l4 destination port parameters.
	 */
	uint16_t	tunnel_dst_port_id;
	uint8_t	unused_0[4];
} hwrm_tunnel_dst_port_free_input_t, *phwrm_tunnel_dst_port_free_input_t;

/* hwrm_tunnel_dst_port_free_output (size:128b/16B) */

typedef struct hwrm_tunnel_dst_port_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Error information */
	uint8_t	error_info;
	/* No error */
	#define HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_SUCCESS	UINT32_C(0x0)
	/* Not owner error */
	#define HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_ERR_NOT_OWNER	UINT32_C(0x1)
	/* Not allocated error */
	#define HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_ERR_NOT_ALLOCATED UINT32_C(0x2)
	#define HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_LAST		HWRM_TUNNEL_DST_PORT_FREE_OUTPUT_ERROR_INFO_ERR_NOT_ALLOCATED
	uint8_t	unused_1[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tunnel_dst_port_free_output_t, *phwrm_tunnel_dst_port_free_output_t;

/* Periodic statistics context DMA to host. */
/* ctx_hw_stats (size:1280b/160B) */

typedef struct ctx_hw_stats {
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA packets */
	uint64_t	tpa_pkts;
	/* Number of TPA bytes */
	uint64_t	tpa_bytes;
	/* Number of TPA events */
	uint64_t	tpa_events;
	/* Number of TPA aborts */
	uint64_t	tpa_aborts;
} ctx_hw_stats_t, *pctx_hw_stats_t;

/*
 * Extended periodic statistics context DMA to host. On cards that
 * support TPA v2, additional TPA related stats exist and can be retrieved
 * by DMA of ctx_hw_stats_ext, rather than legacy ctx_hw_stats structure.
 */
/* ctx_hw_stats_ext (size:1408b/176B) */

typedef struct ctx_hw_stats_ext {
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA events */
	uint64_t	rx_tpa_events;
} ctx_hw_stats_ext_t, *pctx_hw_stats_ext_t;

/* Periodic Engine statistics context DMA to host. */
/* ctx_eng_stats (size:512b/64B) */

typedef struct ctx_eng_stats {
	/*
	 * Count of data bytes into the Engine.
	 * This includes any user supplied prefix,
	 * but does not include any predefined
	 * prefix data.
	 */
	uint64_t	eng_bytes_in;
	/* Count of data bytes out of the Engine. */
	uint64_t	eng_bytes_out;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are input as auxiliary data.
	 * This includes the aux_cmd data.
	 */
	uint64_t	aux_bytes_in;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are output as auxiliary data.
	 * This count is the buffer space for aux_data
	 * output provided in the RQE, not the actual
	 * aux_data written
	 */
	uint64_t	aux_bytes_out;
	/* Count of number of commands executed. */
	uint64_t	commands;
	/*
	 * Count of number of error commands.
	 * These are the commands with a
	 * non-zero status value.
	 */
	uint64_t	error_commands;
	/*
	 * Compression/Encryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cce_engine_usage;
	/*
	 * De-Compression/De-cryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cdd_engine_usage;
} ctx_eng_stats_t, *pctx_eng_stats_t;

/***********************
 * hwrm_stat_ctx_alloc *
 ***********************/


/* hwrm_stat_ctx_alloc_input (size:384b/48B) */

typedef struct hwrm_stat_ctx_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the address for statistic block.
	 * > For new versions of the chip, this address should be 128B
	 * > aligned.
	 */
	uint64_t	stats_dma_addr;
	/*
	 * The statistic block update period in ms.
	 * e.g. 250ms, 500ms, 750ms, 1000ms.
	 * If update_period_ms is 0, then the stats update
	 * shall be never done and the DMA address shall not be used.
	 * In this case, the stat block can only be read by
	 * hwrm_stat_ctx_query command.
	 * On Ethernet/L2 based devices:
	 *   if tpa v2 supported (hwrm_vnic_qcaps[max_aggs_supported]>0),
	 *	ctx_hw_stats_ext is used for DMA,
	 *   else
	 *	ctx_hw_stats is used for DMA.
	 */
	uint32_t	update_period_ms;
	/*
	 * This field is used to specify statistics context specific
	 * configuration flags.
	 */
	uint8_t	stat_ctx_flags;
	/*
	 * When this bit is set to '1', the statistics context shall be
	 * allocated for RoCE traffic only. In this case, traffic other
	 * than offloaded RoCE traffic shall not be included in this
	 * statistic context.
	 * When this bit is set to '0', the statistics context shall be
	 * used for network traffic or engine traffic.
	 */
	#define HWRM_STAT_CTX_ALLOC_INPUT_STAT_CTX_FLAGS_ROCE		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', the PF is requesting a duplicate
	 * host buffer used for VF statistics. The stat_ctx_id and
	 * alloc_seq_id fields must be populated when this bit is set to
	 * '1'. The stat_ctx_id indicates the VF statistics context that
	 * should be copied to this host buffer. The stat_ctx_id and
	 * alloc_seq_id should be copied from the vf_stat_change event
	 * received by the PF. This bit can only be set for a PF. An error
	 * is returned if a VF sets this bit. This bit is only supported if
	 * vf_stat_ejection_supported is '1' in func_qcaps.
	 */
	#define HWRM_STAT_CTX_ALLOC_INPUT_STAT_CTX_FLAGS_DUP_HOST_BUF	UINT32_C(0x2)
	uint8_t	unused_0;
	/*
	 * This is the size of the structure (ctx_hw_stats or
	 * ctx_hw_stats_ext) that the driver has allocated to be used
	 * for the periodic DMA updates.
	 */
	uint16_t	stats_dma_length;
	uint16_t	flags;
	/* This stats context uses the steering tag specified in the command. */
	#define HWRM_STAT_CTX_ALLOC_INPUT_FLAGS_STEERING_TAG_VALID	UINT32_C(0x1)
	/*
	 * Steering tag to use for memory transactions from the periodic DMA
	 * updates. 'steering_tag_valid' should be set and 'steering_tag'
	 * should be specified, when the 'steering_tag_supported' bit is set
	 * under the 'flags_ext2' field of the hwrm_func_qcaps_output.
	 */
	uint16_t	steering_tag;
	/*
	 * Only valid when dup_host_buf is '1'. This value should be copied
	 * from the vf_stat_change event.
	 */
	uint32_t	stat_ctx_id;
	/*
	 * Only valid when dup_host_buf is '1'. This value should be copied
	 * from the vf_stat_change event.
	 */
	uint16_t	alloc_seq_id;
	uint8_t	unused_1[6];
} hwrm_stat_ctx_alloc_input_t, *phwrm_stat_ctx_alloc_input_t;

/* hwrm_stat_ctx_alloc_output (size:128b/16B) */

typedef struct hwrm_stat_ctx_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This is the statistics context ID value. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_alloc_output_t, *phwrm_stat_ctx_alloc_output_t;

/**********************
 * hwrm_stat_ctx_free *
 **********************/


/* hwrm_stat_ctx_free_input (size:192b/24B) */

typedef struct hwrm_stat_ctx_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} hwrm_stat_ctx_free_input_t, *phwrm_stat_ctx_free_input_t;

/* hwrm_stat_ctx_free_output (size:128b/16B) */

typedef struct hwrm_stat_ctx_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This is the statistics context ID value. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_free_output_t, *phwrm_stat_ctx_free_output_t;

/***********************
 * hwrm_stat_ctx_query *
 ***********************/


/* hwrm_stat_ctx_query_input (size:192b/24B) */

typedef struct hwrm_stat_ctx_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_STAT_CTX_QUERY_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0[3];
} hwrm_stat_ctx_query_input_t, *phwrm_stat_ctx_query_input_t;

/* hwrm_stat_ctx_query_output (size:1408b/176B) */

typedef struct hwrm_stat_ctx_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets discarded in transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of packets in transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of packets discarded in receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets in receive path with errors */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of aggregated unicast packets */
	uint64_t	rx_agg_pkts;
	/* Number of aggregated unicast bytes */
	uint64_t	rx_agg_bytes;
	/* Number of aggregation events */
	uint64_t	rx_agg_events;
	/* Number of aborted aggregations */
	uint64_t	rx_agg_aborts;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_query_output_t, *phwrm_stat_ctx_query_output_t;

/***************************
 * hwrm_stat_ext_ctx_query *
 ***************************/


/* hwrm_stat_ext_ctx_query_input (size:192b/24B) */

typedef struct hwrm_stat_ext_ctx_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the extended statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_STAT_EXT_CTX_QUERY_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0[3];
} hwrm_stat_ext_ctx_query_input_t, *phwrm_stat_ext_ctx_query_input_t;

/* hwrm_stat_ext_ctx_query_output (size:1536b/192B) */

typedef struct hwrm_stat_ext_ctx_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA events */
	uint64_t	rx_tpa_events;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ext_ctx_query_output_t, *phwrm_stat_ext_ctx_query_output_t;

/***************************
 * hwrm_stat_ctx_eng_query *
 ***************************/


/* hwrm_stat_ctx_eng_query_input (size:192b/24B) */

typedef struct hwrm_stat_ctx_eng_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} hwrm_stat_ctx_eng_query_input_t, *phwrm_stat_ctx_eng_query_input_t;

/* hwrm_stat_ctx_eng_query_output (size:640b/80B) */

typedef struct hwrm_stat_ctx_eng_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Count of data bytes into the Engine.
	 * This includes any user supplied prefix,
	 * but does not include any predefined
	 * prefix data.
	 */
	uint64_t	eng_bytes_in;
	/* Count of data bytes out of the Engine. */
	uint64_t	eng_bytes_out;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are input as auxiliary data.
	 * This includes the aux_cmd data.
	 */
	uint64_t	aux_bytes_in;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are output as auxiliary data.
	 * This count is the buffer space for aux_data
	 * output provided in the RQE, not the actual
	 * aux_data written
	 */
	uint64_t	aux_bytes_out;
	/* Count of number of commands executed. */
	uint64_t	commands;
	/*
	 * Count of number of error commands.
	 * These are the commands with a
	 * non-zero status value.
	 */
	uint64_t	error_commands;
	/*
	 * Compression/Encryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cce_engine_usage;
	/*
	 * De-Compression/De-cryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cdd_engine_usage;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_eng_query_output_t, *phwrm_stat_ctx_eng_query_output_t;

/***************************
 * hwrm_stat_ctx_clr_stats *
 ***************************/


/* hwrm_stat_ctx_clr_stats_input (size:192b/24B) */

typedef struct hwrm_stat_ctx_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} hwrm_stat_ctx_clr_stats_input_t, *phwrm_stat_ctx_clr_stats_input_t;

/* hwrm_stat_ctx_clr_stats_output (size:128b/16B) */

typedef struct hwrm_stat_ctx_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_clr_stats_output_t, *phwrm_stat_ctx_clr_stats_output_t;

/********************
 * hwrm_pcie_qstats *
 ********************/


/* hwrm_pcie_qstats_input (size:256b/32B) */

typedef struct hwrm_pcie_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The size of PCIe statistics block in bytes.
	 * Firmware will DMA the PCIe statistics to
	 * the host with this field size in the response.
	 */
	uint16_t	pcie_stat_size;
	uint8_t	unused_0[6];
	/*
	 * This is the host address where
	 * PCIe statistics will be stored
	 */
	uint64_t	pcie_stat_host_addr;
} hwrm_pcie_qstats_input_t, *phwrm_pcie_qstats_input_t;

/* hwrm_pcie_qstats_output (size:128b/16B) */

typedef struct hwrm_pcie_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of PCIe statistics block in bytes. */
	uint16_t	pcie_stat_size;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_pcie_qstats_output_t, *phwrm_pcie_qstats_output_t;

/* PCIe Statistics Formats */
/* pcie_ctx_hw_stats (size:768b/96B) */

typedef struct pcie_ctx_hw_stats {
	/* Number of physical layer receiver errors */
	uint64_t	pcie_pl_signal_integrity;
	/* Number of DLLP CRC errors detected by Data Link Layer */
	uint64_t	pcie_dl_signal_integrity;
	/*
	 * Number of TLP LCRC and sequence number errors detected
	 * by Data Link Layer
	 */
	uint64_t	pcie_tl_signal_integrity;
	/* Number of times LTSSM entered Recovery state */
	uint64_t	pcie_link_integrity;
	/* Report number of TLP bits that have been transmitted in Mbps */
	uint64_t	pcie_tx_traffic_rate;
	/* Report number of TLP bits that have been received in Mbps */
	uint64_t	pcie_rx_traffic_rate;
	/* Number of DLLP bytes that have been transmitted */
	uint64_t	pcie_tx_dllp_statistics;
	/* Number of DLLP bytes that have been received */
	uint64_t	pcie_rx_dllp_statistics;
	/*
	 * Number of times spent in each phase of gen3
	 * equalization
	 */
	uint64_t	pcie_equalization_time;
	/* Records the last 16 transitions of the LTSSM */
	uint32_t	pcie_ltssm_histogram[4];
	/*
	 * Record the last 8 reasons on why LTSSM transitioned
	 * to Recovery
	 */
	uint64_t	pcie_recovery_histogram;
} pcie_ctx_hw_stats_t, *ppcie_ctx_hw_stats_t;

/****************************
 * hwrm_stat_generic_qstats *
 ****************************/


/* hwrm_stat_generic_qstats_input (size:256b/32B) */

typedef struct hwrm_stat_generic_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The size of the generic statistics buffer passed in the
	 * generic_stat_host_addr in bytes.
	 * Firmware will not exceed this size when it DMAs the
	 * statistics structure to the host. The actual DMA size
	 * will be returned in the response.
	 */
	uint16_t	generic_stat_size;
	uint8_t	flags;
	/*
	 * The bit should be set to 1 when request is for the counter mask
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_STAT_GENERIC_QSTATS_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0[5];
	/*
	 * This is the host address where
	 * generic statistics will be stored
	 */
	uint64_t	generic_stat_host_addr;
} hwrm_stat_generic_qstats_input_t, *phwrm_stat_generic_qstats_input_t;

/* hwrm_stat_generic_qstats_output (size:128b/16B) */

typedef struct hwrm_stat_generic_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of Generic Statistics block in bytes. */
	uint16_t	generic_stat_size;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_stat_generic_qstats_output_t, *phwrm_stat_generic_qstats_output_t;

/* Generic Statistic Format */
/* generic_sw_hw_stats (size:1472b/184B) */

typedef struct generic_sw_hw_stats {
	/*
	 * This is the number of TLP bytes that have been transmitted for
	 * the caller PF.
	 */
	uint64_t	pcie_statistics_tx_tlp;
	/*
	 * This is the number of TLP bytes that have been received
	 * for the caller PF.
	 */
	uint64_t	pcie_statistics_rx_tlp;
	/* Posted Header Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_hdr_posted;
	/* Non-posted Header Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_hdr_nonposted;
	/* Completion Header Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_hdr_cmpl;
	/* Posted Data Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_data_posted;
	/* Non-Posted Data Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_data_nonposted;
	/* Completion Data Flow Control credits available for the caller PF. */
	uint64_t	pcie_credit_fc_data_cmpl;
	/*
	 * Available Non-posted credit for target flow control reads or
	 * config for the caller PF.
	 */
	uint64_t	pcie_credit_fc_tgt_nonposted;
	/*
	 * Available posted data credit for target flow control writes
	 * for the caller PF.
	 */
	uint64_t	pcie_credit_fc_tgt_data_posted;
	/*
	 * Available posted header credit for target flow control writes
	 * for the caller PF.
	 */
	uint64_t	pcie_credit_fc_tgt_hdr_posted;
	/* Available completion flow control header credits for the caller PF. */
	uint64_t	pcie_credit_fc_cmpl_hdr_posted;
	/* Available completion flow control data credits. */
	uint64_t	pcie_credit_fc_cmpl_data_posted;
	/*
	 * Displays Time information of the longest completion time from any of
	 * the 4 tags for the caller PF. The unit of time recorded is in
	 * microseconds.
	 */
	uint64_t	pcie_cmpl_longest;
	/*
	 * Displays Time information of the shortest completion time from any
	 * of the 4 tags for the caller PF. The unit of time recorded is in
	 * microseconds.
	 */
	uint64_t	pcie_cmpl_shortest;
	/*
	 * This field contains the total number of CFCQ 'misses' observed for
	 * all the PF's.
	 */
	uint64_t	cache_miss_count_cfcq;
	/*
	 * This field contains the total number of CFCS 'misses' observed for
	 * all the PF's.
	 */
	uint64_t	cache_miss_count_cfcs;
	/*
	 * This field contains the total number of CFCC 'misses' observed for
	 * all the PF's.
	 */
	uint64_t	cache_miss_count_cfcc;
	/*
	 * This field contains the total number of CFCM 'misses' observed
	 * for all the PF's.
	 */
	uint64_t	cache_miss_count_cfcm;
	/*
	 * Total number of Doorbell messages dropped from the DB FIFO.
	 * This counter is only applicable for devices that support
	 * the hardware based doorbell drop recovery feature.
	 */
	uint64_t	hw_db_recov_dbs_dropped;
	/*
	 * Total number of doorbell drops serviced.
	 * This counter is only applicable for devices that support
	 * the hardware based doorbell drop recovery feature.
	 */
	uint64_t	hw_db_recov_drops_serviced;
	/*
	 * Total number of dropped doorbells recovered.
	 * This counter is only applicable for devices that support
	 * the hardware based doorbell drop recovery feature.
	 */
	uint64_t	hw_db_recov_dbs_recovered;
	/*
	 * Total number of out of order doorbell messages dropped.
	 * This counter is only applicable for devices that support
	 * the hardware based doorbell drop recovery feature.
	 */
	uint64_t	hw_db_recov_oo_drop_count;
} generic_sw_hw_stats_t, *pgeneric_sw_hw_stats_t;

/*****************************
 * hwrm_stat_db_error_qstats *
 *****************************/


/* hwrm_stat_db_error_qstats_input (size:128b/16B) */

typedef struct hwrm_stat_db_error_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_stat_db_error_qstats_input_t, *phwrm_stat_db_error_qstats_input_t;

/* hwrm_stat_db_error_qstats_output (size:320b/40B) */

typedef struct hwrm_stat_db_error_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Specifies count of doorbells dropped due to RoCE SQs or L2
	 * Tx Rings being in invalid state.
	 */
	uint32_t	tx_db_drop_invalid_qp_state;
	/*
	 * Specifies count of doorbells dropped due to RoCE RQs/SRQs or
	 * L2 Rx Rings being used in invalid state.
	 */
	uint32_t	rx_db_drop_invalid_rq_state;
	/*
	 * Specifies count of doorbells dropped for any doorbell type
	 * due to formatting errors such as illegal doorbell message
	 * type, index out of range etc.
	 */
	uint32_t	tx_db_drop_format_error;
	/*
	 * Specifies count of express mode doorbells dropped for any
	 * doorbell type due to error conditions such as DPI check,
	 * context load error etc.
	 */
	uint32_t	express_db_dropped_misc_error;
	/*
	 * Specifies count of express mode doorbells dropped due to
	 * RoCE SQ overflow.
	 */
	uint32_t	express_db_dropped_sq_overflow;
	/*
	 * Specifies count of express mode doorbells dropped due to
	 * RoCE RQ overflow.
	 */
	uint32_t	express_db_dropped_rq_overflow;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_stat_db_error_qstats_output_t, *phwrm_stat_db_error_qstats_output_t;

/*****************
 * hwrm_fw_reset *
 *****************/


/* hwrm_fw_reset_input (size:192b/24B) */

typedef struct hwrm_fw_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of embedded processor. */
	uint8_t	embedded_proc_type;
	/* Boot Processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_BOOT		UINT32_C(0x0)
	/* Management Processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_MGMT		UINT32_C(0x1)
	/* Network control processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_NETCTRL		UINT32_C(0x2)
	/* RoCE control processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_ROCE		UINT32_C(0x3)
	/*
	 * Host (in multi-host environment): This is only valid if requester
	 * is IPC. Reinit host hardware resources and PCIe.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_HOST		UINT32_C(0x4)
	/*
	 * AP processor complex (in multi-host environment).
	 * Use host_idx to control which core is reset.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_AP			UINT32_C(0x5)
	/* Reset all blocks of the chip (including all processors) */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_CHIP		UINT32_C(0x6)
	/*
	 * Host (in multi-host environment): This is only valid if requester
	 * is IPC. Reinit host hardware resources.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_HOST_RESOURCE_REINIT  UINT32_C(0x7)
	/*
	 * Activate firmware that has been programmed to NVM. The
	 * activation is done in an impactless manner as part of the scheme
	 * where hwrm_fw_state_backup precedes the call, and
	 * hwrm_fw_state_restore follows it. Before this call returns, FW
	 * status is set to a non-0x8000 value to disambiguate reset pending
	 * from reset complete. The reset process begins after this call
	 * returns to ensure this HWRM has completed before reset begins.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_IMPACTLESS_ACTIVATION UINT32_C(0x8)
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_LAST		HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_IMPACTLESS_ACTIVATION
	/* Type of self reset. */
	uint8_t	selfrst_status;
	/* No Self Reset */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTNONE	UINT32_C(0x0)
	/* Self Reset as soon as possible to do so safely */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTASAP	UINT32_C(0x1)
	/* Self Reset on PCIe Reset */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTPCIERST   UINT32_C(0x2)
	/* Self Reset immediately after notification to all clients. */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTIMMEDIATE UINT32_C(0x3)
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_LAST		HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTIMMEDIATE
	/*
	 * Indicate which host is being reset. 0 means first host.
	 * Only valid when embedded_proc_type is host in multihost
	 * environment
	 */
	uint8_t	host_idx;
	uint8_t	flags;
	/*
	 * When this bit is '1', then the core firmware initiates
	 * the reset only after graceful shut down of all registered
	 * instances. If not, the device will continue with the existing
	 * firmware.
	 */
	#define HWRM_FW_RESET_INPUT_FLAGS_RESET_GRACEFUL	UINT32_C(0x1)
	/*
	 * When this bit is '1', then drivers will be notified that
	 * that the purpose of the reset was a firmware activation.
	 * Such notifications are delivered via the RESET_NOTIFY async
	 * event (reason_code: fw_activation).
	 */
	#define HWRM_FW_RESET_INPUT_FLAGS_FW_ACTIVATION	UINT32_C(0x2)
	uint8_t	unused_0[4];
} hwrm_fw_reset_input_t, *phwrm_fw_reset_input_t;

/* hwrm_fw_reset_output (size:128b/16B) */

typedef struct hwrm_fw_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Type of self reset. */
	uint8_t	selfrst_status;
	/* No Self Reset */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTNONE	UINT32_C(0x0)
	/* Self Reset as soon as possible to do so safely */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTASAP	UINT32_C(0x1)
	/* Self Reset on PCIe Reset */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTPCIERST   UINT32_C(0x2)
	/* Self Reset immediately after notification to all clients. */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTIMMEDIATE UINT32_C(0x3)
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_LAST		HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTIMMEDIATE
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_reset_output_t, *phwrm_fw_reset_output_t;

/*******************
 * hwrm_fw_qstatus *
 *******************/


/* hwrm_fw_qstatus_input (size:192b/24B) */

typedef struct hwrm_fw_qstatus_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of embedded processor. */
	uint8_t	embedded_proc_type;
	/* Boot Processor */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_BOOT	UINT32_C(0x0)
	/* Management Processor */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_MGMT	UINT32_C(0x1)
	/* Network control processor */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_NETCTRL UINT32_C(0x2)
	/* RoCE control processor */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_ROCE	UINT32_C(0x3)
	/*
	 * Host (in multi-host environment): This is only valid if requester
	 * is IPC
	 */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_HOST	UINT32_C(0x4)
	/*
	 * AP processor complex (in multi-host environment). Use host_idx to
	 * control which core is reset
	 */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_AP	UINT32_C(0x5)
	/* Reset all blocks of the chip (including all processors) */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_CHIP	UINT32_C(0x6)
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_LAST   HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_CHIP
	uint8_t	unused_0[7];
} hwrm_fw_qstatus_input_t, *phwrm_fw_qstatus_input_t;

/* hwrm_fw_qstatus_output (size:128b/16B) */

typedef struct hwrm_fw_qstatus_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Type of self reset. */
	uint8_t	selfrst_status;
	/* No Self Reset */
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTNONE	UINT32_C(0x0)
	/* Self Reset as soon as possible to do so safely */
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTASAP	UINT32_C(0x1)
	/* Self Reset on PCIe Reset */
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTPCIERST UINT32_C(0x2)
	/* NIC power cycle (system cold boot) required */
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTPOWER   UINT32_C(0x3)
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_LAST	HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTPOWER
	/*
	 * The action needed to apply any pend nvm option changes.
	 * If multiple options have been set the highest level
	 * action is reported.
	 */
	uint8_t	nvm_option_action_status;
	/* No Action needed */
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_NONE	UINT32_C(0x0)
	/* Hot reset needed to apply nvm options */
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_HOTRESET UINT32_C(0x1)
	/* Warm boot needed to apply nvm options */
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_WARMBOOT UINT32_C(0x2)
	/* Cold boot needed to apply nvm options */
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_COLDBOOT UINT32_C(0x3)
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_LAST		HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_COLDBOOT
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_qstatus_output_t, *phwrm_fw_qstatus_output_t;

/********************
 * hwrm_fw_set_time *
 ********************/


/* hwrm_fw_set_time_input (size:256b/32B) */

typedef struct hwrm_fw_set_time_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Current year */
	uint16_t	year;
	/* Date/time is not known */
	#define HWRM_FW_SET_TIME_INPUT_YEAR_UNKNOWN UINT32_C(0x0)
	#define HWRM_FW_SET_TIME_INPUT_YEAR_LAST   HWRM_FW_SET_TIME_INPUT_YEAR_UNKNOWN
	/* Current month of year (1-12) */
	uint8_t	month;
	/* Current day of month (1-31) */
	uint8_t	day;
	/* Current hour (0-23) */
	uint8_t	hour;
	/* Current minute (0-59) */
	uint8_t	minute;
	/* Current second (0-59) */
	uint8_t	second;
	uint8_t	unused_0;
	/* Current millisecond (0-999) */
	uint16_t	millisecond;
	/* Minutes east of UTC, 0xffff if TZ is not known */
	int16_t	zone;
	/* Time zone is Coordinated Universal Time (UTC) */
	#define HWRM_FW_SET_TIME_INPUT_ZONE_UTC	0
	/* Time zone is not known */
	#define HWRM_FW_SET_TIME_INPUT_ZONE_UNKNOWN 65535
	#define HWRM_FW_SET_TIME_INPUT_ZONE_LAST   HWRM_FW_SET_TIME_INPUT_ZONE_UNKNOWN
	uint8_t	unused_1[4];
} hwrm_fw_set_time_input_t, *phwrm_fw_set_time_input_t;

/* hwrm_fw_set_time_output (size:128b/16B) */

typedef struct hwrm_fw_set_time_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_set_time_output_t, *phwrm_fw_set_time_output_t;

/********************
 * hwrm_fw_get_time *
 ********************/


/* hwrm_fw_get_time_input (size:128b/16B) */

typedef struct hwrm_fw_get_time_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_get_time_input_t, *phwrm_fw_get_time_input_t;

/* hwrm_fw_get_time_output (size:192b/24B) */

typedef struct hwrm_fw_get_time_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Current year */
	uint16_t	year;
	/* Date/time is not known */
	#define HWRM_FW_GET_TIME_OUTPUT_YEAR_UNKNOWN UINT32_C(0x0)
	#define HWRM_FW_GET_TIME_OUTPUT_YEAR_LAST   HWRM_FW_GET_TIME_OUTPUT_YEAR_UNKNOWN
	/* Current month of year (1-12) */
	uint8_t	month;
	/* Current day of month (1-31) */
	uint8_t	day;
	/* Current hour (0-23) */
	uint8_t	hour;
	/* Current minute (0-59) */
	uint8_t	minute;
	/* Current second (0-59) */
	uint8_t	second;
	uint8_t	unused_0;
	/* Current millisecond (0-999) */
	uint16_t	millisecond;
	/* Minutes east of UTC, 0xffff if TZ is not known */
	int16_t	zone;
	/* Time zone is Coordinated Universal Time (UTC) */
	#define HWRM_FW_GET_TIME_OUTPUT_ZONE_UTC	0
	/* Time zone is not known */
	#define HWRM_FW_GET_TIME_OUTPUT_ZONE_UNKNOWN 65535
	#define HWRM_FW_GET_TIME_OUTPUT_ZONE_LAST   HWRM_FW_GET_TIME_OUTPUT_ZONE_UNKNOWN
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_get_time_output_t, *phwrm_fw_get_time_output_t;

/* hwrm_struct_hdr (size:128b/16B) */

typedef struct hwrm_struct_hdr {
	/* This value indicates the structured data ID. */
	uint16_t	struct_id;
	/* LLDP configuration structured data ID. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_LLDP_CFG	UINT32_C(0x41b)
	/* DCBX ETS configuration structured data ID. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_DCBX_ETS	UINT32_C(0x41d)
	/* DCBX PFC configuration structured data ID. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_DCBX_PFC	UINT32_C(0x41f)
	/* DCBX APP configuration structured data ID. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_DCBX_APP	UINT32_C(0x421)
	/* DCBX state configuration structured data ID for all DCBX features. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_DCBX_FEATURE_STATE UINT32_C(0x422)
	/*
	 * LLDP generic structured data ID. This is used with
	 * GET_STRUCTURED_DATA only.
	 */
	#define HWRM_STRUCT_HDR_STRUCT_ID_LLDP_GENERIC	UINT32_C(0x424)
	/*
	 * LLDP device structured data ID. This is used with
	 * GET_STRUCTURED_DATA only.
	 */
	#define HWRM_STRUCT_HDR_STRUCT_ID_LLDP_DEVICE	UINT32_C(0x426)
	/* Power Backup info */
	#define HWRM_STRUCT_HDR_STRUCT_ID_POWER_BKUP	UINT32_C(0x427)
	/* Guest physical address to Host physical address mapping */
	#define HWRM_STRUCT_HDR_STRUCT_ID_PEER_MMAP	UINT32_C(0x429)
	/* reserved for AFM usage. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_AFM_OPAQUE	UINT32_C(0x1)
	/* Port description. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_PORT_DESCRIPTION   UINT32_C(0xa)
	/* RSSv2 Configuration. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_RSS_V2		UINT32_C(0x64)
	/* MSI-X vectors per VF table. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_MSIX_PER_VF	UINT32_C(0xc8)
	#define HWRM_STRUCT_HDR_STRUCT_ID_LAST		HWRM_STRUCT_HDR_STRUCT_ID_MSIX_PER_VF
	/* This value indicates the length of structured data. */
	uint16_t	len;
	/* This value indicates the version of structured data. */
	uint8_t	version;
	/* This value indicates the number of structured data elements. */
	uint8_t	count;
	/* This value indicates the subtype. */
	uint16_t	subtype;
	/*
	 * This value indicates the count of 64-bit values that point to the next
	 * header. A value of 0 means that this is the last element. The value is
	 * a count of 64-bit words from the beginning of the current header.
	 */
	uint16_t	next_offset;
	/* This value indicates this is the last element */
	#define HWRM_STRUCT_HDR_NEXT_OFFSET_LAST UINT32_C(0x0)
	uint8_t	unused_0[6];
} hwrm_struct_hdr_t, *phwrm_struct_hdr_t;

/* hwrm_struct_data_dcbx_ets (size:256b/32B) */

typedef struct hwrm_struct_data_dcbx_ets {
	/*
	 * This field indicates if this configuration is ETS recommendation or
	 * ETS configuration. A value 1 means it is ETS configuration, A value of
	 * 2 means it is a ETS recommendation.
	 */
	uint8_t	destination;
	/* ETS configuration */
	#define HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_CONFIGURATION   UINT32_C(0x1)
	/* ETS recommendation */
	#define HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_RECOMMMENDATION UINT32_C(0x2)
	#define HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_LAST	HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_RECOMMMENDATION
	/* This value indicates maximum ETS TCs supported. */
	uint8_t	max_tcs;
	/* unused. */
	uint16_t	unused1;
	/* ETS priority 0 to TC map. */
	uint8_t	pri0_to_tc_map;
	/* ETS priority 1 to TC map. */
	uint8_t	pri1_to_tc_map;
	/* ETS priority 2 to TC map. */
	uint8_t	pri2_to_tc_map;
	/* ETS priority 3 to TC map. */
	uint8_t	pri3_to_tc_map;
	/* ETS priority 4 to TC map. */
	uint8_t	pri4_to_tc_map;
	/* ETS priority 5 to TC map. */
	uint8_t	pri5_to_tc_map;
	/* ETS priority 6 to TC map. */
	uint8_t	pri6_to_tc_map;
	/* ETS priority 7 to TC map. */
	uint8_t	pri7_to_tc_map;
	/* ETS TC 0 to bandwidth map. */
	uint8_t	tc0_to_bw_map;
	/* ETS TC 1 to bandwidth map. */
	uint8_t	tc1_to_bw_map;
	/* ETS TC 2 to bandwidth map. */
	uint8_t	tc2_to_bw_map;
	/* ETS TC 3 to bandwidth map. */
	uint8_t	tc3_to_bw_map;
	/* ETS TC 4 to bandwidth map. */
	uint8_t	tc4_to_bw_map;
	/* ETS TC 5 to bandwidth map. */
	uint8_t	tc5_to_bw_map;
	/* ETS TC 6 to bandwidth map. */
	uint8_t	tc6_to_bw_map;
	/* ETS TC 7 to bandwidth map. */
	uint8_t	tc7_to_bw_map;
	/* ETS TC 0 to TSA map. */
	uint8_t	tc0_to_tsa_map;
	/* strict priority */
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_SP		UINT32_C(0x0)
	/* credit based shaper */
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_CBS		UINT32_C(0x1)
	/* ETS */
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_ETS		UINT32_C(0x2)
	/* vendor specific */
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_VENDOR_SPECIFIC UINT32_C(0xff)
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_LAST			HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_VENDOR_SPECIFIC
	/* ETS TC 1 to TSA map. */
	uint8_t	tc1_to_tsa_map;
	/* ETS TC 2 to TSA map. */
	uint8_t	tc2_to_tsa_map;
	/* ETS TC 3 to TSA map. */
	uint8_t	tc3_to_tsa_map;
	/* ETS TC 4 to TSA map. */
	uint8_t	tc4_to_tsa_map;
	/* ETS TC 5 to TSA map. */
	uint8_t	tc5_to_tsa_map;
	/* ETS TC 6 to TSA map. */
	uint8_t	tc6_to_tsa_map;
	/* ETS TC 7 to TSA map. */
	uint8_t	tc7_to_tsa_map;
	uint8_t	unused_0[4];
} hwrm_struct_data_dcbx_ets_t, *phwrm_struct_data_dcbx_ets_t;

/* hwrm_struct_data_dcbx_pfc (size:64b/8B) */

typedef struct hwrm_struct_data_dcbx_pfc {
	/*
	 * This field indicates PFC priority bit map. A value of '0' indicates
	 * PFC is disabled. A value of '1' indicates PFC is enabled on that
	 * priority.
	 */
	uint8_t	pfc_priority_bitmap;
	/*
	 * This field indicates max PFC TCs supported. Each PFC TC will map to
	 * a lossless CoS queue.
	 */
	uint8_t	max_pfc_tcs;
	/*
	 * This field indicates if MACSec bypass capability is enabled. A value
	 * of '1' indicates MBC is enabled. A value of '0' indicates MBC is
	 * disabled.
	 */
	uint8_t	mbc;
	uint8_t	unused_0[5];
} hwrm_struct_data_dcbx_pfc_t, *phwrm_struct_data_dcbx_pfc_t;

/* hwrm_struct_data_dcbx_app (size:64b/8B) */

typedef struct hwrm_struct_data_dcbx_app {
	/*
	 * This field indicates the protocol identifier. This should be specified
	 *		in big endian format.
	 */
	uint16_t	protocol_id;
	/*
	 * This field indicates the protocol selector. The valid values are
	 *		mentioned below.
	 */
	uint8_t	protocol_selector;
	/* ether type */
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_ETHER_TYPE   UINT32_C(0x1)
	/* TCP port */
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_TCP_PORT	UINT32_C(0x2)
	/* UDP port */
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_UDP_PORT	UINT32_C(0x3)
	/* TCP & UDP port */
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_TCP_UDP_PORT UINT32_C(0x4)
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_LAST	HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_TCP_UDP_PORT
	/* This field indicates application priority. */
	uint8_t	priority;
	/* This field indicates this entry is valid. */
	uint8_t	valid;
	uint8_t	unused_0[3];
} hwrm_struct_data_dcbx_app_t, *phwrm_struct_data_dcbx_app_t;

/* hwrm_struct_data_dcbx_feature_state (size:64b/8B) */

typedef struct hwrm_struct_data_dcbx_feature_state {
	/* DCBX mode - IEEE or CEE. This is read only field. */
	uint8_t	dcbx_mode;
	/* DCBX disabled mode. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_DISABLED UINT32_C(0x0)
	/* DCBX IEEE mode. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_IEEE	UINT32_C(0x1)
	/* DCBX CEE mode. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_CEE	UINT32_C(0x2)
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_LAST	HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_CEE
	/* ETS TLV state. */
	uint8_t	ets_state;
	/* PFC TLV state. */
	uint8_t	pfc_state;
	/* App TLV state. */
	uint8_t	app_state;
	/* Feature enable bit position. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_ENABLE_BIT_POS	UINT32_C(0x7)
	/* Feature willing bit position. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_WILLING_BIT_POS   UINT32_C(0x6)
	/* Feature advertise bit position. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_ADVERTISE_BIT_POS UINT32_C(0x5)
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_LAST		HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_ADVERTISE_BIT_POS
	/* unused. */
	uint8_t	unused[3];
	/*
	 * This field is used to reset the DCBX configuration to factory
	 * defaults.
	 */
	uint8_t	resets;
	/* reset ETS configuration. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_ETS   UINT32_C(0x1)
	/* reset PFC configuration. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_PFC   UINT32_C(0x2)
	/* reset application configuration. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_APP   UINT32_C(0x4)
	/* reset DCBX state configuration. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_STATE UINT32_C(0x8)
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_LAST	HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_STATE
} hwrm_struct_data_dcbx_feature_state_t, *phwrm_struct_data_dcbx_feature_state_t;

/* hwrm_struct_data_lldp (size:64b/8B) */

typedef struct hwrm_struct_data_lldp {
	/* Port admin state */
	uint8_t	admin_state;
	/* Disable both Tx and Rx */
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_DISABLE UINT32_C(0x0)
	/* Enable Tx only */
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_TX	UINT32_C(0x1)
	/* Enable Rx only */
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_RX	UINT32_C(0x2)
	/* Enable both Tx and Rx */
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_ENABLE  UINT32_C(0x3)
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_LAST   HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_ENABLE
	/* Port description TLV transmit state (enable(1)/disable(0)). */
	uint8_t	port_description_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_LAST   HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_ENABLE
	/* System name TLV transmit state (enable(1)/disable(0)). */
	uint8_t	system_name_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_LAST   HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_ENABLE
	/* System description TLV transmit state (enable(1)/disable(0)). */
	uint8_t	system_desc_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_LAST   HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_ENABLE
	/* System capabilities TLV transmit state (enable(1)/disable(0)). */
	uint8_t	system_cap_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_LAST   HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_ENABLE
	/* Management address TLV transmit state (enable(1)/disable(0)). */
	uint8_t	mgmt_addr_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_LAST   HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_ENABLE
	/* Async event notification state (enable(1)/disable(0)). */
	uint8_t	async_event_notification_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_LAST   HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_ENABLE
	uint8_t	unused_0;
} hwrm_struct_data_lldp_t, *phwrm_struct_data_lldp_t;

/* hwrm_struct_data_lldp_generic (size:2112b/264B) */

typedef struct hwrm_struct_data_lldp_generic {
	/* TLV type. */
	uint8_t	tlv_type;
	/* Chassis ID TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_CHASSIS		UINT32_C(0x1)
	/* Port ID TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT		UINT32_C(0x2)
	/* System name TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_SYSTEM_NAME	UINT32_C(0x3)
	/* System description TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_SYSTEM_DESCRIPTION UINT32_C(0x4)
	/* Port name TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT_NAME	UINT32_C(0x5)
	/* Port description TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT_DESCRIPTION   UINT32_C(0x6)
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_LAST		HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT_DESCRIPTION
	/* TLV sub-type. */
	uint8_t	subtype;
	/* Length. */
	uint8_t	length;
	/* unused. */
	uint8_t	unused1[5];
	/* TLV value. */
	uint32_t	tlv_value[64];
} hwrm_struct_data_lldp_generic_t, *phwrm_struct_data_lldp_generic_t;

/* hwrm_struct_data_lldp_device (size:1472b/184B) */

typedef struct hwrm_struct_data_lldp_device {
	/* Time to Live. */
	uint16_t	ttl;
	/* Management address length. */
	uint8_t	mgmt_addr_len;
	/* Management address type. */
	uint8_t	mgmt_addr_type;
	uint8_t	unused_3[4];
	/* Management address. */
	uint32_t	mgmt_addr[8];
	/* System capabilities. */
	uint32_t	system_caps;
	/* Interface number type. */
	uint8_t	intf_num_type;
	/* Management address OID length. */
	uint8_t	mgmt_addr_oid_length;
	uint8_t	unused_4[2];
	/* Interface number. */
	uint32_t	intf_num;
	uint8_t	unused_5[4];
	/* Management address OID. */
	uint32_t	mgmt_addr_oid[32];
} hwrm_struct_data_lldp_device_t, *phwrm_struct_data_lldp_device_t;

/* hwrm_struct_data_port_description (size:64b/8B) */

typedef struct hwrm_struct_data_port_description {
	/*
	 * Port #. Port number starts at 0 and anything greater than number of
	 * ports minus 1 is an error.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_struct_data_port_description_t, *phwrm_struct_data_port_description_t;

/* hwrm_struct_data_rss_v2 (size:128b/16B) */

typedef struct hwrm_struct_data_rss_v2 {
	uint16_t	flags;
	/* When this bit is '1', the hash type and hash key are included. */
	#define HWRM_STRUCT_DATA_RSS_V2_FLAGS_HASH_VALID	UINT32_C(0x1)
	/* RSS Context index. */
	uint16_t	rss_ctx_id;
	/* Number ring group IDs. */
	uint16_t	num_ring_groups;
	uint16_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_IPV4	UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_TCP_IPV4	UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_UDP_IPV4	UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_IPV6	UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_TCP_IPV6	UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_UDP_IPV6	UINT32_C(0x20)
	/* Hash key. This field is optional. */
	uint64_t	hash_key_ring_group_ids;
} hwrm_struct_data_rss_v2_t, *phwrm_struct_data_rss_v2_t;

/* hwrm_struct_data_power_information (size:192b/24B) */

typedef struct hwrm_struct_data_power_information {
	/* Backup power information version */
	uint32_t	bkup_power_info_ver;
	/* Platform backup power count */
	uint32_t	platform_bkup_power_count;
	/* Load in milliwatts */
	uint32_t	load_milli_watt;
	/* Backup time in milliseconds */
	uint32_t	bkup_time_milli_seconds;
	/* Backup power status */
	uint32_t	bkup_power_status;
	/* Backup power charge time */
	uint32_t	bkup_power_charge_time;
} hwrm_struct_data_power_information_t, *phwrm_struct_data_power_information_t;

/*
 * All mappings (upto 8) for a function will be sent down
 * at the same time. If entries are sent down for the same
 * function again, the existing saved entries will be
 * overwritten.
 */
/* hwrm_struct_data_peer_mmap (size:1600b/200B) */

typedef struct hwrm_struct_data_peer_mmap {
	/*
	 * Target function ID for the mappings. The fid should
	 * be 0xffff for current PF or a valid VF fid for child
	 * VF of the current PF.
	 */
	uint16_t	fid;
	/*
	 * Number of mappings for this function. The count has to
	 * be > 0 and <= 8. Maximum of 8 mappings are supported.
	 */
	uint16_t	count;
	uint32_t	unused_0;
	/* Host Physical Address for mapping 0. */
	uint64_t	hpa_0;
	/* Guest Physical Address for mapping 0. */
	uint64_t	gpa_0;
	/* Size in Kilobytes for mapping 0. */
	uint64_t	size_0;
	/* Host Physical Address for mapping 1. */
	uint64_t	hpa_1;
	/* Guest Physical Address for mapping 1. */
	uint64_t	gpa_1;
	/* Size in Kilobytes for mapping 1. */
	uint64_t	size_1;
	/* Host Physical Address for mapping 2. */
	uint64_t	hpa_2;
	/* Guest Physical Address for mapping 2. */
	uint64_t	gpa_2;
	/* Size in Kilobytes for mapping 2. */
	uint64_t	size_2;
	/* Host Physical Address for mapping 3. */
	uint64_t	hpa_3;
	/* Guest Physical Address for mapping 3. */
	uint64_t	gpa_3;
	/* Size in Kilobytes for mapping 3. */
	uint64_t	size_3;
	/* Host Physical Address for mapping 4. */
	uint64_t	hpa_4;
	/* Guest Physical Address for mapping 4. */
	uint64_t	gpa_4;
	/* Size in Kilobytes for mapping 4. */
	uint64_t	size_4;
	/* Host Physical Address for mapping 5. */
	uint64_t	hpa_5;
	/* Guest Physical Address for mapping 5. */
	uint64_t	gpa_5;
	/* Size in Kilobytes for mapping 5. */
	uint64_t	size_5;
	/* Host Physical Address for mapping 6. */
	uint64_t	hpa_6;
	/* Guest Physical Address for mapping 6. */
	uint64_t	gpa_6;
	/* Size in Kilobytes for mapping 6. */
	uint64_t	size_6;
	/* Host Physical Address for mapping 7. */
	uint64_t	hpa_7;
	/* Guest Physical Address for mapping 7. */
	uint64_t	gpa_7;
	/* Size in Kilobytes for mapping 7. */
	uint64_t	size_7;
} hwrm_struct_data_peer_mmap_t, *phwrm_struct_data_peer_mmap_t;

/* hwrm_struct_data_msix_per_vf (size:320b/40B) */

typedef struct hwrm_struct_data_msix_per_vf {
	/* PF ID */
	uint16_t	pf_id;
	/* Number of rows in table. */
	uint16_t	count;
	uint32_t	unused_0;
	/* Starting VF for row 0 */
	uint16_t	start_vf_0;
	/* MSI-X vectors per VF for row 0 */
	uint16_t	msix_0;
	/* Starting VF for row 1 */
	uint16_t	start_vf_1;
	/* MSI-X vectors per VF for row 1 */
	uint16_t	msix_1;
	/* Starting VF for row 2 */
	uint16_t	start_vf_2;
	/* MSI-X vectors per VF for row 2 */
	uint16_t	msix_2;
	/* Starting VF for row 3 */
	uint16_t	start_vf_3;
	/* MSI-X vectors per VF for row 3 */
	uint16_t	msix_3;
	/* Starting VF for row 4 */
	uint16_t	start_vf_4;
	/* MSI-X vectors per VF for row 4 */
	uint16_t	msix_4;
	/* Starting VF for row 5 */
	uint16_t	start_vf_5;
	/* MSI-X vectors per VF for row 5 */
	uint16_t	msix_5;
	/* Starting VF for row 6 */
	uint16_t	start_vf_6;
	/* MSI-X vectors per VF for row 6 */
	uint16_t	msix_6;
	/* Starting VF for row 7 */
	uint16_t	start_vf_7;
	/* MSI-X vectors per VF for row 7 */
	uint16_t	msix_7;
} hwrm_struct_data_msix_per_vf_t, *phwrm_struct_data_msix_per_vf_t;

/*******************************
 * hwrm_fw_set_structured_data *
 *******************************/


/* hwrm_fw_set_structured_data_input (size:256b/32B) */

typedef struct hwrm_fw_set_structured_data_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * structured data will be copied from
	 */
	uint64_t	src_data_addr;
	/* size of data in bytes */
	uint16_t	data_len;
	/*
	 * a count of the number of Structured Data Headers in the data
	 * pointed by src_data_addr.
	 */
	uint8_t	hdr_cnt;
	uint8_t	unused_0[5];
} hwrm_fw_set_structured_data_input_t, *phwrm_fw_set_structured_data_input_t;

/* hwrm_fw_set_structured_data_output (size:128b/16B) */

typedef struct hwrm_fw_set_structured_data_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_set_structured_data_output_t, *phwrm_fw_set_structured_data_output_t;

/* hwrm_fw_set_structured_data_cmd_err (size:64b/8B) */

typedef struct hwrm_fw_set_structured_data_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* count_of_headers is incorrect */
	#define HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_HDR_CNT UINT32_C(0x1)
	/* data improperly formatted */
	#define HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_FMT	UINT32_C(0x2)
	/* unknown structure ID(s) */
	#define HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_ID	UINT32_C(0x3)
	#define HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_LAST	HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_ID
	uint8_t	unused_0[7];
} hwrm_fw_set_structured_data_cmd_err_t, *phwrm_fw_set_structured_data_cmd_err_t;

/*******************************
 * hwrm_fw_get_structured_data *
 *******************************/


/* hwrm_fw_get_structured_data_input (size:256b/32B) */

typedef struct hwrm_fw_get_structured_data_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * structured data will be copied to
	 */
	uint64_t	dest_data_addr;
	/* size of data in bytes */
	uint16_t	data_len;
	/*
	 * Structure_id is the id of the structure data requesting and count is
	 * a requested number of instances of this data requested. The actual
	 * number will be returned in count_of_headers
	 */
	uint16_t	structure_id;
	/*
	 * Subtype is an optional field used to specify additional information
	 * of the data being retrieved. For example, if data can be categorized
	 * as "live" vs "saved" then this field can be used to provide an
	 * indication of "saved" vs "live" data. Not all structured data
	 * supports subtypes and if they are supported then the structured data
	 * will specify the valid values. If structured data is requested that
	 * supports subtypes but no subtype is given then it is implementation
	 * specific what will be returned. Some structure data can support a
	 * subtype of "All" which would cause a list of structures to be
	 * returned for all supported subtypes. "All" is only used on the
	 * hwrm_get_structured_data command.
	 */
	uint16_t	subtype;
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_UNUSED		UINT32_C(0x0)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_ALL			UINT32_C(0xffff)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NEAR_BRIDGE_ADMIN	UINT32_C(0x100)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NEAR_BRIDGE_PEER	UINT32_C(0x101)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NEAR_BRIDGE_OPERATIONAL UINT32_C(0x102)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NON_TPMR_ADMIN	UINT32_C(0x200)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NON_TPMR_PEER	UINT32_C(0x201)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NON_TPMR_OPERATIONAL	UINT32_C(0x202)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_HOST_OPERATIONAL	UINT32_C(0x300)
	#define HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_LAST		HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_HOST_OPERATIONAL
	/* Number of elements. This allows support of arrayed data */
	uint8_t	count;
	uint8_t	unused_0;
} hwrm_fw_get_structured_data_input_t, *phwrm_fw_get_structured_data_input_t;

/* hwrm_fw_get_structured_data_output (size:128b/16B) */

typedef struct hwrm_fw_get_structured_data_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * a count of the number of Structured Data Headers in the data
	 * pointed by dest_data_addr.
	 */
	uint8_t	hdr_cnt;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_get_structured_data_output_t, *phwrm_fw_get_structured_data_output_t;

/* hwrm_fw_get_structured_data_cmd_err (size:64b/8B) */

typedef struct hwrm_fw_get_structured_data_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_FW_GET_STRUCTURED_DATA_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	/* unknown structure ID(s) */
	#define HWRM_FW_GET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_ID  UINT32_C(0x3)
	#define HWRM_FW_GET_STRUCTURED_DATA_CMD_ERR_CODE_LAST   HWRM_FW_GET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_ID
	uint8_t	unused_0[7];
} hwrm_fw_get_structured_data_cmd_err_t, *phwrm_fw_get_structured_data_cmd_err_t;

/*******************
 * hwrm_fw_ipc_msg *
 *******************/


/* hwrm_fw_ipc_msg_input (size:320b/40B) */

typedef struct hwrm_fw_ipc_msg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the command_id field to be
	 * configured.
	 */
	#define HWRM_FW_IPC_MSG_INPUT_ENABLES_COMMAND_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the src_processor field to be
	 * configured.
	 */
	#define HWRM_FW_IPC_MSG_INPUT_ENABLES_SRC_PROCESSOR	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the data_offset field to be
	 * configured.
	 */
	#define HWRM_FW_IPC_MSG_INPUT_ENABLES_DATA_OFFSET	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the length field to be
	 * configured.
	 */
	#define HWRM_FW_IPC_MSG_INPUT_ENABLES_LENGTH		UINT32_C(0x8)
	/* Command ID */
	uint16_t	command_id;
	/* RoCE LAG message */
	#define HWRM_FW_IPC_MSG_INPUT_COMMAND_ID_ROCE_LAG	UINT32_C(0x1)
	/* Query information on PF mapping for x86 and MAIA. */
	#define HWRM_FW_IPC_MSG_INPUT_COMMAND_ID_MHB_HOST	UINT32_C(0x2)
	/* RoCE driver version details to be sent to chimp */
	#define HWRM_FW_IPC_MSG_INPUT_COMMAND_ID_ROCE_DRVR_VERSION UINT32_C(0x3)
	#define HWRM_FW_IPC_MSG_INPUT_COMMAND_ID_LAST		HWRM_FW_IPC_MSG_INPUT_COMMAND_ID_ROCE_DRVR_VERSION
	/* Source processor for this command. */
	uint8_t	src_processor;
	/* Chimp processor */
	#define HWRM_FW_IPC_MSG_INPUT_SRC_PROCESSOR_CFW  UINT32_C(0x1)
	/* BONO processor */
	#define HWRM_FW_IPC_MSG_INPUT_SRC_PROCESSOR_BONO UINT32_C(0x2)
	/* APE processor */
	#define HWRM_FW_IPC_MSG_INPUT_SRC_PROCESSOR_APE  UINT32_C(0x3)
	/* KONG processor */
	#define HWRM_FW_IPC_MSG_INPUT_SRC_PROCESSOR_KONG UINT32_C(0x4)
	#define HWRM_FW_IPC_MSG_INPUT_SRC_PROCESSOR_LAST HWRM_FW_IPC_MSG_INPUT_SRC_PROCESSOR_KONG
	uint8_t	unused_0;
	/* Offset of the data in the source processor memory. */
	uint32_t	data_offset;
	/* Length of the data in source processor. */
	uint16_t	length;
	uint8_t	unused_1[2];
	/* This is for storing FW opaque data. */
	uint64_t	opaque;
} hwrm_fw_ipc_msg_input_t, *phwrm_fw_ipc_msg_input_t;

/* hwrm_fw_ipc_msg_output (size:256b/32B) */

typedef struct hwrm_fw_ipc_msg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	msg_data_1;
	uint32_t	msg_data_2;
	uint64_t	reserved64;
	uint8_t	reserved48[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_ipc_msg_output_t, *phwrm_fw_ipc_msg_output_t;

/***********************
 * hwrm_fw_ipc_mailbox *
 ***********************/


/* hwrm_fw_ipc_mailbox_input (size:256b/32B) */

typedef struct hwrm_fw_ipc_mailbox_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/* unused is 8 b */
	uint8_t	unused;
	/* asynchronous event to hosts. */
	uint8_t	event_id;
	/* PORT ID */
	uint8_t	port_id;
	/* event data1 of asynchronous event */
	uint32_t	event_data1;
	/* event data2 of asynchronous event */
	uint32_t	event_data2;
	uint8_t	unused_0[4];
} hwrm_fw_ipc_mailbox_input_t, *phwrm_fw_ipc_mailbox_input_t;

/* hwrm_fw_ipc_mailbox_output (size:128b/16B) */

typedef struct hwrm_fw_ipc_mailbox_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_ipc_mailbox_output_t, *phwrm_fw_ipc_mailbox_output_t;

/* hwrm_fw_ipc_mailbox_cmd_err (size:64b/8B) */

typedef struct hwrm_fw_ipc_mailbox_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_FW_IPC_MAILBOX_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	/* invalid event */
	#define HWRM_FW_IPC_MAILBOX_CMD_ERR_CODE_BAD_ID  UINT32_C(0x3)
	#define HWRM_FW_IPC_MAILBOX_CMD_ERR_CODE_LAST   HWRM_FW_IPC_MAILBOX_CMD_ERR_CODE_BAD_ID
	uint8_t	unused_0[7];
} hwrm_fw_ipc_mailbox_cmd_err_t, *phwrm_fw_ipc_mailbox_cmd_err_t;

/*******************
 * hwrm_fw_ecn_cfg *
 *******************/


/* hwrm_fw_ecn_cfg_input (size:192b/24B) */

typedef struct hwrm_fw_ecn_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/*
	 * When this bit is '1', Explicit Congestion Notification (ECN) is
	 * enabled device-wide. When ECN is enabled on a multi-host system,
	 * it is enabled for all hosts. This setting takes effect
	 * immediately. When ECN is enabled, the firmware activates
	 * additional receive Class of Service (CoS) queues that are enabled
	 * for ECN marking and steers ECN-capable packets to those queues.
	 * This setting is not saved persistently. To enable ECN
	 * persistently, set NVM option 173, ENABLE_ECN.
	 * Setting this bit to '0' disables ECN immediately.
	 */
	#define HWRM_FW_ECN_CFG_INPUT_FLAGS_ENABLE_ECN	UINT32_C(0x1)
	uint8_t	unused_0[6];
} hwrm_fw_ecn_cfg_input_t, *phwrm_fw_ecn_cfg_input_t;

/* hwrm_fw_ecn_cfg_output (size:128b/16B) */

typedef struct hwrm_fw_ecn_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_ecn_cfg_output_t, *phwrm_fw_ecn_cfg_output_t;

/********************
 * hwrm_fw_ecn_qcfg *
 ********************/


/* hwrm_fw_ecn_qcfg_input (size:128b/16B) */

typedef struct hwrm_fw_ecn_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_ecn_qcfg_input_t, *phwrm_fw_ecn_qcfg_input_t;

/* hwrm_fw_ecn_qcfg_output (size:128b/16B) */

typedef struct hwrm_fw_ecn_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/* When this bit is '1', ECN is enabled device-wide. */
	#define HWRM_FW_ECN_QCFG_OUTPUT_FLAGS_ENABLE_ECN	UINT32_C(0x1)
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_ecn_qcfg_output_t, *phwrm_fw_ecn_qcfg_output_t;

/************************
 * hwrm_fw_health_check *
 ************************/


/* hwrm_fw_health_check_input (size:128b/16B) */

typedef struct hwrm_fw_health_check_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_health_check_input_t, *phwrm_fw_health_check_input_t;

/* hwrm_fw_health_check_output (size:128b/16B) */

typedef struct hwrm_fw_health_check_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	fw_status;
	/*
	 * This bit is '0' if the primary SBI was used this boot,
	 * or '1' if the secondary SBI was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SBI_BOOTED	UINT32_C(0x1)
	/*
	 * This bit is '0' if the primary and secondary SBI images
	 * match, or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SBI_MISMATCH	UINT32_C(0x2)
	/*
	 * This bit is '0' if the primary SRT was used this boot,
	 * or '1' if the secondary SRT was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SRT_BOOTED	UINT32_C(0x4)
	/*
	 * This bit is '0' if the primary and secondary SRT images
	 * match, or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SRT_MISMATCH	UINT32_C(0x8)
	/*
	 * This bit is '0' if the primary CRT (or second stage SRT)
	 * was used this boot, or '1' if the secondary CRT (or
	 * second stage SRT) was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_CRT_BOOTED	UINT32_C(0x10)
	/*
	 * This bit is '0' if the primary and secondary CRT images
	 * (or second stage SRT images) match, or '1' if they do not
	 * match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_CRT_MISMATCH	UINT32_C(0x20)
	/*
	 * This bit is '0' if the second stage RT image is a CRT,
	 * or '1' if the second stage RT image is an SRT.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SECOND_RT		UINT32_C(0x40)
	/*
	 * This bit is '0' if the image was loaded from flash,
	 * or '1' if the image was fastbooted.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_FASTBOOTED	UINT32_C(0x80)
	/*
	 * This bit is '0' if the primary dir_hdr was used to locate
	 * the firmware, or '1' if the secondary dir_hdr was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_DIR_HDR_BOOTED	UINT32_C(0x100)
	/*
	 * This bit is '0' if the primary and secondary dir_hdr match,
	 * or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_DIR_HDR_MISMATCH	UINT32_C(0x200)
	/*
	 * This bit is '0' if the Master Boot Record is in good condition,
	 * or '1' if it is corrupted.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_MBR_CORRUPT	UINT32_C(0x400)
	/*
	 * This bit is '0' if the configuration is in good condition,
	 * or '1' if it is corrupted.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_CFG_MISMATCH	UINT32_C(0x800)
	/*
	 * This bit is '0' if both FRU entries match,
	 * or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_FRU_MISMATCH	UINT32_C(0x1000)
	/*
	 * This bit is '0' if the primary CRT2 was used this boot,
	 * or '1' if the secondary CRT2 was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_CRT2_BOOTED	UINT32_C(0x2000)
	/*
	 * This bit is '0' if the primary and secondary CRT2 images
	 * match, or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_CRT2_MISMATCH	UINT32_C(0x4000)
	/*
	 * This bit is '0' if the primary GXRT was used this boot,
	 * or '1' if the secondary GXRT was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_GXRT_BOOTED	UINT32_C(0x8000)
	/*
	 * This bit is '0' if the primary and secondary GXRT images
	 * match, or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_GXRT_MISMATCH	UINT32_C(0x10000)
	/*
	 * This bit is '0' if the primary SRT2 was used this boot,
	 * or '1' if the secondary SRT2 was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SRT2_BOOTED	UINT32_C(0x20000)
	/*
	 * This bit is '0' if the primary and secondary SRT2 images
	 * match, or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SRT2_MISMATCH	UINT32_C(0x40000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_health_check_output_t, *phwrm_fw_health_check_output_t;

/***************************
 * hwrm_fw_livepatch_query *
 ***************************/


/* hwrm_fw_livepatch_query_input (size:192b/24B) */

typedef struct hwrm_fw_livepatch_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware target to which to apply the livepatch query */
	uint8_t	fw_target;
	/* Common firmware livepatch query. */
	#define HWRM_FW_LIVEPATCH_QUERY_INPUT_FW_TARGET_COMMON_FW UINT32_C(0x1)
	/* Secure firmware livepatch query. */
	#define HWRM_FW_LIVEPATCH_QUERY_INPUT_FW_TARGET_SECURE_FW UINT32_C(0x2)
	#define HWRM_FW_LIVEPATCH_QUERY_INPUT_FW_TARGET_LAST	HWRM_FW_LIVEPATCH_QUERY_INPUT_FW_TARGET_SECURE_FW
	uint8_t	unused_0[7];
} hwrm_fw_livepatch_query_input_t, *phwrm_fw_livepatch_query_input_t;

/* hwrm_fw_livepatch_query_output (size:640b/80B) */

typedef struct hwrm_fw_livepatch_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the patch version string of the NVM installed
	 * livepatch. (ASCII chars with NULL at the end).
	 */
	char	install_ver[32];
	/*
	 * This field represents the patch version string of the active
	 * livepatch. (ASCII chars with NULL at the end).
	 */
	char	active_ver[32];
	uint16_t	status_flags;
	/* This bit is '1' if a livepatch image is installed to NVM. */
	#define HWRM_FW_LIVEPATCH_QUERY_OUTPUT_STATUS_FLAGS_INSTALL	UINT32_C(0x1)
	/* This bit is '1' if firmware livepatch is active. */
	#define HWRM_FW_LIVEPATCH_QUERY_OUTPUT_STATUS_FLAGS_ACTIVE	UINT32_C(0x2)
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_livepatch_query_output_t, *phwrm_fw_livepatch_query_output_t;

/*********************
 * hwrm_fw_livepatch *
 *********************/


/* hwrm_fw_livepatch_input (size:256b/32B) */

typedef struct hwrm_fw_livepatch_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Livepatch operation */
	uint8_t	opcode;
	/*
	 * Activate a livepatch that is NVM installed or via direct load
	 * from host memory. Activate will authenticate a signed patch,
	 * verify the patch version for compatibility and apply the
	 * livepatch to existing firmware at run-time.
	 */
	#define HWRM_FW_LIVEPATCH_INPUT_OPCODE_ACTIVATE   UINT32_C(0x1)
	/*
	 * Deactivate a livepatch and restore to the original firmware
	 * operation state.
	 */
	#define HWRM_FW_LIVEPATCH_INPUT_OPCODE_DEACTIVATE UINT32_C(0x2)
	#define HWRM_FW_LIVEPATCH_INPUT_OPCODE_LAST	HWRM_FW_LIVEPATCH_INPUT_OPCODE_DEACTIVATE
	/* Firmware target to which to apply the livepatch operation. */
	uint8_t	fw_target;
	/* Common firmware livepatch. */
	#define HWRM_FW_LIVEPATCH_INPUT_FW_TARGET_COMMON_FW UINT32_C(0x1)
	/* Secure firmware livepatch. */
	#define HWRM_FW_LIVEPATCH_INPUT_FW_TARGET_SECURE_FW UINT32_C(0x2)
	#define HWRM_FW_LIVEPATCH_INPUT_FW_TARGET_LAST	HWRM_FW_LIVEPATCH_INPUT_FW_TARGET_SECURE_FW
	/* Load method for livepatch. */
	uint8_t	loadtype;
	/* Load a livepatch currently installed on NVM. */
	#define HWRM_FW_LIVEPATCH_INPUT_LOADTYPE_NVM_INSTALL   UINT32_C(0x1)
	/*
	 * Load a livepatch directly from host memory. The livepatch image
	 * is available at host_addr.
	 */
	#define HWRM_FW_LIVEPATCH_INPUT_LOADTYPE_MEMORY_DIRECT UINT32_C(0x2)
	#define HWRM_FW_LIVEPATCH_INPUT_LOADTYPE_LAST	HWRM_FW_LIVEPATCH_INPUT_LOADTYPE_MEMORY_DIRECT
	/* Reserved for future use. */
	uint8_t	flags;
	/* Length of livepatch image for memory direct loading, in bytes. */
	uint32_t	patch_len;
	/* 64-bit Host address of livepatch image for memory direct loading. */
	uint64_t	host_addr;
} hwrm_fw_livepatch_input_t, *phwrm_fw_livepatch_input_t;

/* hwrm_fw_livepatch_output (size:128b/16B) */

typedef struct hwrm_fw_livepatch_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_livepatch_output_t, *phwrm_fw_livepatch_output_t;

/* hwrm_fw_livepatch_cmd_err (size:64b/8B) */

typedef struct hwrm_fw_livepatch_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* Opcode invalid. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_INVALID_OPCODE  UINT32_C(0x1)
	/* Firmware target invalid. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_INVALID_TARGET  UINT32_C(0x2)
	/* Livepatch operation not supported. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_NOT_SUPPORTED   UINT32_C(0x3)
	/* Livepatch image is not installed in NVRAM. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_NOT_INSTALLED   UINT32_C(0x4)
	/* Deactivate failed. Firmware is not currently patched. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_NOT_PATCHED	UINT32_C(0x5)
	/* Authentication of a signed livepatch failed. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_AUTH_FAIL	UINT32_C(0x6)
	/* Livepatch header check failed. Patch incompatible. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_INVALID_HEADER  UINT32_C(0x7)
	/* Livepatch size incompatible. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_INVALID_SIZE	UINT32_C(0x8)
	/*
	 * Activate failed. Firmware has already been patched. Deactivate
	 * existing livepatch before proceeding.
	 */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_ALREADY_PATCHED UINT32_C(0x9)
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_LAST	HWRM_FW_LIVEPATCH_CMD_ERR_CODE_ALREADY_PATCHED
	uint8_t	unused_0[7];
} hwrm_fw_livepatch_cmd_err_t, *phwrm_fw_livepatch_cmd_err_t;

/****************
 * hwrm_fw_sync *
 ****************/


/* hwrm_fw_sync_input (size:192b/24B) */

typedef struct hwrm_fw_sync_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	sync_action;
	/*
	 * If action is '1' (sync) and this bit is set, the SBI
	 * images will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_SBI	UINT32_C(0x1)
	/*
	 * If action is '1' (sync) and this bit is set, the SRT
	 * images will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_SRT	UINT32_C(0x2)
	/*
	 * If action is '1' (sync) and this bit is set, the CRT
	 * images will be synchronized (or second stage SRT if that
	 * is used in place of CRT), copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_CRT	UINT32_C(0x4)
	/*
	 * If action is '1' (sync) and this bit is set, the dir_hdr
	 * partition will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_DIR_HDR	UINT32_C(0x8)
	/*
	 * If action is '1' (sync) and this bit is set, the MBR
	 * will be erased and reprogrammed with valid content.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_WRITE_MBR	UINT32_C(0x10)
	/*
	 * If action is '1' (sync) and this bit is set, the
	 * configuration will be resynced or repaired as needed.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_CFG	UINT32_C(0x20)
	/*
	 * If action is '1' (sync) and this bit is set, the
	 * FRU in NVM file will be synchronized, copying the active
	 * FRU to the backup FRU.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_FRU	UINT32_C(0x40)
	/*
	 * If action is '1' (sync) and this bit is set, the CRT2
	 * images will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_CRT2	UINT32_C(0x80)
	/*
	 * If action is '1' (sync) and this bit is set, the GXRT
	 * images will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_GXRT	UINT32_C(0x100)
	/*
	 * If action is '1' (sync) and this bit is set, the SRT2
	 * images will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_SRT2	UINT32_C(0x200)
	/*
	 * A value of '1' instructs the firmware to perform an image
	 * synchronization of the firmware types denoted by the
	 * sync_sbi, sync_srt, sync_crt, sync_crt2, sync_srt2 bits.
	 * A value of '0' just requests the status for the previously
	 * requested sync operation.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_ACTION	UINT32_C(0x80000000)
	uint8_t	unused_0[4];
} hwrm_fw_sync_input_t, *phwrm_fw_sync_input_t;

/* hwrm_fw_sync_output (size:128b/16B) */

typedef struct hwrm_fw_sync_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	sync_status;
	/* This bit field indicates the error if 'sync_err' bit is set. */
	#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_MASK	UINT32_C(0xff)
	#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_SFT	0
	/* Success, no error */
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_SUCCESS	UINT32_C(0x0)
	/*
	 * A previously requested synchronization command is still
	 * in progress.
	 */
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_IN_PROGRESS  UINT32_C(0x1)
	/* An NVRAM operation has timed out. */
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_TIMEOUT	UINT32_C(0x2)
	/* General NVRAM error code. */
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_GENERAL	UINT32_C(0x3)
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_LAST	HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_GENERAL
	/*
	 * This bit is '1' if the synchronization request has completed
	 * with an error; the 'err_code' field can be used to obtain
	 * information about error type.
	 */
	#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_SYNC_ERR		UINT32_C(0x40000000)
	/*
	 * This bit is '0' if the previously requested synchronization
	 * command is still in progress, or '1' if the previously
	 * requested sync command has completed. If '1', the 'sync_err'
	 * field will indicate if it completed successfully or with
	 * an error.
	 */
	#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_SYNC_COMPLETE	UINT32_C(0x80000000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_sync_output_t, *phwrm_fw_sync_output_t;

/***********************
 * hwrm_fw_state_qcaps *
 ***********************/


/* hwrm_fw_state_qcaps_input (size:128b/16B) */

typedef struct hwrm_fw_state_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_state_qcaps_input_t, *phwrm_fw_state_qcaps_input_t;

/* hwrm_fw_state_qcaps_output (size:256b/32B) */

typedef struct hwrm_fw_state_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field indicates the size in bytes required by host backup
	 * memory. Host software should allocate memory according to this
	 * size requirement and pass the allocated memory to the
	 * HWRM_FW_STATE_BACKUP and HWRM_FW_STATE_RESTORE commands in the form
	 * of PBL data as specified in those commands.
	 */
	uint32_t	backup_memory;
	/*
	 * This field indicates the max time in milliseconds that firmware
	 * waits for quiesce to complete. Firmware indicates successful
	 * quiesce completion if the quiesce operation completes within this
	 * timeout. If firmware is still waiting for the quiesce operation
	 * to complete when this timeout is reached, firmware stops waiting
	 * (without canceling any quiesce action such as pausing or
	 * clearing meter profiles) and indicates a timeout status result
	 * via NQE completion notification. This timeout value may also be
	 * used by the driver to know the max time to wait for any NQE
	 * notification response to the HWRM_FW_STATE_QUIESCE command. After
	 * a timeout, the driver may elect to invoke HWRM_FW_STATE_QUIESCE
	 * again to keep trying or to invoke HWRM_FW_STATE_UNQUIESCE to
	 * revert the operation. Since there is no identifier correlating
	 * each HWRM_FW_STATE_QUIESCE command with its NQE response, it is
	 * important for the driver to wait for the NQE response before
	 * issuing a subsequent HWRM_FW_STATE_QUIESCE command.
	 */
	uint32_t	quiesce_timeout;
	/*
	 * This field indicates time in milliseconds that the driver should
	 * wait after return from HWRM_FW_RESET to begin polling the device
	 * for status 0x8000.
	 */
	uint32_t	fw_status_blackout;
	/*
	 * This field indicates a max time for firmware to poll for status
	 * 0x8000 before assuming a reset failure occurred. This time does
	 * not include fw_status_blackout time which would immediately precede
	 * this wait.
	 */
	uint32_t	fw_status_max_wait;
	uint8_t	unused_0[4];
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_qcaps_output_t, *phwrm_fw_state_qcaps_output_t;

/*************************
 * hwrm_fw_state_quiesce *
 *************************/


/* hwrm_fw_state_quiesce_input (size:192b/24B) */

typedef struct hwrm_fw_state_quiesce_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Setting this bit to '1', indicates impactless firmware update
	 * is in a recovery mode where hardware is in an error state and
	 * where recovery is desired with reasonably minimal impact to
	 * connected clients. The quiesce operation may require separate
	 * steps to handle quiescing when hardware is in a hung or locked
	 * state. For example, quiesce via draining may not be possible
	 * depending on the type of error. This flag's state would be kept
	 * in firmware if recovery-specific steps are also needed for the
	 * HWRM_FW_STATE_BACKUP. Note this option is available only for
	 * specific recovery scenarios and may not be operational across
	 * all controllers.
	 */
	#define HWRM_FW_STATE_QUIESCE_INPUT_FLAGS_ERROR_RECOVERY	UINT32_C(0x1)
	uint8_t	unused_0[7];
} hwrm_fw_state_quiesce_input_t, *phwrm_fw_state_quiesce_input_t;

/* hwrm_fw_state_quiesce_output (size:192b/24B) */

typedef struct hwrm_fw_state_quiesce_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	quiesce_status;
	/*
	 * This bit is '1' if the quiesce request has been successfully
	 * initiated.
	 */
	#define HWRM_FW_STATE_QUIESCE_OUTPUT_QUIESCE_STATUS_INITIATED	UINT32_C(0x80000000)
	uint8_t	unused_0[4];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1' to
	 * indicate that the output has been completely written. When
	 * writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_quiesce_output_t, *phwrm_fw_state_quiesce_output_t;

/***************************
 * hwrm_fw_state_unquiesce *
 ***************************/


/* hwrm_fw_state_unquiesce_input (size:128b/16B) */

typedef struct hwrm_fw_state_unquiesce_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_state_unquiesce_input_t, *phwrm_fw_state_unquiesce_input_t;

/* hwrm_fw_state_unquiesce_output (size:192b/24B) */

typedef struct hwrm_fw_state_unquiesce_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	unquiesce_status;
	/* This bit is '1' if the unquiesce request has fully completed. */
	#define HWRM_FW_STATE_UNQUIESCE_OUTPUT_UNQUIESCE_STATUS_COMPLETE	UINT32_C(0x80000000)
	uint8_t	unused_0[4];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_unquiesce_output_t, *phwrm_fw_state_unquiesce_output_t;

/************************
 * hwrm_fw_state_backup *
 ************************/


/* hwrm_fw_state_backup_input (size:256b/32B) */

typedef struct hwrm_fw_state_backup_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* State backup page size and level. */
	uint8_t	backup_pg_size_backup_lvl;
	/* State backup PBL indirect levels. */
	#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LAST	HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LVL_2
	/* State backup page size. */
	#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_LAST   HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_1G
	uint8_t	unused_0[7];
	/* State backup page directory. */
	uint64_t	backup_page_dir;
} hwrm_fw_state_backup_input_t, *phwrm_fw_state_backup_input_t;

/* hwrm_fw_state_backup_output (size:192b/24B) */

typedef struct hwrm_fw_state_backup_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	backup_status;
	/*
	 * This bit field provides additional information if the error if
	 * error_code in the common HWRM header is set.
	 */
	#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_MASK	UINT32_C(0xff)
	#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_SFT	0
	/* Success, no error */
		#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_SUCCESS	UINT32_C(0x0)
	/* Data or control plane detected as non-quiesced */
		#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_QUIESCE_ERROR  UINT32_C(0x1)
	/* General backup error */
		#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_GENERAL	UINT32_C(0x3)
		#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_LAST	HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_GENERAL
	/*
	 * This bit is '0' if the backout was done in a way that firmware
	 * may continue running normally after the backup, for example if
	 * the host elects to skip the subsequent reset and restore for any
	 * reason. A value of '1' indicates the act of backing up has left
	 * the firmware/device in a state where subsequent reset is
	 * required, for example of probing state of a queue leaves changes
	 * state in a way that is detectable by users.
	 */
	#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_RESET_REQUIRED	UINT32_C(0x40000000)
	/* This bit is '1' if the backup request has fully completed. */
	#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_COMPLETE		UINT32_C(0x80000000)
	uint8_t	unused_0[4];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_backup_output_t, *phwrm_fw_state_backup_output_t;

/*************************
 * hwrm_fw_state_restore *
 *************************/


/* hwrm_fw_state_restore_input (size:256b/32B) */

typedef struct hwrm_fw_state_restore_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* State restore page size and level. */
	uint8_t	restore_pg_size_restore_lvl;
	/* State restore PBL indirect levels. */
	#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LAST	HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LVL_2
	/* State restore page size. */
	#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_LAST   HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_1G
	uint8_t	unused_0[7];
	/* State restore page directory. */
	uint64_t	restore_page_dir;
} hwrm_fw_state_restore_input_t, *phwrm_fw_state_restore_input_t;

/* hwrm_fw_state_restore_output (size:128b/16B) */

typedef struct hwrm_fw_state_restore_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	restore_status;
	/*
	 * This bit field provides additional information if the error if
	 * error_code in the common HWRM header is set.
	 */
	#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_MASK		UINT32_C(0xff)
	#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_SFT		0
	/* Success, no error */
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_SUCCESS		UINT32_C(0x0)
	/* General restore error */
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_GENERAL		UINT32_C(0x1)
	/* Format parse error */
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_FORMAT_PARSE		UINT32_C(0x2)
	/* Integrity check error */
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_INTEGRITY_CHECK	UINT32_C(0x3)
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_LAST		HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_INTEGRITY_CHECK
	/*
	 * If a failure occurs (complete is 0), restore attempts to
	 * completely roll back any state applied so that the failure
	 * results in no state change. This flag indicates whether that
	 * rollback completed successfully and thoroughly.
	 */
	#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_FAILURE_ROLLBACK_COMPLETED	UINT32_C(0x40000000)
	/* This bit is '1' if the restore request has fully completed. */
	#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_COMPLETE			UINT32_C(0x80000000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_restore_output_t, *phwrm_fw_state_restore_output_t;

/**********************
 * hwrm_fw_secure_cfg *
 **********************/


/* hwrm_fw_secure_cfg_input (size:256b/32B) */

typedef struct hwrm_fw_secure_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Specify the type of security option. */
	uint8_t	enable;
	/* Fields for the nvm lock mode are valid. */
	#define HWRM_FW_SECURE_CFG_INPUT_ENABLE_NVRAM UINT32_C(0x1)
	/* Fields for the grc access control are valid. */
	#define HWRM_FW_SECURE_CFG_INPUT_ENABLE_GRC   UINT32_C(0x2)
	/* Fields for the uart access control are valid. */
	#define HWRM_FW_SECURE_CFG_INPUT_ENABLE_UART  UINT32_C(0x3)
	#define HWRM_FW_SECURE_CFG_INPUT_ENABLE_LAST HWRM_FW_SECURE_CFG_INPUT_ENABLE_UART
	/*
	 * This bit field indicates the type of the configuration to be
	 * updated.
	 */
	uint8_t	config_mode;
	/* When this bit is '1', persistent config would be updated. */
	#define HWRM_FW_SECURE_CFG_INPUT_CONFIG_MODE_PERSISTENT	UINT32_C(0x1)
	/* When this bit is '1', runtime config would be updated. */
	#define HWRM_FW_SECURE_CFG_INPUT_CONFIG_MODE_RUNTIME	UINT32_C(0x2)
	/* define lock mode for nvram. */
	uint8_t	nvm_lock_mode;
	/*
	 * Contents of the entire NVRAM including FW and Config can be
	 * altered by a HWRM client.
	 */
	#define HWRM_FW_SECURE_CFG_INPUT_NVM_LOCK_MODE_NONE	UINT32_C(0x0)
	/*
	 * Only partial sections of the NVM are to be locked. To specify
	 * section to be locked the 'nvm_partial_lock_mask' should be used.
	 */
	#define HWRM_FW_SECURE_CFG_INPUT_NVM_LOCK_MODE_PARTIAL UINT32_C(0x1)
	/*
	 * Contents of the entire NVM including FW and Config are to be
	 * locked against any alteration by any HWRM client.
	 */
	#define HWRM_FW_SECURE_CFG_INPUT_NVM_LOCK_MODE_FULL	UINT32_C(0x2)
	/*
	 * This is a HW lock of the NVM itself. Once locked firmware has no
	 * control to unlock. Contents of the NVM cannot be altered.
	 * Require a power cycle to unlock.
	 */
	#define HWRM_FW_SECURE_CFG_INPUT_NVM_LOCK_MODE_CHIP	UINT32_C(0x3)
	#define HWRM_FW_SECURE_CFG_INPUT_NVM_LOCK_MODE_LAST   HWRM_FW_SECURE_CFG_INPUT_NVM_LOCK_MODE_CHIP
	/*
	 * bit field indicating the type of partial_lock.
	 * This field is only applicable if the partial_lock is set.
	 */
	uint8_t	nvm_partial_lock_mask;
	/* When this bit is '1', updating the FW images are locked. */
	#define HWRM_FW_SECURE_CFG_INPUT_NVM_PARTIAL_LOCK_MASK_EXE	UINT32_C(0x1)
	/* When this bit is '1', updating the CFG are locked. */
	#define HWRM_FW_SECURE_CFG_INPUT_NVM_PARTIAL_LOCK_MASK_CFG	UINT32_C(0x2)
	/* specify grc access control for specified HWRM clients. */
	uint8_t	grc_ctrl;
	/* Read Only */
	#define HWRM_FW_SECURE_CFG_INPUT_GRC_CTRL_RO UINT32_C(0x0)
	/* Read-Write */
	#define HWRM_FW_SECURE_CFG_INPUT_GRC_CTRL_RW UINT32_C(0x1)
	#define HWRM_FW_SECURE_CFG_INPUT_GRC_CTRL_LAST HWRM_FW_SECURE_CFG_INPUT_GRC_CTRL_RW
	/* specify debug access control via UART */
	uint8_t	uart_ctrl;
	/* disable UART access for debugging */
	#define HWRM_FW_SECURE_CFG_INPUT_UART_CTRL_DISABLE UINT32_C(0x0)
	/* enable UART access for debugging */
	#define HWRM_FW_SECURE_CFG_INPUT_UART_CTRL_ENABLE  UINT32_C(0x1)
	#define HWRM_FW_SECURE_CFG_INPUT_UART_CTRL_LAST   HWRM_FW_SECURE_CFG_INPUT_UART_CTRL_ENABLE
	uint8_t	unused_0[2];
	uint64_t	unused_1;
} hwrm_fw_secure_cfg_input_t, *phwrm_fw_secure_cfg_input_t;

/* hwrm_fw_secure_cfg_output (size:128b/16B) */

typedef struct hwrm_fw_secure_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_fw_secure_cfg_output_t, *phwrm_fw_secure_cfg_output_t;

/**********************
 * hwrm_exec_fwd_resp *
 **********************/


/* hwrm_exec_fwd_resp_input (size:1024b/128B) */

typedef struct hwrm_exec_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is an encapsulated request. This request should
	 * be executed by the HWRM and the response should be
	 * provided in the response buffer inside the encapsulated
	 * request.
	 */
	uint32_t	encap_request[26];
	/*
	 * This value indicates the target id of the response to
	 * the encapsulated request.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	uint8_t	unused_0[6];
} hwrm_exec_fwd_resp_input_t, *phwrm_exec_fwd_resp_input_t;

/* hwrm_exec_fwd_resp_output (size:128b/16B) */

typedef struct hwrm_exec_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_exec_fwd_resp_output_t, *phwrm_exec_fwd_resp_output_t;

/************************
 * hwrm_reject_fwd_resp *
 ************************/


/* hwrm_reject_fwd_resp_input (size:1024b/128B) */

typedef struct hwrm_reject_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is an encapsulated request. This request should
	 * be rejected by the HWRM and the error response should be
	 * provided in the response buffer inside the encapsulated
	 * request.
	 */
	uint32_t	encap_request[26];
	/*
	 * This value indicates the target id of the response to
	 * the encapsulated request.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	uint8_t	unused_0[6];
} hwrm_reject_fwd_resp_input_t, *phwrm_reject_fwd_resp_input_t;

/* hwrm_reject_fwd_resp_output (size:128b/16B) */

typedef struct hwrm_reject_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_reject_fwd_resp_output_t, *phwrm_reject_fwd_resp_output_t;

/*****************
 * hwrm_fwd_resp *
 *****************/


/* hwrm_fwd_resp_input (size:1024b/128B) */

typedef struct hwrm_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value indicates the target id of the encapsulated
	 * response.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	/*
	 * This value indicates the completion ring the encapsulated
	 * response will be optionally completed on. If the value is
	 * -1, then no CR completion shall be generated for the
	 * encapsulated response. Any other value must be a
	 * valid CR ring_id value. If a valid encap_resp_cmpl_ring
	 * is provided, then a CR completion shall be generated for
	 * the encapsulated response.
	 */
	uint16_t	encap_resp_cmpl_ring;
	/* This field indicates the length of encapsulated response. */
	uint16_t	encap_resp_len;
	uint8_t	unused_0;
	uint8_t	unused_1;
	/*
	 * This is the host address where the encapsulated response
	 * will be written.
	 * This area must be 16B aligned and must be cleared to zero
	 * before the original request is made.
	 */
	uint64_t	encap_resp_addr;
	/* This is an encapsulated response. */
	uint32_t	encap_resp[24];
} hwrm_fwd_resp_input_t, *phwrm_fwd_resp_input_t;

/* hwrm_fwd_resp_output (size:128b/16B) */

typedef struct hwrm_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fwd_resp_output_t, *phwrm_fwd_resp_output_t;

/*****************************
 * hwrm_fwd_async_event_cmpl *
 *****************************/


/* hwrm_fwd_async_event_cmpl_input (size:320b/40B) */

typedef struct hwrm_fwd_async_event_cmpl_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value indicates the target id of the encapsulated
	 * asynchronous event.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - Broadcast to all children VFs (only applicable when
	 * a PF is the requester)
	 */
	uint16_t	encap_async_event_target_id;
	uint8_t	unused_0[6];
	/* This is an encapsulated asynchronous event completion. */
	uint32_t	encap_async_event_cmpl[4];
} hwrm_fwd_async_event_cmpl_input_t, *phwrm_fwd_async_event_cmpl_input_t;

/* hwrm_fwd_async_event_cmpl_output (size:128b/16B) */

typedef struct hwrm_fwd_async_event_cmpl_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fwd_async_event_cmpl_output_t, *phwrm_fwd_async_event_cmpl_output_t;

/***************************
 * hwrm_temp_monitor_query *
 ***************************/


/* hwrm_temp_monitor_query_input (size:128b/16B) */

typedef struct hwrm_temp_monitor_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_temp_monitor_query_input_t, *phwrm_temp_monitor_query_input_t;

/* hwrm_temp_monitor_query_output (size:192b/24B) */

typedef struct hwrm_temp_monitor_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The HWRM shall provide the current temperature of
	 * the device in Celsius. This is the max of PCIe_temp
	 * and PM_temp
	 */
	uint8_t	temp;
	/*
	 * The HWRM shall provide the current temperature of
	 * the phy in Celsius.
	 */
	uint8_t	phy_temp;
	/*
	 * The HWRM shall provide the current temperature of
	 * the module_index in Celsius.
	 */
	uint8_t	om_temp;
	/* Describe individual temperature sensor condition. */
	uint8_t	flags;
	/*
	 * "1" in this bit indicates temperature read not
	 * successful.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_TEMP_NOT_AVAILABLE		UINT32_C(0x1)
	/*
	 * "1" in this bit indicates phy temperature read not
	 * successful.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_PHY_TEMP_NOT_AVAILABLE	UINT32_C(0x2)
	/* "1" in this bit indicates optical module(s) not present. */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_OM_NOT_PRESENT		UINT32_C(0x4)
	/*
	 * "1" in this bit indicates om temperature read not
	 * successful.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_OM_TEMP_NOT_AVAILABLE	UINT32_C(0x8)
	/*
	 * "1" in this bit indicates the extended temperature fields are
	 * available.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_EXT_TEMP_FIELDS_AVAILABLE	UINT32_C(0x10)
	/*
	 * "1" in this bit indicates the thermal threshold values are
	 * available.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_THRESHOLD_VALUES_AVAILABLE	UINT32_C(0x20)
	/*
	 * This field encodes the current device temperature in Celsius.
	 * This field is unsigned and the value range of 0 to 255 is used to
	 * indicate a temperature range from -64 to +191. The actual
	 * temperature is derived by subtracting 64 from this field.
	 * Example: A value of 0 represents a temperature of -64, a value of
	 * 255 represents a temperature of 191.
	 */
	uint8_t	temp2;
	/*
	 * This field encodes the current phy temperature in Celsius. This
	 * field is unsigned and the value range of 0 to 255 is used to
	 * indicate a temperature range from -64 to +191. The actual
	 * temperature is derived by subtracting 64 from this field.
	 * Example: A value of 0 represents a temperature of -64, a value of
	 * 255 represents a temperature of 191.
	 */
	uint8_t	phy_temp2;
	/*
	 * This field encodes the current module index temperature in Celsius.
	 * This field is unsigned and the value range of 0 to 255 is used to
	 * indicate a temperature range from -64 to +191. The actual
	 * temperature is derived by subtracting 64 from this field.
	 * Example: A value of 0 represents a temperature of -64, a value of
	 * 255 represents a temperature of 191.
	 */
	uint8_t	om_temp2;
	/*
	 * This field reports the device's threshold value for reporting
	 * a warning indication. The temperature is reported in Celsius.
	 */
	uint8_t	warn_threshold;
	/*
	 * This field reports the device's threshold value for reporting
	 * a critical indication. The temperature is reported in Celsius.
	 */
	uint8_t	critical_threshold;
	/*
	 * This field reports the device's threshold value for reporting
	 * a fatal indication. The temperature is reported in Celsius.
	 */
	uint8_t	fatal_threshold;
	/*
	 * This field reports the threshold value at which the device will
	 * a perform a self shutdown. The temperature is reported in Celsius.
	 * If the value is zero, then that indicates self shutdown is not
	 * configured.
	 */
	uint8_t	shutdown_threshold;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_temp_monitor_query_output_t, *phwrm_temp_monitor_query_output_t;

/************************
 * hwrm_reg_power_query *
 ************************/


/* hwrm_reg_power_query_input (size:128b/16B) */

typedef struct hwrm_reg_power_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_reg_power_query_input_t, *phwrm_reg_power_query_input_t;

/* hwrm_reg_power_query_output (size:192b/24B) */

typedef struct hwrm_reg_power_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Describe availability of switching regulator power values. */
	uint32_t	flags;
	/* When this bit is set to '1', the input power is available. */
	#define HWRM_REG_POWER_QUERY_OUTPUT_FLAGS_IN_POWER_AVAILABLE	UINT32_C(0x1)
	/* When this bit is set to '1', the output power is available. */
	#define HWRM_REG_POWER_QUERY_OUTPUT_FLAGS_OUT_POWER_AVAILABLE	UINT32_C(0x2)
	/*
	 * The HWRM shall provide the current switching regulator
	 * input power in mW, if available.
	 */
	uint32_t	in_power_mw;
	/*
	 * The HWRM shall provide the current switching regulator
	 * output power in mW, if available.
	 */
	uint32_t	out_power_mw;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_reg_power_query_output_t, *phwrm_reg_power_query_output_t;

/*****************************
 * hwrm_core_frequency_query *
 *****************************/


/* hwrm_core_frequency_query_input (size:128b/16B) */

typedef struct hwrm_core_frequency_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_core_frequency_query_input_t, *phwrm_core_frequency_query_input_t;

/* hwrm_core_frequency_query_output (size:128b/16B) */

typedef struct hwrm_core_frequency_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The HWRM shall provide the core frequency in Hz. */
	uint32_t	core_frequency_hz;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_core_frequency_query_output_t, *phwrm_core_frequency_query_output_t;

/****************************
 * hwrm_reg_power_histogram *
 ****************************/


/* hwrm_reg_power_histogram_input (size:192b/24B) */

typedef struct hwrm_reg_power_histogram_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Describe operational mode of power histogram command. */
	uint32_t	flags;
	/*
	 * When this bit is set to '1', histogram data for the respective
	 * client (HWRM or BMC) is cleared after read.
	 */
	#define HWRM_REG_POWER_HISTOGRAM_INPUT_FLAGS_CLEAR_HISTOGRAM	UINT32_C(0x1)
	uint32_t	unused_0;
} hwrm_reg_power_histogram_input_t, *phwrm_reg_power_histogram_input_t;

/* hwrm_reg_power_histogram_output (size:1088b/136B) */

typedef struct hwrm_reg_power_histogram_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Describe output characteristics of power histogram command. */
	uint16_t	flags;
	/*
	 * Indicates whether input or output power is used. Some switching
	 * regulators provide both input and output voltage and current
	 * measurements, and others provide only output measurements. When
	 * both are available, input is used. This value is constant for a
	 * given board.
	 */
	#define HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT	UINT32_C(0x1)
	/*
	 * The switching regulator's input power is used
	 * data.
	 */
		#define HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT_INPUT   UINT32_C(0x0)
	/*
	 * The switching regulator's output power is used
	 * data.
	 */
		#define HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT_OUTPUT  UINT32_C(0x1)
		#define HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT_LAST   HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT_OUTPUT
	uint8_t	unused_0[2];
	/*
	 * Time in microseconds between samples. This value is constant in
	 * firmware. The initial design sets this constant at 10000 us (10
	 * ms). Power values for voltage regulators calculate a power value
	 * over a 300 us period, so a 10 ms sampling period covers 3% of
	 * time ranges. Future firmware designs may opt for different
	 * sampling periods, so this value is provided on output.
	 */
	uint32_t	sampling_period;
	/*
	 * Total samples taken since last clear. If no counter has
	 * saturated, the sum of counts in each bucket equates to this
	 * sample_count value. If a single counter has saturated, its value
	 * can be calculated by subtracting the remaining bucket values from
	 * this sample_count value.
	 */
	uint64_t	sample_count;
	/*
	 * The power usage expressed in histogram buckets. Bucket value
	 * ranges and array indices are defined per the enumeration
	 * power_histogram_bucket_enum. Values saturate at the max 32-bit
	 * value, 0xFFFFFFFF, and do not roll over. Clients should use the
	 * clear bit on input to clear the histogram array periodically or
	 * when saturation is observed.
	 */
	uint32_t	power_hist[26];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_reg_power_histogram_output_t, *phwrm_reg_power_histogram_output_t;

/*
 * Count of timer callback routines run with no data measured. This
 * may occur when data from the switching regulator is not available
 * to the firmware timer callback routine. One possible reason for
 * this is contention with other users of the i2c bus which is used
 * to communicate with the switching regulator, for example when a
 * call to hwrm_reg_power_query occurs while the timer routine is
 * running.
 */
#define BUCKET_NO_DATA_FOR_SAMPLE UINT32_C(0x0)
/* Count of samples measured at less than 8W */
#define BUCKET_RANGE_8W_OR_LESS   UINT32_C(0x1)
/* Count of samples measured >= 8 W and < 9 W */
#define BUCKET_RANGE_8W_TO_9W	UINT32_C(0x2)
/* Count of samples measured >= 9 W and < 10 W */
#define BUCKET_RANGE_9W_TO_10W	UINT32_C(0x3)
/* Count of samples measured >= 10 W and < 11 W */
#define BUCKET_RANGE_10W_TO_11W   UINT32_C(0x4)
/* Count of samples measured >= 11 W and < 12 W */
#define BUCKET_RANGE_11W_TO_12W   UINT32_C(0x5)
/* Count of samples measured >= 12 W and < 13 W */
#define BUCKET_RANGE_12W_TO_13W   UINT32_C(0x6)
/* Count of samples measured >= 13 W and < 14 W */
#define BUCKET_RANGE_13W_TO_14W   UINT32_C(0x7)
/* Count of samples measured >= 14 W and < 15 W */
#define BUCKET_RANGE_14W_TO_15W   UINT32_C(0x8)
/* Count of samples measured >= 15 W and < 16 W */
#define BUCKET_RANGE_15W_TO_16W   UINT32_C(0x9)
/* Count of samples measured >= 16 W and < 18 W */
#define BUCKET_RANGE_16W_TO_18W   UINT32_C(0xa)
/* Count of samples measured >= 18 W and < 20 W */
#define BUCKET_RANGE_18W_TO_20W   UINT32_C(0xb)
/* Count of samples measured >= 20 W and < 22 W */
#define BUCKET_RANGE_20W_TO_22W   UINT32_C(0xc)
/* Count of samples measured >= 22 W and < 24 W */
#define BUCKET_RANGE_22W_TO_24W   UINT32_C(0xd)
/* Count of samples measured >= 24 W and < 26 W */
#define BUCKET_RANGE_24W_TO_26W   UINT32_C(0xe)
/* Count of samples measured >= 26 W and < 28 W */
#define BUCKET_RANGE_26W_TO_28W   UINT32_C(0xf)
/* Count of samples measured >= 28 W and < 30 W */
#define BUCKET_RANGE_28W_TO_30W   UINT32_C(0x10)
/* Count of samples measured >= 30 W and < 32 W */
#define BUCKET_RANGE_30W_TO_32W   UINT32_C(0x11)
/* Count of samples measured >= 32 W and < 34 W */
#define BUCKET_RANGE_32W_TO_34W   UINT32_C(0x12)
/* Count of samples measured >= 34 W and < 36 W */
#define BUCKET_RANGE_34W_TO_36W   UINT32_C(0x13)
/* Count of samples measured >= 36 W and < 38 W */
#define BUCKET_RANGE_36W_TO_38W   UINT32_C(0x14)
/* Count of samples measured >= 38 W and < 40 W */
#define BUCKET_RANGE_38W_TO_40W   UINT32_C(0x15)
/* Count of samples measured >= 40 W and < 42 W */
#define BUCKET_RANGE_40W_TO_42W   UINT32_C(0x16)
/* Count of samples measured >= 42 W and < 44 W */
#define BUCKET_RANGE_42W_TO_44W   UINT32_C(0x17)
/* Count of samples measured >= 44 W and < 50 W */
#define BUCKET_RANGE_44W_TO_50W   UINT32_C(0x18)
/* Count of samples measured at 50 W or greater */
#define BUCKET_RANGE_OVER_50W	UINT32_C(0x19)
#define BUCKET_LAST		BUCKET_RANGE_OVER_50W


/*************************
 * hwrm_wol_filter_alloc *
 *************************/


/* hwrm_wol_filter_alloc_input (size:512b/64B) */

typedef struct hwrm_wol_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mac_address field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_MAC_ADDRESS	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pattern_offset field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_OFFSET	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the pattern_buf_size field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_BUF_SIZE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the pattern_buf_addr field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_BUF_ADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the pattern_mask_addr field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_MASK_ADDR	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the pattern_mask_size field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_MASK_SIZE	UINT32_C(0x20)
	/* Port ID of port on which WoL filter is configured. */
	uint16_t	port_id;
	/* This value represents a Wake-on-LAN type. */
	uint8_t	wol_type;
	/* Magic Packet */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_MAGICPKT UINT32_C(0x0)
	/* Bitmap */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_BMP	UINT32_C(0x1)
	/* Invalid */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_LAST	HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_INVALID
	uint8_t	unused_0[5];
	/*
	 * # If this field is enabled and magic packet WoL filter
	 * type is specified in this command, the value set in this
	 * field shall be used in setting the magic packet based
	 * WoL filter.
	 * # If this field is not enabled and magic packet WoL
	 * filter type is specified and port id is specified to
	 * 0xFF in this command, then the HWRM
	 * shall use default MAC address configured on the
	 * function associated with the HWRM client.
	 * # If this field is not enabled and magic packet WoL
	 * filter type is specified and port id is not specified to
	 * 0xFF in this command, then the HWRM
	 * shall use default MAC address configured on the port.
	 */
	uint8_t	mac_address[6];
	/*
	 * The offset from the beginning of MAC header where
	 * pattern should be matched.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_offset;
	/*
	 * The size of the pattern that is being matched.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_buf_size;
	/*
	 * The size of the pattern mask.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_mask_size;
	uint8_t	unused_1[4];
	/*
	 * Physical address of the pattern buffer.
	 * Applies to bitmap WoL.
	 */
	uint64_t	pattern_buf_addr;
	/*
	 * Physical address of the pattern mask.
	 * Applies to bitmap WoL.
	 */
	uint64_t	pattern_mask_addr;
} hwrm_wol_filter_alloc_input_t, *phwrm_wol_filter_alloc_input_t;

/* hwrm_wol_filter_alloc_output (size:128b/16B) */

typedef struct hwrm_wol_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value identifies a Wake-on-LAN (WoL) filter. */
	uint8_t	wol_filter_id;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_wol_filter_alloc_output_t, *phwrm_wol_filter_alloc_output_t;

/************************
 * hwrm_wol_filter_free *
 ************************/


/* hwrm_wol_filter_free_input (size:256b/32B) */

typedef struct hwrm_wol_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * # When this bit is set to '1', then all active WoL
	 * filters on the port are requested to be freed.
	 * # If the a function driver sets this flag to '1', then
	 * the HWRM shall free all active WoL filters that are not
	 * set by other function drivers on that port.
	 */
	#define HWRM_WOL_FILTER_FREE_INPUT_FLAGS_FREE_ALL_WOL_FILTERS	UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the wol_filter_id field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_FREE_INPUT_ENABLES_WOL_FILTER_ID	UINT32_C(0x1)
	/* Port ID of the port on which WoL filter(s) is (are) being freed. */
	uint16_t	port_id;
	/*
	 * The HWRM shall ignore this field if free_all_wol_filters
	 * flag is set.
	 */
	uint8_t	wol_filter_id;
	uint8_t	unused_0[5];
} hwrm_wol_filter_free_input_t, *phwrm_wol_filter_free_input_t;

/* hwrm_wol_filter_free_output (size:128b/16B) */

typedef struct hwrm_wol_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_wol_filter_free_output_t, *phwrm_wol_filter_free_output_t;

/************************
 * hwrm_wol_filter_qcfg *
 ************************/


/* hwrm_wol_filter_qcfg_input (size:448b/56B) */

typedef struct hwrm_wol_filter_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port on which WoL filter that is being queried. */
	uint16_t	port_id;
	/*
	 * This is an opaque handle used to access filters.
	 * # The HWRM client shall set this field to 0x0000 to begin
	 * the query.
	 * # After the first query, the HWRM client shall retrieve
	 * next filters (if they exist) using the HWRM provided handle
	 * in the response.
	 */
	uint16_t	handle;
	uint8_t	unused_0[4];
	/*
	 * Physical address of the pattern buffer.
	 * Applies to bitmap WoL filter only.
	 * # Value of 0 indicates an invalid buffer address.
	 * If this field is set to 0, then HWRM shall ignore
	 * pattern_buf_size.
	 * # If the HWRM client provides an invalid buffer address
	 * for the pattern, then the HWRM is not required to
	 * provide pattern when the response contains a bitmap WoL
	 * filter.
	 */
	uint64_t	pattern_buf_addr;
	/*
	 * The size of the pattern buffer.
	 * Applies to bitmap WoL filter only.
	 */
	uint16_t	pattern_buf_size;
	uint8_t	unused_1[6];
	/*
	 * Physical address of the pattern mask.
	 * Applies to bitmap WoL filter only.
	 * # Value of 0 indicates an invalid pattern mask address.
	 * If this field is set to 0, then HWRM shall ignore
	 * pattern_mask_size.
	 * # If the HWRM client provides an invalid mask address
	 * for the pattern, then the HWRM is not required to
	 * provide mask when the response contains a bitmap WoL
	 * filter.
	 */
	uint64_t	pattern_mask_addr;
	/*
	 * The size of the buffer for pattern mask.
	 * Applies to bitmap WoL filter only.
	 */
	uint16_t	pattern_mask_size;
	uint8_t	unused_2[6];
} hwrm_wol_filter_qcfg_input_t, *phwrm_wol_filter_qcfg_input_t;

/* hwrm_wol_filter_qcfg_output (size:256b/32B) */

typedef struct hwrm_wol_filter_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the next handle that is used to access filters.
	 * # If this field is set to 0x0000, then no WoL filters are
	 * currently configured on this port and all other fields in
	 * the output shall be ignored by the HWRM client.
	 * # If this field is set to neither 0x0000 nor 0xFFFF, then the
	 * wol_filter_id is valid and the parameters provided in the
	 * response are based on the wol_type.
	 * # If this field is set to 0xFFFF, then there are no remaining
	 * configured WoL filters to be queried for the queried function
	 * after this response, wol_filter_id is valid and the parameters
	 * provided in the response are based on the wol_type.
	 */
	uint16_t	next_handle;
	/*
	 * This value identifies the filter returned in this
	 * response.
	 */
	uint8_t	wol_filter_id;
	/*
	 * This value identifies the type of WoL filter returned
	 * in this response.
	 */
	uint8_t	wol_type;
	/* Magic Packet */
	#define HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_MAGICPKT UINT32_C(0x0)
	/* Bitmap */
	#define HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_BMP	UINT32_C(0x1)
	/* Invalid */
	#define HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_LAST	HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_INVALID
	uint32_t	unused_0;
	/*
	 * The MAC address value used by the WoL filter.
	 * Applies to magic packet based WoL.
	 */
	uint8_t	mac_address[6];
	/*
	 * The offset from the beginning of MAC header where
	 * pattern should be matched.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_offset;
	/*
	 * The actual size of the pattern that is being returned.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_size;
	/*
	 * The actual size of the pattern mask that is being returned.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_mask_size;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_wol_filter_qcfg_output_t, *phwrm_wol_filter_qcfg_output_t;

/************************
 * hwrm_wol_reason_qcfg *
 ************************/


/* hwrm_wol_reason_qcfg_input (size:320b/40B) */

typedef struct hwrm_wol_reason_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port for which this query is for. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
	/*
	 * Physical address of the packet buffer for querying
	 * WoL packet.
	 */
	uint64_t	wol_pkt_buf_addr;
	/* The size of the buffer for the WoL packet. */
	uint16_t	wol_pkt_buf_size;
	uint8_t	unused_1[6];
} hwrm_wol_reason_qcfg_input_t, *phwrm_wol_reason_qcfg_input_t;

/* hwrm_wol_reason_qcfg_output (size:128b/16B) */

typedef struct hwrm_wol_reason_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value identifies the filter that matched
	 * the last WoL packet.
	 * This id is only valid with valid WoL reason.
	 */
	uint8_t	wol_filter_id;
	/*
	 * This value identifies the type of WoL reason returned
	 * in this response.
	 * When the wol_type is set to invalid, then there is
	 * no WoL event that happened during last system
	 * wake-up.
	 */
	uint8_t	wol_reason;
	/* Magic Packet */
	#define HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_MAGICPKT UINT32_C(0x0)
	/* Bitmap */
	#define HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_BMP	UINT32_C(0x1)
	/* Invalid */
	#define HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_INVALID  UINT32_C(0xff)
	#define HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_LAST	HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_INVALID
	/* The value identifies the length of the WoL packet in bytes. */
	uint8_t	wol_pkt_len;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_wol_reason_qcfg_output_t, *phwrm_wol_reason_qcfg_output_t;

/************************
 * hwrm_dbg_read_direct *
 ************************/


/* hwrm_dbg_read_direct_input (size:256b/32B) */

typedef struct hwrm_dbg_read_direct_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * host address where the data content will be written
	 * when the request is complete. This area must be 16B aligned.
	 */
	uint64_t	host_dest_addr;
	/* address(in ChiMP view) to start reading */
	uint32_t	read_addr;
	/* number of dwords to read */
	uint32_t	read_len32;
} hwrm_dbg_read_direct_input_t, *phwrm_dbg_read_direct_input_t;

/* hwrm_dbg_read_direct_output (size:128b/16B) */

typedef struct hwrm_dbg_read_direct_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field, if not zero, contains the IEEE 802.3 CRC-32 checksum of
	 * the number of dwords read in this request using this polynomial:
	 * x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1
	 */
	uint32_t	crc32;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_read_direct_output_t, *phwrm_dbg_read_direct_output_t;

/*************************
 * hwrm_dbg_write_direct *
 *************************/


/* hwrm_dbg_write_direct_input (size:448b/56B) */

typedef struct hwrm_dbg_write_direct_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* address(in ChiMP view) to start writing */
	uint32_t	write_addr;
	/* number of dwords to write (up to 8 dwords) */
	uint32_t	write_len32;
	/* write data (up to 8 dwords) */
	uint32_t	write_data[8];
} hwrm_dbg_write_direct_input_t, *phwrm_dbg_write_direct_input_t;

/* hwrm_dbg_write_direct_output (size:128b/16B) */

typedef struct hwrm_dbg_write_direct_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_write_direct_output_t, *phwrm_dbg_write_direct_output_t;

/**************************
 * hwrm_dbg_read_indirect *
 **************************/


/* hwrm_dbg_read_indirect_input (size:640b/80B) */

typedef struct hwrm_dbg_read_indirect_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * host address where the data content will be written
	 * when the request is complete. This area must be 16B aligned.
	 */
	uint64_t	host_dest_addr;
	/* Length of host buffer used for transferring debug data. */
	uint32_t	host_dest_addr_len;
	/* Indirect access type to on-chip data structures. */
	uint8_t	indirect_access_type;
	/* L2 Mgmt filters in Transmit Engine (TE) */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_TE_MGMT_FILTERS_L2	UINT32_C(0x0)
	/* L3/L4 Mgmt filters in Transmit Engine (TE) */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_TE_MGMT_FILTERS_L3L4	UINT32_C(0x1)
	/* L2 Mgmt filters in Receive Engine (RE) */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_RE_MGMT_FILTERS_L2	UINT32_C(0x2)
	/* L3/L4 Mgmt filters in Receive Engine (RE) */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_RE_MGMT_FILTERS_L3L4	UINT32_C(0x3)
	/* Statistics contexts */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_STAT_CTXS		UINT32_C(0x4)
	/* TX L2 TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_L2_TCAM		UINT32_C(0x5)
	/* RX L2 TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_L2_TCAM		UINT32_C(0x6)
	/* TX IPv6 subnet TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_IPV6_SUBNET_TCAM	UINT32_C(0x7)
	/* RX IPv6 subnet TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_IPV6_SUBNET_TCAM	UINT32_C(0x8)
	/* TX source properties TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_SRC_PROPERTIES_TCAM UINT32_C(0x9)
	/* RX source properties TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_SRC_PROPERTIES_TCAM UINT32_C(0xa)
	/* VEB Lookup TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_VEB_LOOKUP_TCAM	UINT32_C(0xb)
	/* TX Profile Lookup TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_PROFILE_LOOKUP_TCAM UINT32_C(0xc)
	/* RX Profile Lookup TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_PROFILE_LOOKUP_TCAM UINT32_C(0xd)
	/* TX Lookup TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_LOOKUP_TCAM	UINT32_C(0xe)
	/* RX Lookup TCAM */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_LOOKUP_TCAM	UINT32_C(0xf)
	/* MHB registers (valid for multi-host environment) */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_MHB			UINT32_C(0x10)
	/* PCIE global registers (valid for multi-host environment) */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_PCIE_GBL		UINT32_C(0x11)
	/* SOC registers (valid for multi-host environment) */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_MULTI_HOST_SOC		UINT32_C(0x12)
	/* PCIE private registers */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_PCIE_PRIVATE		UINT32_C(0x13)
	/* Host DMA read */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_HOST_DMA		UINT32_C(0x14)
	/*
	 * Elog (valid for only smartNIC only)
	 * Three sub-types will be supported which will be specified
	 * in the opaque[0] field.
	 * 1) sub-type CHECK(0) if ELOG is available in media.
	 * 2) sub-type READ(1) a portion of the elog.
	 * 3) sub-type ERASE(2) a portion of the elog.
	 *	> opaque[1] Erase offset.
	 *	> opaque[2] Erase size.
	 */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_SOC_ELOG		UINT32_C(0x15)
	/* Context operation */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CTX			UINT32_C(0x16)
	/* Port Stats */
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_STATS			UINT32_C(0x17)
	#define HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_LAST			HWRM_DBG_READ_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_STATS
	uint8_t	unused_0[3];
	/* Entry number to start reading */
	uint32_t	start_index;
	/* Total number of entries to read */
	uint32_t	num_of_entries;
	/*
	 * command dependent data (e.g. function id for host dma command or
	 * sub-code, erase offset and erase size for soc_elog)
	 */
	uint32_t	opaque[10];
} hwrm_dbg_read_indirect_input_t, *phwrm_dbg_read_indirect_input_t;

/* hwrm_dbg_read_indirect_output (size:128b/16B) */

typedef struct hwrm_dbg_read_indirect_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_read_indirect_output_t, *phwrm_dbg_read_indirect_output_t;

/***************************
 * hwrm_dbg_write_indirect *
 ***************************/


/* hwrm_dbg_write_indirect_input (size:832b/104B) */

typedef struct hwrm_dbg_write_indirect_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Indirect access type to on-chip data structures. */
	uint8_t	indirect_access_type;
	/* L2 Mgmt filters in Transmit Engine (TE) */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_TE_MGMT_FILTERS_L2	UINT32_C(0x0)
	/* L3/L4 Mgmt filters in Transmit Engine (TE) */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_TE_MGMT_FILTERS_L3L4	UINT32_C(0x1)
	/* L2 Mgmt filters in Receive Engine (RE) */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_RE_MGMT_FILTERS_L2	UINT32_C(0x2)
	/* L3/L4 Mgmt filters in Receive Engine (RE) */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_RE_MGMT_FILTERS_L3L4	UINT32_C(0x3)
	/* Statistics contexts */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_STAT_CTXS		UINT32_C(0x4)
	/* TX L2 TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_L2_TCAM		UINT32_C(0x5)
	/* RX L2 TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_L2_TCAM		UINT32_C(0x6)
	/* TX IPv6 subnet TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_IPV6_SUBNET_TCAM	UINT32_C(0x7)
	/* RX IPv6 subnet TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_IPV6_SUBNET_TCAM	UINT32_C(0x8)
	/* TX source properties TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_SRC_PROPERTIES_TCAM UINT32_C(0x9)
	/* RX source properties TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_SRC_PROPERTIES_TCAM UINT32_C(0xa)
	/* VEB Lookup TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_VEB_LOOKUP_TCAM	UINT32_C(0xb)
	/* TX Profile Lookup TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_PROFILE_LOOKUP_TCAM UINT32_C(0xc)
	/* RX Profile Lookup TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_PROFILE_LOOKUP_TCAM UINT32_C(0xd)
	/* TX Lookup TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_TX_LOOKUP_TCAM	UINT32_C(0xe)
	/* RX Lookup TCAM */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CFA_RX_LOOKUP_TCAM	UINT32_C(0xf)
	/* MHB registers (valid for multi-host environment) */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_MHB			UINT32_C(0x10)
	/* PCIE global registers (valid for multi-host environment) */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_PCIE_GBL		UINT32_C(0x11)
	/* SOC registers (valid for multi-host environment) */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_MULTI_HOST_SOC		UINT32_C(0x12)
	/* PCIE private registers */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_PCIE_PRIVATE		UINT32_C(0x13)
	/* Host DMA write */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_HOST_DMA		UINT32_C(0x14)
	/* Invalid */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_SOC_ELOG		UINT32_C(0x15)
	/* Context operation */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_CTX			UINT32_C(0x16)
	/* Port Stats */
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_STATS			UINT32_C(0x17)
	#define HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_LAST			HWRM_DBG_WRITE_INDIRECT_INPUT_INDIRECT_ACCESS_TYPE_STATS
	uint8_t	unused_0[3];
	/* Entry number to start reading */
	uint32_t	start_index;
	/* Total number of entries to read */
	uint32_t	num_of_entries;
	uint8_t	unused_1[4];
	/* write data (up to 8 dwords) */
	uint32_t	write_data[8];
	/* command dependent data (e.g. function id for host dma command) */
	uint32_t	opaque[10];
} hwrm_dbg_write_indirect_input_t, *phwrm_dbg_write_indirect_input_t;

/* hwrm_dbg_write_indirect_output (size:128b/16B) */

typedef struct hwrm_dbg_write_indirect_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_write_indirect_output_t, *phwrm_dbg_write_indirect_output_t;

/*****************
 * hwrm_dbg_dump *
 *****************/


/* hwrm_dbg_dump_input (size:320b/40B) */

typedef struct hwrm_dbg_dump_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Handle used to dump debug data.
	 * handle = 0 indicates the beginning of the dump.
	 * handle != 0 indicates the request to dump the next part.
	 */
	uint32_t	handle;
	uint8_t	unused_0[4];
	/*
	 * Address of the host buffer where the debug data is
	 * requested to be dumped.
	 */
	uint64_t	host_dbg_dump_addr;
	/* Length of host buffer used for transferring debug data. */
	uint64_t	host_dbg_dump_addr_len;
} hwrm_dbg_dump_input_t, *phwrm_dbg_dump_input_t;

/* hwrm_dbg_dump_output (size:192b/24B) */

typedef struct hwrm_dbg_dump_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Handle used to indicate availability of additional
	 * debug data.
	 * nexthandle = 0 indicates that there is no more debug data
	 * available.
	 * nexthandle != 0 indicates the handle value that should be used
	 * to request the next part of debug data.
	 */
	uint32_t	nexthandle;
	/*
	 * The number of bytes of debug data written to debug dump
	 * buffer.
	 */
	uint32_t	dbg_data_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_dump_output_t, *phwrm_dbg_dump_output_t;

/**********************
 * hwrm_dbg_erase_nvm *
 **********************/


/* hwrm_dbg_erase_nvm_input (size:192b/24B) */

typedef struct hwrm_dbg_erase_nvm_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* If set to 1, then erase all locations in persistent storage. */
	#define HWRM_DBG_ERASE_NVM_INPUT_FLAGS_ERASE_ALL		UINT32_C(0x1)
	/*
	 * This bit is only used when external secure SoC is used for
	 * Secure boot. This bit is utilized to differentiate between
	 * erase for NIC or Security SoC non-volatile storage on the
	 * device. If this bit is set, then erases all locations in the
	 * persistent storage of the secure SoC non-volatile storage device.
	 */
	#define HWRM_DBG_ERASE_NVM_INPUT_FLAGS_SECURITY_SOC_NVM	UINT32_C(0x2)
	uint8_t	unused_0[6];
} hwrm_dbg_erase_nvm_input_t, *phwrm_dbg_erase_nvm_input_t;

/* hwrm_dbg_erase_nvm_output (size:128b/16B) */

typedef struct hwrm_dbg_erase_nvm_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_erase_nvm_output_t, *phwrm_dbg_erase_nvm_output_t;

/****************
 * hwrm_dbg_cfg *
 ****************/


/* hwrm_dbg_cfg_input (size:192b/24B) */

typedef struct hwrm_dbg_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * If set to 1, then UART logging will be enabled for the primary
	 * firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_CFG_INPUT_FLAGS_UART_LOG		UINT32_C(0x1)
	/*
	 * If set to 1, then UART logging will be enabled for the secondary
	 * firmware. Disabled otherwise. If a single UART is available then
	 * setting this bit will override the uart_log bit.
	 */
	#define HWRM_DBG_CFG_INPUT_FLAGS_UART_LOG_SECONDARY	UINT32_C(0x2)
	/*
	 * If set to 1, then completion ring logging will be enabled for the
	 * primary firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_CFG_INPUT_FLAGS_FW_TRACE		UINT32_C(0x4)
	/*
	 * If set to 1, then completion ring logging will be enabled for the
	 * secondary firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_CFG_INPUT_FLAGS_FW_TRACE_SECONDARY	UINT32_C(0x8)
	/*
	 * If set to 1, firmware will generate debug_notification async
	 * events to the driver as applicable.
	 */
	#define HWRM_DBG_CFG_INPUT_FLAGS_DEBUG_NOTIFY	UINT32_C(0x10)
	/*
	 * If set to 1, firmware is allowed to be unresponsive to heartbeat
	 * health checks, allowing for JTAG debugging scenarios where the
	 * debugger has the firmware processes stopped indefinitely. This
	 * flag has effect only on debug builds of firmware.
	 */
	#define HWRM_DBG_CFG_INPUT_FLAGS_JTAG_DEBUG		UINT32_C(0x20)
	/*
	 * Notification queue (completion ring) used by the firmware to post
	 * async debug notifications and fw trace logs. This field is valid
	 * when fw_trace, fw_trace_secondary or debug_notify flags are set.
	 */
	uint16_t	async_cmpl_ring;
	uint8_t	unused_0[2];
} hwrm_dbg_cfg_input_t, *phwrm_dbg_cfg_input_t;

/* hwrm_dbg_cfg_output (size:128b/16B) */

typedef struct hwrm_dbg_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_cfg_output_t, *phwrm_dbg_cfg_output_t;

/*****************************
 * hwrm_dbg_crashdump_header *
 *****************************/


/* hwrm_dbg_crashdump_header_input (size:192b/24B) */

typedef struct hwrm_dbg_crashdump_header_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint64_t	unused_0;
} hwrm_dbg_crashdump_header_input_t, *phwrm_dbg_crashdump_header_input_t;

/* hwrm_dbg_crashdump_header_output (size:512b/64B) */

typedef struct hwrm_dbg_crashdump_header_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Major version. */
	uint8_t	version_hi;
	/* Minor version. */
	uint8_t	version_low;
	/*
	 * Header length in bytes. This includes all fields from version
	 * to dev_uid (whose length is specified in dev_uid_length).
	 */
	uint16_t	header_len;
	/* This is the crash dump size in bytes. */
	uint32_t	dump_size;
	/*
	 * This is a "wall clock" timestamp value of when the crash occurred.
	 * Format is of time_t type.
	 */
	uint32_t	crash_time;
	/* This is the timezone information for the crash_time. */
	int8_t	utc_offset;
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_UTC				0
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMSTERDAM			4
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_EGYPT			8
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_EUROPE_MOSCOW		12
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_IRAN			14
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_DUBAI			16
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_KABUL			18
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ANTARCTICA_MAWSON		20
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_COLOMBO		22
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_KATHMANDU		23
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_INDIAN_CHAGOS		24
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_INDIAN_COCOS		26
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_BANGKOK		28
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_HONG_KONG		32
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_PYONGYANG		34
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_EUCLA		35
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_TOKYO			36
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_ADELAIDE		38
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_BROKEN_HILL	38
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_DARWIN		38
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_SYDNEY		40
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_LORD_HOWE		42
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ANTARCTICA_MACQUARIE	44
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ANTARCTICA_SOUTH_POLE	48
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_CHATHAM		51
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_APIA		52
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_KIRITIMATIS		56
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ATLANTIC_CAPE_VERDE		-4
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ATLANTIC_SOUTH_GEORGIA	-8
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_ARGENTINA_BUENOS_AIRES -12
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_SAO_PAULO		-12
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_NEWFOUNDLAND	-14
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_BARBADOS		-16
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_CANCUN		-20
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_COSTA_RICA		-24
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_PHOENIX		-28
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_US_ARIZONA			-28
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_US_PACIFIC			-32
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_US_ALASKA			-36
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_MARQUESAS		-38
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_HAWAII		-40
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_MIDWAY		-44
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_LAST			HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_MIDWAY
	/*
	 * This field is a counter value of the crash dump available. This
	 * value is incremented monotonically at each crash.
	 */
	uint8_t	crash_cntr;
	/*
	 * This specifies the length of the dev_uid in bytes. The maximum
	 * value is 31.
	 */
	uint16_t	dev_uid_length;
	/*
	 * This is a unique device identifier (e.g. the first port MAC
	 * address for a network controller or a serial number for an
	 * en/decryption device) in ASCII format. It is used to identify
	 * where the crash dump content is coming from. Unused bytes must
	 * have '\0' character.
	 */
	uint8_t	dev_uid[32];
	/*
	 * This is a count value tracking the number of successful boots
	 * before the crash occurred.
	 */
	uint32_t	power_on_count;
	uint8_t	unused_2[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_crashdump_header_output_t, *phwrm_dbg_crashdump_header_output_t;

/****************************
 * hwrm_dbg_crashdump_erase *
 ****************************/


/* hwrm_dbg_crashdump_erase_input (size:192b/24B) */

typedef struct hwrm_dbg_crashdump_erase_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The scope of the erase */
	uint8_t	scope;
	/*
	 * Wipe all crashdump data blocks, making them available for
	 * the next crash(es). This is the typical value to be used.
	 */
	#define HWRM_DBG_CRASHDUMP_ERASE_INPUT_SCOPE_INVALIDATE UINT32_C(0x0)
	/*
	 * Experimental: Remove all data blocks from the directory
	 * (without erasing any existing contents), re-allocate and
	 * re-initialize new ones. In case where the crash dump feature
	 * stops functioning, this can be used to restore it back to the
	 * clean slate.
	 */
	#define HWRM_DBG_CRASHDUMP_ERASE_INPUT_SCOPE_REINIT	UINT32_C(0x1)
	#define HWRM_DBG_CRASHDUMP_ERASE_INPUT_SCOPE_LAST	HWRM_DBG_CRASHDUMP_ERASE_INPUT_SCOPE_REINIT
	uint8_t	unused_0[3];
	uint32_t	unused_1;
} hwrm_dbg_crashdump_erase_input_t, *phwrm_dbg_crashdump_erase_input_t;

/* hwrm_dbg_crashdump_erase_output (size:128b/16B) */

typedef struct hwrm_dbg_crashdump_erase_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_crashdump_erase_output_t, *phwrm_dbg_crashdump_erase_output_t;

/******************
 * hwrm_dbg_qcaps *
 ******************/


/* hwrm_dbg_qcaps_input (size:192b/24B) */

typedef struct hwrm_dbg_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_dbg_qcaps_input_t, *phwrm_dbg_qcaps_input_t;

/* hwrm_dbg_qcaps_output (size:192b/24B) */

typedef struct hwrm_dbg_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value. This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/*
	 * Bitwise field of components FW supports skipping during collection
	 * of coredump as part of a crash collection.
	 */
	uint32_t	coredump_component_disable_caps;
	/*
	 * If 1, FW supports disabling the collection of NVM during a
	 * coredump taken as part of crash collection.
	 */
	#define HWRM_DBG_QCAPS_OUTPUT_COREDUMP_COMPONENT_DISABLE_CAPS_NVRAM	UINT32_C(0x1)
	uint32_t	flags;
	/* If 1, FW supports writing a crashdump to NVM. */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_CRASHDUMP_NVM		UINT32_C(0x1)
	/* If 1, FW supports writing a crashdump to host ddr. */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_CRASHDUMP_HOST_DDR	UINT32_C(0x2)
	/* If 1, FW supports writing a crashdump to soc ddr. */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_CRASHDUMP_SOC_DDR	UINT32_C(0x4)
	/* If 1, FW supports USEQ operations */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_USEQ			UINT32_C(0x8)
	/*
	 * If 1, FW supports writing a coredump to host ddr.
	 * The driver instance can allocate the Host memory to
	 * capture coredump.
	 */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_COREDUMP_HOST_DDR	UINT32_C(0x10)
	/*
	 * If 1, FW supports HWRM_DBG_COREDUMP_CAPTURE command to collect the
	 * coredump into the Host memory address. The driver instance can
	 * invoke the command to collect coredump upon any fatal event.
	 * Tx timeout is an example scenario.
	 */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_COREDUMP_HOST_CAPTURE	UINT32_C(0x20)
	/*
	 * If 1, FW supports the PTrace capability.PTrace(PEX Trace Capture)
	 * provides a means for capturing and buffering PCIe TLPs, DLLPs and
	 * ordered sets following in both directions through a PEX station.
	 * This capability is advertised only on PF's.
	 */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_PTRACE			UINT32_C(0x40)
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_qcaps_output_t, *phwrm_dbg_qcaps_output_t;

/*****************
 * hwrm_dbg_qcfg *
 *****************/


/* hwrm_dbg_qcfg_input (size:192b/24B) */

typedef struct hwrm_dbg_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint16_t	flags;
	/*
	 * The crashdump size represents size of crashdump
	 * written to the specified destination.
	 */
	#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_MASK	UINT32_C(0x3)
	#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_SFT	0
	/* crashdump size written to nvm */
		#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_NVM	UINT32_C(0x0)
	/* crashdump size written to host_ddr */
		#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_HOST_DDR  UINT32_C(0x1)
	/* crashdump size written to soc_ddr */
		#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_SOC_DDR   UINT32_C(0x2)
		#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_LAST	HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_SOC_DDR
	/*
	 * Bitwise field of components requested for FW to skip when
	 * calculating the size of a coredump collection.
	 */
	uint32_t	coredump_component_disable_flags;
	/*
	 * If 1, NVM will not be collected during a coredump taken as part
	 * of crash collection.
	 */
	#define HWRM_DBG_QCFG_INPUT_COREDUMP_COMPONENT_DISABLE_FLAGS_NVRAM	UINT32_C(0x1)
} hwrm_dbg_qcfg_input_t, *phwrm_dbg_qcfg_input_t;

/* hwrm_dbg_qcfg_output (size:256b/32B) */

typedef struct hwrm_dbg_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value. This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/*
	 * Size in bytes of a coredump file created by the FW. This takes into
	 * consideration any components selected in the
	 * coredump_component_disable_flags field from hwrm_dbg_qcfg_input.
	 */
	uint32_t	coredump_size;
	uint32_t	flags;
	/*
	 * If set to 1, then UART logging is enabled for the primary
	 * firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_UART_LOG		UINT32_C(0x1)
	/*
	 * If set to 1, then UART logging is enabled for the secondary
	 * firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_UART_LOG_SECONDARY	UINT32_C(0x2)
	/*
	 * If set to 1, then completion ring logging is enabled for the
	 * primary firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_FW_TRACE		UINT32_C(0x4)
	/*
	 * If set to 1, then completion ring logging is enabled for the
	 * secondary firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_FW_TRACE_SECONDARY	UINT32_C(0x8)
	/*
	 * If set to 1, firmware will generate debug_notification async
	 * events to the driver as applicable.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_DEBUG_NOTIFY	UINT32_C(0x10)
	/*
	 * If set to 1, firmware is allowed to be unresponsive to heartbeat
	 * health checks, allowing for JTAG debugging scenarios where the
	 * debugger has the firmware processes stopped indefinitely. This
	 * flag has effect only on debug builds of firmware.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_JTAG_DEBUG		UINT32_C(0x20)
	/*
	 * Notification queue (completion ring) used by the firmware to post
	 * async debug notifications and fw trace logs. This field is valid
	 * when fw_trace, fw_trace_secondary or debug_notify flags are set.
	 */
	uint16_t	async_cmpl_ring;
	uint8_t	unused_2[2];
	/*
	 * Size in bytes of a crashdump file created by the FW. Uses input
	 * flags to determine medium destination and corresponding size.
	 */
	uint32_t	crashdump_size;
	uint8_t	unused_3[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_qcfg_output_t, *phwrm_dbg_qcfg_output_t;

/*********************************
 * hwrm_dbg_crashdump_medium_cfg *
 *********************************/


/* hwrm_dbg_crashdump_medium_cfg_input (size:320b/40B) */

typedef struct hwrm_dbg_crashdump_medium_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	output_dest_flags;
	/* Destination is DDR ram. */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_TYPE_DDR	UINT32_C(0x1)
	uint16_t	pg_size_lvl;
	/* PBL indirect levels. */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_MASK	UINT32_C(0x3)
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LAST	HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LVL_2
	/* page size. */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_MASK  UINT32_C(0x1c)
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_SFT   2
	/* 4KB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_4K   (UINT32_C(0x0) << 2)
	/* 8KB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_8K   (UINT32_C(0x1) << 2)
	/* 64KB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_64K  (UINT32_C(0x2) << 2)
	/* 2MB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_2M   (UINT32_C(0x3) << 2)
	/* 8MB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_8M   (UINT32_C(0x4) << 2)
	/* 1GB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_1G   (UINT32_C(0x5) << 2)
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_LAST   HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_1G
	/* unused11 is 11 b */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_UNUSED11_MASK UINT32_C(0xffe0)
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_UNUSED11_SFT  5
	/* Crashdump buffer size. */
	uint32_t	size;
	/*
	 * Bitwise field of components that FW is requested to skip during
	 * coredump as part of a crash collection.
	 */
	uint32_t	coredump_component_disable_flags;
	/*
	 * If 1, then NVM will not be collected during a coredump taken as
	 * part of crash collection.
	 */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_NVRAM	UINT32_C(0x1)
	uint32_t	unused_0;
	/* Crashdump buffer PBL physical address. */
	uint64_t	pbl;
} hwrm_dbg_crashdump_medium_cfg_input_t, *phwrm_dbg_crashdump_medium_cfg_input_t;

/* hwrm_dbg_crashdump_medium_cfg_output (size:128b/16B) */

typedef struct hwrm_dbg_crashdump_medium_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_crashdump_medium_cfg_output_t, *phwrm_dbg_crashdump_medium_cfg_output_t;

/* coredump_segment_record (size:128b/16B) */

typedef struct coredump_segment_record {
	/* Component id of the returned component. */
	uint16_t	component_id;
	/* Segment id of the returned component. */
	uint16_t	segment_id;
	/* Not used. */
	uint16_t	max_instances;
	/* Major version. */
	uint8_t	version_hi;
	/* Minor version. */
	uint8_t	version_low;
	/*
	 * bit 0: live data
	 * bit 1: crashed data
	 */
	uint8_t	seg_flags;
	/* This field is used to indicate the segment is compressed. */
	uint8_t	compress_flags;
	/*
	 * SFLAG_COMPRESSED_ZLIB indicates that the segment data is
	 * compressed.
	 */
	#define SFLAG_COMPRESSED_ZLIB	UINT32_C(0x1)
	uint8_t	unused_0[2];
	/*
	 * This field is the length of the segment data. It will be zero if
	 * the firmware does not support returning the segment data length.
	 */
	uint32_t	segment_len;
} coredump_segment_record_t, *pcoredump_segment_record_t;

/**************************
 * hwrm_dbg_coredump_list *
 **************************/


/* hwrm_dbg_coredump_list_input (size:256b/32B) */

typedef struct hwrm_dbg_coredump_list_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * host address where the data content will be written
	 * when the request is complete. This area must be 16B aligned.
	 */
	uint64_t	host_dest_addr;
	/* Length of host buffer used for transferring debug data. */
	uint32_t	host_buf_len;
	/* Sequence number of the request. Starts at 0. */
	uint16_t	seq_no;
	/*  */
	uint8_t	flags;
	/*
	 * If set to 1, crash dump is requested.
	 * If set to 0, both live core and crash dump are requested.
	 */
	#define HWRM_DBG_COREDUMP_LIST_INPUT_FLAGS_CRASHDUMP	UINT32_C(0x1)
	uint8_t	unused_0[1];
} hwrm_dbg_coredump_list_input_t, *phwrm_dbg_coredump_list_input_t;

/* hwrm_dbg_coredump_list_output (size:128b/16B) */

typedef struct hwrm_dbg_coredump_list_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/*
	 * Value of 1 means that there is more data available.
	 * Issue the request again with the next sequence number.
	 */
	#define HWRM_DBG_COREDUMP_LIST_OUTPUT_FLAGS_MORE	UINT32_C(0x1)
	uint8_t	unused_0;
	/* Total number of segments to be returned. */
	uint16_t	total_segments;
	/* Actual length of data returned in bytes. */
	uint16_t	data_len;
	uint8_t	unused_1;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_coredump_list_output_t, *phwrm_dbg_coredump_list_output_t;

/******************************
 * hwrm_dbg_coredump_initiate *
 ******************************/


/* hwrm_dbg_coredump_initiate_input (size:256b/32B) */

typedef struct hwrm_dbg_coredump_initiate_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Component id of the returned component. */
	uint16_t	component_id;
	/* Segment id of the returned component. */
	uint16_t	segment_id;
	/* Not used. */
	uint16_t	instance;
	/* Not used. */
	uint16_t	unused_0;
	/*
	 * bit 0: live data
	 * bit 1: crashed data
	 * bit 2: collect context l1 cache
	 */
	uint8_t	seg_flags;
	/* Not Used. */
	#define HWRM_DBG_COREDUMP_INITIATE_INPUT_SEG_FLAGS_LIVE_DATA		UINT32_C(0x1)
	/* Not Used. */
	#define HWRM_DBG_COREDUMP_INITIATE_INPUT_SEG_FLAGS_CRASH_DATA		UINT32_C(0x2)
	/*
	 * If this bit is set, this setting will enforce firmware to collect
	 * CFCx l1 cache.
	 */
	#define HWRM_DBG_COREDUMP_INITIATE_INPUT_SEG_FLAGS_COLLECT_CTX_L1_CACHE	UINT32_C(0x4)
	/* Not used. */
	uint8_t	unused_1[7];
} hwrm_dbg_coredump_initiate_input_t, *phwrm_dbg_coredump_initiate_input_t;

/* hwrm_dbg_coredump_initiate_output (size:128b/16B) */

typedef struct hwrm_dbg_coredump_initiate_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_coredump_initiate_output_t, *phwrm_dbg_coredump_initiate_output_t;

/* coredump_data_hdr (size:128b/16B) */

typedef struct coredump_data_hdr {
	/* Starting address of the register range. */
	uint32_t	address;
	/*
	 * length: 0 - 23 bits represents the actual data without the pad.
	 * flags: 24 - 31 bits represents indirect register ranges.
	 *   - bit 24: Set if registers in this segment are indirect accessed.
	 */
	uint32_t	flags_length;
	/* These bits represents the actual length of the data segment */
	#define COREDUMP_DATA_HDR_FLAGS_LENGTH_ACTUAL_LEN_MASK	UINT32_C(0xffffff)
	#define COREDUMP_DATA_HDR_FLAGS_LENGTH_ACTUAL_LEN_SFT	0
	/* Set if registers in this segment are indirect accessed. */
	#define COREDUMP_DATA_HDR_FLAGS_LENGTH_INDIRECT_ACCESS	UINT32_C(0x1000000)
	/* Value in the partner register for indirect or multi-field registers. */
	uint32_t	instance;
	/* Starting address of the next register after the current data range */
	uint32_t	next_offset;
} coredump_data_hdr_t, *pcoredump_data_hdr_t;

/******************************
 * hwrm_dbg_coredump_retrieve *
 ******************************/


/* hwrm_dbg_coredump_retrieve_input (size:448b/56B) */

typedef struct hwrm_dbg_coredump_retrieve_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * host address where the data content will be written
	 * when the request is complete. This area must be 16B aligned.
	 */
	uint64_t	host_dest_addr;
	/* Length of host buffer used for transferring debug data. */
	uint32_t	host_buf_len;
	/* Not used. */
	uint32_t	unused_0;
	/* Component id of the returned component. */
	uint16_t	component_id;
	/* Segment id of the returned component. */
	uint16_t	segment_id;
	/* Not used. */
	uint16_t	instance;
	/* Not used. */
	uint16_t	unused_1;
	/*
	 * bit 0: live data
	 * bit 1: crashed data
	 */
	uint8_t	seg_flags;
	uint8_t	unused_2;
	uint16_t	unused_3;
	/* Not used. */
	uint32_t	unused_4;
	/* Sequence number is used per segment request. Starts at 0. */
	uint32_t	seq_no;
	uint32_t	unused_5;
} hwrm_dbg_coredump_retrieve_input_t, *phwrm_dbg_coredump_retrieve_input_t;

/* hwrm_dbg_coredump_retrieve_output (size:128b/16B) */

typedef struct hwrm_dbg_coredump_retrieve_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/*
	 * Value of 1 means that there is more data available.
	 * Issue the request again with the next sequence number.
	 */
	#define HWRM_DBG_COREDUMP_RETRIEVE_OUTPUT_FLAGS_MORE	UINT32_C(0x1)
	uint8_t	unused_0;
	/* Actual length of data returned in bytes. */
	uint16_t	data_len;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_coredump_retrieve_output_t, *phwrm_dbg_coredump_retrieve_output_t;

/********************
 * hwrm_dbg_i2c_cmd *
 ********************/


/* hwrm_dbg_i2c_cmd_input (size:320b/40B) */

typedef struct hwrm_dbg_i2c_cmd_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * host address where the data content will be read or written.
	 * For master write, data content will be read from host memory and
	 * write to i2c slave. (size defined by write_size)
	 * For master read, data content will be read from i2c slave and write
	 * to the host memory. (size defined by read_size)
	 * For master write/read, data content will be first read from host
	 * memory and write to i2c slave. (size defined by write_size) then
	 * data read from i2c slave will be written back to the same host
	 * memory. (size defined by read_size)
	 */
	uint64_t	host_dest_addr;
	/* read size in bytes, valid only for master read and write/read */
	uint16_t	read_size;
	/* write size in bytes, valid only for master write and write/read */
	uint16_t	write_size;
	/*
	 * instance of i2c channel for this operation. Valid if multiple
	 * instances
	 * of i2c channels are connected to external i2c devices.
	 */
	uint8_t	chnl_id;
	uint8_t	options;
	/*
	 * This bit must be '1' for 10-bit i2c addressing,
	 * 7-bit addressing otherwise.
	 */
	#define HWRM_DBG_I2C_CMD_INPUT_OPTIONS_10_BIT_ADDRESSING	UINT32_C(0x1)
	/*
	 * This bit must be '1' for 400 kbit/s, 100 kbit/s
	 * otherwise.
	 */
	#define HWRM_DBG_I2C_CMD_INPUT_OPTIONS_FAST_MODE		UINT32_C(0x2)
	/* I2C slave address. */
	uint16_t	slave_addr;
	/* I2C transfer mode. */
	uint8_t	xfer_mode;
	/* read data from slave device */
	#define HWRM_DBG_I2C_CMD_INPUT_XFER_MODE_MASTER_READ	UINT32_C(0x0)
	/* write data to slave device */
	#define HWRM_DBG_I2C_CMD_INPUT_XFER_MODE_MASTER_WRITE	UINT32_C(0x1)
	/* write follow by read data from slave device */
	#define HWRM_DBG_I2C_CMD_INPUT_XFER_MODE_MASTER_WRITE_READ UINT32_C(0x2)
	#define HWRM_DBG_I2C_CMD_INPUT_XFER_MODE_LAST		HWRM_DBG_I2C_CMD_INPUT_XFER_MODE_MASTER_WRITE_READ
	uint8_t	unused_1[7];
} hwrm_dbg_i2c_cmd_input_t, *phwrm_dbg_i2c_cmd_input_t;

/* hwrm_dbg_i2c_cmd_output (size:128b/16B) */

typedef struct hwrm_dbg_i2c_cmd_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_i2c_cmd_output_t, *phwrm_dbg_i2c_cmd_output_t;

/*******************
 * hwrm_dbg_fw_cli *
 *******************/


/* hwrm_dbg_fw_cli_input (size:1024b/128B) */

typedef struct hwrm_dbg_fw_cli_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Address of the host buffer where debug CLI data
	 * is requested to be dumped.
	 */
	uint64_t	host_dest_addr;
	/* Length of host buffer used for transferring debug data. */
	uint32_t	host_buf_len;
	/* Length of CLI command. */
	uint16_t	cli_cmd_len;
	uint8_t	unused_0[2];
	/* CLI command string, a single ASCII encoded null terminated string. */
	uint8_t	cli_cmd[96];
} hwrm_dbg_fw_cli_input_t, *phwrm_dbg_fw_cli_input_t;

/* hwrm_dbg_fw_cli_output (size:128b/16B) */

typedef struct hwrm_dbg_fw_cli_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Size of debug CLI data returned in bytes. */
	uint32_t	cli_data_len;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_fw_cli_output_t, *phwrm_dbg_fw_cli_output_t;

/**************************
 * hwrm_dbg_ring_info_get *
 **************************/


/* hwrm_dbg_ring_info_get_input (size:192b/24B) */

typedef struct hwrm_dbg_ring_info_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_L2_CMPL UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_TX	UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_RX	UINT32_C(0x2)
	/* Notification Queue (NQ) */
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_NQ	UINT32_C(0x3)
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_LAST   HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_NQ
	uint8_t	unused_0[3];
	/* Firmware ring ID associated with ring being queried. */
	uint32_t	fw_ring_id;
} hwrm_dbg_ring_info_get_input_t, *phwrm_dbg_ring_info_get_input_t;

/* hwrm_dbg_ring_info_get_output (size:192b/24B) */

typedef struct hwrm_dbg_ring_info_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Producer index for the queried ring. */
	uint32_t	producer_index;
	/* Consumer index for the queried ring. */
	uint32_t	consumer_index;
	/*
	 * CAG Vector Control for the queried NQ ring.
	 * Not valid for other ring types.
	 */
	uint32_t	cag_vector_ctrl;
	/*
	 * Steering Tag. The current value of the steering tag for the ring.
	 * The steering tag is only valid if it is advertised by Firmware in
	 * flags_ext2.steering_tag_supported of hwrm_func_qcaps response.
	 */
	uint16_t	st_tag;
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_ring_info_get_output_t, *phwrm_dbg_ring_info_get_output_t;

/**********************
 * hwrm_dbg_drv_trace *
 **********************/


/* hwrm_dbg_drv_trace_input (size:1024b/128B) */

typedef struct hwrm_dbg_drv_trace_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Severity of the message. */
	uint8_t	severity;
	/* Fatal */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_FATAL   UINT32_C(0x0)
	/* Error */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_ERROR   UINT32_C(0x1)
	/* Warning */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_WARNING UINT32_C(0x2)
	/* Info */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_INFO	UINT32_C(0x3)
	/* Debug */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_DEBUG   UINT32_C(0x4)
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_LAST		HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_DEBUG
	/* Number of bytes to write including terminating 'NULL' if any. */
	uint8_t	write_len;
	uint8_t	unused_0[6];
	/*
	 * This field represents the debug data sent by driver
	 * ASCII chars, 'NULL' termination not required.
	 */
	char	trace_data[104];
} hwrm_dbg_drv_trace_input_t, *phwrm_dbg_drv_trace_input_t;

/* hwrm_dbg_drv_trace_output (size:128b/16B) */

typedef struct hwrm_dbg_drv_trace_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_drv_trace_output_t, *phwrm_dbg_drv_trace_output_t;

/***********************
 * hwrm_dbg_useq_alloc *
 ***********************/


/* hwrm_dbg_useq_alloc_input (size:192b/24B) */

typedef struct hwrm_dbg_useq_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Number size of the allocation, in bytes, for the USEQ in the code
	 * words array
	 */
	uint32_t	size;
	/*
	 * Number of bytes executing the USEQ will produce. Must be a multiple
	 * of 4
	 */
	uint16_t	output_bytes;
	/* This field is reserved */
	uint16_t	unused_0;
} hwrm_dbg_useq_alloc_input_t, *phwrm_dbg_useq_alloc_input_t;

/* hwrm_dbg_useq_alloc_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* Flags indicating current USEQ engine state */
	uint32_t	useq_resp_flags;
	/* When set, there is at least some data available to be delivered */
	#define HWRM_DBG_USEQ_ALLOC_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_AVAIL	UINT32_C(0x1)
	/* When set, all internal buffers are full */
	#define HWRM_DBG_USEQ_ALLOC_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW UINT32_C(0x2)
	#define HWRM_DBG_USEQ_ALLOC_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_LAST	HWRM_DBG_USEQ_ALLOC_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint8_t	useq_resp_unused_0[3];
	/* This is the allocated usid */
	uint16_t	alloc_usid;
	/* This field is reserved */
	uint16_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_alloc_output_t, *phwrm_dbg_useq_alloc_output_t;

/**********************
 * hwrm_dbg_useq_free *
 **********************/


/* hwrm_dbg_useq_free_input (size:192b/24B) */

typedef struct hwrm_dbg_useq_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The USID of the sequence to free */
	uint16_t	usid;
	/* This field is reserved */
	uint8_t	unused_0[6];
} hwrm_dbg_useq_free_input_t, *phwrm_dbg_useq_free_input_t;

/* hwrm_dbg_useq_free_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* Flags indicating current USEQ engine state */
	uint32_t	useq_resp_flags;
	/* When set, there is at least some data available to be delivered */
	#define HWRM_DBG_USEQ_FREE_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_AVAIL	UINT32_C(0x1)
	/* When set, all internal buffers are full */
	#define HWRM_DBG_USEQ_FREE_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW UINT32_C(0x2)
	#define HWRM_DBG_USEQ_FREE_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_LAST	HWRM_DBG_USEQ_FREE_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint8_t	useq_resp_unused_0[3];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_free_output_t, *phwrm_dbg_useq_free_output_t;

/***********************
 * hwrm_dbg_useq_flush *
 ***********************/


/* hwrm_dbg_useq_flush_input (size:192b/24B) */

typedef struct hwrm_dbg_useq_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Bitwise flags described below */
	uint16_t	flags;
	/* Flush all USEQ code words, resetting all USIDs to invalid */
	#define HWRM_DBG_USEQ_FLUSH_INPUT_USEQ_CODE_WORDS UINT32_C(0x1)
	/* Initialize all buffers, clearing out any collected data */
	#define HWRM_DBG_USEQ_FLUSH_INPUT_BUFFERS	UINT32_C(0x2)
	#define HWRM_DBG_USEQ_FLUSH_INPUT_LAST	HWRM_DBG_USEQ_FLUSH_INPUT_BUFFERS
	/* This field is reserved */
	uint8_t	unused_0[6];
} hwrm_dbg_useq_flush_input_t, *phwrm_dbg_useq_flush_input_t;

/* hwrm_dbg_useq_flush_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* Flags indicating current USEQ engine state */
	uint32_t	useq_resp_flags;
	/* When set, there is at least some data available to be delivered */
	#define HWRM_DBG_USEQ_FLUSH_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_AVAIL	UINT32_C(0x1)
	/* When set, all internal buffers are full */
	#define HWRM_DBG_USEQ_FLUSH_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW UINT32_C(0x2)
	#define HWRM_DBG_USEQ_FLUSH_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_LAST	HWRM_DBG_USEQ_FLUSH_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint8_t	useq_resp_unused_0[3];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_flush_output_t, *phwrm_dbg_useq_flush_output_t;

/************************
 * hwrm_dbg_useq_cw_cfg *
 ************************/


/* hwrm_dbg_useq_cw_cfg_input (size:960b/120B) */

typedef struct hwrm_dbg_useq_cw_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The USID of the sequence being configured */
	uint16_t	usid;
	/*
	 * The code words given in this message will be placed
	 * at this offset from the starting code word for this
	 * usid. NOTE: when offset is zero, the first 6 32-bit
	 * words may contain values for F0-F7 as well as the
	 * main code word index. This is determined by checking
	 * the usid_ctrl_present flag.
	 */
	uint16_t	offset;
	/*
	 * When the use_dma flag is clear, this is the length in bytes
	 * to be digested from the opaque data area.
	 */
	uint16_t	size;
	/*
	 * Flags associated with the current message
	 * data area.
	 */
	uint16_t	flags;
	/*
	 * When set, the opaque data begins with a block of control
	 * information to be associated with the usid. This includes
	 * F0-F7 code word indexes as well as the code word index for
	 * main.
	 */
	#define HWRM_DBG_USEQ_CW_CFG_INPUT_FLAGS_USID_CTRL_PRESENT UINT32_C(0x1)
	/*
	 * When set, opaque contains a 64b host address used to DMA
	 * the entire code word sequence. The offset within the
	 * opaque data depends on the state of other flags.
	 */
	#define HWRM_DBG_USEQ_CW_CFG_INPUT_FLAGS_USE_DMA	UINT32_C(0x2)
	/*
	 * When set, this message is the last configuration message
	 * for the given usid.
	 */
	#define HWRM_DBG_USEQ_CW_CFG_INPUT_FLAGS_END		UINT32_C(0x8000)
	#define HWRM_DBG_USEQ_CW_CFG_INPUT_FLAGS_LAST		HWRM_DBG_USEQ_CW_CFG_INPUT_FLAGS_END
	/* command dependent data (e.g. function id for host dma command) */
	uint32_t	opaque[24];
} hwrm_dbg_useq_cw_cfg_input_t, *phwrm_dbg_useq_cw_cfg_input_t;

/* hwrm_dbg_useq_cw_cfg_output (size:192b/24B) */

typedef struct hwrm_dbg_useq_cw_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* Flags indicating current USEQ engine state */
	uint32_t	useq_resp_flags;
	/* When set, there is at least some data available to be delivered */
	#define HWRM_DBG_USEQ_CW_CFG_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_AVAIL	UINT32_C(0x1)
	/* When set, all internal buffers are full */
	#define HWRM_DBG_USEQ_CW_CFG_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW UINT32_C(0x2)
	#define HWRM_DBG_USEQ_CW_CFG_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_LAST	HWRM_DBG_USEQ_CW_CFG_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint8_t	useq_resp_unused_0[3];
} hwrm_dbg_useq_cw_cfg_output_t, *phwrm_dbg_useq_cw_cfg_output_t;

/***********************
 * hwrm_dbg_useq_qcaps *
 ***********************/


/* hwrm_dbg_useq_qcaps_input (size:128b/16B) */

typedef struct hwrm_dbg_useq_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_dbg_useq_qcaps_input_t, *phwrm_dbg_useq_qcaps_input_t;

/* hwrm_dbg_useq_qcaps_output (size:384b/48B) */

typedef struct hwrm_dbg_useq_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* Flags indicating current USEQ engine state */
	uint32_t	useq_resp_flags;
	/* When set, there is at least some data available to be delivered */
	#define HWRM_DBG_USEQ_QCAPS_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_AVAIL	UINT32_C(0x1)
	/* When set, all internal buffers are full */
	#define HWRM_DBG_USEQ_QCAPS_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW UINT32_C(0x2)
	#define HWRM_DBG_USEQ_QCAPS_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_LAST	HWRM_DBG_USEQ_QCAPS_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint8_t	useq_resp_unused_0[3];
	/* Maximum number of USEQ that can be tracked by firmware */
	uint32_t	max_num_useq;
	/* Maximum number of code word bytes for a single USEQ */
	uint32_t	max_useq_size;
	/* The maximum number of output bytes a single USEQ may generate */
	uint32_t	max_useq_32b_output_size;
	/* The number of internal USEQ output buffers, each of 4096 bytes */
	uint32_t	num_buf;
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_qcaps_output_t, *phwrm_dbg_useq_qcaps_output_t;

/***************************
 * hwrm_dbg_useq_sched_cfg *
 ***************************/


/* hwrm_dbg_useq_sched_cfg_input (size:192b/24B) */

typedef struct hwrm_dbg_useq_sched_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Enumeration values for enabling, disabling scheduler */
	uint16_t	global_cfg;
	/* This value will leave the global scheduler in its current state */
	#define HWRM_DBG_USEQ_SCHED_CFG_INPUT_NO_CHANGE UINT32_C(0x0)
	/*
	 * This value disables the global scheduler. This mode must be used
	 * when the RUN command is being used to run individual sequences.
	 */
	#define HWRM_DBG_USEQ_SCHED_CFG_INPUT_DISABLE   UINT32_C(0x1)
	/*
	 * This value enables the global scheduler. When enabled, USEQs will
	 * be scheduled based on their polling intervals
	 */
	#define HWRM_DBG_USEQ_SCHED_CFG_INPUT_ENABLE	UINT32_C(0x2)
	#define HWRM_DBG_USEQ_SCHED_CFG_INPUT_LAST	HWRM_DBG_USEQ_SCHED_CFG_INPUT_ENABLE
	/*
	 * The given polling interval will be associated with this USID. A
	 * value of -1 indicates that the USID is invalid. The invalid USID is
	 * used when using this message only for global scheduler
	 * configuration.
	 */
	uint16_t	usid;
	/* This value represents microseconds between runs of the USEQ */
	uint32_t	polling_interval;
} hwrm_dbg_useq_sched_cfg_input_t, *phwrm_dbg_useq_sched_cfg_input_t;

/* hwrm_dbg_useq_sched_cfg_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_sched_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* Flags indicating current USEQ engine state */
	uint32_t	useq_resp_flags;
	/* When set, there is at least some data available to be delivered */
	#define HWRM_DBG_USEQ_SCHED_CFG_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_AVAIL	UINT32_C(0x1)
	/* When set, all internal buffers are full */
	#define HWRM_DBG_USEQ_SCHED_CFG_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW UINT32_C(0x2)
	#define HWRM_DBG_USEQ_SCHED_CFG_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_LAST	HWRM_DBG_USEQ_SCHED_CFG_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint8_t	useq_resp_unused_0[3];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_sched_cfg_output_t, *phwrm_dbg_useq_sched_cfg_output_t;

/*********************
 * hwrm_dbg_useq_run *
 *********************/


/* hwrm_dbg_useq_run_input (size:320b/40B) */

typedef struct hwrm_dbg_useq_run_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The USID to be run */
	uint16_t	usid;
	/* Type of run to execute for the given USID */
	uint8_t	run_type;
	/* This run type will execute the requested USEQ only a single time */
	#define HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_SINGLE   UINT32_C(0x0)
	/*
	 * This run type will execute the requested USEQ a number of times
	 * given by run_cnt with a run interval given by the run_interval
	 * parameter.
	 */
	#define HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_CNT	UINT32_C(0x1)
	/*
	 * This run type will execute the requested USEQ as many times as it
	 * needs to fill an entire buffer to return to the host. The runs
	 * will occur with a run interval given by the run_interval
	 * parameter.
	 */
	#define HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_FILL_BUF UINT32_C(0x2)
	#define HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_LAST	HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_FILL_BUF
	/*
	 * If indicated by flags, this represents the number of times to run
	 * the USEQ. Note that runs are stopped if the buffer fills prior
	 * regardless of the number of runs. For example, if a run_cnt of 10 is
	 * specified and 3 runs results in the buffer being full then only 3
	 * runs are executed.
	 */
	uint8_t	run_cnt;
	/*
	 * This value represents microseconds between runs of the USEQ when
	 * running multiple times as indicated by flags.
	 */
	uint32_t	run_interval;
	/*
	 * Address of the host buffer where collected USEQ output data will be
	 * placed
	 */
	uint64_t	host_dest_addr;
	/*
	 * Size, in bytes, of the memory associated with host_dest_addr. It is
	 * expected that this is >= 4096
	 */
	uint32_t	host_dest_len;
	/* This field is reserved */
	uint32_t	unused_0;
} hwrm_dbg_useq_run_input_t, *phwrm_dbg_useq_run_input_t;

/* hwrm_dbg_useq_run_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_run_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* Flags indicating current USEQ engine state */
	uint32_t	useq_resp_flags;
	/* When set, there is at least some data available to be delivered */
	#define HWRM_DBG_USEQ_RUN_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_AVAIL	UINT32_C(0x1)
	/* When set, all internal buffers are full */
	#define HWRM_DBG_USEQ_RUN_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW UINT32_C(0x2)
	#define HWRM_DBG_USEQ_RUN_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_LAST	HWRM_DBG_USEQ_RUN_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint8_t	useq_resp_unused_0[3];
	/*
	 * The length, in bytes, of the amount of data placed in the
	 * corresponding host_dest_addr given in the input message. This will
	 * always be a multiple of 4096
	 */
	uint32_t	host_dest_filled_len;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_run_output_t, *phwrm_dbg_useq_run_output_t;

/******************************
 * hwrm_dbg_useq_delivery_req *
 ******************************/


/* hwrm_dbg_useq_delivery_req_input (size:896b/112B) */

typedef struct hwrm_dbg_useq_delivery_req_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Eight destination addresses provide host memory space for FW to
	 * deliver USEQ output details. A value of 0x0 for the address can be
	 * used to inform FW that the buffer is not available.
	 */
	uint64_t	host_dest_addrs[8];
	/*
	 * The length, in bytes, of the corresponding host_dest_addrs array
	 * entry. Each valid hist_dest_addrs entry must have a len of at least
	 * 4096 bytes.
	 */
	uint32_t	host_dest_len[8];
} hwrm_dbg_useq_delivery_req_input_t, *phwrm_dbg_useq_delivery_req_input_t;

/* hwrm_dbg_useq_delivery_req_output (size:512b/64B) */

typedef struct hwrm_dbg_useq_delivery_req_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* Flags indicating current USEQ engine state */
	uint32_t	useq_resp_flags;
	/* When set, there is at least some data available to be delivered */
	#define HWRM_DBG_USEQ_DELIVERY_REQ_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_AVAIL	UINT32_C(0x1)
	/* When set, all internal buffers are full */
	#define HWRM_DBG_USEQ_DELIVERY_REQ_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW UINT32_C(0x2)
	#define HWRM_DBG_USEQ_DELIVERY_REQ_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_LAST	HWRM_DBG_USEQ_DELIVERY_REQ_OUTPUT_HWRM_DBG_USEQ_RESP_HDR_USEQ_RESP_FLAGS_OVERFLOW
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint8_t	useq_resp_unused_0[3];
	/*
	 * The length, in bytes, of the amount of data placed in the
	 * corresponding host_dest_addrs entry given in the input message. This
	 * will always be a multiple of 4096.
	 */
	uint32_t	host_dest_filled_len[8];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_delivery_req_output_t, *phwrm_dbg_useq_delivery_req_output_t;

/*****************************
 * hwrm_dbg_log_buffer_flush *
 *****************************/


/* hwrm_dbg_log_buffer_flush_input (size:192b/24B) */

typedef struct hwrm_dbg_log_buffer_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of trace buffer to flush. */
	uint16_t	type;
	/* SRT trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_SRT_TRACE	UINT32_C(0x0)
	/* SRT2 trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_SRT2_TRACE	UINT32_C(0x1)
	/* CRT trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_CRT_TRACE	UINT32_C(0x2)
	/* CRT2 trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_CRT2_TRACE	UINT32_C(0x3)
	/* RIGP0 trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_RIGP0_TRACE	UINT32_C(0x4)
	/* L2 HWRM trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_L2_HWRM_TRACE   UINT32_C(0x5)
	/* RoCE HWRM trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_ROCE_HWRM_TRACE UINT32_C(0x6)
	/* Context Accelerator CPU 0 trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_CA0_TRACE	UINT32_C(0x7)
	/* Context Accelerator CPU 1 trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_CA1_TRACE	UINT32_C(0x8)
	/* Context Accelerator CPU 2 trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_CA2_TRACE	UINT32_C(0x9)
	/* RIGP1 trace. */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_RIGP1_TRACE	UINT32_C(0xa)
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_LAST	HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_TYPE_RIGP1_TRACE
	uint8_t	unused_1[2];
	/* Control flags. */
	uint32_t	flags;
	/*
	 * When set, it indicates that all buffers should be flushed.
	 * The type will be ignored.
	 */
	#define HWRM_DBG_LOG_BUFFER_FLUSH_INPUT_FLAGS_FLUSH_ALL_BUFFERS	UINT32_C(0x1)
} hwrm_dbg_log_buffer_flush_input_t, *phwrm_dbg_log_buffer_flush_input_t;

/* hwrm_dbg_log_buffer_flush_output (size:128b/16B) */

typedef struct hwrm_dbg_log_buffer_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Specifies the current host buffer offset. Data up to this offset
	 * has been populated by the firmware. For example, if the firmware
	 * has DMA-ed 8192 bytes to the host buffer, then this field has a
	 * value of 8192. This field rolls over to zero once the firmware
	 * writes the last page of the host buffer
	 */
	uint32_t	current_buffer_offset;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_log_buffer_flush_output_t, *phwrm_dbg_log_buffer_flush_output_t;

/************************
 * hwrm_dbg_serdes_test *
 ************************/


/* hwrm_dbg_serdes_test_input (size:320b/40B) */

typedef struct hwrm_dbg_serdes_test_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Host address data is to DMA'd to. */
	uint64_t	resp_data_addr;
	/*
	 * This field contains the offset into the captured data to begin
	 * copying the data to the host from. This should be set to 0 on the
	 * initial call to this command.
	 */
	uint32_t	resp_data_offset;
	/*
	 * Size of the buffer pointed to by resp_data_addr. The firmware may
	 * use this entire buffer or less than the entire buffer, but never
	 * more.
	 */
	uint16_t	data_len;
	/*
	 * This field allows this command to request the individual serdes
	 * tests to be run using this command.
	 */
	uint8_t	flags;
	/* Unused. */
	#define HWRM_DBG_SERDES_TEST_INPUT_FLAGS_UNUSED_TEST_MASK	UINT32_C(0x7)
	#define HWRM_DBG_SERDES_TEST_INPUT_FLAGS_UNUSED_TEST_SFT	0
	/* Display eye_projection */
	#define HWRM_DBG_SERDES_TEST_INPUT_FLAGS_EYE_PROJECTION	UINT32_C(0x8)
	/* Run the PCIe serdes test. */
	#define HWRM_DBG_SERDES_TEST_INPUT_FLAGS_PCIE_SERDES_TEST	UINT32_C(0x10)
	/* Run the Ethernet serdes test. */
	#define HWRM_DBG_SERDES_TEST_INPUT_FLAGS_ETHERNET_SERDES_TEST	UINT32_C(0x20)
	uint8_t	options;
	/*
	 * This field represents the lane number on which tools wants to
	 * retrieve eye plot. This field is valid only when pcie_serdes_test
	 * or ethernet_serdes_test flag is set. For pcie_serdes_test, the
	 * maximum value is the device pcie lane width minus 1. For
	 * ethernet_serdes_test, the maximum value is the total lanes of
	 * the network port minus 1. Valid values from 0 to 16.
	 */
	#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_LANE_NO_MASK	UINT32_C(0xf)
	#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_LANE_NO_SFT	0
	/* This value indicates the Horizontal or vertical plot direction. */
	#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_DIRECTION		UINT32_C(0x10)
	/* Value 0 indicates Horizontal plot request. */
		#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_DIRECTION_HORIZONTAL	(UINT32_C(0x0) << 4)
	/* Value 1 indicates vertical plot request. */
		#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_DIRECTION_VERTICAL	(UINT32_C(0x1) << 4)
		#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_DIRECTION_LAST	HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_DIRECTION_VERTICAL
	/* This value indicates eye projection type */
	#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_PROJ_TYPE		UINT32_C(0x20)
	/*
	 * Value 0 indicates left/top projection in horizontal/vertical
	 * This value is valid only when eye_projection flag was set.
	 */
		#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_PROJ_TYPE_LEFT_TOP	(UINT32_C(0x0) << 5)
	/*
	 * Value 1 indicates right/bottom projection in
	 * horizontal/vertical. This value is valid only when
	 * eye_projection flag was set.
	 */
		#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_PROJ_TYPE_RIGHT_BOTTOM  (UINT32_C(0x1) << 5)
		#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_PROJ_TYPE_LAST	HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_PROJ_TYPE_RIGHT_BOTTOM
	/* Reserved for future. */
	#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_RSVD_MASK		UINT32_C(0xc0)
	#define HWRM_DBG_SERDES_TEST_INPUT_OPTIONS_RSVD_SFT		6
	/*
	 * This field allows this command to request a specific targetBER
	 * to be run using this command.
	 */
	uint8_t	targetBER;
	/* When collecting an eyescope, measure with a target BER of 1e-8 */
	#define HWRM_DBG_SERDES_TEST_INPUT_TARGETBER_BER_1E8  UINT32_C(0x0)
	/* When collecting an eyescope, measure with a target BER of 1e-9 */
	#define HWRM_DBG_SERDES_TEST_INPUT_TARGETBER_BER_1E9  UINT32_C(0x1)
	/* When collecting an eyescope, measure with a target BER of 1e-10 */
	#define HWRM_DBG_SERDES_TEST_INPUT_TARGETBER_BER_1E10 UINT32_C(0x2)
	/* When collecting an eyescope, measure with a target BER of 1e-11 */
	#define HWRM_DBG_SERDES_TEST_INPUT_TARGETBER_BER_1E11 UINT32_C(0x3)
	/* When collecting an eyescope, measure with a target BER of 1e-12 */
	#define HWRM_DBG_SERDES_TEST_INPUT_TARGETBER_BER_1E12 UINT32_C(0x4)
	#define HWRM_DBG_SERDES_TEST_INPUT_TARGETBER_LAST	HWRM_DBG_SERDES_TEST_INPUT_TARGETBER_BER_1E12
	/*
	 * This field allows this command to specify the action to take when
	 * collecting an eyescope.
	 */
	uint8_t	action;
	/*
	 * Value 0 indicates that collection of the eyescope should be
	 * returned synchronously in the output. This only applies to
	 * a targetBER of 1e-8.
	 */
	#define HWRM_DBG_SERDES_TEST_INPUT_ACTION_SYNCHRONOUS UINT32_C(0x0)
	/*
	 * Value 1 indicates to the firmware to start the collection of the
	 * eyescope.
	 */
	#define HWRM_DBG_SERDES_TEST_INPUT_ACTION_START	UINT32_C(0x1)
	/*
	 * Value 2 indicates to the firmware to respond with a progress
	 * percentage of the current eyescope collection from 0.0 to 100.0.
	 */
	#define HWRM_DBG_SERDES_TEST_INPUT_ACTION_PROGRESS	UINT32_C(0x2)
	/*
	 * Value 3 indicates to stop the eyescope. if the progress
	 * percentage is 100.0, the data will be DMAed back to
	 * resp_data_addr.
	 */
	#define HWRM_DBG_SERDES_TEST_INPUT_ACTION_STOP	UINT32_C(0x3)
	#define HWRM_DBG_SERDES_TEST_INPUT_ACTION_LAST	HWRM_DBG_SERDES_TEST_INPUT_ACTION_STOP
	uint8_t	unused[6];
} hwrm_dbg_serdes_test_input_t, *phwrm_dbg_serdes_test_input_t;

/* hwrm_dbg_serdes_test_output (size:192b/24B) */

typedef struct hwrm_dbg_serdes_test_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of stored data. */
	uint16_t	total_data_len;
	/*
	 * Amount of data DMA'd to host by this call. The driver can use this
	 * field along with the total_data_len field above to determine the
	 * value to write to the resp_data_offset field in the next call
	 * if more than one call to these commands is required to retrieve all
	 * the stored data.
	 */
	uint16_t	copied_data_len;
	/*
	 * Percentage of completion of collection of BER values from the
	 * current eyescope operation in tenths of a percentage. 0 (0.0) to
	 * 1000 (100.0).
	 */
	uint16_t	progress_percent;
	/* Timeout in seconds for timeout of an individual BER point. */
	uint16_t	timeout;
	uint8_t	flags;
	/*
	 * This value indicates the structure of data returned by the
	 * firmware when DMA'ed to resp_data_addr.
	 */
	#define HWRM_DBG_SERDES_TEST_OUTPUT_FLAGS_BIT_COUNT_TYPE		UINT32_C(0x1)
	/*
	 * Value 0 indicates that bit_count value is a raw total
	 * such that BER = error_count / bit_count.
	 */
		#define HWRM_DBG_SERDES_TEST_OUTPUT_FLAGS_BIT_COUNT_TYPE_BIT_COUNT_TOTAL  UINT32_C(0x0)
	/*
	 * Value 1 indicates that bit count is a power of
	 * 2 that bit_count is normalized to. A Value of 42 indicates
	 * that BER = error_count / 2^42
	 */
		#define HWRM_DBG_SERDES_TEST_OUTPUT_FLAGS_BIT_COUNT_TYPE_BIT_COUNT_POW2   UINT32_C(0x1)
		#define HWRM_DBG_SERDES_TEST_OUTPUT_FLAGS_BIT_COUNT_TYPE_LAST		HWRM_DBG_SERDES_TEST_OUTPUT_FLAGS_BIT_COUNT_TYPE_BIT_COUNT_POW2
	/* Reserved for future. */
	#define HWRM_DBG_SERDES_TEST_OUTPUT_FLAGS_RSVD_MASK			UINT32_C(0xfe)
	#define HWRM_DBG_SERDES_TEST_OUTPUT_FLAGS_RSVD_SFT			1
	uint8_t	unused_0;
	/*
	 * Size of header prepended to the bit_count and error_count array.
	 * Use this value to skip forward to the bit_count and error_count
	 * array.
	 */
	uint16_t	hdr_size;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_serdes_test_output_t, *phwrm_dbg_serdes_test_output_t;

/*****************************
 * hwrm_dbg_coredump_capture *
 *****************************/


/* hwrm_dbg_coredump_capture_input (size:128b/16B) */

typedef struct hwrm_dbg_coredump_capture_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_dbg_coredump_capture_input_t, *phwrm_dbg_coredump_capture_input_t;

/* hwrm_dbg_coredump_capture_output (size:128b/16B) */

typedef struct hwrm_dbg_coredump_capture_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_coredump_capture_output_t, *phwrm_dbg_coredump_capture_output_t;

/****************************
 * hwrm_dbg_sim_cable_state *
 ****************************/


/* hwrm_dbg_sim_cable_state_input (size:192b/24B) */

typedef struct hwrm_dbg_sim_cable_state_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This field allows this command to specify the action to take. */
	uint8_t	action;
	/* Value 0 indicates to the firmware to insert the cable. */
	#define HWRM_DBG_SIM_CABLE_STATE_INPUT_ACTION_INSERT UINT32_C(0x0)
	/* Value 1 indicates to the firmware to remove the cable. */
	#define HWRM_DBG_SIM_CABLE_STATE_INPUT_ACTION_REMOVE UINT32_C(0x1)
	#define HWRM_DBG_SIM_CABLE_STATE_INPUT_ACTION_LAST  HWRM_DBG_SIM_CABLE_STATE_INPUT_ACTION_REMOVE
	uint8_t	unused_0[7];
} hwrm_dbg_sim_cable_state_input_t, *phwrm_dbg_sim_cable_state_input_t;

/* hwrm_dbg_sim_cable_state_output (size:128b/16B) */

typedef struct hwrm_dbg_sim_cable_state_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_sim_cable_state_output_t, *phwrm_dbg_sim_cable_state_output_t;

/*******************
 * hwrm_dbg_ptrace *
 *******************/


/* hwrm_dbg_ptrace_input (size:320b/40B) */

typedef struct hwrm_dbg_ptrace_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Physical address pointer pointing to a host buffer that the PDI
	 * command's input request. This can be either a host physical address
	 * (HPA) or a guest physical address (GPA) and must point to a
	 * physically contiguous block of memory.
	 */
	uint64_t	pdi_cmd_buf_addr;
	/*
	 * Physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	pdi_resp_buf_addr;
	/* Host PDI request buffer length. */
	uint32_t	pdi_req_buf_len;
	uint16_t	seq_no;
	uint16_t	flags;
	/*
	 * when this flag is set, register access will be enabled for the
	 * ICAP Tx/Egress block.
	 */
	#define HWRM_DBG_PTRACE_INPUT_FLAGS_SELECT_IN	UINT32_C(0x1)
	/*
	 * when this flag is set, register access will be enabled for the
	 * ICAP Rx/Ingress block.
	 */
	#define HWRM_DBG_PTRACE_INPUT_FLAGS_SELECT_OUT	UINT32_C(0x2)
	/*
	 * when this flag is set, capture will be started for both Tx and
	 * Rx directions simultaneously.
	 */
	#define HWRM_DBG_PTRACE_INPUT_FLAGS_GLOBAL_START	UINT32_C(0x4)
	/*
	 * when this flag is set, capture will be stopped for both Tx and
	 * Rx directions simultaneously.
	 */
	#define HWRM_DBG_PTRACE_INPUT_FLAGS_GLOBAL_STOP	UINT32_C(0x8)
} hwrm_dbg_ptrace_input_t, *phwrm_dbg_ptrace_input_t;

/* hwrm_dbg_ptrace_output (size:128b/16B) */

typedef struct hwrm_dbg_ptrace_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/*
	 * When this flag is set, it indicates that there is more data
	 * available.
	 * Issue the request again with the next sequence number.
	 */
	#define HWRM_DBG_PTRACE_OUTPUT_FLAGS_MORE	UINT32_C(0x1)
	uint16_t	data_len;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output is
	 * completely written to RAM. This field should be read as '1' to
	 * indicate that the output has been completely written. When writing
	 * a command completion or response to an internal processor, the order
	 * of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_ptrace_output_t, *phwrm_dbg_ptrace_output_t;

/**************************
 * hwrm_nvm_raw_write_blk *
 **************************/


/* hwrm_nvm_raw_write_blk_input (size:320b/40B) */

typedef struct hwrm_nvm_raw_write_blk_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is the location of the source data to be written.
	 */
	uint64_t	host_src_addr;
	/*
	 * 32-bit Destination Address.
	 * This is the NVRAM byte-offset where the source data will be written
	 * to.
	 */
	uint32_t	dest_addr;
	/* Length of data to be written, in bytes. */
	uint32_t	len;
	uint8_t	flags;
	/*
	 * This bit is only used when external secure SoC is used for
	 * secure boot. This bit is utilized to differentiate between
	 * writes for NIC or Security SoC non-volatile storage on the
	 * device. If this bit is set, then this write is for the
	 * Security SoC non-volatile storage on the device.
	 */
	#define HWRM_NVM_RAW_WRITE_BLK_INPUT_FLAGS_SECURITY_SOC_NVM	UINT32_C(0x1)
	uint8_t	unused_0[7];
} hwrm_nvm_raw_write_blk_input_t, *phwrm_nvm_raw_write_blk_input_t;

/* hwrm_nvm_raw_write_blk_output (size:128b/16B) */

typedef struct hwrm_nvm_raw_write_blk_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_raw_write_blk_output_t, *phwrm_nvm_raw_write_blk_output_t;

/*****************
 * hwrm_nvm_read *
 *****************/


/* hwrm_nvm_read_input (size:320b/40B) */

typedef struct hwrm_nvm_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the data will be written to.
	 */
	uint64_t	host_dest_addr;
	/* The 0-based index of the directory entry. */
	uint16_t	dir_idx;
	uint8_t	unused_0[2];
	/* The NVRAM byte-offset to read from. */
	uint32_t	offset;
	/* The length of the data to be read, in bytes. */
	uint32_t	len;
	uint8_t	unused_1[4];
} hwrm_nvm_read_input_t, *phwrm_nvm_read_input_t;

/* hwrm_nvm_read_output (size:128b/16B) */

typedef struct hwrm_nvm_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_read_output_t, *phwrm_nvm_read_output_t;

/*********************
 * hwrm_nvm_raw_dump *
 *********************/


/* hwrm_nvm_raw_dump_input (size:320b/40B) */

typedef struct hwrm_nvm_raw_dump_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the data will be written to.
	 */
	uint64_t	host_dest_addr;
	/* 32-bit NVRAM byte-offset to read from. */
	uint32_t	offset;
	/* Total length of NVRAM contents to be read, in bytes. */
	uint32_t	len;
	uint8_t	flags;
	/*
	 * This bit is only used when external secure SoC is used for
	 * secure boot. This bit is utilized to differentiate between
	 * read for NIC or Security SoC non-volatile storage on the
	 * device. If this bit is set, then this read is for the Security
	 * SoC non-volatile storage on the device.
	 */
	#define HWRM_NVM_RAW_DUMP_INPUT_FLAGS_SECURITY_SOC_NVM	UINT32_C(0x1)
	uint8_t	unused_0[7];
} hwrm_nvm_raw_dump_input_t, *phwrm_nvm_raw_dump_input_t;

/* hwrm_nvm_raw_dump_output (size:128b/16B) */

typedef struct hwrm_nvm_raw_dump_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_raw_dump_output_t, *phwrm_nvm_raw_dump_output_t;

/****************************
 * hwrm_nvm_get_dir_entries *
 ****************************/


/* hwrm_nvm_get_dir_entries_input (size:192b/24B) */

typedef struct hwrm_nvm_get_dir_entries_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the directory will be written.
	 */
	uint64_t	host_dest_addr;
} hwrm_nvm_get_dir_entries_input_t, *phwrm_nvm_get_dir_entries_input_t;

/* hwrm_nvm_get_dir_entries_output (size:128b/16B) */

typedef struct hwrm_nvm_get_dir_entries_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_dir_entries_output_t, *phwrm_nvm_get_dir_entries_output_t;

/*************************
 * hwrm_nvm_get_dir_info *
 *************************/


/* hwrm_nvm_get_dir_info_input (size:128b/16B) */

typedef struct hwrm_nvm_get_dir_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_nvm_get_dir_info_input_t, *phwrm_nvm_get_dir_info_input_t;

/* hwrm_nvm_get_dir_info_output (size:192b/24B) */

typedef struct hwrm_nvm_get_dir_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of directory entries in the directory. */
	uint32_t	entries;
	/* Size of each directory entry, in bytes. */
	uint32_t	entry_length;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_dir_info_output_t, *phwrm_nvm_get_dir_info_output_t;

/******************
 * hwrm_nvm_write *
 ******************/


/* hwrm_nvm_write_input (size:448b/56B) */

typedef struct hwrm_nvm_write_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is where the source data is.
	 */
	uint64_t	host_src_addr;
	/*
	 * The Directory Entry Type (valid values are defined in the
	 * bnxnvm_directory_type enum defined in the file bnxnvm_defs.h).
	 */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The 0-based instance of the combined Directory Entry Type and
	 * Extension.
	 */
	uint16_t	dir_ordinal;
	/*
	 * The Directory Entry Extension flags (see BNX_DIR_EXT_* in the file
	 * bnxnvm_defs.h).
	 */
	uint16_t	dir_ext;
	/*
	 * Directory Entry Attribute flags (see BNX_DIR_ATTR_* in the file
	 * bnxnvm_defs.h).
	 */
	uint16_t	dir_attr;
	/*
	 * Length of data to write, in bytes. May be less than or equal to the
	 * allocated size for the directory entry.
	 * The data length stored in the directory entry will be updated to
	 * reflect this value once the write is complete.
	 */
	uint32_t	dir_data_length;
	/* Option. */
	uint16_t	option;
	uint16_t	flags;
	/*
	 * When this bit is '1', the original active image
	 * will not be removed. TBD: what purpose is this?
	 */
	#define HWRM_NVM_WRITE_INPUT_FLAGS_KEEP_ORIG_ACTIVE_IMG	UINT32_C(0x1)
	/*
	 * This flag indicates the sender wants to modify a continuous
	 * NVRAM area using a batch of this HWRM requests. The
	 * offset of a request must be continuous to the end of previous
	 * request's. Firmware does not update the directory entry until
	 * receiving the last request, which is indicated by the batch_last
	 * flag. This flag is set usually when a sender does not have a
	 * block of memory that is big enough to hold the entire NVRAM
	 * data for send at one time.
	 */
	#define HWRM_NVM_WRITE_INPUT_FLAGS_BATCH_MODE		UINT32_C(0x2)
	/*
	 * This flag can be used only when the batch_mode flag is set. It
	 * indicates this request is the last of batch requests.
	 */
	#define HWRM_NVM_WRITE_INPUT_FLAGS_BATCH_LAST		UINT32_C(0x4)
	/*
	 * The requested length of the allocated NVM for the item, in bytes.
	 * This value may be greater than or equal to the specified data
	 * length (dir_data_length).
	 * If this value is less than the specified data length, it will be
	 * ignored. The response will contain the actual allocated item length,
	 * which may be greater than the requested item length.
	 * The purpose for allocating more than the required number of bytes
	 * for an item's data is to pre-allocate extra storage (padding) to
	 * accommodate the potential future growth of an item (e.g. upgraded
	 * firmware with a size increase, log growth, expanded configuration
	 * data).
	 */
	uint32_t	dir_item_length;
	/*
	 * 32-bit offset of data blob from where data is being written.
	 * Only valid for batch mode. For non-batch writes 'dont care'.
	 */
	uint32_t	offset;
	/*
	 * Length of data to be written.Should be non-zero.
	 * Only valid for batch mode. For non-batch writes 'dont care'.
	 */
	uint32_t	len;
	uint32_t	unused_0;
} hwrm_nvm_write_input_t, *phwrm_nvm_write_input_t;

/* hwrm_nvm_write_output (size:128b/16B) */

typedef struct hwrm_nvm_write_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Length of the allocated NVM for the item, in bytes. The value may be
	 * greater than or equal to the specified data length or the requested
	 * item length.
	 * The actual item length used when creating a new directory entry will
	 * be a multiple of an NVM block size.
	 */
	uint32_t	dir_item_length;
	/* The directory index of the created or modified item. */
	uint16_t	dir_idx;
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_write_output_t, *phwrm_nvm_write_output_t;

/* hwrm_nvm_write_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_write_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_UNKNOWN  UINT32_C(0x0)
	/* Unable to complete operation due to fragmentation */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_FRAG_ERR UINT32_C(0x1)
	/* nvm is completely full. */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_NO_SPACE UINT32_C(0x2)
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_LAST	HWRM_NVM_WRITE_CMD_ERR_CODE_NO_SPACE
	uint8_t	unused_0[7];
} hwrm_nvm_write_cmd_err_t, *phwrm_nvm_write_cmd_err_t;

/*******************
 * hwrm_nvm_modify *
 *******************/


/* hwrm_nvm_modify_input (size:320b/40B) */

typedef struct hwrm_nvm_modify_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is where the modified data is.
	 */
	uint64_t	host_src_addr;
	/* 16-bit directory entry index. */
	uint16_t	dir_idx;
	uint16_t	flags;
	/*
	 * This flag indicates the sender wants to modify a continuous NVRAM
	 * area using a batch of this HWRM requests. The offset of a request
	 * must be continuous to the end of previous request's. Firmware does
	 * not update the directory entry until receiving the last request,
	 * which is indicated by the batch_last flag.
	 * This flag is set usually when a sender does not have a block of
	 * memory that is big enough to hold the entire NVRAM data for send
	 * at one time.
	 */
	#define HWRM_NVM_MODIFY_INPUT_FLAGS_BATCH_MODE	UINT32_C(0x1)
	/*
	 * This flag can be used only when the batch_mode flag is set.
	 * It indicates this request is the last of batch requests.
	 */
	#define HWRM_NVM_MODIFY_INPUT_FLAGS_BATCH_LAST	UINT32_C(0x2)
	/* 32-bit NVRAM byte-offset to modify content from. */
	uint32_t	offset;
	/*
	 * Length of data to be modified, in bytes. The length shall
	 * be non-zero.
	 */
	uint32_t	len;
	uint8_t	unused_1[4];
} hwrm_nvm_modify_input_t, *phwrm_nvm_modify_input_t;

/* hwrm_nvm_modify_output (size:128b/16B) */

typedef struct hwrm_nvm_modify_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_modify_output_t, *phwrm_nvm_modify_output_t;

/***************************
 * hwrm_nvm_find_dir_entry *
 ***************************/


/* hwrm_nvm_find_dir_entry_input (size:256b/32B) */

typedef struct hwrm_nvm_find_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dir_idx_valid field to be
	 * configured.
	 */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_ENABLES_DIR_IDX_VALID	UINT32_C(0x1)
	/* Directory Entry Index */
	uint16_t	dir_idx;
	/* Directory Entry (Image) Type */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The instance of this Directory Type
	 */
	uint16_t	dir_ordinal;
	/* The Directory Entry Extension flags. */
	uint16_t	dir_ext;
	/* This value indicates the search option using dir_ordinal. */
	uint8_t	opt_ordinal;
	/* This value indicates the search option using dir_ordinal. */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_MASK UINT32_C(0x3)
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_SFT 0
	/* Equal to specified ordinal value. */
		#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_EQ	UINT32_C(0x0)
	/* Greater than or equal to specified ordinal value */
		#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GE	UINT32_C(0x1)
	/* Greater than specified ordinal value */
		#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GT	UINT32_C(0x2)
		#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_LAST HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GT
	uint8_t	unused_0[3];
} hwrm_nvm_find_dir_entry_input_t, *phwrm_nvm_find_dir_entry_input_t;

/* hwrm_nvm_find_dir_entry_output (size:256b/32B) */

typedef struct hwrm_nvm_find_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Allocated NVRAM for this directory entry, in bytes. */
	uint32_t	dir_item_length;
	/* Size of the stored data for this directory entry, in bytes. */
	uint32_t	dir_data_length;
	/*
	 * Firmware version.
	 * Only valid if the directory entry is for embedded firmware stored
	 * in APE_BIN Format.
	 */
	uint32_t	fw_ver;
	/* Directory ordinal. */
	uint16_t	dir_ordinal;
	/* Directory Entry Index */
	uint16_t	dir_idx;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_find_dir_entry_output_t, *phwrm_nvm_find_dir_entry_output_t;

/****************************
 * hwrm_nvm_erase_dir_entry *
 ****************************/


/* hwrm_nvm_erase_dir_entry_input (size:192b/24B) */

typedef struct hwrm_nvm_erase_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Directory Entry Index */
	uint16_t	dir_idx;
	uint8_t	unused_0[6];
} hwrm_nvm_erase_dir_entry_input_t, *phwrm_nvm_erase_dir_entry_input_t;

/* hwrm_nvm_erase_dir_entry_output (size:128b/16B) */

typedef struct hwrm_nvm_erase_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_erase_dir_entry_output_t, *phwrm_nvm_erase_dir_entry_output_t;

/*************************
 * hwrm_nvm_get_dev_info *
 *************************/


/* hwrm_nvm_get_dev_info_input (size:192b/24B) */

typedef struct hwrm_nvm_get_dev_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * This bit is only used when external secure SoC is used for
	 * secure boot.This bit is utilized to differentiate between
	 * device information for NIC or Security SoC non-volatile
	 * storage on the device. If this bit is set, then device
	 * information for the Security SoC non-volatile storage on the
	 * device.
	 */
	#define HWRM_NVM_GET_DEV_INFO_INPUT_FLAGS_SECURITY_SOC_NVM	UINT32_C(0x1)
	uint8_t	unused_0[7];
} hwrm_nvm_get_dev_info_input_t, *phwrm_nvm_get_dev_info_input_t;

/* hwrm_nvm_get_dev_info_output (size:768b/96B) */

typedef struct hwrm_nvm_get_dev_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Manufacturer ID. */
	uint16_t	manufacturer_id;
	/* Device ID. */
	uint16_t	device_id;
	/* Sector size of the NVRAM device. */
	uint32_t	sector_size;
	/* Total size, in bytes of the NVRAM device. */
	uint32_t	nvram_size;
	uint32_t	reserved_size;
	/*
	 * Available size that can be used, in bytes. Available size is the
	 * NVRAM size take away the used size and reserved size.
	 */
	uint32_t	available_size;
	/* This field represents the major version of NVM cfg */
	uint8_t	nvm_cfg_ver_maj;
	/* This field represents the minor version of NVM cfg */
	uint8_t	nvm_cfg_ver_min;
	/* This field represents the update version of NVM cfg */
	uint8_t	nvm_cfg_ver_upd;
	uint8_t	flags;
	/*
	 * If set to 1, firmware will provide various firmware version
	 * information stored in the flash.
	 */
	#define HWRM_NVM_GET_DEV_INFO_OUTPUT_FLAGS_FW_VER_VALID	UINT32_C(0x1)
	/*
	 * This field represents the board package name stored in the flash.
	 * (ASCII chars with NULL at the end).
	 */
	char	pkg_name[16];
	/*
	 * This field represents the major version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_minor;
	/*
	 * This field represents the build version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the HWRM firmware.
	 */
	uint16_t	hwrm_fw_patch;
	/*
	 * This field represents the major version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_major;
	/*
	 * This field represents the minor version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_minor;
	/*
	 * This field represents the build version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the mgmt firmware.
	 */
	uint16_t	mgmt_fw_patch;
	/*
	 * This field represents the major version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_major;
	/*
	 * This field represents the minor version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_minor;
	/*
	 * This field represents the build version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the roce firmware.
	 */
	uint16_t	roce_fw_patch;
	/*
	 * This field represents the major version of network control firmware,
	 * stored in the flash.
	 */
	uint16_t	netctrl_fw_major;
	/*
	 * This field represents the minor version of network control firmware,
	 * stored in the flash.
	 */
	uint16_t	netctrl_fw_minor;
	/*
	 * This field represents the build version of network control firmware,
	 * stored in the flash.
	 */
	uint16_t	netctrl_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the network control firmware.
	 */
	uint16_t	netctrl_fw_patch;
	/*
	 * This field represents the major version of SRT2 firmware, stored in
	 * the flash.
	 */
	uint16_t	srt2_fw_major;
	/*
	 * This field represents the minor version of SRT2 firmware, stored in
	 * the flash.
	 */
	uint16_t	srt2_fw_minor;
	/*
	 * This field represents the build version of SRT2 firmware, stored in
	 * the flash.
	 */
	uint16_t	srt2_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the SRT2 firmware.
	 */
	uint16_t	srt2_fw_patch;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_dev_info_output_t, *phwrm_nvm_get_dev_info_output_t;

/**************************
 * hwrm_nvm_mod_dir_entry *
 **************************/


/* hwrm_nvm_mod_dir_entry_input (size:256b/32B) */

typedef struct hwrm_nvm_mod_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the checksum field to be
	 * configured.
	 */
	#define HWRM_NVM_MOD_DIR_ENTRY_INPUT_ENABLES_CHECKSUM	UINT32_C(0x1)
	/* Directory Entry Index */
	uint16_t	dir_idx;
	/*
	 * Directory ordinal.
	 * The (0-based) instance of this Directory Type.
	 */
	uint16_t	dir_ordinal;
	/*
	 * The Directory Entry Extension flags (see BNX_DIR_EXT_* for
	 * extension flag definitions).
	 */
	uint16_t	dir_ext;
	/*
	 * Directory Entry Attribute flags (see BNX_DIR_ATTR_* for attribute
	 * flag definitions).
	 */
	uint16_t	dir_attr;
	/*
	 * If valid, then this field updates the checksum
	 * value of the content in the directory entry.
	 */
	uint32_t	checksum;
} hwrm_nvm_mod_dir_entry_input_t, *phwrm_nvm_mod_dir_entry_input_t;

/* hwrm_nvm_mod_dir_entry_output (size:128b/16B) */

typedef struct hwrm_nvm_mod_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_mod_dir_entry_output_t, *phwrm_nvm_mod_dir_entry_output_t;

/**************************
 * hwrm_nvm_verify_update *
 **************************/


/* hwrm_nvm_verify_update_input (size:192b/24B) */

typedef struct hwrm_nvm_verify_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Directory Entry Type, to be verified. */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The instance of the Directory Type to be verified.
	 */
	uint16_t	dir_ordinal;
	/*
	 * The Directory Entry Extension flags.
	 * The "UPDATE" extension flag must be set in this value.
	 * A corresponding directory entry with the same type and ordinal
	 * values but *without*
	 * the "UPDATE" extension flag must also exist. The other flags of
	 * the extension must
	 * be identical between the active and update entries.
	 */
	uint16_t	dir_ext;
	uint8_t	unused_0[2];
} hwrm_nvm_verify_update_input_t, *phwrm_nvm_verify_update_input_t;

/* hwrm_nvm_verify_update_output (size:128b/16B) */

typedef struct hwrm_nvm_verify_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_verify_update_output_t, *phwrm_nvm_verify_update_output_t;

/***************************
 * hwrm_nvm_install_update *
 ***************************/


/* hwrm_nvm_install_update_input (size:192b/24B) */

typedef struct hwrm_nvm_install_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Installation type. If the value 3 through 0xffff is used,
	 * only packaged items with that type value will be installed and
	 * conditional installation directives for those packaged items
	 * will be over-ridden (i.e. 'create' or 'replace' will be treated
	 * as 'install').
	 */
	uint32_t	install_type;
	/*
	 * Perform a normal package installation. Conditional installation
	 * directives (e.g. 'create' and 'replace') of packaged items
	 * will be followed.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_NORMAL UINT32_C(0x0)
	/*
	 * Install all packaged items regardless of installation directive
	 * (i.e. treat all packaged items as though they have an installation
	 * directive of 'install').
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_ALL	UINT32_C(0xffffffff)
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_LAST  HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_ALL
	uint16_t	flags;
	/*
	 * If set to 1, then securely erase all unused locations in
	 * persistent storage.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_ERASE_UNUSED_SPACE	UINT32_C(0x1)
	/*
	 * If set to 1, then unspecified images, images not in the package
	 * file, will be safely deleted.
	 * When combined with erase_unused_space then unspecified images will
	 * be securely erased.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_REMOVE_UNUSED_PKG	UINT32_C(0x2)
	/*
	 * If set to 1, FW will defragment the NVM if defragmentation is
	 * required for the update.
	 * Allow additional time for this command to complete if this bit is
	 * set to 1.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_ALLOWED_TO_DEFRAG	UINT32_C(0x4)
	/*
	 * If set to 1, FW will verify the package in the "UPDATE" NVM item
	 * without installing it. This flag is for FW internal use only.
	 * Users should not set this flag. The request will otherwise fail.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_VERIFY_ONLY		UINT32_C(0x8)
	uint8_t	unused_0[2];
} hwrm_nvm_install_update_input_t, *phwrm_nvm_install_update_input_t;

/* hwrm_nvm_install_update_output (size:192b/24B) */

typedef struct hwrm_nvm_install_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bit-mask of successfully installed items.
	 * Bit-0 corresponding to the first packaged item, Bit-1 for the second
	 * item, etc. A value of 0 indicates that no items were successfully
	 * installed.
	 */
	uint64_t	installed_items;
	/* result is 8 b corresponding to BCMRETVAL error codes */
	uint8_t	result;
	/* There was no problem with the package installation. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_SUCCESS			UINT32_C(0x0)
	/* Generic failure */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_FAILURE			UINT32_C(0xff)
	/* Allocation error malloc failure */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_MALLOC_FAILURE		UINT32_C(0xfd)
	/* NVM install error due to invalid index */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_INDEX_PARAMETER	UINT32_C(0xfb)
	/* NVM install error due to invalid type */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_TYPE_PARAMETER	UINT32_C(0xf3)
	/* Invalid package due to invalid prerequisite */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_PREREQUISITE	UINT32_C(0xf2)
	/* Invalid package due to invalid file header */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_FILE_HEADER	UINT32_C(0xec)
	/* Invalid package due to invalid format */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_SIGNATURE		UINT32_C(0xeb)
	/* Invalid package due to invalid property stream */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_PROP_STREAM	UINT32_C(0xea)
	/* Invalid package due to invalid property length */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_PROP_LENGTH	UINT32_C(0xe9)
	/* Invalid package due to invalid manifest */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_MANIFEST		UINT32_C(0xe8)
	/* Invalid package due to invalid trailer */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_TRAILER		UINT32_C(0xe7)
	/* Invalid package due to invalid checksum */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_CHECKSUM		UINT32_C(0xe6)
	/* Invalid package due to invalid item checksum */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_ITEM_CHECKSUM	UINT32_C(0xe5)
	/* Invalid package due to invalid length */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_DATA_LENGTH	UINT32_C(0xe4)
	/* Invalid package due to invalid directive */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INVALID_DIRECTIVE		UINT32_C(0xe1)
	/* Invalid device due to unsupported chip revision */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_CHIP_REV	UINT32_C(0xce)
	/* Invalid device due to unsupported device ID */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_DEVICE_ID	UINT32_C(0xcd)
	/* Invalid device due to unsupported subsystem vendor */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_SUBSYS_VENDOR	UINT32_C(0xcc)
	/* Invalid device due to unsupported subsystem ID */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_SUBSYS_ID	UINT32_C(0xcb)
	/* Invalid device due to unsupported product ID or customer ID */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_UNSUPPORTED_PLATFORM	UINT32_C(0xc5)
	/* Invalid package due to duplicate item */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_DUPLICATE_ITEM		UINT32_C(0xc4)
	/* Invalid package due to zero length item */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_ZERO_LENGTH_ITEM		UINT32_C(0xc3)
	/* NVM integrity error checksum */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INSTALL_CHECKSUM_ERROR	UINT32_C(0xb9)
	/* NVM integrity error */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INSTALL_DATA_ERROR	UINT32_C(0xb8)
	/* Authentication error */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_INSTALL_AUTHENTICATION_ERROR UINT32_C(0xb7)
	/* NVM install error item not found */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_ITEM_NOT_FOUND		UINT32_C(0xb0)
	/* NVM install error item locked */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_ITEM_LOCKED		UINT32_C(0xa7)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_LAST			HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_ITEM_LOCKED
	/* problem_item is 8 b */
	uint8_t	problem_item;
	/* There was no problem with any packaged items. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_NONE	UINT32_C(0x0)
	/* There was a problem with the NVM package itself. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_PACKAGE UINT32_C(0xff)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_LAST   HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_PACKAGE
	/* reset_required is 8 b */
	uint8_t	reset_required;
	/*
	 * No reset is required for installed/updated firmware or
	 * microcode to take effect.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_NONE  UINT32_C(0x0)
	/*
	 * A PCIe reset (e.g. system reboot) is
	 * required for newly installed/updated firmware or
	 * microcode to take effect.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_PCI   UINT32_C(0x1)
	/*
	 * A controller power reset (e.g. system power-cycle) is
	 * required for newly installed/updated firmware or
	 * microcode to take effect. Some newly installed/updated
	 * firmware or microcode may still take effect upon the
	 * next PCIe reset.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_POWER UINT32_C(0x2)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_LAST HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_POWER
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_install_update_output_t, *phwrm_nvm_install_update_output_t;

/* hwrm_nvm_install_update_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_install_update_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_UNKNOWN		UINT32_C(0x0)
	/* Unable to complete operation due to fragmentation */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_FRAG_ERR	UINT32_C(0x1)
	/* nvm is completely full. */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_SPACE	UINT32_C(0x2)
	/* Firmware update failed due to Anti-rollback. */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_ANTI_ROLLBACK	UINT32_C(0x3)
	/* Firmware update does not support voltage regulators on the device. */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_VOLTREG_SUPPORT UINT32_C(0x4)
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_LAST		HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_VOLTREG_SUPPORT
	uint8_t	unused_0[7];
} hwrm_nvm_install_update_cmd_err_t, *phwrm_nvm_install_update_cmd_err_t;

/******************
 * hwrm_nvm_flush *
 ******************/


/* hwrm_nvm_flush_input (size:128b/16B) */

typedef struct hwrm_nvm_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_nvm_flush_input_t, *phwrm_nvm_flush_input_t;

/* hwrm_nvm_flush_output (size:128b/16B) */

typedef struct hwrm_nvm_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_flush_output_t, *phwrm_nvm_flush_output_t;

/* hwrm_nvm_flush_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_flush_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	/* flush could not be performed */
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_FAIL	UINT32_C(0x1)
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_LAST   HWRM_NVM_FLUSH_CMD_ERR_CODE_FAIL
	uint8_t	unused_0[7];
} hwrm_nvm_flush_cmd_err_t, *phwrm_nvm_flush_cmd_err_t;

/*************************
 * hwrm_nvm_get_variable *
 *************************/


/* hwrm_nvm_get_variable_input (size:320b/40B) */

typedef struct hwrm_nvm_get_variable_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be stored
	 */
	uint64_t	dest_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_0	UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF UINT32_C(0xffff)
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_LAST	HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	flags;
	/*
	 * When this bit is set to 1, the factory default value will be
	 * returned, 0 returns the operational value.
	 */
	#define HWRM_NVM_GET_VARIABLE_INPUT_FLAGS_FACTORY_DFLT	UINT32_C(0x1)
	uint8_t	unused_0;
} hwrm_nvm_get_variable_input_t, *phwrm_nvm_get_variable_input_t;

/* hwrm_nvm_get_variable_output (size:128b/16B) */

typedef struct hwrm_nvm_get_variable_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* size of data of the actual variable retrieved in bits */
	uint16_t	data_len;
	/*
	 * option_num is the option number for the data retrieved. It is
	 * possible in the future that the option number returned would be
	 * different than requested. This condition could occur if an option is
	 * deprecated and a new option id is defined with similar
	 * characteristics, but has a slightly different definition. This
	 * also makes it convenient for the caller to identify the variable
	 * result with the option id from the response.
	 */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_0	UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_FFFF UINT32_C(0xffff)
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_LAST	HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_FFFF
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_variable_output_t, *phwrm_nvm_get_variable_output_t;

/* hwrm_nvm_get_variable_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_get_variable_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* variable does not exist */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST UINT32_C(0x1)
	/* configuration is corrupted and the variable cannot be saved */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR   UINT32_C(0x2)
	/* length specified is too small */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LEN_TOO_SHORT UINT32_C(0x3)
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LAST	HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LEN_TOO_SHORT
	uint8_t	unused_0[7];
} hwrm_nvm_get_variable_cmd_err_t, *phwrm_nvm_get_variable_cmd_err_t;

/*************************
 * hwrm_nvm_set_variable *
 *************************/


/* hwrm_nvm_set_variable_input (size:320b/40B) */

typedef struct hwrm_nvm_set_variable_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be copied from
	 */
	uint64_t	src_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_0	UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF UINT32_C(0xffff)
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_LAST	HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	flags;
	/*
	 * When this bit is 1, flush internal cache after this write
	 * operation (see hwrm_nvm_flush command.)
	 */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FORCE_FLUSH		UINT32_C(0x1)
	/* encryption method */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_MASK	UINT32_C(0xe)
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_SFT	1
	/* No encryption. */
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_NONE		(UINT32_C(0x0) << 1)
	/* one-way encryption. */
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1	(UINT32_C(0x1) << 1)
	/* symmetric AES256 encryption. */
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_AES256	(UINT32_C(0x2) << 1)
	/* SHA1 digest appended to plaintext contents, for authentication */
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1_AUTH  (UINT32_C(0x3) << 1)
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_LAST	HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1_AUTH
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FLAGS_UNUSED_0_MASK	UINT32_C(0x70)
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FLAGS_UNUSED_0_SFT	4
	/* When this bit is 1, update the factory default region */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FACTORY_DEFAULT		UINT32_C(0x80)
	uint8_t	unused_0;
} hwrm_nvm_set_variable_input_t, *phwrm_nvm_set_variable_input_t;

/* hwrm_nvm_set_variable_output (size:128b/16B) */

typedef struct hwrm_nvm_set_variable_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_set_variable_output_t, *phwrm_nvm_set_variable_output_t;

/* hwrm_nvm_set_variable_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_set_variable_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* variable does not exist */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST UINT32_C(0x1)
	/* configuration is corrupted and the variable cannot be saved */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR   UINT32_C(0x2)
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_LAST	HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR
	uint8_t	unused_0[7];
} hwrm_nvm_set_variable_cmd_err_t, *phwrm_nvm_set_variable_cmd_err_t;

/****************************
 * hwrm_nvm_validate_option *
 ****************************/


/* hwrm_nvm_validate_option_input (size:320b/40B) */

typedef struct hwrm_nvm_validate_option_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be copied from
	 */
	uint64_t	src_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_0	UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_FFFF UINT32_C(0xffff)
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_LAST	HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	unused_0[2];
} hwrm_nvm_validate_option_input_t, *phwrm_nvm_validate_option_input_t;

/* hwrm_nvm_validate_option_output (size:128b/16B) */

typedef struct hwrm_nvm_validate_option_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	result;
	/*
	 * indicates that the value provided for the option is not matching
	 * with the saved data.
	 */
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_NOT_MATCH UINT32_C(0x0)
	/*
	 * indicates that the value provided for the option is matching the
	 * saved data.
	 */
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_MATCH	UINT32_C(0x1)
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_LAST	HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_MATCH
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_validate_option_output_t, *phwrm_nvm_validate_option_output_t;

/* hwrm_nvm_validate_option_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_validate_option_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	#define HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_LAST   HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_UNKNOWN
	uint8_t	unused_0[7];
} hwrm_nvm_validate_option_cmd_err_t, *phwrm_nvm_validate_option_cmd_err_t;

/*****************************
 * hwrm_nvm_factory_defaults *
 *****************************/


/* hwrm_nvm_factory_defaults_input (size:192b/24B) */

typedef struct hwrm_nvm_factory_defaults_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* mode is 8 b */
	uint8_t	mode;
	/*
	 * If set to 1, it triggers restoration of factory default data.
	 * If the selection field is zero, all data are restored to default.
	 * If the selection field is non-zero, only the selected data are
	 * restored.
	 */
	#define HWRM_NVM_FACTORY_DEFAULTS_INPUT_MODE_RESTORE UINT32_C(0x0)
	/*
	 * If set to 1, it triggers creation of factory default data.
	 * If the selection field is zero, all default data are created.
	 * If the selection field is non-zero, only the selected data are
	 * created.
	 */
	#define HWRM_NVM_FACTORY_DEFAULTS_INPUT_MODE_CREATE  UINT32_C(0x1)
	#define HWRM_NVM_FACTORY_DEFAULTS_INPUT_MODE_LAST   HWRM_NVM_FACTORY_DEFAULTS_INPUT_MODE_CREATE
	uint8_t	unused_0[1];
	/*
	 * This field selects which data the factory default operation applies.
	 * If it is '0', the operation applies to all data. If it is not '0',
	 * the operation only applies to the data selected by this field.
	 */
	uint16_t	selection;
	/* When this bit is '1', config option is selected. */
	#define HWRM_NVM_FACTORY_DEFAULTS_INPUT_SELECTION_CFG_OPTION	UINT32_C(0x1)
	/* When this bit is '1', crashdump is selected. */
	#define HWRM_NVM_FACTORY_DEFAULTS_INPUT_SELECTION_CRASHDUMP	UINT32_C(0x2)
	uint8_t	unused_1[4];
} hwrm_nvm_factory_defaults_input_t, *phwrm_nvm_factory_defaults_input_t;

/* hwrm_nvm_factory_defaults_output (size:128b/16B) */

typedef struct hwrm_nvm_factory_defaults_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	result;
	/* factory defaults created successfully. */
	#define HWRM_NVM_FACTORY_DEFAULTS_OUTPUT_RESULT_CREATE_OK	UINT32_C(0x0)
	/* factory defaults restored successfully. */
	#define HWRM_NVM_FACTORY_DEFAULTS_OUTPUT_RESULT_RESTORE_OK	UINT32_C(0x1)
	/* factory defaults already created. */
	#define HWRM_NVM_FACTORY_DEFAULTS_OUTPUT_RESULT_CREATE_ALREADY UINT32_C(0x2)
	#define HWRM_NVM_FACTORY_DEFAULTS_OUTPUT_RESULT_LAST	HWRM_NVM_FACTORY_DEFAULTS_OUTPUT_RESULT_CREATE_ALREADY
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_factory_defaults_output_t, *phwrm_nvm_factory_defaults_output_t;

/* hwrm_nvm_factory_defaults_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_factory_defaults_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_FACTORY_DEFAULTS_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* valid configuration not present to create defaults */
	#define HWRM_NVM_FACTORY_DEFAULTS_CMD_ERR_CODE_NO_VALID_CFG UINT32_C(0x1)
	/* No saved configuration present to restore, restore failed */
	#define HWRM_NVM_FACTORY_DEFAULTS_CMD_ERR_CODE_NO_SAVED_CFG UINT32_C(0x2)
	#define HWRM_NVM_FACTORY_DEFAULTS_CMD_ERR_CODE_LAST	HWRM_NVM_FACTORY_DEFAULTS_CMD_ERR_CODE_NO_SAVED_CFG
	uint8_t	unused_0[7];
} hwrm_nvm_factory_defaults_cmd_err_t, *phwrm_nvm_factory_defaults_cmd_err_t;

/****************************
 * hwrm_nvm_req_arbitration *
 ****************************/


/* hwrm_nvm_req_arbitration_input (size:192b/24B) */

typedef struct hwrm_nvm_req_arbitration_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of NVRAM arbitration request */
	uint8_t	type;
	/* Query if NVRAM arbitration semaphore is acquired outside of Nitro */
	#define HWRM_NVM_REQ_ARBITRATION_INPUT_TYPE_STATUS  UINT32_C(0x0)
	/* Acquire NVRAM arbitration semaphore */
	#define HWRM_NVM_REQ_ARBITRATION_INPUT_TYPE_ACQUIRE UINT32_C(0x1)
	/* Release NVRAM arbitration semaphore */
	#define HWRM_NVM_REQ_ARBITRATION_INPUT_TYPE_RELEASE UINT32_C(0x2)
	#define HWRM_NVM_REQ_ARBITRATION_INPUT_TYPE_LAST   HWRM_NVM_REQ_ARBITRATION_INPUT_TYPE_RELEASE
	uint8_t	unused_0[7];
} hwrm_nvm_req_arbitration_input_t, *phwrm_nvm_req_arbitration_input_t;

/* hwrm_nvm_req_arbitration_output (size:128b/16B) */

typedef struct hwrm_nvm_req_arbitration_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* NVRAM arbitration semaphore is acquired if value is 1 */
	uint8_t	acquired;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_req_arbitration_output_t, *phwrm_nvm_req_arbitration_output_t;

/*******************
 * hwrm_nvm_defrag *
 *******************/


/* hwrm_nvm_defrag_input (size:192b/24B) */

typedef struct hwrm_nvm_defrag_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* This bit must be '1' to perform NVM defragmentation. */
	#define HWRM_NVM_DEFRAG_INPUT_FLAGS_DEFRAG	UINT32_C(0x1)
	uint8_t	unused_0[4];
} hwrm_nvm_defrag_input_t, *phwrm_nvm_defrag_input_t;

/* hwrm_nvm_defrag_output (size:128b/16B) */

typedef struct hwrm_nvm_defrag_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_defrag_output_t, *phwrm_nvm_defrag_output_t;

/* hwrm_nvm_defrag_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_defrag_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_DEFRAG_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	/* NVM defragmentation could not be performed */
	#define HWRM_NVM_DEFRAG_CMD_ERR_CODE_FAIL	UINT32_C(0x1)
	#define HWRM_NVM_DEFRAG_CMD_ERR_CODE_LAST   HWRM_NVM_DEFRAG_CMD_ERR_CODE_FAIL
	uint8_t	unused_0[7];
} hwrm_nvm_defrag_cmd_err_t, *phwrm_nvm_defrag_cmd_err_t;

/*******************************
 * hwrm_nvm_get_vpd_field_info *
 *******************************/


/* hwrm_nvm_get_vpd_field_info_input (size:192b/24B) */

typedef struct hwrm_nvm_get_vpd_field_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Tag ID of the requested field. To request the Product Name
	 * a value of [0x00, 0x82] should be used. All other fields
	 * would use the two byte hexadecimal value of the ASCII
	 * characters. The first letter of the ASCII keyword is recorded
	 * in tag_id[0] and the next letter in tag_id[1].
	 */
	uint8_t	tag_id[2];
	uint8_t	unused_0[6];
} hwrm_nvm_get_vpd_field_info_input_t, *phwrm_nvm_get_vpd_field_info_input_t;

/* hwrm_nvm_get_vpd_field_info_output (size:2176b/272B) */

typedef struct hwrm_nvm_get_vpd_field_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Data retrieved from VPD field */
	uint8_t	data[256];
	/* size of data retrieved in bytes */
	uint16_t	data_len;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_vpd_field_info_output_t, *phwrm_nvm_get_vpd_field_info_output_t;

/*******************************
 * hwrm_nvm_set_vpd_field_info *
 *******************************/


/* hwrm_nvm_set_vpd_field_info_input (size:256b/32B) */

typedef struct hwrm_nvm_set_vpd_field_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * VPD data value will be copied from
	 */
	uint64_t	host_src_addr;
	/*
	 * Tag ID of the requested field. To request the Product Name
	 * a value of [0x00, 0x82] should be used. All other fields
	 * would use the two byte hexadecimal value of the ASCII
	 * characters. The first letter of the ASCII keyword is recorded
	 * in tag_id[0] and the next letter in tag_id[1].
	 */
	uint8_t	tag_id[2];
	/* size of data in bytes */
	uint16_t	data_len;
	uint8_t	unused_0[4];
} hwrm_nvm_set_vpd_field_info_input_t, *phwrm_nvm_set_vpd_field_info_input_t;

/* hwrm_nvm_set_vpd_field_info_output (size:128b/16B) */

typedef struct hwrm_nvm_set_vpd_field_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_set_vpd_field_info_output_t, *phwrm_nvm_set_vpd_field_info_output_t;

#define ROCE_SP_HSI_VERSION_MAJOR 1
#define ROCE_SP_HSI_VERSION_MINOR 8
#define ROCE_SP_HSI_VERSION_UPDATE 4
#define ROCE_SP_HSI_VERSION_STR "1.8.4"
/*
 * Following is the signature for ROCE_SP_HSI message field that indicates
 * not applicable (All F's). Need to cast it the size of the field if
 * needed.
 */
#define ROCE_SP_HSI_NA_SIGNATURE ((uint32_t)(-1))

/* cmdq_init (size:128b/16B) */

typedef struct cmdq_init {
	/* CMDQ PBL physical address. */
	uint64_t	cmdq_pbl;
	uint16_t	cmdq_size_cmdq_lvl;
	/* CMDQ PBL indirection levels. */
	#define CMDQ_INIT_CMDQ_LVL_MASK UINT32_C(0x3)
	#define CMDQ_INIT_CMDQ_LVL_SFT  0
	/* CMDQ size. */
	#define CMDQ_INIT_CMDQ_SIZE_MASK UINT32_C(0xfffc)
	#define CMDQ_INIT_CMDQ_SIZE_SFT 2
	/* CREQ completion ring id. */
	uint16_t	creq_ring_id;
	/* Mailbox producer index. MSB must also be set. */
	uint32_t	prod_idx;
} cmdq_init_t, *pcmdq_init_t;

/* cmdq_update (size:128b/16B) */

typedef struct cmdq_update {
	/* reserved64 is 64 b */
	uint64_t	reserved64;
	/* reserved32 is 32 b */
	uint32_t	reserved32;
	/* Mailbox producer index. */
	uint32_t	prod_idx;
} cmdq_update_t, *pcmdq_update_t;

/* cmdq_base (size:128b/16B) */

typedef struct cmdq_base {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Create QP command allocates QP context with the specified
	 * SQ, RQ/SRQ, CQ and other parameters.
	 */
	#define CMDQ_BASE_OPCODE_CREATE_QP			UINT32_C(0x1)
	/*
	 * Destroy QP command deletes the QP context and ceases
	 * any further reference.
	 */
	#define CMDQ_BASE_OPCODE_DESTROY_QP			UINT32_C(0x2)
	/*
	 * Modify QP command changes QP states and other QP specific
	 * parameters.
	 */
	#define CMDQ_BASE_OPCODE_MODIFY_QP			UINT32_C(0x3)
	/* Query QP command retrieves info about the specified QP. */
	#define CMDQ_BASE_OPCODE_QUERY_QP			UINT32_C(0x4)
	/* Create SRQ command allocates a SRQ with the specified parameters. */
	#define CMDQ_BASE_OPCODE_CREATE_SRQ			UINT32_C(0x5)
	/* Destroy SRQ command deletes and flushes the specified SRQ. */
	#define CMDQ_BASE_OPCODE_DESTROY_SRQ			UINT32_C(0x6)
	/* Query SRP command retrieves info about the specified SRQ. */
	#define CMDQ_BASE_OPCODE_QUERY_SRQ			UINT32_C(0x8)
	/* Create CQ command allocates a CQ with the specified parameters. */
	#define CMDQ_BASE_OPCODE_CREATE_CQ			UINT32_C(0x9)
	/* Destroy CQ command deletes and flushes the specified CQ. */
	#define CMDQ_BASE_OPCODE_DESTROY_CQ			UINT32_C(0xa)
	/* Resize CQ command resizes the specified CQ. */
	#define CMDQ_BASE_OPCODE_RESIZE_CQ			UINT32_C(0xc)
	/*
	 * Allocate MRW command allocates a MR/MW with the specified parameters
	 * and returns the region's L_KEY/R_KEY
	 */
	#define CMDQ_BASE_OPCODE_ALLOCATE_MRW			UINT32_C(0xd)
	/*
	 * De-allocate key command frees a MR/MW entry associated with the
	 * specified key.
	 */
	#define CMDQ_BASE_OPCODE_DEALLOCATE_KEY		UINT32_C(0xe)
	/* Register MR command registers memory to the specified MR. */
	#define CMDQ_BASE_OPCODE_REGISTER_MR			UINT32_C(0xf)
	/* Deregister MR command de-registers memory from the specified MR. */
	#define CMDQ_BASE_OPCODE_DEREGISTER_MR		UINT32_C(0x10)
	/* Add GID command adds a GID to the local address table. */
	#define CMDQ_BASE_OPCODE_ADD_GID			UINT32_C(0x11)
	/* Delete GID command deletes a GID from the local address table. */
	#define CMDQ_BASE_OPCODE_DELETE_GID			UINT32_C(0x12)
	/* Modify GID command modifies a GID in the local address table. */
	#define CMDQ_BASE_OPCODE_MODIFY_GID			UINT32_C(0x17)
	/* Query GID command queries a GID in the local address table. */
	#define CMDQ_BASE_OPCODE_QUERY_GID			UINT32_C(0x18)
	/* Create QP1 command allocates a QP1 only. */
	#define CMDQ_BASE_OPCODE_CREATE_QP1			UINT32_C(0x13)
	/* Destroy QP1 command deletes and flushes the specified QP1. */
	#define CMDQ_BASE_OPCODE_DESTROY_QP1			UINT32_C(0x14)
	/* Create AH command allocates an AH with the specified parameters. */
	#define CMDQ_BASE_OPCODE_CREATE_AH			UINT32_C(0x15)
	/* Destroy AH command deletes the specified AH. */
	#define CMDQ_BASE_OPCODE_DESTROY_AH			UINT32_C(0x16)
	/*
	 * Initialize firmware command initializes the firmware with
	 * the specified parameters.
	 */
	#define CMDQ_BASE_OPCODE_INITIALIZE_FW		UINT32_C(0x80)
	/* De-initialize firmware command deinitializes the firmware. */
	#define CMDQ_BASE_OPCODE_DEINITIALIZE_FW		UINT32_C(0x81)
	/* Stop the function */
	#define CMDQ_BASE_OPCODE_STOP_FUNC			UINT32_C(0x82)
	/* Query the HW capabilities for the function. */
	#define CMDQ_BASE_OPCODE_QUERY_FUNC			UINT32_C(0x83)
	/*
	 * Set the following resources for the function:
	 * - Max QP, CQ, MR+MW, SRQ per PF
	 * - Max QP, CQ, MR+MW, SRQ per VF
	 */
	#define CMDQ_BASE_OPCODE_SET_FUNC_RESOURCES		UINT32_C(0x84)
	/*
	 * Read the current state of any internal resource context. Can only be
	 * issued from a PF.
	 */
	#define CMDQ_BASE_OPCODE_READ_CONTEXT			UINT32_C(0x85)
	/*
	 * Send a request from VF to pass a command to the PF. VF HSI is
	 * suspended until the PF returns the response
	 */
	#define CMDQ_BASE_OPCODE_VF_BACKCHANNEL_REQUEST	UINT32_C(0x86)
	/*
	 * Read VF memory (primarily to get the backchannel request blob). Can
	 * only be issued from a PF.
	 */
	#define CMDQ_BASE_OPCODE_READ_VF_MEMORY		UINT32_C(0x87)
	/*
	 * Write VF memory (primarily to put the backchannel response blob),
	 * and reenable VF HSI (post a CAG completion to it). Can only be
	 * issued from a PF.
	 */
	#define CMDQ_BASE_OPCODE_COMPLETE_VF_REQUEST		UINT32_C(0x88)
	/*
	 * Deprecated.
	 * Extend resource (QPC, MRW, CQ, SRQ) array, after the host allocates
	 * more. Can only be issued from a PF.
	 */
	#define CMDQ_BASE_OPCODE_EXTEND_CONTEXT_ARRAY_DEPRECATED UINT32_C(0x89)
	/* Map TC to COS. Can only be issued from a PF. */
	#define CMDQ_BASE_OPCODE_MAP_TC_TO_COS		UINT32_C(0x8a)
	/* Query version. */
	#define CMDQ_BASE_OPCODE_QUERY_VERSION		UINT32_C(0x8b)
	/* Modify congestion control. Can only be issued from a PF. */
	#define CMDQ_BASE_OPCODE_MODIFY_ROCE_CC		UINT32_C(0x8c)
	/* Query congestion control. */
	#define CMDQ_BASE_OPCODE_QUERY_ROCE_CC		UINT32_C(0x8d)
	/* Query RoCE statistics. */
	#define CMDQ_BASE_OPCODE_QUERY_ROCE_STATS		UINT32_C(0x8e)
	/* Set LAG mode. */
	#define CMDQ_BASE_OPCODE_SET_LINK_AGGR_MODE		UINT32_C(0x8f)
	/* Modify CQ */
	#define CMDQ_BASE_OPCODE_MODIFY_CQ			UINT32_C(0x90)
	/*
	 * Query QP for a PF other than the requesting PF. Also can query for
	 * more than one QP.
	 */
	#define CMDQ_BASE_OPCODE_QUERY_QP_EXTEND		UINT32_C(0x91)
	/* Query extended RoCE statistics. */
	#define CMDQ_BASE_OPCODE_QUERY_ROCE_STATS_EXT		UINT32_C(0x92)
	/*
	 * This command updates the QP context id ranges on the PF,
	 * to orchestrate QP context id range migration.
	 * This command is valid for devices that
	 * support the pseudo-static QP allocation feature.
	 */
	#define CMDQ_BASE_OPCODE_ORCHESTRATE_QID_MIGRATION	UINT32_C(0x93)
	/*
	 * This command allocates a batch of the requested count of QPs
	 * in a sequential range.
	 */
	#define CMDQ_BASE_OPCODE_CREATE_QP_BATCH		UINT32_C(0x94)
	/*
	 * This command deletes a batch of the requested count of QPs.
	 * The starting QP ID can be specified to request a batch deletion
	 * of a sequential range.
	 */
	#define CMDQ_BASE_OPCODE_DESTROY_QP_BATCH		UINT32_C(0x95)
	/*
	 * This command allocates an extended RoCE statistics context
	 * that supports periodic DMA to a host address. The extended
	 * statistics context id can be assigned by the driver
	 * via `create_qp`, `create_qp_batch`, or `modify_qp` to a specific QP,
	 * a subset of QPs or to all QPs of a specific function.
	 * These statistics can be queried via `query_roce_stats_ext_v2`.
	 */
	#define CMDQ_BASE_OPCODE_ALLOCATE_ROCE_STATS_EXT_CTX	UINT32_C(0x96)
	/* This command deallocates an extended RoCE statistics context. */
	#define CMDQ_BASE_OPCODE_DEALLOCATE_ROCE_STATS_EXT_CTX   UINT32_C(0x97)
	/*
	 * This command queries extended RoCE statistics for context
	 * allocated via `allocate_roce_stats_ext_ctx`.
	 */
	#define CMDQ_BASE_OPCODE_QUERY_ROCE_STATS_EXT_V2	UINT32_C(0x98)
	#define CMDQ_BASE_OPCODE_LAST			CMDQ_BASE_OPCODE_QUERY_ROCE_STATS_EXT_V2
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_base_t, *pcmdq_base_t;

/* creq_base (size:128b/16B) */

typedef struct creq_base {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_BASE_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_BASE_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_BASE_TYPE_QP_EVENT	UINT32_C(0x38)
	/* Function Async Notification */
		#define CREQ_BASE_TYPE_FUNC_EVENT  UINT32_C(0x3a)
		#define CREQ_BASE_TYPE_LAST	CREQ_BASE_TYPE_FUNC_EVENT
	uint8_t	reserved56[7];
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_BASE_V	UINT32_C(0x1)
	/* This is the modifier on to the type field. */
	uint8_t	event;
	uint8_t	reserved48[6];
} creq_base_t, *pcreq_base_t;

/* creq_resp_sb_hdr (size:64b/8B) */

typedef struct creq_resp_sb_hdr {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_QP		UINT32_C(0x4)
	/* Query SRQ command response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_SRQ		UINT32_C(0x8)
	/* Query GID command response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_GID		UINT32_C(0x18)
	/* Query info PF command response */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_FUNC		UINT32_C(0x83)
	/* Query version response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_VERSION	UINT32_C(0x8b)
	/* Query congestion control response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_ROCE_CC	UINT32_C(0x8d)
	/* Query RoCE statistics response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_ROCE_STATS	UINT32_C(0x8e)
	/* Query QP extended response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_QP_EXTEND	UINT32_C(0x91)
	/* Query extended RoCE statistics response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_ROCE_STATS_EXT	UINT32_C(0x92)
	/* Query extended RoCE statistics v2 response. */
	#define CREQ_RESP_SB_HDR_OPCODE_QUERY_ROCE_STATS_EXT_V2 UINT32_C(0x98)
	#define CREQ_RESP_SB_HDR_OPCODE_LAST		CREQ_RESP_SB_HDR_OPCODE_QUERY_ROCE_STATS_EXT_V2
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
} creq_resp_sb_hdr_t, *pcreq_resp_sb_hdr_t;

/*
 * Structure to be used for the qp_params array of
 * the `create_qp_batch` command.
 */
/* create_qp_batch_data (size:768b/96B) */

typedef struct create_qp_batch_data {
	/* QP handle. */
	uint64_t	qp_handle;
	/* Create QP flags. */
	uint32_t	qp_flags;
	/*
	 * SRQ is used.
	 * This flag is not supported on express mode QPs.
	 */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_SRQ_USED		UINT32_C(0x1)
	/* post CQE for all SQ WQEs. */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_FORCE_COMPLETION	UINT32_C(0x2)
	/* This QP can use reserved L_Key */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_RESERVED_LKEY_ENABLE	UINT32_C(0x4)
	/* This QP can fast register physical memory */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_FR_PMR_ENABLED		UINT32_C(0x8)
	/* This QP can send variable sized WQEs. */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_VARIABLE_SIZED_WQE_ENABLED UINT32_C(0x10)
	/*
	 * WQEs with inline data sent on this QP are able to flow
	 * through an optimized transmit path to lower latency. This
	 * transmit path is opportunistic and not guaranteed to always
	 * occur.
	 */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_OPTIMIZED_TRANSMIT_ENABLED UINT32_C(0x20)
	/*
	 * For UD QPs the default responder CQE format is `cq_res_ud`.
	 * This flag specifies the `cq_res_ud_cfa` format to be used
	 * instead.
	 */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_RESPONDER_UD_CQE_WITH_CFA  UINT32_C(0x40)
	/*
	 * This QP must be included in the extended RoCE statistics
	 * that can be queried via `query_roce_stats_ext`.
	 */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_EXT_STATS_ENABLED	UINT32_C(0x80)
	/* This QP uses express mode. */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_EXPRESS_MODE_ENABLED	UINT32_C(0x100)
	/* This QP uses the steering tag specified in the command. */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_STEERING_TAG_VALID	UINT32_C(0x200)
	/*
	 * This QP can be used for RDMA Read or Atomic operations.
	 * This value is used to optimize metadata memory allocation
	 * when the device supports `internal_queue_memory` feature.
	 */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_RDMA_READ_OR_ATOMICS_USED  UINT32_C(0x400)
	/*
	 * This QP must be included in the extended RoCE statistics context
	 * specified in the field `ext_stats_ctx_id`
	 */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_EXT_STATS_CTX_VALID	UINT32_C(0x800)
	/* The schq_id field passed in by the caller is valid. */
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_SCHQ_ID_VALID		UINT32_C(0x1000)
	#define CREATE_QP_BATCH_DATA_QP_FLAGS_LAST			CREATE_QP_BATCH_DATA_QP_FLAGS_SCHQ_ID_VALID
	/* Supported QP types. */
	uint8_t	type;
	/* Reliable Connection. */
	#define CREATE_QP_BATCH_DATA_TYPE_RC		UINT32_C(0x2)
	/* Unreliable Datagram. */
	#define CREATE_QP_BATCH_DATA_TYPE_UD		UINT32_C(0x4)
	/* Raw Ethertype. */
	#define CREATE_QP_BATCH_DATA_TYPE_RAW_ETHERTYPE UINT32_C(0x6)
	/* General Services Interface on QP1 over UD. */
	#define CREATE_QP_BATCH_DATA_TYPE_GSI	UINT32_C(0x7)
	#define CREATE_QP_BATCH_DATA_TYPE_LAST	CREATE_QP_BATCH_DATA_TYPE_GSI
	uint8_t	sq_pg_size_sq_lvl;
	/*
	 * SQ PBL indirect levels.
	 * This field is ignored for express mode QPs.
	 */
	#define CREATE_QP_BATCH_DATA_SQ_LVL_MASK	UINT32_C(0xf)
	#define CREATE_QP_BATCH_DATA_SQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CREATE_QP_BATCH_DATA_SQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CREATE_QP_BATCH_DATA_SQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define CREATE_QP_BATCH_DATA_SQ_LVL_LVL_2	UINT32_C(0x2)
		#define CREATE_QP_BATCH_DATA_SQ_LVL_LAST	CREATE_QP_BATCH_DATA_SQ_LVL_LVL_2
	/*
	 * SQ page size.
	 * This field is ignored for express mode QPs.
	 */
	#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CREATE_QP_BATCH_DATA_SQ_PG_SIZE_LAST   CREATE_QP_BATCH_DATA_SQ_PG_SIZE_PG_1G
	uint8_t	rq_pg_size_rq_lvl;
	/*
	 * RQ PBL indirect levels.
	 * This field is ignored for express mode QPs.
	 */
	#define CREATE_QP_BATCH_DATA_RQ_LVL_MASK	UINT32_C(0xf)
	#define CREATE_QP_BATCH_DATA_RQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CREATE_QP_BATCH_DATA_RQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CREATE_QP_BATCH_DATA_RQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define CREATE_QP_BATCH_DATA_RQ_LVL_LVL_2	UINT32_C(0x2)
		#define CREATE_QP_BATCH_DATA_RQ_LVL_LAST	CREATE_QP_BATCH_DATA_RQ_LVL_LVL_2
	/*
	 * RQ page size.
	 * This field is ignored for express mode QPs.
	 */
	#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CREATE_QP_BATCH_DATA_RQ_PG_SIZE_LAST   CREATE_QP_BATCH_DATA_RQ_PG_SIZE_PG_1G
	uint8_t	unused_0;
	/* Doorbell page index. */
	uint32_t	dpi;
	/*
	 * When the SQ is configured to use variable-size WQE, 'sq_size'
	 * denotes the SQ size with a unit of 16B. When the SQ is configured
	 * to use fixed-size WQE, 'sq_size' denotes the max number of SQ WQEs.
	 */
	uint32_t	sq_size;
	/* Max number of RQ wqes. */
	uint32_t	rq_size;
	uint16_t	sq_fwo_sq_sge;
	/*
	 * Max send SGEs per SWQE. This is only applicable to fixed-size
	 * WQE support. On variable-size WQE, this is ignored.
	 */
	#define CREATE_QP_BATCH_DATA_SQ_SGE_MASK UINT32_C(0xf)
	#define CREATE_QP_BATCH_DATA_SQ_SGE_SFT 0
	/*
	 * Offset of First WQE in the first SQ page, in 128 byte units.
	 * This field is ignored for express mode QPs.
	 */
	#define CREATE_QP_BATCH_DATA_SQ_FWO_MASK UINT32_C(0xfff0)
	#define CREATE_QP_BATCH_DATA_SQ_FWO_SFT 4
	uint16_t	rq_fwo_rq_sge;
	/*
	 * Max recv SGEs per RWQE.
	 * On chips with variable-size WQE support, a value of zero implies
	 * 30 SGEs.
	 */
	#define CREATE_QP_BATCH_DATA_RQ_SGE_MASK UINT32_C(0xf)
	#define CREATE_QP_BATCH_DATA_RQ_SGE_SFT 0
	/*
	 * Offset of First WQE in the first RQ page, in 128 byte units.
	 * This field is ignored for express mode QPs.
	 */
	#define CREATE_QP_BATCH_DATA_RQ_FWO_MASK UINT32_C(0xfff0)
	#define CREATE_QP_BATCH_DATA_RQ_FWO_SFT 4
	/* Send CQ context id. */
	uint32_t	scq_cid;
	/* Receive CQ context id. */
	uint32_t	rcq_cid;
	/* SRQ context id. */
	uint32_t	srq_cid;
	/* Protection domain id. */
	uint32_t	pd_id;
	/*
	 * SQ PBL physical address.
	 * This field is ignored for express mode QPs.
	 */
	uint64_t	sq_pbl;
	/*
	 * RQ PBL physical address.
	 * This field is ignored for express mode QPs.
	 */
	uint64_t	rq_pbl;
	/*
	 * IRRQ address. This field is ignored on devices that
	 * support the `internal_queue_memory` feature.
	 */
	uint64_t	irrq_addr;
	/*
	 * ORRQ address. This field is ignored on devices that
	 * support the `internal_queue_memory` feature.
	 */
	uint64_t	orrq_addr;
	/*
	 * xid to use for the non-QP1 QP.
	 * The requested xid must be within the valid range
	 * of the predetermined assignment scheme of the
	 * pseudo static QP allocation feature. The valid range
	 * for the data QPs is determined by the start_qid and
	 * max_qp fields of query_func response. When the value is zero,
	 * firmware will automatically choose an xid from its free pool.
	 * QP1 allocation, indicated by specifying `type` field as gsi,
	 * must specify a request_xid as zero.
	 * This field is ignored on devices that do not support
	 * the pseudo static QP allocation feature.
	 */
	uint32_t	request_xid;
	/* Steering tag to use for memory transactions. */
	uint16_t	steering_tag;
	/*
	 * This value is used to optimize metadata memory allocation when
	 * the device supports `internal_queue_memory` feature.
	 * When the SQ is configured to use variable-size WQEs, the SQ size is
	 * only specified in units of 16 Bytes. This value hints the max number
	 * of WQEs that would ever be present on the SQ.
	 */
	uint16_t	sq_max_num_wqes;
	/* Extended RoCE statistics context id. */
	uint32_t	ext_stats_ctx_id;
	/*
	 * Identifies the new scheduling queue to associate with
	 * the RoCE QP. A value of zero indicates that the QP is being
	 * created with the default scheduling queue. Can only be specified
	 * by the PF driver. VFs get assigned a scheduling queue based on PF
	 * configuration (via HWRM_FUNC_CFG). Specified scheduling queue id is
	 * allocated by firmware (via HWRM_SCHQ_ALLOC) when the device supports
	 * the `scheduling queue` feature.
	 */
	uint16_t	schq_id;
	uint16_t	reserved16;
} create_qp_batch_data_t, *pcreate_qp_batch_data_t;

/* Periodic extended RoCE statistics context DMA to host. */
/* roce_stats_ext_ctx (size:1856b/232B) */

typedef struct roce_stats_ext_ctx {
	/* Number of transmitted Atomic request packets without errors. */
	uint64_t	tx_atomic_req_pkts;
	/* Number of transmitted Read request packets without errors. */
	uint64_t	tx_read_req_pkts;
	/* Number of transmitted Read response packets without errors. */
	uint64_t	tx_read_res_pkts;
	/* Number of transmitted Write request packets without errors. */
	uint64_t	tx_write_req_pkts;
	/* Number of transmitted RC Send packets without errors. */
	uint64_t	tx_rc_send_req_pkts;
	/*
	 * Number of transmitted UD Send (including QP1) packets
	 * without errors.
	 */
	uint64_t	tx_ud_send_req_pkts;
	/* Number of transmitted CNPs. Includes DCN_CNPs. */
	uint64_t	tx_cnp_pkts;
	/*
	 * Number of transmitted RoCE packets.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	tx_roce_pkts;
	/*
	 * Number of transmitted RoCE header and payload bytes.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	tx_roce_bytes;
	/*
	 * Number of drops that occurred to lack of buffers.
	 * This count includes RC sends, RC writes with immediate,
	 * UD sends, RawEth, and QP1 packets dropped due to lack of buffers.
	 */
	uint64_t	rx_out_of_buffer_pkts;
	/* Number of packets that were received out of sequence. */
	uint64_t	rx_out_of_sequence_pkts;
	/*
	 * Number of duplicate read/atomic requests resulting in responder
	 * hardware retransmission.
	 */
	uint64_t	dup_req;
	/*
	 * Number of missing response packets resulting in hardware
	 * retransmission.
	 */
	uint64_t	missing_resp;
	/*
	 * Number of sequence error NAKs received resulting in hardware
	 * retransmission.
	 */
	uint64_t	seq_err_naks_rcvd;
	/* Number of RNR NAKs received resulting in hardware retransmission. */
	uint64_t	rnr_naks_rcvd;
	/* Number of timeouts resulting in hardware retransmission. */
	uint64_t	to_retransmits;
	/* Number of received Atomic request packets without errors. */
	uint64_t	rx_atomic_req_pkts;
	/* Number of received Read request packets without errors. */
	uint64_t	rx_read_req_pkts;
	/* Number of received Read response packets without errors. */
	uint64_t	rx_read_res_pkts;
	/* Number of received Write request packets without errors. */
	uint64_t	rx_write_req_pkts;
	/* Number of received RC Send packets without errors. */
	uint64_t	rx_rc_send_pkts;
	/* Number of received UD Send packets without errors. */
	uint64_t	rx_ud_send_pkts;
	/* Number of received DCN payload cut packets. */
	uint64_t	rx_dcn_payload_cut;
	/* Number of received ECN-marked packets. */
	uint64_t	rx_ecn_marked_pkts;
	/* Number of received CNP packets. Includes DCN_CNPs. */
	uint64_t	rx_cnp_pkts;
	/*
	 * Number of received RoCE packets including RoCE packets with errors.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	rx_roce_pkts;
	/*
	 * Number of received RoCE header and payload bytes including RoCE
	 * packets with errors.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	rx_roce_bytes;
	/*
	 * Number of received RoCE packets without errors.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	rx_roce_good_pkts;
	/*
	 * Number of received RoCE header and payload bytes without errors.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	rx_roce_good_bytes;
} roce_stats_ext_ctx_t, *proce_stats_ext_ctx_t;

/*****************
 * query_version *
 *****************/


/* cmdq_query_version (size:128b/16B) */

typedef struct cmdq_query_version {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query version. */
	#define CMDQ_QUERY_VERSION_OPCODE_QUERY_VERSION UINT32_C(0x8b)
	#define CMDQ_QUERY_VERSION_OPCODE_LAST	CMDQ_QUERY_VERSION_OPCODE_QUERY_VERSION
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_query_version_t, *pcmdq_query_version_t;

/* creq_query_version_resp (size:128b/16B) */

typedef struct creq_query_version_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_VERSION_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_VERSION_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_VERSION_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_VERSION_RESP_TYPE_LAST	CREQ_QUERY_VERSION_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* firmware major version */
	uint8_t	fw_maj;
	/* firmware minor version */
	uint8_t	fw_minor;
	/* firmware build version */
	uint8_t	fw_bld;
	/* firmware reserved version */
	uint8_t	fw_rsvd;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_VERSION_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query firmware and interface version response. */
	#define CREQ_QUERY_VERSION_RESP_EVENT_QUERY_VERSION UINT32_C(0x8b)
	#define CREQ_QUERY_VERSION_RESP_EVENT_LAST	CREQ_QUERY_VERSION_RESP_EVENT_QUERY_VERSION
	uint16_t	reserved16;
	/* interface major version */
	uint8_t	intf_maj;
	/* interface minor version */
	uint8_t	intf_minor;
	/* interface build version */
	uint8_t	intf_bld;
	/* interface reserved version */
	uint8_t	intf_rsvd;
} creq_query_version_resp_t, *pcreq_query_version_resp_t;

/*****************
 * initialize_fw *
 *****************/


/* cmdq_initialize_fw (size:1024b/128B) */

typedef struct cmdq_initialize_fw {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Initialize firmware command initializes the firmware with
	 * the specified parameters.
	 */
	#define CMDQ_INITIALIZE_FW_OPCODE_INITIALIZE_FW UINT32_C(0x80)
	#define CMDQ_INITIALIZE_FW_OPCODE_LAST	CMDQ_INITIALIZE_FW_OPCODE_INITIALIZE_FW
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When set, the 32b `max_mrw_per_vf` field is logically divided
	 * into two 16b fields, `max_mr_per_vf` and `max_av_per_vf`.
	 */
	#define CMDQ_INITIALIZE_FW_FLAGS_MRAV_RESERVATION_SPLIT	UINT32_C(0x1)
	/*
	 * When set, the hardware based requester retransmission
	 * feature is supported.
	 */
	#define CMDQ_INITIALIZE_FW_FLAGS_HW_REQUESTER_RETX_SUPPORTED	UINT32_C(0x2)
	/* When set, the driver version is provided. */
	#define CMDQ_INITIALIZE_FW_FLAGS_DRV_VERSION			UINT32_C(0x4)
	/* When set, driver supports optimizing Modify QP operation. */
	#define CMDQ_INITIALIZE_FW_FLAGS_OPTIMIZE_MODIFY_QP_SUPPORTED	UINT32_C(0x8)
	/*
	 * When set, the VF RoCE resources will be managed by the L2
	 * driver via func_cfg.
	 */
	#define CMDQ_INITIALIZE_FW_FLAGS_L2_VF_RESOURCE_MGMT		UINT32_C(0x10)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	uint8_t	qpc_pg_size_qpc_lvl;
	/* QPC PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_QPC_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_QPC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_QPC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_QPC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define CMDQ_INITIALIZE_FW_QPC_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_QPC_LVL_LAST	CMDQ_INITIALIZE_FW_QPC_LVL_LVL_2
	/* QPC page size. */
	#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_1G
	uint8_t	mrw_pg_size_mrw_lvl;
	/* MRW PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_MRW_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_MRW_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_MRW_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_MRW_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_INITIALIZE_FW_MRW_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_MRW_LVL_LAST	CMDQ_INITIALIZE_FW_MRW_LVL_LVL_2
	/* MRW page size. */
	#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_1G
	uint8_t	srq_pg_size_srq_lvl;
	/* SRQ PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_SRQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_SRQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_SRQ_LVL_LAST	CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_2
	/* SRQ page size. */
	#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_1G
	uint8_t	cq_pg_size_cq_lvl;
	/* CQ PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_CQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_CQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_INITIALIZE_FW_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_CQ_LVL_LAST	CMDQ_INITIALIZE_FW_CQ_LVL_LVL_2
	/* CQ page size. */
	#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_1G
	uint8_t	tqm_pg_size_tqm_lvl;
	/* TQM PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_TQM_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_TQM_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_TQM_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_TQM_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_INITIALIZE_FW_TQM_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_TQM_LVL_LAST	CMDQ_INITIALIZE_FW_TQM_LVL_LVL_2
	/* TQM page size. */
	#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_1G
	uint8_t	tim_pg_size_tim_lvl;
	/* TIM PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_TIM_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_TIM_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_TIM_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_TIM_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_INITIALIZE_FW_TIM_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_TIM_LVL_LAST	CMDQ_INITIALIZE_FW_TIM_LVL_LVL_2
	/* TIM page size. */
	#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_1G
	uint16_t	log2_dbr_pg_size;
	/*
	 * Log base 2 of DBR page size - 12. 0 for 4KB. HW supported values
	 * are enumerated below.
	 */
	#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_MASK   UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_SFT	0
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_4K	UINT32_C(0x0)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_8K	UINT32_C(0x1)
	/* 16KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_16K   UINT32_C(0x2)
	/* 32KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_32K   UINT32_C(0x3)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_64K   UINT32_C(0x4)
	/* 128KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_128K  UINT32_C(0x5)
	/* 256KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_256K  UINT32_C(0x6)
	/* 512KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_512K  UINT32_C(0x7)
	/* 1MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_1M	UINT32_C(0x8)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_2M	UINT32_C(0x9)
	/* 4MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_4M	UINT32_C(0xa)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_8M	UINT32_C(0xb)
	/* 16MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_16M   UINT32_C(0xc)
	/* 32MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_32M   UINT32_C(0xd)
	/* 64MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_64M   UINT32_C(0xe)
	/* 128MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_128M  UINT32_C(0xf)
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_LAST	CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_128M
	/* rsvd is 12 b */
	#define CMDQ_INITIALIZE_FW_RSVD_MASK		UINT32_C(0xfff0)
	#define CMDQ_INITIALIZE_FW_RSVD_SFT		4
	/* Kernel notification queue page directory. */
	uint64_t	qpc_page_dir;
	/* MRW page directory. */
	uint64_t	mrw_page_dir;
	/* SRQ page directory. */
	uint64_t	srq_page_dir;
	/* CQ page directory. */
	uint64_t	cq_page_dir;
	/* TQM page directory. */
	uint64_t	tqm_page_dir;
	/* TIM page directory. */
	uint64_t	tim_page_dir;
	/*
	 * Number of QPs. This field is ignored when the backing store HWRM's
	 * are used.
	 */
	uint32_t	number_of_qp;
	/*
	 * Number of MRWs. This field is ignored when the backing store HWRM's
	 * are used.
	 */
	uint32_t	number_of_mrw;
	/*
	 * Number of SRQs. This field is ignored when the backing store HWRM's
	 * are used.
	 */
	uint32_t	number_of_srq;
	/*
	 * Number of CQs. This field is ignored when the backing store HWRM's
	 * are used.
	 */
	uint32_t	number_of_cq;
	/*
	 * Number of QPs per VF. This field must be set to zero when the flag,
	 * l2_vf_resource_mgmt, is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_qp_per_vf;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries allowed per
	 * VF. For versions of firmware that support the split reservation,
	 * when it is not specified half of the entries will be reserved
	 * for MRs and the other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `max_mr_per_vf` and bits `[15:0]` represents
	 * `max_av_per_vf`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 *
	 * This field must be set to zero when the flag, l2_vf_resource_mgmt,
	 * is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_mrw_per_vf;
	/*
	 * Number of SRQs per VF. This field must be set to zero when the flag,
	 * l2_vf_resource_mgmt, is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_srq_per_vf;
	/*
	 * Number of CQs per VF. This field must be set to zero when the flag,
	 * l2_vf_resource_mgmt, is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_cq_per_vf;
	/*
	 * Number of GIDs per VF. This field must be set to zero when the flag,
	 * l2_vf_resource_mgmt, is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_gid_per_vf;
	/* Statistics context index for this function. */
	uint32_t	stat_ctx_id;
	/* The driver HSI major version number. */
	uint8_t	drv_hsi_ver_maj;
	/* The driver HSI minor version number. */
	uint8_t	drv_hsi_ver_min;
	/* The driver HSI update version number. */
	uint8_t	drv_hsi_ver_upd;
	/* This is the 40bit unused. */
	uint8_t	unused40[5];
	/* The driver build major version number. */
	uint16_t	drv_build_ver_maj;
	/* The driver build minor version number. */
	uint16_t	drv_build_ver_min;
	/* The driver build update version number. */
	uint16_t	drv_build_ver_upd;
	/* The driver build patch version number. */
	uint16_t	drv_build_ver_patch;
} cmdq_initialize_fw_t, *pcmdq_initialize_fw_t;

/* creq_initialize_fw_resp (size:128b/16B) */

typedef struct creq_initialize_fw_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_INITIALIZE_FW_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_INITIALIZE_FW_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_INITIALIZE_FW_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_INITIALIZE_FW_RESP_TYPE_LAST	CREQ_INITIALIZE_FW_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_INITIALIZE_FW_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Initialize firmware command response. */
	#define CREQ_INITIALIZE_FW_RESP_EVENT_INITIALIZE_FW UINT32_C(0x80)
	#define CREQ_INITIALIZE_FW_RESP_EVENT_LAST	CREQ_INITIALIZE_FW_RESP_EVENT_INITIALIZE_FW
	uint8_t	reserved48[6];
} creq_initialize_fw_resp_t, *pcreq_initialize_fw_resp_t;

/*******************
 * deinitialize_fw *
 *******************/


/* cmdq_deinitialize_fw (size:128b/16B) */

typedef struct cmdq_deinitialize_fw {
	/* Command opcode. */
	uint8_t	opcode;
	/* De-initialize firmware command deinitializes the firmware. */
	#define CMDQ_DEINITIALIZE_FW_OPCODE_DEINITIALIZE_FW UINT32_C(0x81)
	#define CMDQ_DEINITIALIZE_FW_OPCODE_LAST	CMDQ_DEINITIALIZE_FW_OPCODE_DEINITIALIZE_FW
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_deinitialize_fw_t, *pcmdq_deinitialize_fw_t;

/* creq_deinitialize_fw_resp (size:128b/16B) */

typedef struct creq_deinitialize_fw_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DEINITIALIZE_FW_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DEINITIALIZE_FW_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DEINITIALIZE_FW_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DEINITIALIZE_FW_RESP_TYPE_LAST	CREQ_DEINITIALIZE_FW_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DEINITIALIZE_FW_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* De-initialize firmware command response. */
	#define CREQ_DEINITIALIZE_FW_RESP_EVENT_DEINITIALIZE_FW UINT32_C(0x81)
	#define CREQ_DEINITIALIZE_FW_RESP_EVENT_LAST	CREQ_DEINITIALIZE_FW_RESP_EVENT_DEINITIALIZE_FW
	uint8_t	reserved48[6];
} creq_deinitialize_fw_resp_t, *pcreq_deinitialize_fw_resp_t;

/*************
 * create_qp *
 *************/


/* cmdq_create_qp (size:896b/112B) */

typedef struct cmdq_create_qp {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Create QP command allocates QP context with the specified
	 * SQ, RQ/SRQ, CQ and other parameters.
	 */
	#define CMDQ_CREATE_QP_OPCODE_CREATE_QP UINT32_C(0x1)
	#define CMDQ_CREATE_QP_OPCODE_LAST	CMDQ_CREATE_QP_OPCODE_CREATE_QP
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP handle. */
	uint64_t	qp_handle;
	/* Create QP flags. */
	uint32_t	qp_flags;
	/*
	 * SRQ is used.
	 * This flag is not supported on express mode QPs.
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_SRQ_USED		UINT32_C(0x1)
	/* post CQE for all SQ WQEs. */
	#define CMDQ_CREATE_QP_QP_FLAGS_FORCE_COMPLETION	UINT32_C(0x2)
	/* This QP can use reserved L_Key */
	#define CMDQ_CREATE_QP_QP_FLAGS_RESERVED_LKEY_ENABLE	UINT32_C(0x4)
	/* This QP can fast register physical memory */
	#define CMDQ_CREATE_QP_QP_FLAGS_FR_PMR_ENABLED		UINT32_C(0x8)
	/* This QP can send variable sized WQEs. */
	#define CMDQ_CREATE_QP_QP_FLAGS_VARIABLE_SIZED_WQE_ENABLED UINT32_C(0x10)
	/*
	 * WQEs with inline data sent on this QP are able to flow
	 * through an optimized transmit path to lower latency. This
	 * transmit path is opportunistic and not guaranteed to always
	 * occur.
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_OPTIMIZED_TRANSMIT_ENABLED UINT32_C(0x20)
	/*
	 * For UD QPs the default responder CQE format is `cq_res_ud`.
	 * This flag specifies the `cq_res_ud_cfa` format to be used
	 * instead.
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_RESPONDER_UD_CQE_WITH_CFA  UINT32_C(0x40)
	/*
	 * This QP must be included in the extended RoCE statistics
	 * that can be queried via `query_roce_stats_ext`.
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_EXT_STATS_ENABLED	UINT32_C(0x80)
	/* This QP uses express mode. */
	#define CMDQ_CREATE_QP_QP_FLAGS_EXPRESS_MODE_ENABLED	UINT32_C(0x100)
	/* This QP uses the steering tag specified in the command. */
	#define CMDQ_CREATE_QP_QP_FLAGS_STEERING_TAG_VALID	UINT32_C(0x200)
	/*
	 * This QP can be used for RDMA Read or Atomic operations.
	 * This value is used to optimize metadata memory allocation
	 * when the device supports `internal_queue_memory` feature.
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_RDMA_READ_OR_ATOMICS_USED  UINT32_C(0x400)
	/*
	 * This QP must be included in the extended RoCE statistics context
	 * specified in the field `ext_stats_ctx_id`
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_EXT_STATS_CTX_VALID	UINT32_C(0x800)
	/* The schq_id field passed in by the caller is valid. */
	#define CMDQ_CREATE_QP_QP_FLAGS_SCHQ_ID_VALID		UINT32_C(0x1000)
	#define CMDQ_CREATE_QP_QP_FLAGS_LAST			CMDQ_CREATE_QP_QP_FLAGS_SCHQ_ID_VALID
	/* Supported QP types. */
	uint8_t	type;
	/* Reliable Connection. */
	#define CMDQ_CREATE_QP_TYPE_RC		UINT32_C(0x2)
	/* Unreliable Datagram. */
	#define CMDQ_CREATE_QP_TYPE_UD		UINT32_C(0x4)
	/* Raw Ethertype. */
	#define CMDQ_CREATE_QP_TYPE_RAW_ETHERTYPE UINT32_C(0x6)
	/* General Services Interface on QP1 over UD. */
	#define CMDQ_CREATE_QP_TYPE_GSI	UINT32_C(0x7)
	#define CMDQ_CREATE_QP_TYPE_LAST	CMDQ_CREATE_QP_TYPE_GSI
	uint8_t	sq_pg_size_sq_lvl;
	/*
	 * SQ PBL indirect levels.
	 * This field is ignored for express mode QPs.
	 */
	#define CMDQ_CREATE_QP_SQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_CREATE_QP_SQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_QP_SQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_QP_SQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define CMDQ_CREATE_QP_SQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_QP_SQ_LVL_LAST	CMDQ_CREATE_QP_SQ_LVL_LVL_2
	/*
	 * SQ page size.
	 * This field is ignored for express mode QPs.
	 */
	#define CMDQ_CREATE_QP_SQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_CREATE_QP_SQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_LAST   CMDQ_CREATE_QP_SQ_PG_SIZE_PG_1G
	uint8_t	rq_pg_size_rq_lvl;
	/*
	 * RQ PBL indirect levels.
	 * This field is ignored for express mode QPs.
	 */
	#define CMDQ_CREATE_QP_RQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_CREATE_QP_RQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_QP_RQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_QP_RQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define CMDQ_CREATE_QP_RQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_QP_RQ_LVL_LAST	CMDQ_CREATE_QP_RQ_LVL_LVL_2
	/*
	 * RQ page size.
	 * This field is ignored for express mode QPs.
	 */
	#define CMDQ_CREATE_QP_RQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_CREATE_QP_RQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_LAST   CMDQ_CREATE_QP_RQ_PG_SIZE_PG_1G
	uint8_t	unused_0;
	/* Doorbell page index. */
	uint32_t	dpi;
	/*
	 * When the SQ is configured to use variable-size WQE, 'sq_size'
	 * denotes the SQ size with a unit of 16B. When the SQ is configured
	 * to use fixed-size WQE, 'sq_size' denotes the max number of SQ WQEs.
	 */
	uint32_t	sq_size;
	/* Max number of RQ wqes. */
	uint32_t	rq_size;
	uint16_t	sq_fwo_sq_sge;
	/*
	 * Max send SGEs per SWQE. This is only applicable to fixed-size
	 * WQE support. On variable-size WQE, this is ignored.
	 */
	#define CMDQ_CREATE_QP_SQ_SGE_MASK UINT32_C(0xf)
	#define CMDQ_CREATE_QP_SQ_SGE_SFT 0
	/*
	 * Offset of First WQE in the first SQ page, in 128 byte units.
	 * This field is ignored for express mode QPs.
	 */
	#define CMDQ_CREATE_QP_SQ_FWO_MASK UINT32_C(0xfff0)
	#define CMDQ_CREATE_QP_SQ_FWO_SFT 4
	uint16_t	rq_fwo_rq_sge;
	/*
	 * Max recv SGEs per RWQE.
	 * On chips with variable-size WQE support, a value of zero implies
	 * 30 SGEs.
	 */
	#define CMDQ_CREATE_QP_RQ_SGE_MASK UINT32_C(0xf)
	#define CMDQ_CREATE_QP_RQ_SGE_SFT 0
	/*
	 * Offset of First WQE in the first RQ page, in 128 byte units.
	 * This field is ignored for express mode QPs.
	 */
	#define CMDQ_CREATE_QP_RQ_FWO_MASK UINT32_C(0xfff0)
	#define CMDQ_CREATE_QP_RQ_FWO_SFT 4
	/* Send CQ context id. */
	uint32_t	scq_cid;
	/* Receive CQ context id. */
	uint32_t	rcq_cid;
	/* SRQ context id. */
	uint32_t	srq_cid;
	/* Protection domain id. */
	uint32_t	pd_id;
	/*
	 * SQ PBL physical address.
	 * This field is ignored for express mode QPs.
	 */
	uint64_t	sq_pbl;
	/*
	 * RQ PBL physical address.
	 * This field is ignored for express mode QPs.
	 */
	uint64_t	rq_pbl;
	/*
	 * IRRQ address. This field is ignored on devices that
	 * support the `internal_queue_memory` feature.
	 */
	uint64_t	irrq_addr;
	/*
	 * ORRQ address. This field is ignored on devices that
	 * support the `internal_queue_memory` feature.
	 */
	uint64_t	orrq_addr;
	/*
	 * xid to use for the non-QP1 QP.
	 * The requested xid must be within the valid range
	 * of the predetermined assignment scheme of the
	 * pseudo static QP allocation feature. The valid range
	 * for the data QPs is determined by the start_qid and
	 * max_qp fields of query_func response. When the value is zero,
	 * firmware will automatically choose an xid from its free pool.
	 * QP1 allocation, indicated by specifying `type` field as gsi,
	 * must specify a request_xid as zero.
	 * This field is ignored on devices that do not support
	 * the pseudo static QP allocation feature.
	 */
	uint32_t	request_xid;
	/* Steering tag to use for memory transactions. */
	uint16_t	steering_tag;
	/*
	 * This value is used to optimize metadata memory allocation when
	 * the device supports `internal_queue_memory` feature.
	 * When the SQ is configured to use variable-size WQEs, the SQ size is
	 * only specified in units of 16 Bytes. This value hints the max number
	 * of WQEs that would ever be present on the SQ.
	 */
	uint16_t	sq_max_num_wqes;
	/* Extended RoCE statistics context id. */
	uint32_t	ext_stats_ctx_id;
	/*
	 * Identifies the new scheduling queue to associate with
	 * the RoCE QP. A value of zero indicates that the QP is being
	 * created with the default scheduling queue. Can only be specified
	 * by the PF driver. VFs get assigned a scheduling queue based on PF
	 * configuration (via HWRM_FUNC_CFG). Specified scheduling queue id is
	 * allocated by firmware (via HWRM_SCHQ_ALLOC) when the device supports
	 * the `scheduling queue` feature.
	 */
	uint16_t	schq_id;
	uint16_t	reserved16;
} cmdq_create_qp_t, *pcmdq_create_qp_t;

/* creq_create_qp_resp (size:128b/16B) */

typedef struct creq_create_qp_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_QP_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_QP_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_QP_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_QP_RESP_TYPE_LAST	CREQ_CREATE_QP_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_QP_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create QP command response. */
	#define CREQ_CREATE_QP_RESP_EVENT_CREATE_QP UINT32_C(0x1)
	#define CREQ_CREATE_QP_RESP_EVENT_LAST	CREQ_CREATE_QP_RESP_EVENT_CREATE_QP
	/*
	 * Support for optimized transmit path to lower latency
	 * for WQEs with inline data has been enabled for this QP.
	 */
	uint8_t	optimized_transmit_enabled;
	uint8_t	reserved48[5];
} creq_create_qp_resp_t, *pcreq_create_qp_resp_t;

/**************
 * destroy_qp *
 **************/


/* cmdq_destroy_qp (size:192b/24B) */

typedef struct cmdq_destroy_qp {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Destroy QP command deletes the QP context and ceases
	 * any further reference.
	 */
	#define CMDQ_DESTROY_QP_OPCODE_DESTROY_QP UINT32_C(0x2)
	#define CMDQ_DESTROY_QP_OPCODE_LAST	CMDQ_DESTROY_QP_OPCODE_DESTROY_QP
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP context id */
	uint32_t	qp_cid;
	uint32_t	unused_0;
} cmdq_destroy_qp_t, *pcmdq_destroy_qp_t;

/* creq_destroy_qp_resp (size:128b/16B) */

typedef struct creq_destroy_qp_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_QP_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_QP_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_QP_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_QP_RESP_TYPE_LAST	CREQ_DESTROY_QP_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_QP_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy QP command response. */
	#define CREQ_DESTROY_QP_RESP_EVENT_DESTROY_QP UINT32_C(0x2)
	#define CREQ_DESTROY_QP_RESP_EVENT_LAST	CREQ_DESTROY_QP_RESP_EVENT_DESTROY_QP
	uint8_t	reserved48[6];
} creq_destroy_qp_resp_t, *pcreq_destroy_qp_resp_t;

/*************
 * modify_qp *
 *************/


/* cmdq_modify_qp (size:1152b/144B) */

typedef struct cmdq_modify_qp {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Modify QP command changes QP states and other QP specific
	 * parameters.
	 */
	#define CMDQ_MODIFY_QP_OPCODE_MODIFY_QP UINT32_C(0x3)
	#define CMDQ_MODIFY_QP_OPCODE_LAST	CMDQ_MODIFY_QP_OPCODE_MODIFY_QP
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * This field, used by firmware for optimizing Modify QP operation,
	 * must be set when the driver has indicated support for the
	 * optimize_modify_qp_supported feature in cmdq_initialize_fw and
	 * when QP Type RC is configured to use SRQ.
	 */
	#define CMDQ_MODIFY_QP_FLAGS_SRQ_USED		UINT32_C(0x1)
	/*
	 * This field must be set when the driver has indicated that the
	 * qp should be excluded from udcc sessions.
	 */
	#define CMDQ_MODIFY_QP_FLAGS_EXCLUDE_QP_UDCC	UINT32_C(0x2)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	/*
	 * This field, used by firmware for optimizing Modify QP operation,
	 * must be set when the driver has indicated support for the
	 * optimize_modify_qp_supported feature in cmdq_initialize_fw.
	 */
	uint8_t	qp_type;
	/* Reliable Connection. */
	#define CMDQ_MODIFY_QP_QP_TYPE_RC		UINT32_C(0x2)
	/* Unreliable Datagram. */
	#define CMDQ_MODIFY_QP_QP_TYPE_UD		UINT32_C(0x4)
	/* Raw Ethertype. */
	#define CMDQ_MODIFY_QP_QP_TYPE_RAW_ETHERTYPE UINT32_C(0x6)
	/* General Services Interface on QP1 over UD. */
	#define CMDQ_MODIFY_QP_QP_TYPE_GSI	UINT32_C(0x7)
	#define CMDQ_MODIFY_QP_QP_TYPE_LAST	CMDQ_MODIFY_QP_QP_TYPE_GSI
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* QP state change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_STATE		UINT32_C(0x1)
	/* Enable SQ drain asynchronous notification change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_EN_SQD_ASYNC_NOTIFY	UINT32_C(0x2)
	/* Access change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_ACCESS		UINT32_C(0x4)
	/* P_KEY change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_PKEY			UINT32_C(0x8)
	/* Q_KEY index change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_QKEY			UINT32_C(0x10)
	/* Destination GID change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_DGID			UINT32_C(0x20)
	/* Flow label change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_FLOW_LABEL		UINT32_C(0x40)
	/* SGID change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SGID_INDEX		UINT32_C(0x80)
	/* Hop limit change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_HOP_LIMIT		UINT32_C(0x100)
	/* Traffic class change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_TRAFFIC_CLASS	UINT32_C(0x200)
	/* destination MAC change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_DEST_MAC		UINT32_C(0x400)
	/* Ping pong push mode change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_PINGPONG_PUSH_MODE	UINT32_C(0x800)
	/* Path MTU change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_PATH_MTU		UINT32_C(0x1000)
	/* Timeout change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_TIMEOUT		UINT32_C(0x2000)
	/* Retry count change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RETRY_CNT		UINT32_C(0x4000)
	/* RNR Retry change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RNR_RETRY		UINT32_C(0x8000)
	/* RQ start packet sequence number change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RQ_PSN		UINT32_C(0x10000)
	/* Max outstanding RDMA read atomic change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_MAX_RD_ATOMIC	UINT32_C(0x20000)
	/* RNR minimum timer change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_MIN_RNR_TIMER	UINT32_C(0x40000)
	/* SQ start packet sequence number change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SQ_PSN		UINT32_C(0x80000)
	/* Max destination outstanding RDMA read atomic change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_MAX_DEST_RD_ATOMIC	UINT32_C(0x100000)
	/* Max send WQE change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SQ_SIZE		UINT32_C(0x200000)
	/* Max recv WQE change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RQ_SIZE		UINT32_C(0x400000)
	/* Max recv SGEs per SWQE change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SQ_SGE		UINT32_C(0x800000)
	/* Max send SGEs per RWQE change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RQ_SGE		UINT32_C(0x1000000)
	/* Max inline data length change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_MAX_INLINE_DATA	UINT32_C(0x2000000)
	/* Destination QP id change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_DEST_QP_ID		UINT32_C(0x4000000)
	/* Source MAC change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SRC_MAC		UINT32_C(0x8000000)
	/* Source VLAN id change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_VLAN_ID		UINT32_C(0x10000000)
	/* Congestion control RoCE v2 change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_ENABLE_CC		UINT32_C(0x20000000)
	/* IP TOS ECN change */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_TOS_ECN		UINT32_C(0x40000000)
	/* IP TOS DSCP change */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_TOS_DSCP		UINT32_C(0x80000000)
	/* QP context id */
	uint32_t	qp_cid;
	uint8_t	network_type_en_sqd_async_notify_new_state;
	/* New QP state. */
	#define CMDQ_MODIFY_QP_NEW_STATE_MASK	UINT32_C(0xf)
	#define CMDQ_MODIFY_QP_NEW_STATE_SFT	0
	/* Reset. */
		#define CMDQ_MODIFY_QP_NEW_STATE_RESET	UINT32_C(0x0)
	/* Init. */
		#define CMDQ_MODIFY_QP_NEW_STATE_INIT		UINT32_C(0x1)
	/* Ready To Receive. */
		#define CMDQ_MODIFY_QP_NEW_STATE_RTR		UINT32_C(0x2)
	/* Ready To Send. */
		#define CMDQ_MODIFY_QP_NEW_STATE_RTS		UINT32_C(0x3)
	/* SQ Drain. */
		#define CMDQ_MODIFY_QP_NEW_STATE_SQD		UINT32_C(0x4)
	/* SQ Error. */
		#define CMDQ_MODIFY_QP_NEW_STATE_SQE		UINT32_C(0x5)
	/* Error. */
		#define CMDQ_MODIFY_QP_NEW_STATE_ERR		UINT32_C(0x6)
		#define CMDQ_MODIFY_QP_NEW_STATE_LAST	CMDQ_MODIFY_QP_NEW_STATE_ERR
	/* Enable SQ drain asynchronous notification. */
	#define CMDQ_MODIFY_QP_EN_SQD_ASYNC_NOTIFY	UINT32_C(0x10)
	/* unused1 is 1 b */
	#define CMDQ_MODIFY_QP_UNUSED1		UINT32_C(0x20)
	/* network type. */
	#define CMDQ_MODIFY_QP_NETWORK_TYPE_MASK	UINT32_C(0xc0)
	#define CMDQ_MODIFY_QP_NETWORK_TYPE_SFT	6
	/* RoCEv1. */
		#define CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV1	(UINT32_C(0x0) << 6)
	/* RoCEv2 IPv4. */
		#define CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV2_IPV4  (UINT32_C(0x2) << 6)
	/* RoCEv2 IPv6. */
		#define CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV2_IPV6  (UINT32_C(0x3) << 6)
		#define CMDQ_MODIFY_QP_NETWORK_TYPE_LAST	CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV2_IPV6
	/* Access flags. */
	uint8_t	access;
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_ATOMIC_REMOTE_READ_REMOTE_WRITE_LOCAL_WRITE_MASK		UINT32_C(0xff)
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_ATOMIC_REMOTE_READ_REMOTE_WRITE_LOCAL_WRITE_SFT		0
	/* Local write access. */
	#define CMDQ_MODIFY_QP_ACCESS_LOCAL_WRITE							UINT32_C(0x1)
	/* Remote write access. */
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_WRITE							UINT32_C(0x2)
	/* Remote read access. */
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_READ							UINT32_C(0x4)
	/*
	 * Remote atomic access. Applicable to devices that support
	 * Atomic operations.
	 */
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_ATOMIC							UINT32_C(0x8)
	/* P_KEY. */
	uint16_t	pkey;
	/* Q_KEY. */
	uint32_t	qkey;
	/* Destination GID. */
	uint32_t	dgid[4];
	/* Flow label. */
	uint32_t	flow_label;
	/* Source GID index. */
	uint16_t	sgid_index;
	/* Hop limit. */
	uint8_t	hop_limit;
	/* Traffic class. */
	uint8_t	traffic_class;
	/* Destination MAC address. */
	uint16_t	dest_mac[3];
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. Valid values are 1 or 2 when ECN is enabled. */
	#define CMDQ_MODIFY_QP_TOS_ECN_MASK UINT32_C(0x3)
	#define CMDQ_MODIFY_QP_TOS_ECN_SFT  0
	/* IP TOS DSCP. */
	#define CMDQ_MODIFY_QP_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CMDQ_MODIFY_QP_TOS_DSCP_SFT 2
	uint8_t	path_mtu_pingpong_push_enable;
	/*
	 * Driver requests for ping pong push mode to be enabled for this
	 * QP. This request can be done only during modify from RST to INIT
	 * state.
	 */
	#define CMDQ_MODIFY_QP_PINGPONG_PUSH_ENABLE	UINT32_C(0x1)
	/* unused3 is 3 b */
	#define CMDQ_MODIFY_QP_UNUSED3_MASK		UINT32_C(0xe)
	#define CMDQ_MODIFY_QP_UNUSED3_SFT		1
	/* Path MTU. */
	#define CMDQ_MODIFY_QP_PATH_MTU_MASK		UINT32_C(0xf0)
	#define CMDQ_MODIFY_QP_PATH_MTU_SFT		4
	/* 256. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_256	(UINT32_C(0x0) << 4)
	/* 512. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_512	(UINT32_C(0x1) << 4)
	/* 1024. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_1024	(UINT32_C(0x2) << 4)
	/* 2048. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_2048	(UINT32_C(0x3) << 4)
	/* 4096. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_4096	(UINT32_C(0x4) << 4)
	/* 8192. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_8192	(UINT32_C(0x5) << 4)
		#define CMDQ_MODIFY_QP_PATH_MTU_LAST		CMDQ_MODIFY_QP_PATH_MTU_MTU_8192
	/* Timeout value for SWQEs. */
	uint8_t	timeout;
	/* Max retry count for WQEs. */
	uint8_t	retry_cnt;
	/* Max RNR retry count for WQEs. */
	uint8_t	rnr_retry;
	/* Min RNR timer that the QP will report to the remote. */
	uint8_t	min_rnr_timer;
	/* RQ start packet sequence number. */
	uint32_t	rq_psn;
	/* SQ start packet sequence number. */
	uint32_t	sq_psn;
	/* Max outstanding RDMA read atomic. */
	uint8_t	max_rd_atomic;
	/* Max destination outstanding RDMA read atomic. */
	uint8_t	max_dest_rd_atomic;
	uint16_t	enable_cc;
	/* Enable congestion control. */
	#define CMDQ_MODIFY_QP_ENABLE_CC	UINT32_C(0x1)
	/* unused15 is 15 b */
	#define CMDQ_MODIFY_QP_UNUSED15_MASK UINT32_C(0xfffe)
	#define CMDQ_MODIFY_QP_UNUSED15_SFT  1
	/* Max send WQE. */
	uint32_t	sq_size;
	/* Max recv WQE. */
	uint32_t	rq_size;
	/* Max send SGEs per SWQE. */
	uint16_t	sq_sge;
	/* Max recv SGEs per RWQE. */
	uint16_t	rq_sge;
	/* Max inline data length (up to 120 bytes). */
	uint32_t	max_inline_data;
	/* Destination QP id. */
	uint32_t	dest_qp_id;
	/* This is the DPI RoCE driver allocated for ping pong push. */
	uint32_t	pingpong_push_dpi;
	/* Source MAC. (Unused. Comes from Source GID index) */
	uint16_t	src_mac[3];
	uint16_t	vlan_pcp_vlan_dei_vlan_id;
	/* VLAN id. (Unused. Comes from Source GID index) */
	#define CMDQ_MODIFY_QP_VLAN_ID_MASK UINT32_C(0xfff)
	#define CMDQ_MODIFY_QP_VLAN_ID_SFT  0
	/* VLAN DEI field - Drop Eligibility Indicator. */
	#define CMDQ_MODIFY_QP_VLAN_DEI	UINT32_C(0x1000)
	/* VLAN PCP field - Priority Code Point. */
	#define CMDQ_MODIFY_QP_VLAN_PCP_MASK UINT32_C(0xe000)
	#define CMDQ_MODIFY_QP_VLAN_PCP_SFT 13
	/* IRRQ address. */
	uint64_t	irrq_addr;
	/* ORRQ address. */
	uint64_t	orrq_addr;
	/*
	 * Extended Modify mask signifies the field that is requesting the
	 * change.
	 */
	uint32_t	ext_modify_mask;
	/* Extended RoCE statistics context id change */
	#define CMDQ_MODIFY_QP_EXT_MODIFY_MASK_EXT_STATS_CTX	UINT32_C(0x1)
	/* The schq_id field is valid */
	#define CMDQ_MODIFY_QP_EXT_MODIFY_MASK_SCHQ_ID_VALID	UINT32_C(0x2)
	/* Extended RoCE statistics context id. */
	uint32_t	ext_stats_ctx_id;
	/*
	 * Identifies the new scheduling queue to associate to the RoCE QP.
	 * A value of zero indicates that the QP is being modified to use
	 * the default scheduling queue. Specified scheduling queue id is
	 * allocated by firmware (via HWRM_SCHQ_ALLOC) when the device supports
	 * the `scheduling queue` feature.
	 */
	uint16_t	schq_id;
	/* unused_0 is 16 b */
	uint16_t	unused_0;
	/* reserved32 is 32 b */
	uint32_t	reserved32;
} cmdq_modify_qp_t, *pcmdq_modify_qp_t;

/* creq_modify_qp_resp (size:128b/16B) */

typedef struct creq_modify_qp_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MODIFY_QP_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MODIFY_QP_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MODIFY_QP_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MODIFY_QP_RESP_TYPE_LAST	CREQ_MODIFY_QP_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MODIFY_QP_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Modify QP command response. */
	#define CREQ_MODIFY_QP_RESP_EVENT_MODIFY_QP UINT32_C(0x3)
	#define CREQ_MODIFY_QP_RESP_EVENT_LAST	CREQ_MODIFY_QP_RESP_EVENT_MODIFY_QP
	uint8_t	pingpong_push_state_index_enabled;
	/*
	 * When set it indicates that FW was able to successfully enable
	 * ping pong push mode for this QP.
	 */
	#define CREQ_MODIFY_QP_RESP_PINGPONG_PUSH_ENABLED	UINT32_C(0x1)
	/*
	 * When ping pong push mode is enabled this field will give the
	 * index into the push page where the QP has been mapped.
	 */
	#define CREQ_MODIFY_QP_RESP_PINGPONG_PUSH_INDEX_MASK  UINT32_C(0xe)
	#define CREQ_MODIFY_QP_RESP_PINGPONG_PUSH_INDEX_SFT   1
	/*
	 * This bit will tell whether to use ping or pong buffer
	 * for first push operation. 0 - ping buffer, 1 - pong buffer.
	 */
	#define CREQ_MODIFY_QP_RESP_PINGPONG_PUSH_STATE	UINT32_C(0x10)
	uint8_t	reserved8;
	/* Scrambled src mac needed to calculate UDP source port. */
	uint32_t	lag_src_mac;
} creq_modify_qp_resp_t, *pcreq_modify_qp_resp_t;

/************
 * query_qp *
 ************/


/* cmdq_query_qp (size:192b/24B) */

typedef struct cmdq_query_qp {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command retrieves info about the specified QP. */
	#define CMDQ_QUERY_QP_OPCODE_QUERY_QP UINT32_C(0x4)
	#define CMDQ_QUERY_QP_OPCODE_LAST	CMDQ_QUERY_QP_OPCODE_QUERY_QP
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP context id */
	uint32_t	qp_cid;
	uint32_t	unused_0;
} cmdq_query_qp_t, *pcmdq_query_qp_t;

/* creq_query_qp_resp (size:128b/16B) */

typedef struct creq_query_qp_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_QP_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_QP_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_QP_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_QP_RESP_TYPE_LAST	CREQ_QUERY_QP_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_QP_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query QP command response. */
	#define CREQ_QUERY_QP_RESP_EVENT_QUERY_QP UINT32_C(0x4)
	#define CREQ_QUERY_QP_RESP_EVENT_LAST	CREQ_QUERY_QP_RESP_EVENT_QUERY_QP
	uint8_t	reserved48[6];
} creq_query_qp_resp_t, *pcreq_query_qp_resp_t;

/* Query QP command response side buffer structure. */
/* creq_query_qp_resp_sb (size:832b/104B) */

typedef struct creq_query_qp_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command response. */
	#define CREQ_QUERY_QP_RESP_SB_OPCODE_QUERY_QP UINT32_C(0x4)
	#define CREQ_QUERY_QP_RESP_SB_OPCODE_LAST	CREQ_QUERY_QP_RESP_SB_OPCODE_QUERY_QP
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* QP context id */
	uint32_t	xid;
	uint8_t	en_sqd_async_notify_state;
	/* QP state */
	#define CREQ_QUERY_QP_RESP_SB_STATE_MASK		UINT32_C(0xf)
	#define CREQ_QUERY_QP_RESP_SB_STATE_SFT		0
	/* Reset. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_RESET		UINT32_C(0x0)
	/* Init. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_INIT		UINT32_C(0x1)
	/* Ready To Receive. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_RTR		UINT32_C(0x2)
	/* Ready To Send. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_RTS		UINT32_C(0x3)
	/* SQ Drain. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_SQD		UINT32_C(0x4)
	/* SQ Error. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_SQE		UINT32_C(0x5)
	/* Error. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_ERR		UINT32_C(0x6)
		#define CREQ_QUERY_QP_RESP_SB_STATE_LAST		CREQ_QUERY_QP_RESP_SB_STATE_ERR
	/* SQ drain asynchronous notification. */
	#define CREQ_QUERY_QP_RESP_SB_EN_SQD_ASYNC_NOTIFY	UINT32_C(0x10)
	/* Enable congestion control. */
	#define CREQ_QUERY_QP_RESP_SB_UNUSED3_MASK		UINT32_C(0xe0)
	#define CREQ_QUERY_QP_RESP_SB_UNUSED3_SFT		5
	/* Access flags. */
	uint8_t	access;
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_ATOMIC_REMOTE_READ_REMOTE_WRITE_LOCAL_WRITE_MASK		UINT32_C(0xff)
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_ATOMIC_REMOTE_READ_REMOTE_WRITE_LOCAL_WRITE_SFT		0
	/* Local write access. */
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_LOCAL_WRITE							UINT32_C(0x1)
	/* Remote write access. */
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_WRITE							UINT32_C(0x2)
	/* Remote read access. */
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_READ							UINT32_C(0x4)
	/* Remote atomic access. */
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_ATOMIC							UINT32_C(0x8)
	/* P_KEY index. */
	uint16_t	pkey;
	/* Q_KEY. */
	uint32_t	qkey;
	/*
	 * UDP source port used in RoCEv2 packets. Valid only when
	 * change_udp_src_port_wqe_supported feature is advertised.
	 */
	uint16_t	udp_src_port;
	uint16_t	reserved16;
	/* Destination GID. */
	uint32_t	dgid[4];
	/* Flow label. */
	uint32_t	flow_label;
	/* Source GID index. */
	uint16_t	sgid_index;
	/* Hop limit. */
	uint8_t	hop_limit;
	/* Traffic class. */
	uint8_t	traffic_class;
	/* Destination MAC address. */
	uint16_t	dest_mac[3];
	uint16_t	path_mtu_dest_vlan_id;
	/* Destination VLAN ID. */
	#define CREQ_QUERY_QP_RESP_SB_DEST_VLAN_ID_MASK UINT32_C(0xfff)
	#define CREQ_QUERY_QP_RESP_SB_DEST_VLAN_ID_SFT 0
	/* Path MTU. */
	#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MASK	UINT32_C(0xf000)
	#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_SFT	12
	/* 256. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_256   (UINT32_C(0x0) << 12)
	/* 512. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_512   (UINT32_C(0x1) << 12)
	/* 1024. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_1024  (UINT32_C(0x2) << 12)
	/* 2048. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_2048  (UINT32_C(0x3) << 12)
	/* 4096. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_4096  (UINT32_C(0x4) << 12)
	/* 8192. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_8192  (UINT32_C(0x5) << 12)
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_LAST	CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_8192
	/* Timeout value for SWQEs. */
	uint8_t	timeout;
	/* Max retry count for WQEs. */
	uint8_t	retry_cnt;
	/* Max RNR retry count for WQEs. */
	uint8_t	rnr_retry;
	/* Min RNR timer that the QP will report to the remote. */
	uint8_t	min_rnr_timer;
	/* RQ start packet sequence number. */
	uint32_t	rq_psn;
	/* SQ start packet sequence number. */
	uint32_t	sq_psn;
	/* Max outstanding RDMA read atomic. */
	uint8_t	max_rd_atomic;
	/* Max destination outstanding RDMA read atomic. */
	uint8_t	max_dest_rd_atomic;
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. */
	#define CREQ_QUERY_QP_RESP_SB_TOS_ECN_MASK UINT32_C(0x3)
	#define CREQ_QUERY_QP_RESP_SB_TOS_ECN_SFT  0
	/* IP TOS DSCP. */
	#define CREQ_QUERY_QP_RESP_SB_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CREQ_QUERY_QP_RESP_SB_TOS_DSCP_SFT 2
	uint8_t	enable_cc;
	/* enable_cc is 1 b */
	#define CREQ_QUERY_QP_RESP_SB_ENABLE_CC	UINT32_C(0x1)
	/* Max send WQE. */
	uint32_t	sq_size;
	/* Max recv WQE. */
	uint32_t	rq_size;
	/* Max send SGEs per SWQE. */
	uint16_t	sq_sge;
	/* Max recv SGEs per RWQE (NOT SUPPORTED BY HARDWARE). */
	uint16_t	rq_sge;
	/* Max inline data length (up to 120 bytes). */
	uint32_t	max_inline_data;
	/* Destination QP id. */
	uint32_t	dest_qp_id;
	/* Port ID associated with the QP. */
	uint16_t	port_id;
	uint8_t	unused_0;
	/* Statistic collection ID allocated for this QP. */
	uint8_t	stat_collection_id;
	/* Source MAC. */
	uint16_t	src_mac[3];
	uint16_t	vlan_pcp_vlan_dei_vlan_id;
	/* Source VLAN id. */
	#define CREQ_QUERY_QP_RESP_SB_VLAN_ID_MASK UINT32_C(0xfff)
	#define CREQ_QUERY_QP_RESP_SB_VLAN_ID_SFT  0
	/* VLAN DEI field - Drop Eligibility Indicator. */
	#define CREQ_QUERY_QP_RESP_SB_VLAN_DEI	UINT32_C(0x1000)
	/* VLAN PCP field - Priority Code Point. */
	#define CREQ_QUERY_QP_RESP_SB_VLAN_PCP_MASK UINT32_C(0xe000)
	#define CREQ_QUERY_QP_RESP_SB_VLAN_PCP_SFT 13
} creq_query_qp_resp_sb_t, *pcreq_query_qp_resp_sb_t;

/*******************
 * query_qp_extend *
 *******************/


/* cmdq_query_qp_extend (size:192b/24B) */

typedef struct cmdq_query_qp_extend {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Query QP extend command retrieves info about multiple QPs
	 * associated with a specific PF.
	 */
	#define CMDQ_QUERY_QP_EXTEND_OPCODE_QUERY_QP_EXTEND UINT32_C(0x91)
	#define CMDQ_QUERY_QP_EXTEND_OPCODE_LAST	CMDQ_QUERY_QP_EXTEND_OPCODE_QUERY_QP_EXTEND
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	/*
	 * Number of QPs for which FW needs to query and provide info back to
	 * host.
	 */
	uint8_t	num_qps;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Unique identified for a function */
	uint32_t	function_id;
	/* PF number */
	#define CMDQ_QUERY_QP_EXTEND_PF_NUM_MASK  UINT32_C(0xff)
	#define CMDQ_QUERY_QP_EXTEND_PF_NUM_SFT   0
	/* VF number */
	#define CMDQ_QUERY_QP_EXTEND_VF_NUM_MASK  UINT32_C(0xffff00)
	#define CMDQ_QUERY_QP_EXTEND_VF_NUM_SFT   8
	/* When set the vf_num is valid. */
	#define CMDQ_QUERY_QP_EXTEND_VF_VALID	UINT32_C(0x1000000)
	/*
	 * This is the current index where firmware left off for query qp.
	 * Driver will pass this back in the next query_qp_extend command.
	 */
	uint32_t	current_index;
} cmdq_query_qp_extend_t, *pcmdq_query_qp_extend_t;

/* creq_query_qp_extend_resp (size:128b/16B) */

typedef struct creq_query_qp_extend_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_QP_EXTEND_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_QP_EXTEND_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_QP_EXTEND_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_QP_EXTEND_RESP_TYPE_LAST	CREQ_QUERY_QP_EXTEND_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_QP_EXTEND_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query QP extend command response. */
	#define CREQ_QUERY_QP_EXTEND_RESP_EVENT_QUERY_QP_EXTEND UINT32_C(0x91)
	#define CREQ_QUERY_QP_EXTEND_RESP_EVENT_LAST	CREQ_QUERY_QP_EXTEND_RESP_EVENT_QUERY_QP_EXTEND
	uint16_t	reserved16;
	/*
	 * This is the current index where firmware left off for query qp.
	 * Driver will pass this back in the next query_qp_extend command.
	 */
	uint32_t	current_index;
} creq_query_qp_extend_resp_t, *pcreq_query_qp_extend_resp_t;

/* Query QP extend command response side buffer structure. */
/* creq_query_qp_extend_resp_sb (size:384b/48B) */

typedef struct creq_query_qp_extend_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command extend response. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_OPCODE_QUERY_QP_EXTEND UINT32_C(0x91)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_OPCODE_LAST	CREQ_QUERY_QP_EXTEND_RESP_SB_OPCODE_QUERY_QP_EXTEND
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* QP context id */
	uint32_t	xid;
	uint8_t	state;
	/* QP state */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_MASK  UINT32_C(0xf)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_SFT   0
	/* Reset. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_RESET   UINT32_C(0x0)
	/* Init. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_INIT	UINT32_C(0x1)
	/* Ready To Receive. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_RTR	UINT32_C(0x2)
	/* Ready To Send. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_RTS	UINT32_C(0x3)
	/* SQ Drain. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_SQD	UINT32_C(0x4)
	/* SQ Error. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_SQE	UINT32_C(0x5)
	/* Error. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_ERR	UINT32_C(0x6)
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_LAST   CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_ERR
	/*  */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_UNUSED4_MASK UINT32_C(0xf0)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_UNUSED4_SFT 4
	uint8_t	reserved_8;
	/* Port ID associated with the QP. */
	uint16_t	port_id;
	/* Q_KEY. */
	uint32_t	qkey;
	/* Source GID index. */
	uint16_t	sgid_index;
	/* Network type. */
	uint8_t	network_type;
	/* RoCEv1. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_ROCEV1	UINT32_C(0x0)
	/* RoCEv2 IPv4. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_ROCEV2_IPV4 UINT32_C(0x2)
	/* RoCEv2 IPv6. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_ROCEV2_IPV6 UINT32_C(0x3)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_LAST	CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_ROCEV2_IPV6
	uint8_t	unused_0;
	/* Destination GID. */
	uint32_t	dgid[4];
	/* Destination QP id. */
	uint32_t	dest_qp_id;
	/* Statistic collection ID allocated for this QP. */
	uint8_t	stat_collection_id;
	uint8_t	reserved2_8;
	uint16_t	reserved_16;
} creq_query_qp_extend_resp_sb_t, *pcreq_query_qp_extend_resp_sb_t;

/*
 * TLV encapsulated Query QP extend control command response
 * side buffer.
 */
/* creq_query_qp_extend_resp_sb_tlv (size:512b/64B) */

typedef struct creq_query_qp_extend_resp_sb_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED_LAST CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	/*
	 * Size of the tlv encapsulated response,
	 * including all tlvs and extension data in 16-byte units.
	 */
	uint8_t	total_size;
	uint8_t	reserved56[7];
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command extend response. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_OPCODE_QUERY_QP_EXTEND UINT32_C(0x91)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_OPCODE_LAST	CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_OPCODE_QUERY_QP_EXTEND
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* QP context id */
	uint32_t	xid;
	uint8_t	state;
	/* QP state */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_MASK  UINT32_C(0xf)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_SFT   0
	/* Reset. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_RESET   UINT32_C(0x0)
	/* Init. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_INIT	UINT32_C(0x1)
	/* Ready To Receive. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_RTR	UINT32_C(0x2)
	/* Ready To Send. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_RTS	UINT32_C(0x3)
	/* SQ Drain. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_SQD	UINT32_C(0x4)
	/* SQ Error. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_SQE	UINT32_C(0x5)
	/* Error. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_ERR	UINT32_C(0x6)
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_LAST   CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_ERR
	/*  */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_UNUSED4_MASK UINT32_C(0xf0)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_UNUSED4_SFT 4
	uint8_t	reserved_8;
	/* Port ID associated with the QP. */
	uint16_t	port_id;
	/* Q_KEY. */
	uint32_t	qkey;
	/* Source GID index. */
	uint16_t	sgid_index;
	/* Network type. */
	uint8_t	network_type;
	/* RoCEv1. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_ROCEV1	UINT32_C(0x0)
	/* RoCEv2 IPv4. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_ROCEV2_IPV4 UINT32_C(0x2)
	/* RoCEv2 IPv6. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_ROCEV2_IPV6 UINT32_C(0x3)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_LAST	CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_ROCEV2_IPV6
	uint8_t	unused_0;
	/* Destination GID. */
	uint32_t	dgid[4];
	/* Destination QP id. */
	uint32_t	dest_qp_id;
	/* Statistic collection ID allocated for this QP. */
	uint8_t	stat_collection_id;
	uint8_t	reserved2_8;
	uint16_t	reserved_16;
} creq_query_qp_extend_resp_sb_tlv_t, *pcreq_query_qp_extend_resp_sb_tlv_t;

/**************
 * create_srq *
 **************/


/* cmdq_create_srq (size:512b/64B) */

typedef struct cmdq_create_srq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Create SRQ command allocates a SRQ with the specified parameters. */
	#define CMDQ_CREATE_SRQ_OPCODE_CREATE_SRQ UINT32_C(0x5)
	#define CMDQ_CREATE_SRQ_OPCODE_LAST	CMDQ_CREATE_SRQ_OPCODE_CREATE_SRQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* This SRQ uses the steering tag specified in the command. */
	#define CMDQ_CREATE_SRQ_FLAGS_STEERING_TAG_VALID	UINT32_C(0x1)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* SRQ handle. */
	uint64_t	srq_handle;
	uint16_t	pg_size_lvl;
	/* SRQ PBL indirect levels. */
	#define CMDQ_CREATE_SRQ_LVL_MASK	UINT32_C(0x3)
	#define CMDQ_CREATE_SRQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_SRQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_SRQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_CREATE_SRQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_SRQ_LVL_LAST	CMDQ_CREATE_SRQ_LVL_LVL_2
	/* page size. */
	#define CMDQ_CREATE_SRQ_PG_SIZE_MASK  UINT32_C(0x1c)
	#define CMDQ_CREATE_SRQ_PG_SIZE_SFT   2
	/* 4KB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 2)
	/* 8KB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 2)
	/* 64KB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 2)
	/* 2MB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 2)
	/* 8MB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 2)
	/* 1GB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 2)
		#define CMDQ_CREATE_SRQ_PG_SIZE_LAST   CMDQ_CREATE_SRQ_PG_SIZE_PG_1G
	/* unused11 is 11 b */
	#define CMDQ_CREATE_SRQ_UNUSED11_MASK UINT32_C(0xffe0)
	#define CMDQ_CREATE_SRQ_UNUSED11_SFT  5
	uint16_t	eventq_id;
	/* eventq_id is 12 b */
	#define CMDQ_CREATE_SRQ_EVENTQ_ID_MASK UINT32_C(0xfff)
	#define CMDQ_CREATE_SRQ_EVENTQ_ID_SFT 0
	/* unused4 is 4 b */
	#define CMDQ_CREATE_SRQ_UNUSED4_MASK  UINT32_C(0xf000)
	#define CMDQ_CREATE_SRQ_UNUSED4_SFT   12
	/* Max number of SRQ wqes. */
	uint16_t	srq_size;
	uint16_t	srq_fwo;
	/* Offset of first WQE in the first page of SRQ, in 128 byte units */
	#define CMDQ_CREATE_SRQ_SRQ_FWO_MASK UINT32_C(0xfff)
	#define CMDQ_CREATE_SRQ_SRQ_FWO_SFT 0
	/*
	 * Max SGEs per SRQ WQE. This field is enabled if flag,
	 * create_srq_sge_supported, is set in query_func response.
	 */
	#define CMDQ_CREATE_SRQ_SRQ_SGE_MASK UINT32_C(0xf000)
	#define CMDQ_CREATE_SRQ_SRQ_SGE_SFT 12
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Protection domain id. */
	uint32_t	pd_id;
	/* RQ PBL physical address. */
	uint64_t	pbl;
	/* Steering tag to use for memory transactions. */
	uint16_t	steering_tag;
	uint8_t	reserved48[6];
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_create_srq_t, *pcmdq_create_srq_t;

/* creq_create_srq_resp (size:128b/16B) */

typedef struct creq_create_srq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_SRQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_SRQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_SRQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_SRQ_RESP_TYPE_LAST	CREQ_CREATE_SRQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* SRQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_SRQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create SRQ command response. */
	#define CREQ_CREATE_SRQ_RESP_EVENT_CREATE_SRQ UINT32_C(0x5)
	#define CREQ_CREATE_SRQ_RESP_EVENT_LAST	CREQ_CREATE_SRQ_RESP_EVENT_CREATE_SRQ
	uint8_t	reserved48[6];
} creq_create_srq_resp_t, *pcreq_create_srq_resp_t;

/***************
 * destroy_srq *
 ***************/


/* cmdq_destroy_srq (size:192b/24B) */

typedef struct cmdq_destroy_srq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Destroy SRQ command deletes and flushes the specified SRQ. */
	#define CMDQ_DESTROY_SRQ_OPCODE_DESTROY_SRQ UINT32_C(0x6)
	#define CMDQ_DESTROY_SRQ_OPCODE_LAST	CMDQ_DESTROY_SRQ_OPCODE_DESTROY_SRQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* SRQ context id */
	uint32_t	srq_cid;
	uint32_t	unused_0;
} cmdq_destroy_srq_t, *pcmdq_destroy_srq_t;

/* creq_destroy_srq_resp (size:128b/16B) */

typedef struct creq_destroy_srq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_SRQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_SRQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_SRQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_SRQ_RESP_TYPE_LAST	CREQ_DESTROY_SRQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* SRQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_SRQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy SRQ command response. */
	#define CREQ_DESTROY_SRQ_RESP_EVENT_DESTROY_SRQ UINT32_C(0x6)
	#define CREQ_DESTROY_SRQ_RESP_EVENT_LAST	CREQ_DESTROY_SRQ_RESP_EVENT_DESTROY_SRQ
	uint16_t	enable_for_arm[3];
	#define CREQ_DESTROY_SRQ_RESP_UNUSED0_MASK	UINT32_C(0xffff)
	#define CREQ_DESTROY_SRQ_RESP_UNUSED0_SFT	0
	/*
	 * Set to 1 if this SRQ is allowed to be armed for threshold async
	 * event
	 */
	#define CREQ_DESTROY_SRQ_RESP_ENABLE_FOR_ARM_MASK UINT32_C(0x30000)
	#define CREQ_DESTROY_SRQ_RESP_ENABLE_FOR_ARM_SFT 16
} creq_destroy_srq_resp_t, *pcreq_destroy_srq_resp_t;

/*************
 * query_srq *
 *************/


/* cmdq_query_srq (size:192b/24B) */

typedef struct cmdq_query_srq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query SRP command retrieves info about the specified SRQ. */
	#define CMDQ_QUERY_SRQ_OPCODE_QUERY_SRQ UINT32_C(0x8)
	#define CMDQ_QUERY_SRQ_OPCODE_LAST	CMDQ_QUERY_SRQ_OPCODE_QUERY_SRQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* SRQ context id */
	uint32_t	srq_cid;
	uint32_t	unused_0;
} cmdq_query_srq_t, *pcmdq_query_srq_t;

/* creq_query_srq_resp (size:128b/16B) */

typedef struct creq_query_srq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_SRQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_SRQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_SRQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_SRQ_RESP_TYPE_LAST	CREQ_QUERY_SRQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_SRQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query SRQ command response. */
	#define CREQ_QUERY_SRQ_RESP_EVENT_QUERY_SRQ UINT32_C(0x8)
	#define CREQ_QUERY_SRQ_RESP_EVENT_LAST	CREQ_QUERY_SRQ_RESP_EVENT_QUERY_SRQ
	uint8_t	reserved48[6];
} creq_query_srq_resp_t, *pcreq_query_srq_resp_t;

/* Query SRQ command response side buffer structure. */
/* creq_query_srq_resp_sb (size:256b/32B) */

typedef struct creq_query_srq_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query SRQ command response. */
	#define CREQ_QUERY_SRQ_RESP_SB_OPCODE_QUERY_SRQ UINT32_C(0x8)
	#define CREQ_QUERY_SRQ_RESP_SB_OPCODE_LAST	CREQ_QUERY_SRQ_RESP_SB_OPCODE_QUERY_SRQ
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* SRQ context id */
	uint32_t	xid;
	/* Watermark value to generate a SRQ limit event. */
	uint16_t	srq_limit;
	uint16_t	reserved16;
	/* data is 128 b */
	uint32_t	data[4];
} creq_query_srq_resp_sb_t, *pcreq_query_srq_resp_sb_t;

/*************
 * create_cq *
 *************/


/* cmdq_create_cq (size:512b/64B) */

typedef struct cmdq_create_cq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Create CQ command allocates a CQ with the specified parameters. */
	#define CMDQ_CREATE_CQ_OPCODE_CREATE_CQ UINT32_C(0x9)
	#define CMDQ_CREATE_CQ_OPCODE_LAST	CMDQ_CREATE_CQ_OPCODE_CREATE_CQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When the HW Doorbell Drop Recovery feature is enabled,
	 * HW can flag false CQ overflow when CQ consumer index
	 * doorbells are dropped when there really wasn't any overflow.
	 * The CQE values could have already been processed by the driver,
	 * but HW doesn't know about this because of the doorbell drop.
	 * To avoid false detection of CQ overflow events,
	 * it is recommended that CQ overflow detection is disabled
	 * by the driver when HW based doorbell recovery is enabled.
	 */
	#define CMDQ_CREATE_CQ_FLAGS_DISABLE_CQ_OVERFLOW_DETECTION	UINT32_C(0x1)
	/* This CQ uses the steering tag specified in the command. */
	#define CMDQ_CREATE_CQ_FLAGS_STEERING_TAG_VALID		UINT32_C(0x2)
	/*
	 * This CQ uses the infinite CQ mode.
	 * In the infinite CQ mode, all CQEs are written to the same
	 * address. Note that this mode implies a HW client is
	 * handling each entry instantly and avoiding overwrites.
	 * The following limitations apply when this mode is enabled:
	 * -cq_size field must be 1
	 * -disable_cq_overflow_detection flag must be true.
	 * -the CQ will never be armed.
	 * -the consumer index of CQ will never be changed
	 */
	#define CMDQ_CREATE_CQ_FLAGS_INFINITE_CQ_MODE		UINT32_C(0x4)
	/*
	 * This CQ uses coalescing data specified in the command.
	 * This feature is not supported if infinite_cq_mode is also enabled.
	 */
	#define CMDQ_CREATE_CQ_FLAGS_COALESCING_VALID		UINT32_C(0x8)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* CQ handle. */
	uint64_t	cq_handle;
	uint32_t	pg_size_lvl;
	/* PBL indirect levels. */
	#define CMDQ_CREATE_CQ_LVL_MASK	UINT32_C(0x3)
	#define CMDQ_CREATE_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_CQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_CREATE_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_CQ_LVL_LAST	CMDQ_CREATE_CQ_LVL_LVL_2
	/* page size. */
	#define CMDQ_CREATE_CQ_PG_SIZE_MASK  UINT32_C(0x1c)
	#define CMDQ_CREATE_CQ_PG_SIZE_SFT   2
	/* 4KB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 2)
	/* 8KB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 2)
	/* 64KB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 2)
	/* 2MB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 2)
	/* 8MB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 2)
	/* 1GB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 2)
		#define CMDQ_CREATE_CQ_PG_SIZE_LAST   CMDQ_CREATE_CQ_PG_SIZE_PG_1G
	/* unused27 is 27 b */
	#define CMDQ_CREATE_CQ_UNUSED27_MASK UINT32_C(0xffffffe0)
	#define CMDQ_CREATE_CQ_UNUSED27_SFT  5
	uint32_t	cq_fco_cnq_id;
	/* cnq_id is 12 b */
	#define CMDQ_CREATE_CQ_CNQ_ID_MASK UINT32_C(0xfff)
	#define CMDQ_CREATE_CQ_CNQ_ID_SFT 0
	/* Offset of first CQE in the first Page, in 32 byte units */
	#define CMDQ_CREATE_CQ_CQ_FCO_MASK UINT32_C(0xfffff000)
	#define CMDQ_CREATE_CQ_CQ_FCO_SFT 12
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Max number of CQ wqes. */
	uint32_t	cq_size;
	/* CQ PBL physical address. */
	uint64_t	pbl;
	/* Steering tag to use for memory transactions. */
	uint16_t	steering_tag;
	uint8_t	reserved16[2];
	uint32_t	coalescing;
	/*
	 * Buffer Max time before flushing buffer (units of 1us). This
	 * specifies the maximum time before completion buffers are
	 * flushed out to host memory even if the number of coalesced
	 * buffers is less than the threshold. buf_maxtime is 9 bits.
	 */
	#define CMDQ_CREATE_CQ_BUF_MAXTIME_MASK	UINT32_C(0x1ff)
	#define CMDQ_CREATE_CQ_BUF_MAXTIME_SFT	0
	/*
	 * This specifies the number of buffers coalesced before sending
	 * to memory during normal operation. Buffer unit is 16B
	 * completions. normal_maxbuf is 5 bits.
	 */
	#define CMDQ_CREATE_CQ_NORMAL_MAXBUF_MASK	UINT32_C(0x3e00)
	#define CMDQ_CREATE_CQ_NORMAL_MAXBUF_SFT	9
	/*
	 * This specifies the number of buffers coalesced before sending
	 * to memory when the interrupt is masked. Buffer unit is 16B
	 * completions. during_maxbuf is 5 bits.
	 */
	#define CMDQ_CREATE_CQ_DURING_MAXBUF_MASK	UINT32_C(0x7c000)
	#define CMDQ_CREATE_CQ_DURING_MAXBUF_SFT	14
	/*
	 * This field is used to enable ring for global idle mode interrupt
	 * generation. This mode will generate a notification (interrupt)
	 * if armed when only one completion has been generated if the chip
	 * is globally idle as determined by the device.
	 * enable_ring_idle_mode is 1 bit.
	 */
	#define CMDQ_CREATE_CQ_ENABLE_RING_IDLE_MODE	UINT32_C(0x80000)
	/* unused12 is 12 b */
	#define CMDQ_CREATE_CQ_UNUSED12_MASK		UINT32_C(0xfff00000)
	#define CMDQ_CREATE_CQ_UNUSED12_SFT		20
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_create_cq_t, *pcmdq_create_cq_t;

/* creq_create_cq_resp (size:128b/16B) */

typedef struct creq_create_cq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_CQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_CQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_CQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_CQ_RESP_TYPE_LAST	CREQ_CREATE_CQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_CQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create CQ command response. */
	#define CREQ_CREATE_CQ_RESP_EVENT_CREATE_CQ UINT32_C(0x9)
	#define CREQ_CREATE_CQ_RESP_EVENT_LAST	CREQ_CREATE_CQ_RESP_EVENT_CREATE_CQ
	uint8_t	reserved48[6];
} creq_create_cq_resp_t, *pcreq_create_cq_resp_t;

/**************
 * destroy_cq *
 **************/


/* cmdq_destroy_cq (size:192b/24B) */

typedef struct cmdq_destroy_cq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Destroy CQ command deletes and flushes the specified CQ. */
	#define CMDQ_DESTROY_CQ_OPCODE_DESTROY_CQ UINT32_C(0xa)
	#define CMDQ_DESTROY_CQ_OPCODE_LAST	CMDQ_DESTROY_CQ_OPCODE_DESTROY_CQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* CQ context id */
	uint32_t	cq_cid;
	uint32_t	unused_0;
} cmdq_destroy_cq_t, *pcmdq_destroy_cq_t;

/* creq_destroy_cq_resp (size:128b/16B) */

typedef struct creq_destroy_cq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_CQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_CQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_CQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_CQ_RESP_TYPE_LAST	CREQ_DESTROY_CQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_CQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy CQ command response. */
	#define CREQ_DESTROY_CQ_RESP_EVENT_DESTROY_CQ UINT32_C(0xa)
	#define CREQ_DESTROY_CQ_RESP_EVENT_LAST	CREQ_DESTROY_CQ_RESP_EVENT_DESTROY_CQ
	uint16_t	cq_arm_lvl;
	/*
	 * CQ ARM Level:
	 * 0 ? Not Armed
	 * 1 ? Arm SE Only, Generate CNQE only for incoming Solicited Events
	 * 2 ? Arm all, Generate CNQE for Rx and Tx
	 */
	#define CREQ_DESTROY_CQ_RESP_CQ_ARM_LVL_MASK UINT32_C(0x3)
	#define CREQ_DESTROY_CQ_RESP_CQ_ARM_LVL_SFT 0
	/*
	 * The total number of CNQ events for the CQ, incremented on each CNQ
	 * event for the CQ (including firmware-generated CQ error
	 * notification).
	 */
	uint16_t	total_cnq_events;
	uint16_t	reserved16;
} creq_destroy_cq_resp_t, *pcreq_destroy_cq_resp_t;

/*************
 * resize_cq *
 *************/


/* cmdq_resize_cq (size:320b/40B) */

typedef struct cmdq_resize_cq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Resize CQ command resizes the specified CQ. */
	#define CMDQ_RESIZE_CQ_OPCODE_RESIZE_CQ UINT32_C(0xc)
	#define CMDQ_RESIZE_CQ_OPCODE_LAST	CMDQ_RESIZE_CQ_OPCODE_RESIZE_CQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* CQ context id */
	uint32_t	cq_cid;
	uint32_t	new_cq_size_pg_size_lvl;
	/* PBL indirect levels. */
	#define CMDQ_RESIZE_CQ_LVL_MASK	UINT32_C(0x3)
	#define CMDQ_RESIZE_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_RESIZE_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_RESIZE_CQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_RESIZE_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_RESIZE_CQ_LVL_LAST	CMDQ_RESIZE_CQ_LVL_LVL_2
	/* page size. */
	#define CMDQ_RESIZE_CQ_PG_SIZE_MASK	UINT32_C(0x1c)
	#define CMDQ_RESIZE_CQ_PG_SIZE_SFT	2
	/* 4KB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_4K	(UINT32_C(0x0) << 2)
	/* 8KB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_8K	(UINT32_C(0x1) << 2)
	/* 64KB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_64K	(UINT32_C(0x2) << 2)
	/* 2MB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_2M	(UINT32_C(0x3) << 2)
	/* 8MB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_8M	(UINT32_C(0x4) << 2)
	/* 1GB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_1G	(UINT32_C(0x5) << 2)
		#define CMDQ_RESIZE_CQ_PG_SIZE_LAST	CMDQ_RESIZE_CQ_PG_SIZE_PG_1G
	/* New max number of CQ wqes. */
	#define CMDQ_RESIZE_CQ_NEW_CQ_SIZE_MASK UINT32_C(0x1fffffe0)
	#define CMDQ_RESIZE_CQ_NEW_CQ_SIZE_SFT 5
	/* CQ PBL physical address. */
	uint64_t	new_pbl;
	/* Offset of first CQE in the first Page, in 32 byte units */
	uint32_t	new_cq_fco;
	uint32_t	unused_0;
} cmdq_resize_cq_t, *pcmdq_resize_cq_t;

/* creq_resize_cq_resp (size:128b/16B) */

typedef struct creq_resize_cq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_RESIZE_CQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_RESIZE_CQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_RESIZE_CQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_RESIZE_CQ_RESP_TYPE_LAST	CREQ_RESIZE_CQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_RESIZE_CQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Resize CQ command response. */
	#define CREQ_RESIZE_CQ_RESP_EVENT_RESIZE_CQ UINT32_C(0xc)
	#define CREQ_RESIZE_CQ_RESP_EVENT_LAST	CREQ_RESIZE_CQ_RESP_EVENT_RESIZE_CQ
	uint8_t	reserved48[6];
} creq_resize_cq_resp_t, *pcreq_resize_cq_resp_t;

/*************
 * modify_cq *
 *************/


/* cmdq_modify_cq (size:512b/64B) */

typedef struct cmdq_modify_cq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Modify CQ updates specific params in the CQ context. */
	#define CMDQ_MODIFY_CQ_OPCODE_MODIFY_CQ UINT32_C(0x90)
	#define CMDQ_MODIFY_CQ_OPCODE_LAST	CMDQ_MODIFY_CQ_OPCODE_MODIFY_CQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When the HW Doorbell Drop Recovery feature is enabled,
	 * HW can flag false CQ overflow when CQ consumer index
	 * doorbells are dropped when there really wasn't any overflow.
	 * The CQE values could have already been processed by the driver,
	 * but HW doesn't know about this because of the doorbell drop.
	 * To avoid false detection of CQ overflow events,
	 * it is recommended that CQ overflow detection is disabled
	 * by the driver when HW based doorbell recovery is enabled.
	 */
	#define CMDQ_MODIFY_CQ_FLAGS_DISABLE_CQ_OVERFLOW_DETECTION	UINT32_C(0x1)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* Enable change. */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_CQ_HANDLE	UINT32_C(0x1)
	/* CNQ ID */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_CNQ_ID	UINT32_C(0x2)
	/* Offset of first CQE in the first page, in 32 byte units */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_FCO	UINT32_C(0x4)
	/* Doorbell page index */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_DPI	UINT32_C(0x8)
	/* Max number of CQ Wqes */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_CQ_SIZE	UINT32_C(0x10)
	/* CQ PBL physical address */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_PBL	UINT32_C(0x20)
	/* reserved32 is 32 b */
	uint32_t	reserved32;
	/* CQ handle. */
	uint64_t	cq_handle;
	uint32_t	cq_fco_cnq_id;
	/* cnq_id is 12 b */
	#define CMDQ_MODIFY_CQ_CNQ_ID_MASK UINT32_C(0xfff)
	#define CMDQ_MODIFY_CQ_CNQ_ID_SFT 0
	/* Offset of first CQE in the first Page, in 32 byte units */
	#define CMDQ_MODIFY_CQ_CQ_FCO_MASK UINT32_C(0xfffff000)
	#define CMDQ_MODIFY_CQ_CQ_FCO_SFT 12
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Max number of CQ wqes. */
	uint32_t	cq_size;
	/* reserved32_1 is 32 b */
	uint32_t	reserved32_1;
	/* CQ PBL physical address. */
	uint64_t	pbl;
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_modify_cq_t, *pcmdq_modify_cq_t;

/* creq_modify_cq_resp (size:128b/16B) */

typedef struct creq_modify_cq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MODIFY_CQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MODIFY_CQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MODIFY_CQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MODIFY_CQ_RESP_TYPE_LAST	CREQ_MODIFY_CQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MODIFY_CQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Modify CQ command response. */
	#define CREQ_MODIFY_CQ_RESP_EVENT_MODIFY_CQ UINT32_C(0x9)
	#define CREQ_MODIFY_CQ_RESP_EVENT_LAST	CREQ_MODIFY_CQ_RESP_EVENT_MODIFY_CQ
	uint8_t	reserved48[6];
} creq_modify_cq_resp_t, *pcreq_modify_cq_resp_t;

/****************
 * allocate_mrw *
 ****************/


/* cmdq_allocate_mrw (size:256b/32B) */

typedef struct cmdq_allocate_mrw {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Allocate MRW command allocates a MR/MW with the specified
	 * parameters and returns the region's L_KEY/R_KEY
	 */
	#define CMDQ_ALLOCATE_MRW_OPCODE_ALLOCATE_MRW UINT32_C(0xd)
	#define CMDQ_ALLOCATE_MRW_OPCODE_LAST	CMDQ_ALLOCATE_MRW_OPCODE_ALLOCATE_MRW
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* MRW handle. */
	uint64_t	mrw_handle;
	uint8_t	mrw_flags;
	/* Allocate MRW flags. */
	#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MASK	UINT32_C(0xf)
	#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_SFT	0
	/* Allocate Memory Region */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MR		UINT32_C(0x0)
	/* Allocate Physical Memory Region */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_PMR		UINT32_C(0x1)
	/* Allocate Memory Window (type 1) */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE1	UINT32_C(0x2)
	/* Allocate Memory Window (type 2A) */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE2A	UINT32_C(0x3)
	/* Allocate Memory Window (type 2B) */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE2B	UINT32_C(0x4)
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_LAST	CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE2B
	/*
	 * This Memory Region / Memory Window uses the
	 * steering tag specified in the command.
	 */
	#define CMDQ_ALLOCATE_MRW_STEERING_TAG_VALID	UINT32_C(0x10)
	/* unused3 is 3 b */
	#define CMDQ_ALLOCATE_MRW_UNUSED3_MASK	UINT32_C(0xe0)
	#define CMDQ_ALLOCATE_MRW_UNUSED3_SFT		5
	/* Access flags. */
	uint8_t	access;
	/* Consumer owns the key */
	#define CMDQ_ALLOCATE_MRW_ACCESS_CONSUMER_OWNED_KEY	UINT32_C(0x20)
	/* Steering tag to use for memory transactions. */
	uint16_t	steering_tag;
	/* Protection domain id. */
	uint32_t	pd_id;
} cmdq_allocate_mrw_t, *pcmdq_allocate_mrw_t;

/* creq_allocate_mrw_resp (size:128b/16B) */

typedef struct creq_allocate_mrw_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_ALLOCATE_MRW_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_ALLOCATE_MRW_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_ALLOCATE_MRW_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_ALLOCATE_MRW_RESP_TYPE_LAST	CREQ_ALLOCATE_MRW_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* L_KEY for MR, R_KEY for MW */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_ALLOCATE_MRW_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Allocate MRW command response. */
	#define CREQ_ALLOCATE_MRW_RESP_EVENT_ALLOCATE_MRW UINT32_C(0xd)
	#define CREQ_ALLOCATE_MRW_RESP_EVENT_LAST	CREQ_ALLOCATE_MRW_RESP_EVENT_ALLOCATE_MRW
	uint8_t	reserved48[6];
} creq_allocate_mrw_resp_t, *pcreq_allocate_mrw_resp_t;

/******************
 * deallocate_key *
 ******************/


/* cmdq_deallocate_key (size:192b/24B) */

typedef struct cmdq_deallocate_key {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * De-allocate key command frees a MR/MW entry associated with the
	 * specified key.
	 */
	#define CMDQ_DEALLOCATE_KEY_OPCODE_DEALLOCATE_KEY UINT32_C(0xe)
	#define CMDQ_DEALLOCATE_KEY_OPCODE_LAST	CMDQ_DEALLOCATE_KEY_OPCODE_DEALLOCATE_KEY
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	uint8_t	mrw_flags;
	/* Deallocate MRW flags. */
	#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MASK	UINT32_C(0xf)
	#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_SFT	0
	/* Deallocate Memory Region */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MR	UINT32_C(0x0)
	/* Deallocate Physical Memory Region */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_PMR	UINT32_C(0x1)
	/* Deallocate Memory Window (type 1) */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE1   UINT32_C(0x2)
	/* Deallocate Memory Window (type 2A) */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE2A  UINT32_C(0x3)
	/* Deallocate Memory Window (type 2B) */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE2B  UINT32_C(0x4)
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_LAST	CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE2B
	/* unused4 is 4 b */
	#define CMDQ_DEALLOCATE_KEY_UNUSED4_MASK	UINT32_C(0xf0)
	#define CMDQ_DEALLOCATE_KEY_UNUSED4_SFT	4
	/* unused24 is 24 b */
	uint8_t	unused24[3];
	/* key is 32 b */
	uint32_t	key;
} cmdq_deallocate_key_t, *pcmdq_deallocate_key_t;

/* creq_deallocate_key_resp (size:128b/16B) */

typedef struct creq_deallocate_key_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DEALLOCATE_KEY_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DEALLOCATE_KEY_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DEALLOCATE_KEY_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DEALLOCATE_KEY_RESP_TYPE_LAST	CREQ_DEALLOCATE_KEY_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* L_KEY for MR, R_KEY for MW */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DEALLOCATE_KEY_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* De-allocate key command response. */
	#define CREQ_DEALLOCATE_KEY_RESP_EVENT_DEALLOCATE_KEY UINT32_C(0xe)
	#define CREQ_DEALLOCATE_KEY_RESP_EVENT_LAST	CREQ_DEALLOCATE_KEY_RESP_EVENT_DEALLOCATE_KEY
	uint16_t	reserved16;
	/*
	 * This is advisory data to facilitate eventual destruction of
	 * lingering memory regions in Windows. For memory window, it contains
	 * non-zero HWID of a region this window was bound to (without the
	 * 8-bit key portion). The host may check if the region is lingering in
	 * destroyed state and try to destroy it now. For memory region, if
	 * deallocation fails because there are windows bound to this region,
	 * this field will contain approximate number of those windows. This
	 * number is read from the context right before the deregistration is
	 * attempted and can potentially be slightly different from the current
	 * number.
	 */
	uint32_t	bound_window_info;
} creq_deallocate_key_resp_t, *pcreq_deallocate_key_resp_t;

/***************
 * register_mr *
 ***************/


/* cmdq_register_mr (size:512b/64B) */

typedef struct cmdq_register_mr {
	/* Command opcode. */
	uint8_t	opcode;
	/* Register MR command registers memory to the specified MR. */
	#define CMDQ_REGISTER_MR_OPCODE_REGISTER_MR UINT32_C(0xf)
	#define CMDQ_REGISTER_MR_OPCODE_LAST	CMDQ_REGISTER_MR_OPCODE_REGISTER_MR
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When set, a new MR will be allocated first and then registered
	 * using the fields in this command. Note that for MR allocation
	 * the `key` field doesn't hold a valid L_KEY and is instead
	 * overloaded to hold the Protection Domain ID `pd_id`.
	 */
	#define CMDQ_REGISTER_MR_FLAGS_ALLOC_MR		UINT32_C(0x1)
	/*
	 * This MR uses the steering tag specified in the command.
	 * This flag can only be enabled when the command is used
	 * to allocate a new MR first.
	 */
	#define CMDQ_REGISTER_MR_FLAGS_STEERING_TAG_VALID	UINT32_C(0x2)
	/* When set, enable per MR relaxed ordering support. */
	#define CMDQ_REGISTER_MR_FLAGS_ENABLE_RO		UINT32_C(0x4)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	uint8_t	log2_pg_size_lvl;
	/* PBL indirect levels. */
	#define CMDQ_REGISTER_MR_LVL_MASK		UINT32_C(0x3)
	#define CMDQ_REGISTER_MR_LVL_SFT		0
	/* PBL pointer is physical start address. */
		#define CMDQ_REGISTER_MR_LVL_LVL_0		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_REGISTER_MR_LVL_LVL_1		UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_REGISTER_MR_LVL_LVL_2		UINT32_C(0x2)
		#define CMDQ_REGISTER_MR_LVL_LAST		CMDQ_REGISTER_MR_LVL_LVL_2
	/*
	 * Log base 2 of page size; 12 is the minimum for 4KB. HW supported
	 * values are enumerated below.
	 */
	#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_MASK   UINT32_C(0x7c)
	#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_SFT	2
	/* 4KB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_4K	(UINT32_C(0xc) << 2)
	/* 8KB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_8K	(UINT32_C(0xd) << 2)
	/* 64KB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_64K   (UINT32_C(0x10) << 2)
	/* 256KB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_256K  (UINT32_C(0x12) << 2)
	/* 1MB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_1M	(UINT32_C(0x14) << 2)
	/* 2MB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_2M	(UINT32_C(0x15) << 2)
	/* 4MB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_4M	(UINT32_C(0x16) << 2)
	/* 1GB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_1G	(UINT32_C(0x1e) << 2)
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_LAST	CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_1G
	/* unused1 is 1 b */
	#define CMDQ_REGISTER_MR_UNUSED1		UINT32_C(0x80)
	/* Access flags. */
	uint8_t	access;
	/* Local write access. */
	#define CMDQ_REGISTER_MR_ACCESS_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote read access. */
	#define CMDQ_REGISTER_MR_ACCESS_REMOTE_READ	UINT32_C(0x2)
	/* Remote write access. */
	#define CMDQ_REGISTER_MR_ACCESS_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote atomic access. */
	#define CMDQ_REGISTER_MR_ACCESS_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Bind access allowed. */
	#define CMDQ_REGISTER_MR_ACCESS_MW_BIND	UINT32_C(0x10)
	/* Indicate Zero Based Virtual Address (ZBVA). */
	#define CMDQ_REGISTER_MR_ACCESS_ZERO_BASED	UINT32_C(0x20)
	uint16_t	log2_pbl_pg_size;
	/*
	 * Log base 2 of PBL page size; 12 is the minimum for 4KB. HW
	 * supported values are enumerated below
	 */
	#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_MASK   UINT32_C(0x1f)
	#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_SFT	0
	/* 4KB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_4K	UINT32_C(0xc)
	/* 8KB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_8K	UINT32_C(0xd)
	/* 64KB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_64K   UINT32_C(0x10)
	/* 256KB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_256K  UINT32_C(0x12)
	/* 1MB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_1M	UINT32_C(0x14)
	/* 2MB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_2M	UINT32_C(0x15)
	/* 4MB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_4M	UINT32_C(0x16)
	/* 1GB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_1G	UINT32_C(0x1e)
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_LAST	CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_1G
	/* unused11 is 11 b */
	#define CMDQ_REGISTER_MR_UNUSED11_MASK	UINT32_C(0xffe0)
	#define CMDQ_REGISTER_MR_UNUSED11_SFT		5
	/*
	 * L_KEY of the previously allocated MR.
	 *
	 * If the `ALLOC_MR` flag is set then this field does not hold an
	 * L_KEY and instead contains the Protection Domain ID `pd_id`.
	 */
	uint32_t	key;
	/* Page table of the MR memory. */
	uint64_t	pbl;
	/* Virtual address of the MR. */
	uint64_t	va;
	/* Size of the MR. */
	uint64_t	mr_size;
	/* Steering tag to use for memory transactions. */
	uint16_t	steering_tag;
	uint8_t	reserved48[6];
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_register_mr_t, *pcmdq_register_mr_t;

/* creq_register_mr_resp (size:128b/16B) */

typedef struct creq_register_mr_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_REGISTER_MR_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_REGISTER_MR_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_REGISTER_MR_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_REGISTER_MR_RESP_TYPE_LAST	CREQ_REGISTER_MR_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* L_KEY */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_REGISTER_MR_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Register MR command response. */
	#define CREQ_REGISTER_MR_RESP_EVENT_REGISTER_MR UINT32_C(0xf)
	#define CREQ_REGISTER_MR_RESP_EVENT_LAST	CREQ_REGISTER_MR_RESP_EVENT_REGISTER_MR
	uint8_t	reserved48[6];
} creq_register_mr_resp_t, *pcreq_register_mr_resp_t;

/*****************
 * deregister_mr *
 *****************/


/* cmdq_deregister_mr (size:192b/24B) */

typedef struct cmdq_deregister_mr {
	/* Command opcode. */
	uint8_t	opcode;
	/* Deregister MR command de-registers memory from the specified MR. */
	#define CMDQ_DEREGISTER_MR_OPCODE_DEREGISTER_MR UINT32_C(0x10)
	#define CMDQ_DEREGISTER_MR_OPCODE_LAST	CMDQ_DEREGISTER_MR_OPCODE_DEREGISTER_MR
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* L_KEY of the MR. */
	uint32_t	lkey;
	uint32_t	unused_0;
} cmdq_deregister_mr_t, *pcmdq_deregister_mr_t;

/* creq_deregister_mr_resp (size:128b/16B) */

typedef struct creq_deregister_mr_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DEREGISTER_MR_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DEREGISTER_MR_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DEREGISTER_MR_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DEREGISTER_MR_RESP_TYPE_LAST	CREQ_DEREGISTER_MR_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* L_KEY */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DEREGISTER_MR_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Deregister MR command response. */
	#define CREQ_DEREGISTER_MR_RESP_EVENT_DEREGISTER_MR UINT32_C(0x10)
	#define CREQ_DEREGISTER_MR_RESP_EVENT_LAST	CREQ_DEREGISTER_MR_RESP_EVENT_DEREGISTER_MR
	uint16_t	reserved16;
	/*
	 * If deregister fails because there are windows bound to this region,
	 * this field will contain approximate number of those windows. This
	 * number is read from the context right before the deregistration is
	 * attempted and can potentially be slightly different from the current
	 * number.
	 */
	uint32_t	bound_windows;
} creq_deregister_mr_resp_t, *pcreq_deregister_mr_resp_t;

/***********
 * add_gid *
 ***********/


/* cmdq_add_gid (size:384b/48B) */

typedef struct cmdq_add_gid {
	/* Command opcode. */
	uint8_t	opcode;
	/* Add GID command adds a GID to the local address table. */
	#define CMDQ_ADD_GID_OPCODE_ADD_GID UINT32_C(0x11)
	#define CMDQ_ADD_GID_OPCODE_LAST   CMDQ_ADD_GID_OPCODE_ADD_GID
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* GID, specified in LE format. */
	uint32_t	gid[4];
	/* Source MAC. */
	uint16_t	src_mac[3];
	/* flags. */
	uint16_t	vlan;
	#define CMDQ_ADD_GID_VLAN_VLAN_EN_TPID_VLAN_ID_MASK	UINT32_C(0xffff)
	#define CMDQ_ADD_GID_VLAN_VLAN_EN_TPID_VLAN_ID_SFT	0
	/* Source VLAN id. */
	#define CMDQ_ADD_GID_VLAN_VLAN_ID_MASK			UINT32_C(0xfff)
	#define CMDQ_ADD_GID_VLAN_VLAN_ID_SFT			0
	/* This set of bits select the TPID of the VLAN Tag. */
	#define CMDQ_ADD_GID_VLAN_TPID_MASK			UINT32_C(0x7000)
	#define CMDQ_ADD_GID_VLAN_TPID_SFT			12
	/* TPID = 0x88A8. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_88A8			(UINT32_C(0x0) << 12)
	/* TPID = 0x8100. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_8100			(UINT32_C(0x1) << 12)
	/* TPID = 0x9100. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_9100			(UINT32_C(0x2) << 12)
	/* TPID = 0x9200. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_9200			(UINT32_C(0x3) << 12)
	/* TPID = 0x9300. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_9300			(UINT32_C(0x4) << 12)
	/* TPID = Configurable 1. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_CFG1			(UINT32_C(0x5) << 12)
	/* TPID = Configurable 2. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_CFG2			(UINT32_C(0x6) << 12)
	/* TPID = Configurable 3. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_CFG3			(UINT32_C(0x7) << 12)
		#define CMDQ_ADD_GID_VLAN_TPID_LAST			CMDQ_ADD_GID_VLAN_TPID_TPID_CFG3
	/*
	 * Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE
	 * header.
	 */
	#define CMDQ_ADD_GID_VLAN_VLAN_EN				UINT32_C(0x8000)
	/* Identifier field in the IP header. */
	uint16_t	ipid;
	/* Stats context ID to use with this SGID */
	uint16_t	stats_ctx;
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_VALID_STATS_CTX_ID_MASK		UINT32_C(0xffff)
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_VALID_STATS_CTX_ID_SFT		0
	/* stats_ctx_id is 15 b */
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_ID_MASK				UINT32_C(0x7fff)
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_ID_SFT				0
	/*
	 * Setting this bit to 1 enables use of own stats context ID
	 * instead of per-function.
	 */
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_VALID				UINT32_C(0x8000)
	uint32_t	unused_0;
} cmdq_add_gid_t, *pcmdq_add_gid_t;

/* creq_add_gid_resp (size:128b/16B) */

typedef struct creq_add_gid_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_ADD_GID_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_ADD_GID_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_ADD_GID_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_ADD_GID_RESP_TYPE_LAST	CREQ_ADD_GID_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* GID index */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_ADD_GID_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Add GID command response. */
	#define CREQ_ADD_GID_RESP_EVENT_ADD_GID UINT32_C(0x11)
	#define CREQ_ADD_GID_RESP_EVENT_LAST   CREQ_ADD_GID_RESP_EVENT_ADD_GID
	uint8_t	reserved48[6];
} creq_add_gid_resp_t, *pcreq_add_gid_resp_t;

/**************
 * delete_gid *
 **************/


/* cmdq_delete_gid (size:192b/24B) */

typedef struct cmdq_delete_gid {
	/* Command opcode. */
	uint8_t	opcode;
	/* Delete GID command deletes a GID from the local address table. */
	#define CMDQ_DELETE_GID_OPCODE_DELETE_GID UINT32_C(0x12)
	#define CMDQ_DELETE_GID_OPCODE_LAST	CMDQ_DELETE_GID_OPCODE_DELETE_GID
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* GID index */
	uint16_t	gid_index;
	uint8_t	unused_0[6];
} cmdq_delete_gid_t, *pcmdq_delete_gid_t;

/* creq_delete_gid_resp (size:128b/16B) */

typedef struct creq_delete_gid_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DELETE_GID_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DELETE_GID_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DELETE_GID_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DELETE_GID_RESP_TYPE_LAST	CREQ_DELETE_GID_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* GID index */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DELETE_GID_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Delete GID command response. */
	#define CREQ_DELETE_GID_RESP_EVENT_DELETE_GID UINT32_C(0x12)
	#define CREQ_DELETE_GID_RESP_EVENT_LAST	CREQ_DELETE_GID_RESP_EVENT_DELETE_GID
	uint8_t	reserved48[6];
} creq_delete_gid_resp_t, *pcreq_delete_gid_resp_t;

/**************
 * modify_gid *
 **************/


/* cmdq_modify_gid (size:384b/48B) */

typedef struct cmdq_modify_gid {
	/* Command opcode. */
	uint8_t	opcode;
	/* Modify GID command modifies a GID in the local address table. */
	#define CMDQ_MODIFY_GID_OPCODE_MODIFY_GID UINT32_C(0x17)
	#define CMDQ_MODIFY_GID_OPCODE_LAST	CMDQ_MODIFY_GID_OPCODE_MODIFY_GID
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* GID */
	uint32_t	gid[4];
	/* Source MAC. */
	uint16_t	src_mac[3];
	/* flags. */
	uint16_t	vlan;
	/* Source VLAN id. */
	#define CMDQ_MODIFY_GID_VLAN_VLAN_ID_MASK  UINT32_C(0xfff)
	#define CMDQ_MODIFY_GID_VLAN_VLAN_ID_SFT   0
	/* This set of bits select the TPID of the VLAN Tag. */
	#define CMDQ_MODIFY_GID_VLAN_TPID_MASK	UINT32_C(0x7000)
	#define CMDQ_MODIFY_GID_VLAN_TPID_SFT	12
	/* TPID = 0x88A8. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_88A8  (UINT32_C(0x0) << 12)
	/* TPID = 0x8100. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_8100  (UINT32_C(0x1) << 12)
	/* TPID = 0x9100. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_9100  (UINT32_C(0x2) << 12)
	/* TPID = 0x9200. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_9200  (UINT32_C(0x3) << 12)
	/* TPID = 0x9300. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_9300  (UINT32_C(0x4) << 12)
	/* TPID = Configurable 1. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG1  (UINT32_C(0x5) << 12)
	/* TPID = Configurable 2. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG2  (UINT32_C(0x6) << 12)
	/* TPID = Configurable 3. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG3  (UINT32_C(0x7) << 12)
		#define CMDQ_MODIFY_GID_VLAN_TPID_LAST	CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG3
	/*
	 * Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE
	 * header.
	 */
	#define CMDQ_MODIFY_GID_VLAN_VLAN_EN	UINT32_C(0x8000)
	/* Identifier field in the IP header. */
	uint16_t	ipid;
	/* GID index */
	uint16_t	gid_index;
	/* Stats context ID to use with this SGID */
	uint16_t	stats_ctx;
	/* stats_ctx_id is 15 b */
	#define CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_ID_MASK   UINT32_C(0x7fff)
	#define CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_ID_SFT	0
	/*
	 * Setting this bit to 1 enables use of own stats context ID
	 * instead of per-function.
	 */
	#define CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_VALID	UINT32_C(0x8000)
	uint16_t	unused_0;
} cmdq_modify_gid_t, *pcmdq_modify_gid_t;

/* creq_modify_gid_resp (size:128b/16B) */

typedef struct creq_modify_gid_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MODIFY_GID_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MODIFY_GID_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MODIFY_GID_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MODIFY_GID_RESP_TYPE_LAST	CREQ_MODIFY_GID_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* GID index */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MODIFY_GID_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Add GID command response. */
	#define CREQ_MODIFY_GID_RESP_EVENT_ADD_GID UINT32_C(0x11)
	#define CREQ_MODIFY_GID_RESP_EVENT_LAST   CREQ_MODIFY_GID_RESP_EVENT_ADD_GID
	uint8_t	reserved48[6];
} creq_modify_gid_resp_t, *pcreq_modify_gid_resp_t;

/*************
 * query_gid *
 *************/


/* cmdq_query_gid (size:192b/24B) */

typedef struct cmdq_query_gid {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query GID command queries a GID in the local address table. */
	#define CMDQ_QUERY_GID_OPCODE_QUERY_GID UINT32_C(0x18)
	#define CMDQ_QUERY_GID_OPCODE_LAST	CMDQ_QUERY_GID_OPCODE_QUERY_GID
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* GID index */
	uint16_t	gid_index;
	/* unused16 is 16 b */
	uint8_t	unused16[6];
} cmdq_query_gid_t, *pcmdq_query_gid_t;

/* creq_query_gid_resp (size:128b/16B) */

typedef struct creq_query_gid_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_GID_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_GID_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_GID_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_GID_RESP_TYPE_LAST	CREQ_QUERY_GID_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_GID_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query GID command response. */
	#define CREQ_QUERY_GID_RESP_EVENT_QUERY_GID UINT32_C(0x18)
	#define CREQ_QUERY_GID_RESP_EVENT_LAST	CREQ_QUERY_GID_RESP_EVENT_QUERY_GID
	uint8_t	reserved48[6];
} creq_query_gid_resp_t, *pcreq_query_gid_resp_t;

/* Query GID command response side buffer structure */
/* creq_query_gid_resp_sb (size:320b/40B) */

typedef struct creq_query_gid_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query GID command response. */
	#define CREQ_QUERY_GID_RESP_SB_OPCODE_QUERY_GID UINT32_C(0x18)
	#define CREQ_QUERY_GID_RESP_SB_OPCODE_LAST	CREQ_QUERY_GID_RESP_SB_OPCODE_QUERY_GID
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* GID */
	uint32_t	gid[4];
	/* Source MAC. */
	uint16_t	src_mac[3];
	/* flags. */
	uint16_t	vlan;
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_EN_TPID_VLAN_ID_MASK	UINT32_C(0xffff)
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_EN_TPID_VLAN_ID_SFT	0
	/* Source VLAN id. */
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_ID_MASK			UINT32_C(0xfff)
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_ID_SFT			0
	/* This set of bits select the TPID of the VLAN Tag. */
	#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_MASK			UINT32_C(0x7000)
	#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_SFT			12
	/* TPID = 0x88A8. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_88A8			(UINT32_C(0x0) << 12)
	/* TPID = 0x8100. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_8100			(UINT32_C(0x1) << 12)
	/* TPID = 0x9100. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9100			(UINT32_C(0x2) << 12)
	/* TPID = 0x9200. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9200			(UINT32_C(0x3) << 12)
	/* TPID = 0x9300. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9300			(UINT32_C(0x4) << 12)
	/* TPID = Configurable 1. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG1			(UINT32_C(0x5) << 12)
	/* TPID = Configurable 2. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG2			(UINT32_C(0x6) << 12)
	/* TPID = Configurable 3. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG3			(UINT32_C(0x7) << 12)
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_LAST			CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG3
	/*
	 * Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE
	 * header.
	 */
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_EN				UINT32_C(0x8000)
	/* Identifier field in the IP header. */
	uint16_t	ipid;
	/* GID index */
	uint16_t	gid_index;
	uint32_t	unused_0;
} creq_query_gid_resp_sb_t, *pcreq_query_gid_resp_sb_t;

/**************
 * create_qp1 *
 **************/


/* cmdq_create_qp1 (size:640b/80B) */

typedef struct cmdq_create_qp1 {
	/* Command opcode. */
	uint8_t	opcode;
	/* Create QP1 command allocates a QP1 only. */
	#define CMDQ_CREATE_QP1_OPCODE_CREATE_QP1 UINT32_C(0x13)
	#define CMDQ_CREATE_QP1_OPCODE_LAST	CMDQ_CREATE_QP1_OPCODE_CREATE_QP1
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP1 handle. */
	uint64_t	qp_handle;
	/* Create QP1 flags. */
	uint32_t	qp_flags;
	/* SRQ is used. */
	#define CMDQ_CREATE_QP1_QP_FLAGS_SRQ_USED		UINT32_C(0x1)
	/* post CQE for all SQ WQEs. */
	#define CMDQ_CREATE_QP1_QP_FLAGS_FORCE_COMPLETION	UINT32_C(0x2)
	/* This QP can use reserved L_Key */
	#define CMDQ_CREATE_QP1_QP_FLAGS_RESERVED_LKEY_ENABLE UINT32_C(0x4)
	#define CMDQ_CREATE_QP1_QP_FLAGS_LAST		CMDQ_CREATE_QP1_QP_FLAGS_RESERVED_LKEY_ENABLE
	/* Supported QP1 types. */
	uint8_t	type;
	/* General Services Interface on QP 1. */
	#define CMDQ_CREATE_QP1_TYPE_GSI UINT32_C(0x1)
	#define CMDQ_CREATE_QP1_TYPE_LAST CMDQ_CREATE_QP1_TYPE_GSI
	uint8_t	sq_pg_size_sq_lvl;
	/* SQ PBL indirect levels. */
	#define CMDQ_CREATE_QP1_SQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_CREATE_QP1_SQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_QP1_SQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_QP1_SQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_CREATE_QP1_SQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_QP1_SQ_LVL_LAST	CMDQ_CREATE_QP1_SQ_LVL_LVL_2
	/* SQ page size. */
	#define CMDQ_CREATE_QP1_SQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_CREATE_QP1_SQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_LAST   CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_1G
	uint8_t	rq_pg_size_rq_lvl;
	/* RQ PBL indirect levels. */
	#define CMDQ_CREATE_QP1_RQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_CREATE_QP1_RQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_QP1_RQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_QP1_RQ_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define CMDQ_CREATE_QP1_RQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_QP1_RQ_LVL_LAST	CMDQ_CREATE_QP1_RQ_LVL_LVL_2
	/* RQ page size. */
	#define CMDQ_CREATE_QP1_RQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_CREATE_QP1_RQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_LAST   CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_1G
	uint8_t	unused_0;
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Max number of SQ wqes. */
	uint32_t	sq_size;
	/* Max number of RQ wqes. */
	uint32_t	rq_size;
	uint16_t	sq_fwo_sq_sge;
	/* Max send SGEs per SWQE. */
	#define CMDQ_CREATE_QP1_SQ_SGE_MASK UINT32_C(0xf)
	#define CMDQ_CREATE_QP1_SQ_SGE_SFT 0
	/* Offset of First WQE in the first SQ page, in 128 byte units */
	#define CMDQ_CREATE_QP1_SQ_FWO_MASK UINT32_C(0xfff0)
	#define CMDQ_CREATE_QP1_SQ_FWO_SFT 4
	uint16_t	rq_fwo_rq_sge;
	/* Max recv SGEs per RWQE (NOT SUPPORTED BY HARDWARE). */
	#define CMDQ_CREATE_QP1_RQ_SGE_MASK UINT32_C(0xf)
	#define CMDQ_CREATE_QP1_RQ_SGE_SFT 0
	/* Offset of First WQE in the first RQ page, in 128 byte units */
	#define CMDQ_CREATE_QP1_RQ_FWO_MASK UINT32_C(0xfff0)
	#define CMDQ_CREATE_QP1_RQ_FWO_SFT 4
	/* Send CQ context id. */
	uint32_t	scq_cid;
	/* Receive CQ context id. */
	uint32_t	rcq_cid;
	/* SRQ CQ context id. */
	uint32_t	srq_cid;
	/* Protection domain id. */
	uint32_t	pd_id;
	/* SQ PBL physical address. */
	uint64_t	sq_pbl;
	/* RQ PBL physical address. */
	uint64_t	rq_pbl;
} cmdq_create_qp1_t, *pcmdq_create_qp1_t;

/* creq_create_qp1_resp (size:128b/16B) */

typedef struct creq_create_qp1_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_QP1_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_QP1_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_QP1_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_QP1_RESP_TYPE_LAST	CREQ_CREATE_QP1_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP1 context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_QP1_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create QP1 command response. */
	#define CREQ_CREATE_QP1_RESP_EVENT_CREATE_QP1 UINT32_C(0x13)
	#define CREQ_CREATE_QP1_RESP_EVENT_LAST	CREQ_CREATE_QP1_RESP_EVENT_CREATE_QP1
	uint8_t	reserved48[6];
} creq_create_qp1_resp_t, *pcreq_create_qp1_resp_t;

/***************
 * destroy_qp1 *
 ***************/


/* cmdq_destroy_qp1 (size:192b/24B) */

typedef struct cmdq_destroy_qp1 {
	/* Command opcode. */
	uint8_t	opcode;
	/* Destroy QP1 command deletes and flushes the specified QP1. */
	#define CMDQ_DESTROY_QP1_OPCODE_DESTROY_QP1 UINT32_C(0x14)
	#define CMDQ_DESTROY_QP1_OPCODE_LAST	CMDQ_DESTROY_QP1_OPCODE_DESTROY_QP1
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP1 context id */
	uint32_t	qp1_cid;
	uint32_t	unused_0;
} cmdq_destroy_qp1_t, *pcmdq_destroy_qp1_t;

/* creq_destroy_qp1_resp (size:128b/16B) */

typedef struct creq_destroy_qp1_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_QP1_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_QP1_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_QP1_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_QP1_RESP_TYPE_LAST	CREQ_DESTROY_QP1_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP1 context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_QP1_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy QP1 command response. */
	#define CREQ_DESTROY_QP1_RESP_EVENT_DESTROY_QP1 UINT32_C(0x14)
	#define CREQ_DESTROY_QP1_RESP_EVENT_LAST	CREQ_DESTROY_QP1_RESP_EVENT_DESTROY_QP1
	uint8_t	reserved48[6];
} creq_destroy_qp1_resp_t, *pcreq_destroy_qp1_resp_t;

/*************
 * create_ah *
 *************/


/* cmdq_create_ah (size:512b/64B) */

typedef struct cmdq_create_ah {
	/* Command opcode. */
	uint8_t	opcode;
	/* Create AH command allocates an AH with the specified parameters. */
	#define CMDQ_CREATE_AH_OPCODE_CREATE_AH UINT32_C(0x15)
	#define CMDQ_CREATE_AH_OPCODE_LAST	CMDQ_CREATE_AH_OPCODE_CREATE_AH
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* AH handle. */
	uint64_t	ah_handle;
	/* Destination GID, specified in BE format. */
	uint32_t	dgid[4];
	/* V1, V2IPv4 or V2IPv6. */
	uint8_t	type;
	/* V2IPv4. */
	#define CMDQ_CREATE_AH_TYPE_V1	UINT32_C(0x0)
	/* V2IPv4. */
	#define CMDQ_CREATE_AH_TYPE_V2IPV4 UINT32_C(0x2)
	/* V2IPv6. */
	#define CMDQ_CREATE_AH_TYPE_V2IPV6 UINT32_C(0x3)
	#define CMDQ_CREATE_AH_TYPE_LAST  CMDQ_CREATE_AH_TYPE_V2IPV6
	/* IPv6 Hop limit. */
	uint8_t	hop_limit;
	/* SGID index. */
	uint16_t	sgid_index;
	uint32_t	dest_vlan_id_flow_label;
	/* Flow label. */
	#define CMDQ_CREATE_AH_FLOW_LABEL_MASK  UINT32_C(0xfffff)
	#define CMDQ_CREATE_AH_FLOW_LABEL_SFT   0
	/* Destination VLAN ID. */
	#define CMDQ_CREATE_AH_DEST_VLAN_ID_MASK UINT32_C(0xfff00000)
	#define CMDQ_CREATE_AH_DEST_VLAN_ID_SFT 20
	/* Protection domain id. */
	uint32_t	pd_id;
	uint32_t	unused_0;
	/* Destination MAC address. */
	uint16_t	dest_mac[3];
	/* Traffic class. */
	uint8_t	traffic_class;
	uint8_t	enable_cc;
	/* Enable congestion control. */
	#define CMDQ_CREATE_AH_ENABLE_CC	UINT32_C(0x1)
} cmdq_create_ah_t, *pcmdq_create_ah_t;

/* creq_create_ah_resp (size:128b/16B) */

typedef struct creq_create_ah_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_AH_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_AH_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_AH_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_AH_RESP_TYPE_LAST	CREQ_CREATE_AH_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* AH context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_AH_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create AH command response. */
	#define CREQ_CREATE_AH_RESP_EVENT_CREATE_AH UINT32_C(0x15)
	#define CREQ_CREATE_AH_RESP_EVENT_LAST	CREQ_CREATE_AH_RESP_EVENT_CREATE_AH
	uint8_t	reserved48[6];
} creq_create_ah_resp_t, *pcreq_create_ah_resp_t;

/**************
 * destroy_ah *
 **************/


/* cmdq_destroy_ah (size:192b/24B) */

typedef struct cmdq_destroy_ah {
	/* Command opcode. */
	uint8_t	opcode;
	/* Destroy AH command deletes the specified AH. */
	#define CMDQ_DESTROY_AH_OPCODE_DESTROY_AH UINT32_C(0x16)
	#define CMDQ_DESTROY_AH_OPCODE_LAST	CMDQ_DESTROY_AH_OPCODE_DESTROY_AH
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* AH context id */
	uint32_t	ah_cid;
	uint32_t	unused_0;
} cmdq_destroy_ah_t, *pcmdq_destroy_ah_t;

/* creq_destroy_ah_resp (size:128b/16B) */

typedef struct creq_destroy_ah_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_AH_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_AH_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_AH_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_AH_RESP_TYPE_LAST	CREQ_DESTROY_AH_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* AH context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_AH_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy AH command response. */
	#define CREQ_DESTROY_AH_RESP_EVENT_DESTROY_AH UINT32_C(0x16)
	#define CREQ_DESTROY_AH_RESP_EVENT_LAST	CREQ_DESTROY_AH_RESP_EVENT_DESTROY_AH
	uint8_t	reserved48[6];
} creq_destroy_ah_resp_t, *pcreq_destroy_ah_resp_t;

/********************
 * query_roce_stats *
 ********************/


/* cmdq_query_roce_stats (size:192b/24B) */

typedef struct cmdq_query_roce_stats {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query RoCE statistics. */
	#define CMDQ_QUERY_ROCE_STATS_OPCODE_QUERY_ROCE_STATS UINT32_C(0x8e)
	#define CMDQ_QUERY_ROCE_STATS_OPCODE_LAST		CMDQ_QUERY_ROCE_STATS_OPCODE_QUERY_ROCE_STATS
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When this bit is set FW will use the collection_id to extract
	 * RoCE statistics. If function_id is also specified the FW will
	 * return stats corresponding to the collection for the function_id
	 * specified.
	 */
	#define CMDQ_QUERY_ROCE_STATS_FLAGS_COLLECTION_ID	UINT32_C(0x1)
	/*
	 * When this bit is set FW will use the function_id to extract RoCE
	 * statistics. When collection is specified then FW will return the
	 * specific collection stats and if the collection is not specified
	 * then FW will return the default stats which will be for all QPs.
	 */
	#define CMDQ_QUERY_ROCE_STATS_FLAGS_FUNCTION_ID	UINT32_C(0x2)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	/* The specific statistics group being queried. */
	uint8_t	collection_id;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Unique identifier for a function */
	uint32_t	function_id;
	/* PF number */
	#define CMDQ_QUERY_ROCE_STATS_PF_NUM_MASK  UINT32_C(0xff)
	#define CMDQ_QUERY_ROCE_STATS_PF_NUM_SFT   0
	/* VF number */
	#define CMDQ_QUERY_ROCE_STATS_VF_NUM_MASK  UINT32_C(0xffff00)
	#define CMDQ_QUERY_ROCE_STATS_VF_NUM_SFT   8
	/* When set the vf_num is valid. */
	#define CMDQ_QUERY_ROCE_STATS_VF_VALID	UINT32_C(0x1000000)
	uint32_t	reserved32;
} cmdq_query_roce_stats_t, *pcmdq_query_roce_stats_t;

/* creq_query_roce_stats_resp (size:128b/16B) */

typedef struct creq_query_roce_stats_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_ROCE_STATS_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_STATS_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_ROCE_STATS_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_ROCE_STATS_RESP_TYPE_LAST	CREQ_QUERY_ROCE_STATS_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_ROCE_STATS_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query RoCE statistics. */
	#define CREQ_QUERY_ROCE_STATS_RESP_EVENT_QUERY_ROCE_STATS UINT32_C(0x8e)
	#define CREQ_QUERY_ROCE_STATS_RESP_EVENT_LAST		CREQ_QUERY_ROCE_STATS_RESP_EVENT_QUERY_ROCE_STATS
	uint8_t	reserved48[6];
} creq_query_roce_stats_resp_t, *pcreq_query_roce_stats_resp_t;

/* Query RoCE Stats command response side buffer structure. */
/* creq_query_roce_stats_resp_sb (size:3072b/384B) */

typedef struct creq_query_roce_stats_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query RoCE statistics. */
	#define CREQ_QUERY_ROCE_STATS_RESP_SB_OPCODE_QUERY_ROCE_STATS UINT32_C(0x8e)
	#define CREQ_QUERY_ROCE_STATS_RESP_SB_OPCODE_LAST		CREQ_QUERY_ROCE_STATS_RESP_SB_OPCODE_QUERY_ROCE_STATS
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	rsvd;
	uint32_t	num_counters;
	uint32_t	rsvd1;
	uint64_t	to_retransmits;
	/* seq_err_naks_rcvd is 64 b */
	uint64_t	seq_err_naks_rcvd;
	/* max_retry_exceeded is 64 b */
	uint64_t	max_retry_exceeded;
	/* rnr_naks_rcvd is 64 b */
	uint64_t	rnr_naks_rcvd;
	uint64_t	missing_resp;
	/* unrecoverable_err is 64 b */
	uint64_t	unrecoverable_err;
	/* bad_resp_err is 64 b */
	uint64_t	bad_resp_err;
	/* local_qp_op_err is 64 b */
	uint64_t	local_qp_op_err;
	/* local_protection_err is 64 b */
	uint64_t	local_protection_err;
	/* mem_mgmt_op_err is 64 b */
	uint64_t	mem_mgmt_op_err;
	/* remote_invalid_req_err is 64 b */
	uint64_t	remote_invalid_req_err;
	/* remote_access_err is 64 b */
	uint64_t	remote_access_err;
	/* remote_op_err is 64 b */
	uint64_t	remote_op_err;
	/* dup_req is 64 b */
	uint64_t	dup_req;
	/* res_exceed_max is 64 b */
	uint64_t	res_exceed_max;
	/* res_length_mismatch is 64 b */
	uint64_t	res_length_mismatch;
	/* res_exceeds_wqe is 64 b */
	uint64_t	res_exceeds_wqe;
	/* res_opcode_err is 64 b */
	uint64_t	res_opcode_err;
	/* res_rx_invalid_rkey is 64 b */
	uint64_t	res_rx_invalid_rkey;
	/* res_rx_domain_err is 64 b */
	uint64_t	res_rx_domain_err;
	/* res_rx_no_perm is 64 b */
	uint64_t	res_rx_no_perm;
	/* res_rx_range_err is 64 b */
	uint64_t	res_rx_range_err;
	/* res_tx_invalid_rkey is 64 b */
	uint64_t	res_tx_invalid_rkey;
	/* res_tx_domain_err is 64 b */
	uint64_t	res_tx_domain_err;
	/* res_tx_no_perm is 64 b */
	uint64_t	res_tx_no_perm;
	/* res_tx_range_err is 64 b */
	uint64_t	res_tx_range_err;
	/* res_irrq_oflow is 64 b */
	uint64_t	res_irrq_oflow;
	/* res_unsup_opcode is 64 b */
	uint64_t	res_unsup_opcode;
	/* res_unaligned_atomic is 64 b */
	uint64_t	res_unaligned_atomic;
	/* res_rem_inv_err is 64 b */
	uint64_t	res_rem_inv_err;
	/* res_mem_error is 64 b */
	uint64_t	res_mem_error;
	/* res_srq_err is 64 b */
	uint64_t	res_srq_err;
	/* res_cmp_err is 64 b */
	uint64_t	res_cmp_err;
	/* res_invalid_dup_rkey is 64 b */
	uint64_t	res_invalid_dup_rkey;
	/* res_wqe_format_err is 64 b */
	uint64_t	res_wqe_format_err;
	/* res_cq_load_err is 64 b */
	uint64_t	res_cq_load_err;
	/* res_srq_load_err is 64 b */
	uint64_t	res_srq_load_err;
	/* res_tx_pci_err is 64 b */
	uint64_t	res_tx_pci_err;
	/* res_rx_pci_err is 64 b */
	uint64_t	res_rx_pci_err;
	/* res_oos_drop_count is 64 b */
	uint64_t	res_oos_drop_count;
	/* active_qp_count_p0 is 64 b */
	uint64_t	active_qp_count_p0;
	/* active_qp_count_p1 is 64 b */
	uint64_t	active_qp_count_p1;
	/* active_qp_count_p2 is 64 b */
	uint64_t	active_qp_count_p2;
	/* active_qp_count_p3 is 64 b */
	uint64_t	active_qp_count_p3;
	/* express mode SQ doorbell overflow error 64b counter. */
	uint64_t	xp_sq_overflow_err;
	/* express mode RQ doorbell overflow error 64b counter. */
	uint64_t	xp_rq_overflow_error;
} creq_query_roce_stats_resp_sb_t, *pcreq_query_roce_stats_resp_sb_t;

/************************
 * query_roce_stats_ext *
 ************************/


/* cmdq_query_roce_stats_ext (size:192b/24B) */

typedef struct cmdq_query_roce_stats_ext {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query extended RoCE statistics. */
	#define CMDQ_QUERY_ROCE_STATS_EXT_OPCODE_QUERY_ROCE_STATS UINT32_C(0x92)
	#define CMDQ_QUERY_ROCE_STATS_EXT_OPCODE_LAST		CMDQ_QUERY_ROCE_STATS_EXT_OPCODE_QUERY_ROCE_STATS
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When this bit is set FW will use the collection_id to extract
	 * RoCE statistics. If function_id is also specified the FW will
	 * return stats corresponding to the collection for the function_id
	 * specified.
	 */
	#define CMDQ_QUERY_ROCE_STATS_EXT_FLAGS_COLLECTION_ID	UINT32_C(0x1)
	/*
	 * When this bit is set FW will use the function_id to extract RoCE
	 * statistics. When collection is specified then FW will return the
	 * specific collection stats and if the collection is not specified
	 * then FW will return the default stats which will be for all QPs.
	 */
	#define CMDQ_QUERY_ROCE_STATS_EXT_FLAGS_FUNCTION_ID	UINT32_C(0x2)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	/* The specific statistics group being queried. */
	uint8_t	collection_id;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Unique identifier for a function */
	uint32_t	function_id;
	/* PF number */
	#define CMDQ_QUERY_ROCE_STATS_EXT_PF_NUM_MASK  UINT32_C(0xff)
	#define CMDQ_QUERY_ROCE_STATS_EXT_PF_NUM_SFT   0
	/* VF number */
	#define CMDQ_QUERY_ROCE_STATS_EXT_VF_NUM_MASK  UINT32_C(0xffff00)
	#define CMDQ_QUERY_ROCE_STATS_EXT_VF_NUM_SFT   8
	/* When set the vf_num is valid. */
	#define CMDQ_QUERY_ROCE_STATS_EXT_VF_VALID	UINT32_C(0x1000000)
	uint32_t	reserved32;
} cmdq_query_roce_stats_ext_t, *pcmdq_query_roce_stats_ext_t;

/* creq_query_roce_stats_ext_resp (size:128b/16B) */

typedef struct creq_query_roce_stats_ext_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_LAST	CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query extended RoCE statistics. */
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_EVENT_QUERY_ROCE_STATS_EXT UINT32_C(0x92)
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_EVENT_LAST		CREQ_QUERY_ROCE_STATS_EXT_RESP_EVENT_QUERY_ROCE_STATS_EXT
	uint8_t	reserved48[6];
} creq_query_roce_stats_ext_resp_t, *pcreq_query_roce_stats_ext_resp_t;

/* Query extended RoCE Stats command response side buffer structure. */
/* creq_query_roce_stats_ext_resp_sb (size:2304b/288B) */

typedef struct creq_query_roce_stats_ext_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query extended RoCE statistics. */
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_SB_OPCODE_QUERY_ROCE_STATS_EXT UINT32_C(0x92)
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_SB_OPCODE_LAST		CREQ_QUERY_ROCE_STATS_EXT_RESP_SB_OPCODE_QUERY_ROCE_STATS_EXT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	rsvd;
	/* Number of transmitted Atomic request packets. */
	uint64_t	tx_atomic_req_pkts;
	/* Number of transmitted Read request packets. */
	uint64_t	tx_read_req_pkts;
	/* Number of transmitted Read response packets. */
	uint64_t	tx_read_res_pkts;
	/* Number of transmitted Write request packets. */
	uint64_t	tx_write_req_pkts;
	/*
	 * Number of transmitted Send request packets.
	 * This is for RC QPs only.
	 */
	uint64_t	tx_send_req_pkts;
	/*
	 * Number of transmitted RoCE packets.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	tx_roce_pkts;
	/*
	 * Number of transmitted RoCE header and payload bytes.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	tx_roce_bytes;
	/* Number of received Atomic request packets. */
	uint64_t	rx_atomic_req_pkts;
	/* Number of received Read request packets. */
	uint64_t	rx_read_req_pkts;
	/* Number of received Read response packets. */
	uint64_t	rx_read_res_pkts;
	/* Number of received Write request packets. */
	uint64_t	rx_write_req_pkts;
	/*
	 * Number of received Send request packets.
	 * This is for RC QPs only.
	 */
	uint64_t	rx_send_req_pkts;
	/*
	 * Number of received RoCE packets including RoCE packets with errors.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	rx_roce_pkts;
	/*
	 * Number of received RoCE header and payload bytes including RoCE
	 * packets with errors.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	rx_roce_bytes;
	/*
	 * Number of received RoCE packets.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	rx_roce_good_pkts;
	/*
	 * Number of received RoCE header and payload bytes.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	rx_roce_good_bytes;
	/*
	 * Number of drops that occurred to lack of buffers.
	 * This is for RC QPs only.
	 */
	uint64_t	rx_out_of_buffer_pkts;
	/* Number of packets that were received out of sequence. */
	uint64_t	rx_out_of_sequence_pkts;
	/* Number of transmitted CNP packets. The counter is per port. */
	uint64_t	tx_cnp_pkts;
	/* Number of received CNP packets. The counter is per port. */
	uint64_t	rx_cnp_pkts;
	/* Number of received ECN-marked RoCE packets. The counter is per port. */
	uint64_t	rx_ecn_marked_pkts;
	/* Number of transmitted CNP bytes. */
	uint64_t	tx_cnp_bytes;
	/* Number of received CNP bytes. */
	uint64_t	rx_cnp_bytes;
	/*
	 * Number of sequence error NAKs received.
	 * This counter is only applicable for devices that support
	 * hardware based retransmission.
	 */
	uint64_t	seq_err_naks_rcvd;
	/*
	 * Number of RNR NAKs received.
	 * This counter is only applicable for devices that support
	 * hardware based retransmission.
	 */
	uint64_t	rnr_naks_rcvd;
	/*
	 * Number of missing response resulting in HW retransmission.
	 * This counter is only applicable for devices that support
	 * hardware based retransmission.
	 */
	uint64_t	missing_resp;
	/*
	 * Number of timeouts resulting in HW retransmission.
	 * This counter is only applicable for devices that support
	 * hardware based retransmission.
	 */
	uint64_t	to_retransmit;
	/*
	 * Number of duplicate read/atomic requests resulting in HW
	 * retransmission.
	 * This counter is only applicable for devices that support
	 * hardware based retransmission.
	 */
	uint64_t	dup_req;
	/*
	 * Number of received DCN payload cut packets.
	 * This counter is only applicable for devices that support
	 * the DCN Payload Cut feature.
	 */
	uint64_t	rx_dcn_payload_cut;
	/* Number of transmitted packets that bypassed the transmit engine. */
	uint64_t	te_bypassed;
	/*
	 * Number of transmitted DCN CNP packets.
	 * This counter is only applicable for devices that support
	 * the DCN Payload Cut feature.
	 */
	uint64_t	tx_dcn_cnp;
	/*
	 * Number of received DCN CNP packets.
	 * This counter is only applicable for devices that support
	 * the DCN Payload Cut feature.
	 */
	uint64_t	rx_dcn_cnp;
	/*
	 * Number of received DCN payload cut packets.
	 * This counter is only applicable for devices that support
	 * the DCN Payload Cut feature.
	 */
	uint64_t	rx_payload_cut;
	/*
	 * Number of received DCN payload cut packets that are ignored
	 * because they failed the PSN checks.
	 * This counter is only applicable for devices that support
	 * the DCN Payload Cut feature.
	 */
	uint64_t	rx_payload_cut_ignored;
	/*
	 * Number of received DCN CNP packets that are ignored either
	 * because the ECN is not enabled on the QP or the ECN is enabled
	 * but the CNP packets do not pass the packet validation checks.
	 * This counter is only applicable for devices that support
	 * the DCN Payload Cut feature.
	 */
	uint64_t	rx_dcn_cnp_ignored;
} creq_query_roce_stats_ext_resp_sb_t, *pcreq_query_roce_stats_ext_resp_sb_t;

/**************
 * query_func *
 **************/


/* cmdq_query_func (size:128b/16B) */

typedef struct cmdq_query_func {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query the HW capabilities for the function. */
	#define CMDQ_QUERY_FUNC_OPCODE_QUERY_FUNC UINT32_C(0x83)
	#define CMDQ_QUERY_FUNC_OPCODE_LAST	CMDQ_QUERY_FUNC_OPCODE_QUERY_FUNC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_query_func_t, *pcmdq_query_func_t;

/* creq_query_func_resp (size:128b/16B) */

typedef struct creq_query_func_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_FUNC_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_FUNC_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_FUNC_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_FUNC_RESP_TYPE_LAST	CREQ_QUERY_FUNC_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_FUNC_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query info PF command response. */
	#define CREQ_QUERY_FUNC_RESP_EVENT_QUERY_FUNC UINT32_C(0x83)
	#define CREQ_QUERY_FUNC_RESP_EVENT_LAST	CREQ_QUERY_FUNC_RESP_EVENT_QUERY_FUNC
	uint8_t	reserved48[6];
} creq_query_func_resp_t, *pcreq_query_func_resp_t;

/* Query function command response side buffer structure. */
/* creq_query_func_resp_sb (size:1280b/160B) */

typedef struct creq_query_func_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query info PF command response. */
	#define CREQ_QUERY_FUNC_RESP_SB_OPCODE_QUERY_FUNC UINT32_C(0x83)
	#define CREQ_QUERY_FUNC_RESP_SB_OPCODE_LAST	CREQ_QUERY_FUNC_RESP_SB_OPCODE_QUERY_FUNC
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Max MR size supported. */
	uint64_t	max_mr_size;
	/*
	 * Max QP supported.
	 * For devices that support the pseudo static allocation scheme,
	 * this count:
	 * -excludes the QP1 count.
	 * -includes the count of QPs that can be migrated from the other PF
	 *  Therefore, during normal operation when both PFs are active,
	 *  the supported number of RoCE QPs for each of the PF is half
	 *  of the advertised value.
	 */
	uint32_t	max_qp;
	/* Max WQEs per QP. */
	uint16_t	max_qp_wr;
	/* Device capability flags. */
	uint16_t	dev_cap_flags;
	/* Allow QP resizing. */
	#define CREQ_QUERY_FUNC_RESP_SB_RESIZE_QP				UINT32_C(0x1)
	/* Specifies Congestion Control (CC) generation. */
	#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_MASK		UINT32_C(0xe)
	#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_SFT			1
	/*
	 * Includes support for DCTCP and TCP CC algorithms,
	 * enabling operation in networks where PFC is enabled.
	 */
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN0		(UINT32_C(0x0) << 1)
	/*
	 * Enhances cc_gen0 support with probabilistic marking algorithm,
	 * enabling fast ramp up and convergence,
	 * as well as operation in networks where PFC is not enabled.
	 * Includes a number of parameters that are different from cc_gen0
	 * chips as well as new parameters. TCP CC algorithm is not
	 * supported.
	 */
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN1		(UINT32_C(0x1) << 1)
	/*
	 * Enhances cc_gen1 support for additional CC parameters:
	 * reduce_init_en, reduce_init_cong_free_rtts_th, random_no_red_en,
	 * actual_cr_shift_correction_en, quota_period_adjust_en
	 */
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN1_EXT		(UINT32_C(0x2) << 1)
	/*
	 * Enhances cc_gen1_ext support, to include support for DCN/SARA.
	 * Enables query and modification of Queue level table attributes,
	 * which are used by the hardware to determine the QP's flow rate
	 * based on congestion level and thereby reduce RoCE packet drop
	 * due to network congestion.
	 */
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN2		(UINT32_C(0x3) << 1)
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_LAST			CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN2
	/*
	 * Support for the extended RoCE statistics is available. These
	 * statistics are queried via the `query_roce_stats_ext` command
	 * and are enabled on a per-QP basis via `create_qp`.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_EXT_STATS				UINT32_C(0x10)
	/*
	 * Support for both allocating and registering a new MR via the
	 * `register_mr` command is available. With this feature the
	 * `allocate_mrw` command does not have to be called before
	 * registering.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_MR_REGISTER_ALLOC			UINT32_C(0x20)
	/*
	 * Support for optimized transmit path to lower latency for WQEs
	 * with inline data.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_OPTIMIZED_TRANSMIT_ENABLED	UINT32_C(0x40)
	/*
	 * The underlying HW uses the version 2 of the CQEs definitions for
	 * the following CQE types:
	 * RES_UD, RES_RAWETH_QP1, RES_UD_CFA
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_CQE_V2				UINT32_C(0x80)
	/* Support for ping pong push mode is available. */
	#define CREQ_QUERY_FUNC_RESP_SB_PINGPONG_PUSH_MODE		UINT32_C(0x100)
	/* Support for hardware requester retransmission is enabled. */
	#define CREQ_QUERY_FUNC_RESP_SB_HW_REQUESTER_RETX_ENABLED		UINT32_C(0x200)
	/* Support for hardware responder retransmission is enabled. */
	#define CREQ_QUERY_FUNC_RESP_SB_HW_RESPONDER_RETX_ENABLED		UINT32_C(0x400)
	/* Support for link aggregation is enabled. */
	#define CREQ_QUERY_FUNC_RESP_SB_LINK_AGGR_SUPPORTED		UINT32_C(0x800)
	/* link_aggr_supported is valid. */
	#define CREQ_QUERY_FUNC_RESP_SB_LINK_AGGR_SUPPORTED_VALID		UINT32_C(0x1000)
	/*
	 * Support for pseudo static QP allocation is enabled.
	 * This feature enables the following capabilities:
	 * - QP context ID space is pseudo-static partitioned across PFs.
	 * - An application can use a predetermined
	 *   QP context ID assignment scheme for specific operations.
	 * - For 2-port adapters, the application can migrate the QP context
	 *   ID range across PFs, using the `orchestrate_qid_migration` HWRM,
	 *   during network events such as Link Down.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_PSEUDO_STATIC_QP_ALLOC_SUPPORTED	UINT32_C(0x2000)
	/*
	 * Support for Express Mode is enabled.
	 * For Express mode, the QP resources (SQ/RQ) are allocated in
	 * on-chip queue memory. The host driver should not allocate memory
	 * for these queue structures.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_EXPRESS_MODE_SUPPORTED		UINT32_C(0x4000)
	/*
	 * IRRQ/ORRQ and MSN Table structures are allocated in internal
	 * queue memory.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_INTERNAL_QUEUE_MEMORY		UINT32_C(0x8000)
	/* Max CQs supported. */
	uint32_t	max_cq;
	/* Max CQEs per CQ supported. */
	uint32_t	max_cqe;
	/* Max PDs supported. */
	uint32_t	max_pd;
	/*
	 * Max SGEs per QP WQE supported. On chips with variable-size WQE
	 * support, this field is applicable only for the backward compatible
	 * mode.
	 */
	uint8_t	max_sge;
	/* Max SGEs per SRQ WQE supported. */
	uint8_t	max_srq_sge;
	/* Max outstanding RDMA read & atomic supported. */
	uint8_t	max_qp_rd_atom;
	/*
	 * Max outstanding RDMA read & atomic that can be sent from an
	 * initiator.
	 */
	uint8_t	max_qp_init_rd_atom;
	/* Max MRs supported. */
	uint32_t	max_mr;
	/* Max MWs supported. */
	uint32_t	max_mw;
	/* Max Raw Ethertype QPs supported. */
	uint32_t	max_raw_eth_qp;
	/* Max AHs supported. */
	uint32_t	max_ah;
	/* Max FMRs supported. */
	uint32_t	max_fmr;
	/* Max WQEs per SRQ supported. */
	uint32_t	max_srq_wr;
	/* Max PKEYs supported. */
	uint32_t	max_pkeys;
	/*
	 * Max inline data supported. On chips with variable-size WQE support,
	 * this field is applicable only for the backward compatible mode.
	 */
	uint32_t	max_inline_data;
	/* Max mappings per FMR supported. */
	uint8_t	max_map_per_fmr;
	/* L2 DB space size in pages. */
	uint8_t	l2_db_space_size;
	/* Max SRQs supported. */
	uint16_t	max_srq;
	/* Max GIDs supported. */
	uint32_t	max_gid;
	/*
	 * An array of 48 8-bit values to specify allocation multiplier for TQM
	 * host buffer regions. Each region occupies 16 MB of TQM PBL address
	 * space: 0x00000000, 0x01000000, 0x02000000, etc.
	 * The host needs to allocate (<Number of QPs>*multiplier, rounded up
	 * to page size) of physical memory for non-zero slots and map the
	 * pages to the corresponding 16MB regions. Typically there are total
	 * 3 non-zero values in this array, their values are 16, 16, 12.
	 * Cu+ will only populate up to index 11. SR may populate up to
	 * index 47.
	 */
	uint32_t	tqm_alloc_reqs[12];
	/* Max Doorbell page indices supported. */
	uint32_t	max_dpi;
	/* Max SGEs per QP WQE supported in the variable-size WQE mode. */
	uint8_t	max_sge_var_wqe;
	/* Device capability extended flags. */
	uint8_t	dev_cap_ext_flags;
	/* RDMA Atomic operations are not supported. */
	#define CREQ_QUERY_FUNC_RESP_SB_ATOMIC_OPS_NOT_SUPPORTED	UINT32_C(0x1)
	/* Support driver version registration. */
	#define CREQ_QUERY_FUNC_RESP_SB_DRV_VERSION_RGTR_SUPPORTED	UINT32_C(0x2)
	/* Support for batch allocation of QPs is enabled. */
	#define CREQ_QUERY_FUNC_RESP_SB_CREATE_QP_BATCH_SUPPORTED	UINT32_C(0x4)
	/* Support for batch deletion of QPs is enabled. */
	#define CREQ_QUERY_FUNC_RESP_SB_DESTROY_QP_BATCH_SUPPORTED	UINT32_C(0x8)
	/*
	 * Support for extended RoCE statistics context
	 * with periodic DMA is enabled. The statistics contexts
	 * are allocated via `allocate_roce_stats_ext_ctx`
	 * and deallocated via `deallocate_roce_stats_ext_ctx`.
	 * These contexts are assigned on a per-QP, per-group of QPs
	 * or per-function basis via `create_qp`, `create_qp_batch`
	 * or `modify_qp`command.
	 * In addition to periodic DMA to a host address,
	 * these statistics can be queried via `query_roce_stats_ext_v2`.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_ROCE_STATS_EXT_CTX_SUPPORTED	UINT32_C(0x10)
	/*
	 * Support for the srq_sge field in the create_srq command is
	 * enabled.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_CREATE_SRQ_SGE_SUPPORTED	UINT32_C(0x20)
	/* Support for fixed size SQ wqe (128B) is disabled. */
	#define CREQ_QUERY_FUNC_RESP_SB_FIXED_SIZE_WQE_DISABLED	UINT32_C(0x40)
	/* Support for DCN (Drop Congestion Notification) is enabled. */
	#define CREQ_QUERY_FUNC_RESP_SB_DCN_SUPPORTED			UINT32_C(0x80)
	/* Max inline data supported in the variable-size WQE mode. */
	uint16_t	max_inline_data_var_wqe;
	/*
	 * starting xid of the predetermined assignment scheme supported
	 * by the pseudo static allocation feature. Note that for a PF,
	 * the start_qid is itself pseudo_static, and can change when the QP
	 * context id range is migrated by the driver using the
	 * cmdq_orchestrate_qid_migration. The supported QP count is
	 * available in the `max_qp` field of `cmdq_query_func`.
	 */
	uint32_t	start_qid;
	/*
	 * Max number of MSN table entries supported for devices that support
	 * the `internal_queue_memory` feature.
	 */
	uint8_t	max_msn_table_size;
	/* reserved8_1 is 8 b */
	uint8_t	reserved8_1;
	/* Device capability extended flags_2 */
	uint16_t	dev_cap_ext_flags_2;
	/* Firmware support for optimizing Modify QP operation */
	#define CREQ_QUERY_FUNC_RESP_SB_OPTIMIZE_MODIFY_QP_SUPPORTED		UINT32_C(0x1)
	/*
	 * Device supports changing UDP source port of RoCEv2 packets using
	 * WQE.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_CHANGE_UDP_SRC_PORT_WQE_SUPPORTED	UINT32_C(0x2)
	/* Device supports CQ Coalescing. */
	#define CREQ_QUERY_FUNC_RESP_SB_CQ_COALESCING_SUPPORTED		UINT32_C(0x4)
	/*
	 * Device allows a memory region to be designated as
	 * relaxed-ordering enabled or disabled.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_MEMORY_REGION_RO_SUPPORTED		UINT32_C(0x8)
	/* The type of lookup table used for requester retransmission. */
	#define CREQ_QUERY_FUNC_RESP_SB_REQ_RETRANSMISSION_SUPPORT_MASK	UINT32_C(0x30)
	#define CREQ_QUERY_FUNC_RESP_SB_REQ_RETRANSMISSION_SUPPORT_SFT	4
	/* Requester Retransmission uses a PSN table in host memory. */
		#define CREQ_QUERY_FUNC_RESP_SB_REQ_RETRANSMISSION_SUPPORT_HOST_PSN_TABLE  (UINT32_C(0x0) << 4)
	/* Requester Retransmission uses an MSN table in host memory. */
		#define CREQ_QUERY_FUNC_RESP_SB_REQ_RETRANSMISSION_SUPPORT_HOST_MSN_TABLE  (UINT32_C(0x1) << 4)
	/*
	 * Requester Retransmission uses an MSN table in Device Internal
	 * Queue Memory.
	 */
		#define CREQ_QUERY_FUNC_RESP_SB_REQ_RETRANSMISSION_SUPPORT_IQM_MSN_TABLE   (UINT32_C(0x2) << 4)
		#define CREQ_QUERY_FUNC_RESP_SB_REQ_RETRANSMISSION_SUPPORT_LAST	CREQ_QUERY_FUNC_RESP_SB_REQ_RETRANSMISSION_SUPPORT_IQM_MSN_TABLE
	/*
	 * Max number of 16B IQM memory slots supported by SQ or RQ
	 * when QP is in express mode.
	 * This field is only valid for express mode QPs.
	 */
	uint16_t	max_xp_qp_size;
	/*
	 * Max number of QPs that can be created in one `create_qp_batch`
	 * command.
	 */
	uint16_t	create_qp_batch_size;
	/*
	 * Max number of QPs that can be destroyed in one `destroy_qp_batch`
	 * command.
	 */
	uint16_t	destroy_qp_batch_size;
	uint16_t	reserved16;
	uint64_t	reserved64;
} creq_query_func_resp_sb_t, *pcreq_query_func_resp_sb_t;

/**********************
 * set_func_resources *
 **********************/


/* cmdq_set_func_resources (size:448b/56B) */

typedef struct cmdq_set_func_resources {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Set the following resources for the function:
	 * - Max QP, CQ, MR+MW, SRQ per PF
	 * - Max QP, CQ, MR+MW, SRQ per VF
	 */
	#define CMDQ_SET_FUNC_RESOURCES_OPCODE_SET_FUNC_RESOURCES UINT32_C(0x84)
	#define CMDQ_SET_FUNC_RESOURCES_OPCODE_LAST		CMDQ_SET_FUNC_RESOURCES_OPCODE_SET_FUNC_RESOURCES
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When set, the 32b `max_mrw_per_vf` field is logically divided
	 * into two 16b fields, `max_mr_per_vf` and `max_av_per_vf`.
	 */
	#define CMDQ_SET_FUNC_RESOURCES_FLAGS_MRAV_RESERVATION_SPLIT	UINT32_C(0x1)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/*
	 * Number of QPs. It is the responsibility of the host to first extend
	 * the existing PBL with new addresses to pages to handle the
	 * adjustment. Must be greater or equal to current.
	 */
	uint32_t	number_of_qp;
	/*
	 * Number of MRWs. It is the responsibility of the host to first extend
	 * the existing PBL with new addresses to pages to handle the
	 * adjustment. Must be greater or equal to current.
	 */
	uint32_t	number_of_mrw;
	/*
	 * Number of SRQs. It is the responsibility of the host to first extend
	 * the existing PBL with new addresses to pages to handle the
	 * adjustment. Must be greater or equal to current.
	 */
	uint32_t	number_of_srq;
	/*
	 * Number of CQs. It is the responsibility of the host to first extend
	 * the existing PBL with new addresses to pages to handle the
	 * adjustment. Must be greater or equal to current.
	 */
	uint32_t	number_of_cq;
	/*
	 * Number of QPs per VF. This field must be set to zero when the flag,
	 * l2_vf_resource_mgmt, is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_qp_per_vf;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries allowed per
	 * VF. For versions of firmware that support the split reservation,
	 * when it is not specified half of the entries will be reserved
	 * for MRs and the other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `max_mr_per_vf` and bits `[15:0]` represents
	 * `max_av_per_vf`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 *
	 * This field must be set to zero when the flag, l2_vf_resource_mgmt,
	 * is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_mrw_per_vf;
	/*
	 * Number of SRQs per VF. This field must be set to zero when the flag,
	 * l2_vf_resource_mgmt, is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_srq_per_vf;
	/*
	 * Number of CQs per VF. This field must be set to zero when the flag,
	 * l2_vf_resource_mgmt, is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_cq_per_vf;
	/*
	 * Number of GIDs per VF. This field must be set to zero when the flag,
	 * l2_vf_resource_mgmt, is set and RoCE SRIOV is enabled.
	 */
	uint32_t	max_gid_per_vf;
	/* Statistics context index for this function. */
	uint32_t	stat_ctx_id;
} cmdq_set_func_resources_t, *pcmdq_set_func_resources_t;

/* creq_set_func_resources_resp (size:128b/16B) */

typedef struct creq_set_func_resources_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_SET_FUNC_RESOURCES_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_SET_FUNC_RESOURCES_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_SET_FUNC_RESOURCES_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_SET_FUNC_RESOURCES_RESP_TYPE_LAST	CREQ_SET_FUNC_RESOURCES_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_SET_FUNC_RESOURCES_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Set function resources command response. */
	#define CREQ_SET_FUNC_RESOURCES_RESP_EVENT_SET_FUNC_RESOURCES UINT32_C(0x84)
	#define CREQ_SET_FUNC_RESOURCES_RESP_EVENT_LAST		CREQ_SET_FUNC_RESOURCES_RESP_EVENT_SET_FUNC_RESOURCES
	uint8_t	reserved48[6];
} creq_set_func_resources_resp_t, *pcreq_set_func_resources_resp_t;

/*************
 * stop_func *
 *************/


/* cmdq_stop_func (size:128b/16B) */

typedef struct cmdq_stop_func {
	/* Command opcode. */
	uint8_t	opcode;
	/* Stop the function */
	#define CMDQ_STOP_FUNC_OPCODE_STOP_FUNC UINT32_C(0x82)
	#define CMDQ_STOP_FUNC_OPCODE_LAST	CMDQ_STOP_FUNC_OPCODE_STOP_FUNC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_stop_func_t, *pcmdq_stop_func_t;

/* creq_stop_func_resp (size:128b/16B) */

typedef struct creq_stop_func_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_STOP_FUNC_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_STOP_FUNC_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_STOP_FUNC_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_STOP_FUNC_RESP_TYPE_LAST	CREQ_STOP_FUNC_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_STOP_FUNC_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Stop PF command response. */
	#define CREQ_STOP_FUNC_RESP_EVENT_STOP_FUNC UINT32_C(0x82)
	#define CREQ_STOP_FUNC_RESP_EVENT_LAST	CREQ_STOP_FUNC_RESP_EVENT_STOP_FUNC
	uint8_t	reserved48[6];
} creq_stop_func_resp_t, *pcreq_stop_func_resp_t;

/****************
 * read_context *
 ****************/


/* cmdq_read_context (size:192b/24B) */

typedef struct cmdq_read_context {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Read the current state of any internal resource context. Can only
	 * be issued from a PF.
	 */
	#define CMDQ_READ_CONTEXT_OPCODE_READ_CONTEXT UINT32_C(0x85)
	#define CMDQ_READ_CONTEXT_OPCODE_LAST	CMDQ_READ_CONTEXT_OPCODE_READ_CONTEXT
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Context ID */
	uint32_t	xid;
	/* Context type */
	uint8_t	type;
	/*
	 * Read QPC. The context (448 bytes) goes to resp_addr (as is,
	 * without a header), and resp_size should be set to 28
	 * (448/16).
	 */
	#define CMDQ_READ_CONTEXT_TYPE_QPC UINT32_C(0x0)
	/*
	 * Read CQ. The context (64 bytes) goes to resp_addr (as is,
	 * without a header), and resp_size should be set to 4 (64/16)
	 */
	#define CMDQ_READ_CONTEXT_TYPE_CQ  UINT32_C(0x1)
	/*
	 * Read MRW. The context (128 bytes) goes to resp_addr (as is,
	 * without a header), and resp_size should be set to 8 (128/16)
	 */
	#define CMDQ_READ_CONTEXT_TYPE_MRW UINT32_C(0x2)
	/*
	 * Read SRQ. The context (64 bytes) goes to resp_addr (as is,
	 * without a header), and resp_size should be set to 4 (64/16)
	 */
	#define CMDQ_READ_CONTEXT_TYPE_SRQ UINT32_C(0x3)
	#define CMDQ_READ_CONTEXT_TYPE_LAST CMDQ_READ_CONTEXT_TYPE_SRQ
	uint8_t	unused_0[3];
} cmdq_read_context_t, *pcmdq_read_context_t;

/* creq_read_context (size:128b/16B) */

typedef struct creq_read_context {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B records.
	 * records.
	 */
	#define CREQ_READ_CONTEXT_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_READ_CONTEXT_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_READ_CONTEXT_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_READ_CONTEXT_TYPE_LAST	CREQ_READ_CONTEXT_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_READ_CONTEXT_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/*
	 * Read the current state of any internal resource context. Can only
	 * be issued from a PF.
	 */
	#define CREQ_READ_CONTEXT_EVENT_READ_CONTEXT UINT32_C(0x85)
	#define CREQ_READ_CONTEXT_EVENT_LAST	CREQ_READ_CONTEXT_EVENT_READ_CONTEXT
	uint16_t	reserved16;
	uint32_t	reserved_32;
} creq_read_context_t, *pcreq_read_context_t;

/*****************
 * map_tc_to_cos *
 *****************/


/* cmdq_map_tc_to_cos (size:192b/24B) */

typedef struct cmdq_map_tc_to_cos {
	/* Command opcode. */
	uint8_t	opcode;
	/* Map TC to COS. Can only be issued from a PF. */
	#define CMDQ_MAP_TC_TO_COS_OPCODE_MAP_TC_TO_COS UINT32_C(0x8a)
	#define CMDQ_MAP_TC_TO_COS_OPCODE_LAST	CMDQ_MAP_TC_TO_COS_OPCODE_MAP_TC_TO_COS
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* 1st COS index mapped to RoCE */
	uint16_t	cos0;
	/* Don't change this COS. */
	#define CMDQ_MAP_TC_TO_COS_COS0_NO_CHANGE UINT32_C(0xffff)
	#define CMDQ_MAP_TC_TO_COS_COS0_LAST	CMDQ_MAP_TC_TO_COS_COS0_NO_CHANGE
	/* 2nd COS index mapped to RoCE */
	uint16_t	cos1;
	/* Disable this COS. */
	#define CMDQ_MAP_TC_TO_COS_COS1_DISABLE   UINT32_C(0x8000)
	/* Don't change this COS. */
	#define CMDQ_MAP_TC_TO_COS_COS1_NO_CHANGE UINT32_C(0xffff)
	#define CMDQ_MAP_TC_TO_COS_COS1_LAST	CMDQ_MAP_TC_TO_COS_COS1_NO_CHANGE
	uint32_t	unused_0;
} cmdq_map_tc_to_cos_t, *pcmdq_map_tc_to_cos_t;

/* creq_map_tc_to_cos_resp (size:128b/16B) */

typedef struct creq_map_tc_to_cos_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MAP_TC_TO_COS_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MAP_TC_TO_COS_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MAP_TC_TO_COS_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MAP_TC_TO_COS_RESP_TYPE_LAST	CREQ_MAP_TC_TO_COS_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MAP_TC_TO_COS_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Map TC to COS response. */
	#define CREQ_MAP_TC_TO_COS_RESP_EVENT_MAP_TC_TO_COS UINT32_C(0x8a)
	#define CREQ_MAP_TC_TO_COS_RESP_EVENT_LAST	CREQ_MAP_TC_TO_COS_RESP_EVENT_MAP_TC_TO_COS
	uint8_t	reserved48[6];
} creq_map_tc_to_cos_resp_t, *pcreq_map_tc_to_cos_resp_t;

/*****************
 * query_roce_cc *
 *****************/


/* cmdq_query_roce_cc (size:128b/16B) */

typedef struct cmdq_query_roce_cc {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query congestion control. */
	#define CMDQ_QUERY_ROCE_CC_OPCODE_QUERY_ROCE_CC UINT32_C(0x8d)
	#define CMDQ_QUERY_ROCE_CC_OPCODE_LAST	CMDQ_QUERY_ROCE_CC_OPCODE_QUERY_ROCE_CC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_query_roce_cc_t, *pcmdq_query_roce_cc_t;

/* creq_query_roce_cc_resp (size:128b/16B) */

typedef struct creq_query_roce_cc_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_CC_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_ROCE_CC_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_ROCE_CC_RESP_TYPE_LAST	CREQ_QUERY_ROCE_CC_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query congestion control response. */
	#define CREQ_QUERY_ROCE_CC_RESP_EVENT_QUERY_ROCE_CC UINT32_C(0x8d)
	#define CREQ_QUERY_ROCE_CC_RESP_EVENT_LAST	CREQ_QUERY_ROCE_CC_RESP_EVENT_QUERY_ROCE_CC
	uint8_t	reserved48[6];
} creq_query_roce_cc_resp_t, *pcreq_query_roce_cc_resp_t;

/* Query congestion control command response side buffer structure. */
/* creq_query_roce_cc_resp_sb (size:256b/32B) */

typedef struct creq_query_roce_cc_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query congestion control response. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_OPCODE_QUERY_ROCE_CC UINT32_C(0x8d)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_OPCODE_LAST	CREQ_QUERY_ROCE_CC_RESP_SB_OPCODE_QUERY_ROCE_CC
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	uint8_t	enable_cc;
	/* Enable. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ENABLE_CC	UINT32_C(0x1)
	/* unused7 is 7 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_UNUSED7_MASK  UINT32_C(0xfe)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_UNUSED7_SFT   1
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TOS_ECN_MASK UINT32_C(0x3)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TOS_ECN_SFT  0
	/*
	 * IP TOS DSCP. When multi-lossless queue feature is enabled,
	 * query applies only to the default traffic class (1).
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TOS_DSCP_SFT 2
	/* Congestion Probability averaging factor. */
	uint8_t	g;
	/* Number of phases in Fast Recovery and Active Increase. */
	uint8_t	num_phases_per_state;
	/* The starting value of rate. */
	uint16_t	init_cr;
	/* The starting value of target rate. */
	uint16_t	init_tr;
	uint8_t	alt_vlan_pcp;
	/* Alternate vlan pcp value for CNP packets. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ALT_VLAN_PCP_MASK UINT32_C(0x7)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ALT_VLAN_PCP_SFT 0
	/* rsvd1 is 5 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD1_MASK	UINT32_C(0xf8)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD1_SFT	3
	uint8_t	alt_tos_dscp;
	/* Alternate IP TOS DSCP. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ALT_TOS_DSCP_MASK UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ALT_TOS_DSCP_SFT 0
	/* rsvd4 is 2 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD4_MASK	UINT32_C(0xc0)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD4_SFT	6
	uint8_t	cc_mode;
	/* DCTCP CC algorithm. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE_DCTCP	UINT32_C(0x0)
	/*
	 * Probabilistic marking CC algorithm. On chips with CC Gen 0
	 * support this will be TCP CC algorithm.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE_PROBABILISTIC UINT32_C(0x1)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE_LAST	CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE_PROBABILISTIC
	/* Specifies the RoCE Tx Queue to use for sending CNP packets. */
	uint8_t	tx_queue;
	uint16_t	rtt;
	/* Round trip time in units of usecs */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RTT_MASK  UINT32_C(0x3fff)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RTT_SFT   0
	/* rsvd5 is 2 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD5_MASK UINT32_C(0xc000)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD5_SFT 14
	uint16_t	tcp_cp;
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TCP_CP_MASK UINT32_C(0x3ff)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TCP_CP_SFT 0
	/* rsvd6 is 6 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD6_MASK UINT32_C(0xfc00)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD6_SFT  10
	/* Inactivity time after which QP CC parameters are initialized */
	uint16_t	inactivity_th;
	/* Number of packets per phase. Max is 255. */
	uint8_t	pkts_per_phase;
	/* Amount of time per phase in units of ms. Max is 15 */
	uint8_t	time_per_phase;
	uint32_t	reserved32;
} creq_query_roce_cc_resp_sb_t, *pcreq_query_roce_cc_resp_sb_t;

/*
 * TLV encapsulated Query congestion control command response
 * side buffer, with extended TLV record included for specifying
 * the extended configuration for CC level 1.
 */
/* creq_query_roce_cc_resp_sb_tlv (size:384b/48B) */

typedef struct creq_query_roce_cc_resp_sb_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED_LAST CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	/*
	 * Size of the tlv encapsulated response,
	 * including all tlvs and extension data in 16-byte units.
	 */
	uint8_t	total_size;
	uint8_t	reserved56[7];
	/* Command opcode. */
	uint8_t	opcode;
	/* Query congestion control response. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_OPCODE_QUERY_ROCE_CC UINT32_C(0x8d)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_OPCODE_LAST	CREQ_QUERY_ROCE_CC_RESP_SB_TLV_OPCODE_QUERY_ROCE_CC
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	uint8_t	enable_cc;
	/* Enable. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ENABLE_CC	UINT32_C(0x1)
	/* unused7 is 7 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_UNUSED7_MASK  UINT32_C(0xfe)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_UNUSED7_SFT   1
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TOS_ECN_MASK UINT32_C(0x3)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TOS_ECN_SFT  0
	/*
	 * IP TOS DSCP. When multi-lossless queue feature is enabled,
	 * query applies only to the default traffic class (1).
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TOS_DSCP_SFT 2
	/* Congestion Probability averaging factor. */
	uint8_t	g;
	/* Number of phases in Fast Recovery and Active Increase. */
	uint8_t	num_phases_per_state;
	/* The starting value of rate. */
	uint16_t	init_cr;
	/* The starting value of target rate. */
	uint16_t	init_tr;
	uint8_t	alt_vlan_pcp;
	/* Alternate vlan pcp value for CNP packets. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ALT_VLAN_PCP_MASK UINT32_C(0x7)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ALT_VLAN_PCP_SFT 0
	/* rsvd1 is 5 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD1_MASK	UINT32_C(0xf8)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD1_SFT	3
	uint8_t	alt_tos_dscp;
	/* Alternate IP TOS DSCP. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ALT_TOS_DSCP_MASK UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ALT_TOS_DSCP_SFT 0
	/* rsvd4 is 2 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD4_MASK	UINT32_C(0xc0)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD4_SFT	6
	uint8_t	cc_mode;
	/* DCTCP CC algorithm. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_CC_MODE_DCTCP	UINT32_C(0x0)
	/*
	 * Probabilistic marking CC algorithm. On chips with CC Gen 0
	 * support this will be TCP CC algorithm.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_CC_MODE_PROBABILISTIC UINT32_C(0x1)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_CC_MODE_LAST	CREQ_QUERY_ROCE_CC_RESP_SB_TLV_CC_MODE_PROBABILISTIC
	/* Specifies the RoCE Tx Queue to use for sending CNP packets. */
	uint8_t	tx_queue;
	uint16_t	rtt;
	/* Round trip time in units of usecs */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RTT_MASK  UINT32_C(0x3fff)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RTT_SFT   0
	/* rsvd5 is 2 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD5_MASK UINT32_C(0xc000)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD5_SFT 14
	uint16_t	tcp_cp;
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TCP_CP_MASK UINT32_C(0x3ff)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TCP_CP_SFT 0
	/* rsvd6 is 6 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD6_MASK UINT32_C(0xfc00)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD6_SFT  10
	/* Inactivity time after which QP CC parameters are initialized */
	uint16_t	inactivity_th;
	/* Number of packets per phase. Max is 255. */
	uint8_t	pkts_per_phase;
	/* Amount of time per phase in units of ms. Max is 15 */
	uint8_t	time_per_phase;
	uint32_t	reserved32;
} creq_query_roce_cc_resp_sb_tlv_t, *pcreq_query_roce_cc_resp_sb_tlv_t;

/* creq_query_roce_cc_gen1_resp_sb_tlv (size:704b/88B) */

typedef struct creq_query_roce_cc_gen1_resp_sb_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED_LAST CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	uint64_t	reserved64;
	/* High order bits of inactivity threshold. */
	uint16_t	inactivity_th_hi;
	/*
	 * The number of uS between generation of CNPs when cc_mode is
	 * probabilistic marking.
	 */
	uint16_t	min_time_between_cnps;
	/*
	 * The starting value of congestion probability. Input range
	 * is 0 - 1023.
	 */
	uint16_t	init_cp;
	/*
	 * In tr_update_mode 0, Target Rate (TR) is updated to
	 * halfway between the Current Rate (CR) before and after reduction.
	 * In tr_update_mode 1, TR is updated to CR's value before reduction.
	 */
	uint8_t	tr_update_mode;
	/*
	 * Determine for how many RTTs with CNPs in a row, TR is being updated.
	 * 0: TR is updated when QPC. rtts_with_cnps == 0
	 * 1-6: TR is updated if QPC. rtts_with_cnps <= tr_update_cycles
	 * 7: TR is updated on all reductions.
	 */
	uint8_t	tr_update_cycles;
	/* Number of RTTs in Fast Recovery stage. */
	uint8_t	fr_num_rtts;
	/* Time increment to increase TR in active increase phase. */
	uint8_t	ai_rate_increase;
	/*
	 * Indicates for how many RTTs with CNPs after the first one
	 * to not reduce rate even if CNPs are received.
	 */
	uint16_t	reduction_relax_rtts_th;
	/*
	 * For low rates, additional number of RTTS with CNPs
	 * for which no rate reduction is made.
	 * num_bits: 14
	 */
	uint16_t	additional_relax_cr_th;
	/*
	 * If CR is less than or equal to this value,
	 * then the actual CR average is set to this value
	 * (shifted by bw_avg_weight).
	 */
	uint16_t	cr_min_th;
	/* Log based averaging weight for QPC variable actual_cr_avg. */
	uint8_t	bw_avg_weight;
	/*
	 * Used to compare CR to this factor times QPC.actual_cr_average
	 * as a reduction reference. Values between 0 and 6 represent factor of
	 * 1.125, 1.25, 1.5, 1.75, 2, 2.25, 2.5 respectively.
	 */
	uint8_t	actual_cr_factor;
	/* The level of CR above which CP is set to maximum level. */
	uint16_t	max_cp_cr_th;
	/*
	 * Enable adding fraction of CR to CP.
	 * 0 for disable, 1 for enable.
	 */
	uint8_t	cp_bias_en;
	/* Log based fraction of cr to add to CP when cp_bias_en is 1. */
	uint8_t	cp_bias;
	/*
	 * The value of ECN bits in a CNP packet generated by hardware.
	 * ECN-Capable Transport (ECT) codepoints supported include:
	 * 0 for not_ect, 1 for ect_0, 2 for ect_1
	 */
	uint8_t	cnp_ecn;
	/* Not ECN capable Transport */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_NOT_ECT UINT32_C(0x0)
	/* ECN Capable Transport-1 */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_ECT_1   UINT32_C(0x1)
	/* ECN Capable Transport-0 */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_ECT_0   UINT32_C(0x2)
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_LAST   CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_ECT_0
	/* Enables jitter in RTT. */
	uint8_t	rtt_jitter_en;
	/*
	 * Number of bytes per usec, dependent on port speed.
	 * 200 Gbps: 25,000
	 * 100 Gbps: 12,500
	 * 50 Gbps: 6,250
	 * 25 Gbps: 3125
	 * 10 Gbps: 1250
	 */
	uint16_t	link_bytes_per_usec;
	/*
	 * If CR is greater than or equal to this threshold,
	 * QPC's CC state is reset to its initial state.
	 */
	uint16_t	reset_cc_cr_th;
	/*
	 * The number of valid lsbits in CR and TR.
	 * Supported values include 10 through 14 to support 2^cr_width rate.
	 */
	uint8_t	cr_width;
	/* Lower end of random selection of quota_period. */
	uint8_t	quota_period_min;
	/* Upper end of random selection of quota_period. */
	uint8_t	quota_period_max;
	/*
	 * The absolute maximum possible quota_period,
	 * applicable when rate table for lower 24 levels is used.
	 */
	uint8_t	quota_period_abs_max;
	/* TR never goes below this level. */
	uint16_t	tr_lower_bound;
	/* Factor on probability threshold for adding 0.5 to CR randomly. */
	uint8_t	cr_prob_factor;
	/* Factor on probability threshold for adding 0.5 to TR randomly. */
	uint8_t	tr_prob_factor;
	/*
	 * Threshold to ensure fairness between requester and responder.
	 * If CR is less than the fairness threshold and a quota period has
	 * passed priority will be given to the path that did not last
	 * transfer data.
	 */
	uint16_t	fairness_cr_th;
	/* Log based rate reduction divider. */
	uint8_t	red_div;
	/* Threshold for rate reductions when CNPS received over last RTT. */
	uint8_t	cnp_ratio_th;
	/*
	 * Extended number of RTTS to wait, when there is no congestion,
	 * to start doubling the rate.
	 */
	uint16_t	exp_ai_rtts;
	/* Log based CR to CP ratio used in exponential increase. */
	uint8_t	exp_ai_cr_cp_ratio;
	/* Enable use of lowest 24 rate levels rate_table. */
	uint8_t	use_rate_table;
	/*
	 * Determines after how many congestion free RTTs to start
	 * updating CP to track CR.
	 */
	uint16_t	cp_exp_update_th;
	/*
	 * The threshold on congestion free RTTs above which AI can increase
	 * to 16.
	 */
	uint16_t	high_exp_ai_rtts_th1;
	/*
	 * The threshold on congestion free RTTs above which AI can increase
	 * to 32.
	 */
	uint16_t	high_exp_ai_rtts_th2;
	/*
	 * The number of congestion free RTTs above which
	 * reduction based on actual rate is enabled.
	 */
	uint16_t	actual_cr_cong_free_rtts_th;
	/*
	 * If rtts_with_cong is greater than 7 (severe congestion) and
	 * CR level post reduction is above this threshold,
	 * then TR is capped to 1.5 times CR..
	 */
	uint16_t	severe_cong_cr_th1;
	/*
	 * If rtts_with_cong is greater than 7 (severe congestion) and
	 * CR level post reduction is above this threshold,
	 * then TR is capped to 1.25 times CR..
	 */
	uint16_t	severe_cong_cr_th2;
	/*
	 * The maximum number of 64B that can be transmitted during RTT time,
	 * including all headers and Inter Packet Gap.
	 */
	uint32_t	link64B_per_rtt;
	/*
	 * The number of bytes to subtract from QPC.cc_bucket
	 * when an ack is scheduled.
	 */
	uint8_t	cc_ack_bytes;
	/*
	 * Enables reduction of CR, TR, and CP to init values when
	 * congestion free RTTs is greater than reduce2_init_cong_free_rtts_th.
	 */
	uint8_t	reduce_init_en;
	/*
	 * Minimum threshold value for number of congestion free RTTs before
	 * reducing to init values for CR, TR, and CP when reduce_init_en is
	 * enabled.
	 */
	uint16_t	reduce_init_cong_free_rtts_th;
	/* Enables random no reduction of CR. */
	uint8_t	random_no_red_en;
	/*
	 * Enables coarse correction to actual CR when actual RTT is longer
	 * than nominal.
	 */
	uint8_t	actual_cr_shift_correction_en;
	/* Enables adjustment to refill quota. */
	uint8_t	quota_period_adjust_en;
	uint8_t	reserved[5];
} creq_query_roce_cc_gen1_resp_sb_tlv_t, *pcreq_query_roce_cc_gen1_resp_sb_tlv_t;

/* creq_query_roce_cc_gen2_resp_sb_tlv (size:512b/64B) */

typedef struct creq_query_roce_cc_gen2_resp_sb_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_TLV_FLAGS_REQUIRED_LAST CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	uint64_t	reserved64;
	/*
	 * DCN queue level threshold values associated with DCN queue
	 * level table indices 0 to 7.
	 */
	uint16_t	dcn_qlevel_tbl_thr[8];
	/*
	 * DCN queue level table action values.
	 * Returns CR, INC_CNP, UPD_IMM & TR fields associated with
	 * DCN queue level table indices 0 to 7.
	 */
	uint32_t	dcn_qlevel_tbl_act[8];
	/* DCN queue level current rate. */
	#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_DCN_QLEVEL_TBL_ACT_CR_MASK	UINT32_C(0x3fff)
	#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_DCN_QLEVEL_TBL_ACT_CR_SFT	0
	/* DCN queue level increment CNP count. */
	#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_DCN_QLEVEL_TBL_ACT_INC_CNP	UINT32_C(0x4000)
	/* DCN queue level update CR and TR immediately. */
	#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_DCN_QLEVEL_TBL_ACT_UPD_IMM	UINT32_C(0x8000)
	/* DCN queue level target rate */
	#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_DCN_QLEVEL_TBL_ACT_TR_MASK	UINT32_C(0x3fff0000)
	#define CREQ_QUERY_ROCE_CC_GEN2_RESP_SB_TLV_DCN_QLEVEL_TBL_ACT_TR_SFT	16
} creq_query_roce_cc_gen2_resp_sb_tlv_t, *pcreq_query_roce_cc_gen2_resp_sb_tlv_t;

/***********************
 * cmdq_modify_roce_cc *
 ***********************/


/* cmdq_modify_roce_cc (size:448b/56B) */

typedef struct cmdq_modify_roce_cc {
	/* Command opcode. */
	uint8_t	opcode;
	/* Modify congestion control. Can only be issued from a PF. */
	#define CMDQ_MODIFY_ROCE_CC_OPCODE_MODIFY_ROCE_CC UINT32_C(0x8c)
	#define CMDQ_MODIFY_ROCE_CC_OPCODE_LAST	CMDQ_MODIFY_ROCE_CC_OPCODE_MODIFY_ROCE_CC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* Enable change. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ENABLE_CC		UINT32_C(0x1)
	/* Running average weight change. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_G			UINT32_C(0x2)
	/* Number of phases in Fast Recovery. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_NUMPHASEPERSTATE	UINT32_C(0x4)
	/* The starting value of rate change. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INIT_CR		UINT32_C(0x8)
	/* The starting value of target rate change. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INIT_TR		UINT32_C(0x10)
	/* IP TOS ECN change */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TOS_ECN		UINT32_C(0x20)
	/* IP TOS DSCP change */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TOS_DSCP		UINT32_C(0x40)
	/* Alternate IP TOS ECN change */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ALT_VLAN_PCP	UINT32_C(0x80)
	/* Alternate IP TOS DSCP change */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ALT_TOS_DSCP	UINT32_C(0x100)
	/* Round trip time in units of usecs */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_RTT		UINT32_C(0x200)
	/* Congestion Control mode */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_CC_MODE		UINT32_C(0x400)
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TCP_CP		UINT32_C(0x800)
	/* Specifies the RoCE Tx Queue to use for sending CNP packets */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TX_QUEUE		UINT32_C(0x1000)
	/* Inactivity time after which QP CC parameters are initialized */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INACTIVITY_CP	UINT32_C(0x2000)
	/* Amount of time per phase in units of ms. Max is 15. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TIME_PER_PHASE	UINT32_C(0x4000)
	/* Number of packets per phase. Max is 255. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_PKTS_PER_PHASE	UINT32_C(0x8000)
	uint8_t	enable_cc;
	/* Enable. */
	#define CMDQ_MODIFY_ROCE_CC_ENABLE_CC	UINT32_C(0x1)
	/* rsvd1 is 7 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD1_MASK	UINT32_C(0xfe)
	#define CMDQ_MODIFY_ROCE_CC_RSVD1_SFT	1
	/* Congestion Probability averaging factor. */
	uint8_t	g;
	/* Number of phases in Fast Recovery. */
	uint8_t	num_phases_per_state;
	/* Number of packets per phase. Max is 255. */
	uint8_t	pkts_per_phase;
	/*
	 * The starting value of rate.
	 * The max value supported for CC support level 1 is 1024.
	 */
	uint16_t	init_cr;
	/*
	 * The starting value of target rate.
	 * The max value supported for CC support level 1 is 1024.
	 */
	uint16_t	init_tr;
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. Valid values are 1 or 2 when ECN is enabled. */
	#define CMDQ_MODIFY_ROCE_CC_TOS_ECN_MASK UINT32_C(0x3)
	#define CMDQ_MODIFY_ROCE_CC_TOS_ECN_SFT  0
	/*
	 * IP TOS DSCP. When multi-lossless queue feature is enabled,
	 * update applies only to the default traffic class (1).
	 */
	#define CMDQ_MODIFY_ROCE_CC_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CMDQ_MODIFY_ROCE_CC_TOS_DSCP_SFT 2
	uint8_t	alt_vlan_pcp;
	/* Alternate vlan pcp value for CNP packets. */
	#define CMDQ_MODIFY_ROCE_CC_ALT_VLAN_PCP_MASK UINT32_C(0x7)
	#define CMDQ_MODIFY_ROCE_CC_ALT_VLAN_PCP_SFT 0
	/* rsvd3 is 5 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD3_MASK	UINT32_C(0xf8)
	#define CMDQ_MODIFY_ROCE_CC_RSVD3_SFT	3
	uint16_t	alt_tos_dscp;
	/* Alternate IP TOS DSCP. */
	#define CMDQ_MODIFY_ROCE_CC_ALT_TOS_DSCP_MASK UINT32_C(0x3f)
	#define CMDQ_MODIFY_ROCE_CC_ALT_TOS_DSCP_SFT 0
	/* rsvd4 is 10 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD4_MASK	UINT32_C(0xffc0)
	#define CMDQ_MODIFY_ROCE_CC_RSVD4_SFT	6
	uint16_t	rtt;
	/*
	 * Round trip time in units of usecs.
	 * The max value supported for CC support level 1 is 2047.
	 */
	#define CMDQ_MODIFY_ROCE_CC_RTT_MASK  UINT32_C(0x3fff)
	#define CMDQ_MODIFY_ROCE_CC_RTT_SFT   0
	/* rsvd5 is 2 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD5_MASK UINT32_C(0xc000)
	#define CMDQ_MODIFY_ROCE_CC_RSVD5_SFT 14
	uint16_t	tcp_cp;
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CMDQ_MODIFY_ROCE_CC_TCP_CP_MASK UINT32_C(0x3ff)
	#define CMDQ_MODIFY_ROCE_CC_TCP_CP_SFT 0
	/* rsvd6 is 6 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD6_MASK UINT32_C(0xfc00)
	#define CMDQ_MODIFY_ROCE_CC_RSVD6_SFT  10
	uint8_t	cc_mode;
	/* DCTCP */
	#define CMDQ_MODIFY_ROCE_CC_CC_MODE_DCTCP_CC_MODE	UINT32_C(0x0)
	/*
	 * Probabilistic marking. On chips with CC Gen 0 support this
	 * will be TCP CC algorithm.
	 */
	#define CMDQ_MODIFY_ROCE_CC_CC_MODE_PROBABILISTIC_CC_MODE UINT32_C(0x1)
	#define CMDQ_MODIFY_ROCE_CC_CC_MODE_LAST		CMDQ_MODIFY_ROCE_CC_CC_MODE_PROBABILISTIC_CC_MODE
	/*
	 * Specifies the RoCE Tx Queue to use for sending CNP packets.
	 * CC support level 0 support 0 to 3 Tx queues.
	 * CC support level 1 supports 0 to 7 Tx queues.
	 */
	uint8_t	tx_queue;
	/* Inactivity time after which QP CC parameters are initialized */
	uint16_t	inactivity_th;
	/* Amount of time per phase in units of ms. Max is 15 */
	uint8_t	time_per_phase;
	/* reserved8 is 8 b */
	uint8_t	reserved8_1;
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	uint32_t	reserved32;
	uint64_t	reserved64;
} cmdq_modify_roce_cc_t, *pcmdq_modify_roce_cc_t;

/*
 * TLV encapsulated modify CC command, with extended TLV record
 * included for specifying the extended configuration for CC level 1.
 */
/* cmdq_modify_roce_cc_tlv (size:640b/80B) */

typedef struct cmdq_modify_roce_cc_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED_LAST CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	/*
	 * Size of the tlv encapsulated command, including all tlvs and
	 * extension data in 16-byte units.
	 */
	uint8_t	total_size;
	uint8_t	reserved56[7];
	/* Command opcode. */
	uint8_t	opcode;
	/* Modify congestion control. Can only be issued from a PF. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_OPCODE_MODIFY_ROCE_CC UINT32_C(0x8c)
	#define CMDQ_MODIFY_ROCE_CC_TLV_OPCODE_LAST	CMDQ_MODIFY_ROCE_CC_TLV_OPCODE_MODIFY_ROCE_CC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* Enable change. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_ENABLE_CC		UINT32_C(0x1)
	/* Running average weight change. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_G			UINT32_C(0x2)
	/* Number of phases in Fast Recovery. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_NUMPHASEPERSTATE	UINT32_C(0x4)
	/* The starting value of rate change. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_INIT_CR		UINT32_C(0x8)
	/* The starting value of target rate change. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_INIT_TR		UINT32_C(0x10)
	/* IP TOS ECN change */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TOS_ECN		UINT32_C(0x20)
	/* IP TOS DSCP change */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TOS_DSCP		UINT32_C(0x40)
	/* Alternate IP TOS ECN change */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_ALT_VLAN_PCP	UINT32_C(0x80)
	/* Alternate IP TOS DSCP change */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_ALT_TOS_DSCP	UINT32_C(0x100)
	/* Round trip time in units of usecs */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_RTT		UINT32_C(0x200)
	/* Congestion Control mode */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_CC_MODE		UINT32_C(0x400)
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TCP_CP		UINT32_C(0x800)
	/* Specifies the RoCE Tx Queue to use for sending CNP packets */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TX_QUEUE		UINT32_C(0x1000)
	/* Inactivity time after which QP CC parameters are initialized */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_INACTIVITY_CP	UINT32_C(0x2000)
	/* Amount of time per phase in units of ms. Max is 15. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TIME_PER_PHASE	UINT32_C(0x4000)
	/* Number of packets per phase. Max is 255. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_PKTS_PER_PHASE	UINT32_C(0x8000)
	uint8_t	enable_cc;
	/* Enable. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_ENABLE_CC	UINT32_C(0x1)
	/* rsvd1 is 7 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD1_MASK	UINT32_C(0xfe)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD1_SFT	1
	/* Congestion Probability averaging factor. */
	uint8_t	g;
	/* Number of phases in Fast Recovery. */
	uint8_t	num_phases_per_state;
	/* Number of packets per phase. Max is 255. */
	uint8_t	pkts_per_phase;
	/*
	 * The starting value of rate.
	 * The max value supported for CC support level 1 is 1024.
	 */
	uint16_t	init_cr;
	/*
	 * The starting value of target rate.
	 * The max value supported for CC support level 1 is 1024.
	 */
	uint16_t	init_tr;
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. Valid values are 1 or 2 when ECN is enabled. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TOS_ECN_MASK UINT32_C(0x3)
	#define CMDQ_MODIFY_ROCE_CC_TLV_TOS_ECN_SFT  0
	/*
	 * IP TOS DSCP. When multi-lossless queue feature is enabled,
	 * update applies only to the default traffic class (1).
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CMDQ_MODIFY_ROCE_CC_TLV_TOS_DSCP_SFT 2
	uint8_t	alt_vlan_pcp;
	/* Alternate vlan pcp value for CNP packets. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_ALT_VLAN_PCP_MASK UINT32_C(0x7)
	#define CMDQ_MODIFY_ROCE_CC_TLV_ALT_VLAN_PCP_SFT 0
	/* rsvd3 is 5 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD3_MASK	UINT32_C(0xf8)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD3_SFT	3
	uint16_t	alt_tos_dscp;
	/* Alternate IP TOS DSCP. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_ALT_TOS_DSCP_MASK UINT32_C(0x3f)
	#define CMDQ_MODIFY_ROCE_CC_TLV_ALT_TOS_DSCP_SFT 0
	/* rsvd4 is 10 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD4_MASK	UINT32_C(0xffc0)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD4_SFT	6
	uint16_t	rtt;
	/*
	 * Round trip time in units of usecs.
	 * The max value supported for CC support level 1 is 2047.
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RTT_MASK  UINT32_C(0x3fff)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RTT_SFT   0
	/* rsvd5 is 2 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD5_MASK UINT32_C(0xc000)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD5_SFT 14
	uint16_t	tcp_cp;
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TCP_CP_MASK UINT32_C(0x3ff)
	#define CMDQ_MODIFY_ROCE_CC_TLV_TCP_CP_SFT 0
	/* rsvd6 is 6 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD6_MASK UINT32_C(0xfc00)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD6_SFT  10
	uint8_t	cc_mode;
	/* DCTCP */
	#define CMDQ_MODIFY_ROCE_CC_TLV_CC_MODE_DCTCP_CC_MODE	UINT32_C(0x0)
	/*
	 * Probabilistic marking. On chips with CC Gen 0 support this
	 * will be TCP CC algorithm.
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_CC_MODE_PROBABILISTIC_CC_MODE UINT32_C(0x1)
	#define CMDQ_MODIFY_ROCE_CC_TLV_CC_MODE_LAST		CMDQ_MODIFY_ROCE_CC_TLV_CC_MODE_PROBABILISTIC_CC_MODE
	/*
	 * Specifies the RoCE Tx Queue to use for sending CNP packets.
	 * CC support level 0 support 0 to 3 Tx queues.
	 * CC support level 1 supports 0 to 7 Tx queues.
	 */
	uint8_t	tx_queue;
	/* Inactivity time after which QP CC parameters are initialized */
	uint16_t	inactivity_th;
	/* Amount of time per phase in units of ms. Max is 15 */
	uint8_t	time_per_phase;
	/* reserved8 is 8 b */
	uint8_t	reserved8_1;
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	uint32_t	reserved32;
	uint64_t	reserved64;
	uint64_t	reservedtlvpad;
} cmdq_modify_roce_cc_tlv_t, *pcmdq_modify_roce_cc_tlv_t;

/* cmdq_modify_roce_cc_gen1_tlv (size:768b/96B) */

typedef struct cmdq_modify_roce_cc_gen1_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED_LAST CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	uint64_t	reserved64;
	/* Modify mask signifies the field that is requesting the change. */
	uint64_t	modify_mask;
	/*
	 * Update the number of uS between generation of CNPs for
	 * probabilistic marking mode.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_MIN_TIME_BETWEEN_CNPS		UINT32_C(0x1)
	/*
	 * Update starting value of Congestion Probability (CP).
	 * Maximum value supported is 1023.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_INIT_CP			UINT32_C(0x2)
	/* Update Target Rate (TR) Update Mode. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_TR_UPDATE_MODE			UINT32_C(0x4)
	/* Update number of RTTs with CNPs in a row for TR update. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_TR_UPDATE_CYCLES		UINT32_C(0x8)
	/* Update number of RTTs in Fast Recovery stage. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_FR_NUM_RTTS			UINT32_C(0x10)
	/* Update time increment to increase TR in active increase phase. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_AI_RATE_INCREASE		UINT32_C(0x20)
	/*
	 * Update count of RTTs with CNPs, received after
	 * the first one, to wait, before reducing rate.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_REDUCTION_RELAX_RTTS_TH	UINT32_C(0x40)
	/*
	 * Update additional number of RTTS with CNPs, to wait,
	 * before further rate reduction, for low rates.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_ADDITIONAL_RELAX_CR_TH		UINT32_C(0x80)
	/* Update threshold for update to Actual Current Rate (CR) */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CR_MIN_TH			UINT32_C(0x100)
	/* Update log based averaging weight for QPC variable actual_cr */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_BW_AVG_WEIGHT			UINT32_C(0x200)
	/* Update factor used in the computation of rate reduction. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_ACTUAL_CR_FACTOR		UINT32_C(0x400)
	/* Update the level of CR above which CP is set to maximum level. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_MAX_CP_CR_TH			UINT32_C(0x800)
	/* Enable adding fraction of CR to CP. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CP_BIAS_EN			UINT32_C(0x1000)
	/*
	 * Update log based fraction of CR to add to CP
	 * when cp_bias_en is 1.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CP_BIAS			UINT32_C(0x2000)
	/* Update ECN bits in a CNP packet generated by hardware. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CNP_ECN			UINT32_C(0x4000)
	/* Update enable of jitter in RTT. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_RTT_JITTER_EN			UINT32_C(0x8000)
	/* Update number of bytes per usec. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_LINK_BYTES_PER_USEC		UINT32_C(0x10000)
	/*
	 * Update threshold used to reset QPC CC state to its initial
	 * state.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_RESET_CC_CR_TH			UINT32_C(0x20000)
	/* Update number of valid lsbits in CR and TR */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CR_WIDTH			UINT32_C(0x40000)
	/* Update lower end of random selection of quota_period. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_QUOTA_PERIOD_MIN		UINT32_C(0x80000)
	/* Update upper end of random selection of quota_period. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_QUOTA_PERIOD_MAX		UINT32_C(0x100000)
	/*
	 * Update absolute maximum possible quota_period,
	 * when rate table for lower 24 levels is used.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_QUOTA_PERIOD_ABS_MAX		UINT32_C(0x200000)
	/* Update lower bound of TR. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_TR_LOWER_BOUND			UINT32_C(0x400000)
	/*
	 * Update factor on probability threshold for adding
	 * 0.5 to CR randomly.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CR_PROB_FACTOR			UINT32_C(0x800000)
	/*
	 * Update factor on probability threshold for adding
	 * 0.5 to TR randomly.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_TR_PROB_FACTOR			UINT32_C(0x1000000)
	/*
	 * Update threshold that ensures fairness between requester
	 * and responder
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_FAIRNESS_CR_TH			UINT32_C(0x2000000)
	/* Update log based rate reduction divider. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_RED_DIV			UINT32_C(0x4000000)
	/*
	 * Update threshold for rate reductions when CNPS received
	 * over last RTT.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CNP_RATIO_TH			UINT32_C(0x8000000)
	/*
	 * Update extended number of RTTS to wait,
	 * when there is no congestion, to start doubling the rate.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_EXP_AI_RTTS			UINT32_C(0x10000000)
	/* Update log based CR to CP ratio used in exponential increase. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_EXP_AI_CR_CP_RATIO		UINT32_C(0x20000000)
	/*
	 * Update threshold, in congestion free RTTs,
	 * that triggers start of CP update to track CR.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CP_EXP_UPDATE_TH		UINT32_C(0x40000000)
	/*
	 * Update threshold on congestion free RTTs above
	 * which AI can increase to 16.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_HIGH_EXP_AI_RTTS_TH1		UINT32_C(0x80000000)
	/*
	 * Update threshold on congestion free RTTs above
	 * which AI can increase to 32.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_HIGH_EXP_AI_RTTS_TH2		UINT32_C(0x100000000)L
	/* Update use of lowest 24 rate levels rate_table. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_USE_RATE_TABLE			UINT32_C(0x200000000)L
	/*
	 * Update the maximum number of 64B that can be transmitted
	 * during RTT time.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_LINK64B_PER_RTT		UINT32_C(0x400000000)L
	/*
	 * Update number of congestion free RTTs above which
	 * reduction based on actual rate is enabled.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_ACTUAL_CR_CONG_FREE_RTTS_TH	UINT32_C(0x800000000)L
	/*
	 * Update threshold used in severe congestion for
	 * limiting TR to 1.5 times CR.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_SEVERE_CONG_CR_TH1		UINT32_C(0x1000000000)L
	/*
	 * Update threshold used in severe congestion for
	 * limiting TR to 1.25 times CR.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_SEVERE_CONG_CR_TH2		UINT32_C(0x2000000000)L
	/*
	 * Update number of bytes to subtract from QPC.cc_bucket
	 * when an ack is scheduled.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CC_ACK_BYTES			UINT32_C(0x4000000000)L
	/* Update enable of reduction of CR, TR, and CP to init values. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_REDUCE_INIT_EN			UINT32_C(0x8000000000)L
	/*
	 * Update threshold used for reduction of CR, TR, and CP to init
	 * values.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_REDUCE_INIT_CONG_FREE_RTTS_TH	UINT32_C(0x10000000000)L
	/* Update enable of random no reduction of CR. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_RANDOM_NO_RED_EN		UINT32_C(0x20000000000)L
	/* Update enable of coarse correction to actual CR. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_ACTUAL_CR_SHIFT_CORRECTION_EN	UINT32_C(0x40000000000)L
	/* Update enable of adjustment to refill quota. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_QUOTA_PERIOD_ADJUST_EN		UINT32_C(0x80000000000)L
	/* High order bits of inactivity threshold. */
	uint16_t	inactivity_th_hi;
	/*
	 * The number of uS between generation of CNPs when cc_mode is
	 * probabilistic marking.
	 */
	uint16_t	min_time_between_cnps;
	/*
	 * The starting value of congestion probability. Input range
	 * is 0 - 1023.
	 */
	uint16_t	init_cp;
	/*
	 * In tr_update_mode 0, Target Rate (TR) is updated to
	 * halfway between the Current Rate (CR) before and after reduction.
	 * In tr_update_mode 1, TR is updated to CR's value before reduction.
	 */
	uint8_t	tr_update_mode;
	/*
	 * Determine for how many RTTs with CNPs in a row, TR is being updated.
	 * 0: TR is updated when QPC. rtts_with_cnps == 0
	 * 1-6: TR is updated if QPC. rtts_with_cnps <= tr_update_cycles
	 * 7: TR is updated on all reductions.
	 */
	uint8_t	tr_update_cycles;
	/* Number of RTTs in Fast Recovery stage. */
	uint8_t	fr_num_rtts;
	/* Time increment to increase TR in active increase phase. */
	uint8_t	ai_rate_increase;
	/*
	 * Indicates for how many RTTs with CNPs after the first one
	 * to not reduce rate even if CNPs are received.
	 */
	uint16_t	reduction_relax_rtts_th;
	/*
	 * For low rates, additional number of RTTS with CNPs
	 * for which no rate reduction is made.
	 * num_bits: 14
	 */
	uint16_t	additional_relax_cr_th;
	/*
	 * If CR is less than or equal to this value,
	 * then the actual CR average is set to this value
	 * (shifted by bw_avg_weight).
	 */
	uint16_t	cr_min_th;
	/* Log based averaging weight for QPC variable actual_cr_avg. */
	uint8_t	bw_avg_weight;
	/*
	 * Used to compare CR to this factor times QPC.actual_cr_average
	 * as a reduction reference. Values between 0 and 6 represent factor of
	 * 1.125, 1.25, 1.5, 1.75, 2, 2.25, 2.5 respectively.
	 */
	uint8_t	actual_cr_factor;
	/* The level of CR above which CP is set to maximum level. */
	uint16_t	max_cp_cr_th;
	/*
	 * Enable adding fraction of CR to CP.
	 * 0 for disable, 1 for enable.
	 */
	uint8_t	cp_bias_en;
	/* Log based fraction of cr to add to CP when cp_bias_en is 1. */
	uint8_t	cp_bias;
	/*
	 * The value of ECN bits in a CNP packet generated by hardware.
	 * ECN-Capable Transport (ECT) codepoints supported include:
	 * 0 for not_ect, 1 for ect_0, 2 for ect_1
	 */
	uint8_t	cnp_ecn;
	/* Not ECN capable Transport */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_NOT_ECT UINT32_C(0x0)
	/* ECN Capable Transport-1 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_ECT_1   UINT32_C(0x1)
	/* ECN Capable Transport-0 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_ECT_0   UINT32_C(0x2)
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_LAST   CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_ECT_0
	/* Enables jitter in RTT. */
	uint8_t	rtt_jitter_en;
	/*
	 * Number of bytes per usec, dependent on port speed.
	 * 200 Gbps: 25,000
	 * 100 Gbps: 12,500
	 * 50 Gbps: 6,250
	 * 25 Gbps: 3125
	 * 10 Gbps: 1250
	 */
	uint16_t	link_bytes_per_usec;
	/*
	 * If CR is greater than or equal to this threshold,
	 * QPC's CC state is reset to its initial state.
	 */
	uint16_t	reset_cc_cr_th;
	/*
	 * The number of valid lsbits in CR and TR.
	 * Supported values include 10 through 14 to support 2^cr_width rate.
	 */
	uint8_t	cr_width;
	/* Lower end of random selection of quota_period. */
	uint8_t	quota_period_min;
	/* Upper end of random selection of quota_period. */
	uint8_t	quota_period_max;
	/*
	 * The absolute maximum possible quota_period,
	 * applicable when rate table for lower 24 levels is used.
	 */
	uint8_t	quota_period_abs_max;
	/* TR never goes below this level. */
	uint16_t	tr_lower_bound;
	/* Factor on probability threshold for adding 0.5 to CR randomly. */
	uint8_t	cr_prob_factor;
	/* Factor on probability threshold for adding 0.5 to TR randomly. */
	uint8_t	tr_prob_factor;
	/*
	 * Threshold to ensure fairness between requester and responder.
	 * If CR is less than the fairness threshold and a quota period has
	 * passed priority will be given to the path that did not last
	 * transfer data.
	 */
	uint16_t	fairness_cr_th;
	/* Log based rate reduction divider. */
	uint8_t	red_div;
	/* Threshold for rate reductions when CNPS received over last RTT. */
	uint8_t	cnp_ratio_th;
	/*
	 * Extended number of RTTS to wait, when there is no congestion,
	 * to start doubling the rate.
	 */
	uint16_t	exp_ai_rtts;
	/* Log based CR to CP ratio used in exponential increase. */
	uint8_t	exp_ai_cr_cp_ratio;
	/* Enable use of lowest 24 rate levels rate_table. */
	uint8_t	use_rate_table;
	/*
	 * Determines after how many congestion free RTTs to start
	 * updating CP to track CR.
	 */
	uint16_t	cp_exp_update_th;
	/*
	 * The threshold on congestion free RTTs above which AI can increase
	 * to 16.
	 */
	uint16_t	high_exp_ai_rtts_th1;
	/*
	 * The threshold on congestion free RTTs above which AI can increase
	 * to 32.
	 */
	uint16_t	high_exp_ai_rtts_th2;
	/*
	 * The number of congestion free RTTs above which
	 * reduction based on actual rate is enabled.
	 */
	uint16_t	actual_cr_cong_free_rtts_th;
	/*
	 * If rtts_with_cong is greater than 7 (severe congestion) and
	 * CR level post reduction is above this threshold,
	 * then TR is capped to 1.5 times CR..
	 */
	uint16_t	severe_cong_cr_th1;
	/*
	 * If rtts_with_cong is greater than 7 (severe congestion) and
	 * CR level post reduction is above this threshold,
	 * then TR is capped to 1.25 times CR..
	 */
	uint16_t	severe_cong_cr_th2;
	/*
	 * The maximum number of 64B that can be transmitted during RTT time,
	 * including all headers and Inter Packet Gap.
	 */
	uint32_t	link64B_per_rtt;
	/*
	 * The number of bytes to subtract from QPC.cc_bucket
	 * when an ack is scheduled.
	 */
	uint8_t	cc_ack_bytes;
	/*
	 * Enables reduction of CR, TR, and CP to init values when
	 * congestion free RTTs is greater than reduce2_init_cong_free_rtts_th.
	 */
	uint8_t	reduce_init_en;
	/*
	 * Minimum threshold value for number of congestion free RTTs before
	 * reducing to init values for CR, TR, and CP when reduce_init_en is
	 * enabled.
	 */
	uint16_t	reduce_init_cong_free_rtts_th;
	/* Enables random no reduction of CR. */
	uint8_t	random_no_red_en;
	/*
	 * Enables coarse correction to actual CR when actual RTT is longer
	 * than nominal.
	 */
	uint8_t	actual_cr_shift_correction_en;
	/* Enables adjustment to refill quota. */
	uint8_t	quota_period_adjust_en;
	uint8_t	reserved[5];
} cmdq_modify_roce_cc_gen1_tlv_t, *pcmdq_modify_roce_cc_gen1_tlv_t;

/* cmdq_modify_roce_cc_gen2_tlv (size:256b/32B) */

typedef struct cmdq_modify_roce_cc_gen2_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_TLV_FLAGS_REQUIRED_LAST CMDQ_MODIFY_ROCE_CC_GEN2_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	uint64_t	reserved64;
	/* Modify mask signifies the field that is requesting the change. */
	uint64_t	modify_mask;
	/*
	 * Modify the specific DCN queue level table index data.
	 * This must be set, to select the table index that needs an
	 * update.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_MODIFY_MASK_DCN_QLEVEL_TBL_IDX	UINT32_C(0x1)
	/* Modify the DCN queue level threshold. */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_MODIFY_MASK_DCN_QLEVEL_TBL_THR	UINT32_C(0x2)
	/* Modify DCN queue level current rate. */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_MODIFY_MASK_DCN_QLEVEL_TBL_CR	UINT32_C(0x4)
	/* Modify DCN queue level increment CNP count. */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_MODIFY_MASK_DCN_QLEVEL_TBL_INC_CNP	UINT32_C(0x8)
	/* Modify DCN queue level update current & target rate immediately. */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_MODIFY_MASK_DCN_QLEVEL_TBL_UPD_IMM	UINT32_C(0x10)
	/* Modify DCN queue level target rate. */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_MODIFY_MASK_DCN_QLEVEL_TBL_TR	UINT32_C(0x20)
	/* DCN queue level table index. Valid values are from 0 to 7. */
	uint8_t	dcn_qlevel_tbl_idx;
	uint8_t	reserved8;
	/*
	 * DCN queue level threshold value associated with a DCN queue
	 * level table index.
	 */
	uint16_t	dcn_qlevel_tbl_thr;
	/*
	 * DCN queue level table action.
	 * Updates CR, INC_CNP, UPD_IMM & TR fields associated with the
	 * DCN queue level table index.
	 */
	uint32_t	dcn_qlevel_tbl_act;
	/* DCN queue level current rate. */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_DCN_QLEVEL_TBL_ACT_CR_MASK	UINT32_C(0x3fff)
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_DCN_QLEVEL_TBL_ACT_CR_SFT	0
	/* DCN queue level increment CNP count. */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_DCN_QLEVEL_TBL_ACT_INC_CNP	UINT32_C(0x4000)
	/* DCN queue level update CR and TR immediately. */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_DCN_QLEVEL_TBL_ACT_UPD_IMM	UINT32_C(0x8000)
	/* DCN queue level target rate */
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_DCN_QLEVEL_TBL_ACT_TR_MASK	UINT32_C(0x3fff0000)
	#define CMDQ_MODIFY_ROCE_CC_GEN2_TLV_DCN_QLEVEL_TBL_ACT_TR_SFT	16
} cmdq_modify_roce_cc_gen2_tlv_t, *pcmdq_modify_roce_cc_gen2_tlv_t;

/* creq_modify_roce_cc_resp (size:128b/16B) */

typedef struct creq_modify_roce_cc_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MODIFY_ROCE_CC_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MODIFY_ROCE_CC_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MODIFY_ROCE_CC_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MODIFY_ROCE_CC_RESP_TYPE_LAST	CREQ_MODIFY_ROCE_CC_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MODIFY_ROCE_CC_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Modify congestion control response. */
	#define CREQ_MODIFY_ROCE_CC_RESP_EVENT_MODIFY_ROCE_CC UINT32_C(0x8c)
	#define CREQ_MODIFY_ROCE_CC_RESP_EVENT_LAST	CREQ_MODIFY_ROCE_CC_RESP_EVENT_MODIFY_ROCE_CC
	uint8_t	reserved48[6];
} creq_modify_roce_cc_resp_t, *pcreq_modify_roce_cc_resp_t;

/******************************
 * cmdq_set_link_aggr_mode_cc *
 ******************************/


/* cmdq_set_link_aggr_mode_cc (size:320b/40B) */

typedef struct cmdq_set_link_aggr_mode_cc {
	/* Command opcode. */
	uint8_t	opcode;
	/* Set LAG mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_OPCODE_SET_LINK_AGGR_MODE UINT32_C(0x8f)
	#define CMDQ_SET_LINK_AGGR_MODE_OPCODE_LAST		CMDQ_SET_LINK_AGGR_MODE_OPCODE_SET_LINK_AGGR_MODE
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* Enable Link aggregation. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_AGGR_EN		UINT32_C(0x1)
	/* Bitmap of ports that are eligible to transmit RoCE traffic. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_ACTIVE_PORT_MAP	UINT32_C(0x2)
	/* Bitmap of ports that are members of the RoCE LAG. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_MEMBER_PORT_MAP	UINT32_C(0x4)
	/* Link aggregation mode being used. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_AGGR_MODE	UINT32_C(0x8)
	/* Stat context ID for all the ports. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_STAT_CTX_ID	UINT32_C(0x10)
	uint8_t	aggr_enable;
	/* Enable Link aggregation. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_ENABLE	UINT32_C(0x1)
	/* rsvd1 is 7 b */
	#define CMDQ_SET_LINK_AGGR_MODE_RSVD1_MASK	UINT32_C(0xfe)
	#define CMDQ_SET_LINK_AGGR_MODE_RSVD1_SFT	1
	uint8_t	active_port_map;
	/* Bitmap of ports that are eligible to transmit RoCE traffic. */
	#define CMDQ_SET_LINK_AGGR_MODE_ACTIVE_PORT_MAP_MASK UINT32_C(0xf)
	#define CMDQ_SET_LINK_AGGR_MODE_ACTIVE_PORT_MAP_SFT 0
	/* rsvd2 is 4 b */
	#define CMDQ_SET_LINK_AGGR_MODE_RSVD2_MASK	UINT32_C(0xf0)
	#define CMDQ_SET_LINK_AGGR_MODE_RSVD2_SFT	4
	/* Bitmap of ports that are members of the RoCE LAG. */
	uint8_t	member_port_map;
	/* Link aggregation mode being used. */
	uint8_t	link_aggr_mode;
	/* active active mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_ACTIVE_ACTIVE UINT32_C(0x1)
	/* active backup mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_ACTIVE_BACKUP UINT32_C(0x2)
	/* Balance XOR mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_BALANCE_XOR   UINT32_C(0x3)
	/* 802.3AD mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_802_3_AD	UINT32_C(0x4)
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_LAST	CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_802_3_AD
	/* Stat context IDs for all 4 ports. */
	uint16_t	stat_ctx_id[4];
	uint64_t	rsvd1;
} cmdq_set_link_aggr_mode_cc_t, *pcmdq_set_link_aggr_mode_cc_t;

/* creq_set_link_aggr_mode_resources_resp (size:128b/16B) */

typedef struct creq_set_link_aggr_mode_resources_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_LAST	CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_SET_LINK_AGGR_MODE_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Set LAG mode. */
	#define CREQ_SET_LINK_AGGR_MODE_RESP_EVENT_SET_LINK_AGGR_MODE UINT32_C(0x8f)
	#define CREQ_SET_LINK_AGGR_MODE_RESP_EVENT_LAST		CREQ_SET_LINK_AGGR_MODE_RESP_EVENT_SET_LINK_AGGR_MODE
	uint8_t	reserved48[6];
} creq_set_link_aggr_mode_resources_resp_t, *pcreq_set_link_aggr_mode_resources_resp_t;

/* Send a request from VF to pass a command to the PF. VF HSI is suspended. */
/* cmdq_vf_backchannel_request (size:256b/32B) */

typedef struct cmdq_vf_backchannel_request {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Send a request from VF to pass a command to the PF. VF HSI is
	 * suspended until the PF returns the response.
	 */
	#define CMDQ_VF_BACKCHANNEL_REQUEST_OPCODE_VF_BACKCHANNEL_REQUEST UINT32_C(0x86)
	#define CMDQ_VF_BACKCHANNEL_REQUEST_OPCODE_LAST		CMDQ_VF_BACKCHANNEL_REQUEST_OPCODE_VF_BACKCHANNEL_REQUEST
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Address of command request structure in VF space */
	uint64_t	command_addr;
	/*
	 * Command request length (up to 4K). An optional address of the extended
	 * response buffer should be provided in the request.
	 */
	uint16_t	command_length;
	uint8_t	unused_0[6];
} cmdq_vf_backchannel_request_t, *pcmdq_vf_backchannel_request_t;

/* Read VF memory (primarily to get the backchannel request blob). */
/* cmdq_read_vf_memory (size:256b/32B) */

typedef struct cmdq_read_vf_memory {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Read VF memory (primarily to get the backchannel request blob). Can
	 * only be issued from a PF.
	 */
	#define CMDQ_READ_VF_MEMORY_OPCODE_READ_VF_MEMORY UINT32_C(0x87)
	#define CMDQ_READ_VF_MEMORY_OPCODE_LAST	CMDQ_READ_VF_MEMORY_OPCODE_READ_VF_MEMORY
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Address of memory in VF space to read */
	uint64_t	addr;
	/* VF id, as provided in 0xC0 VF request notification */
	uint16_t	vf_id;
	/* Length to read, up to 4K */
	uint16_t	length;
	uint32_t	unused_0;
} cmdq_read_vf_memory_t, *pcmdq_read_vf_memory_t;

/* Write VF memory (primarily to put the backchannel response blob). */
/* cmdq_complete_vf_request (size:320b/40B) */

typedef struct cmdq_complete_vf_request {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Write VF memory (primarily to put the backchannel response blob),
	 * and reenable VF HSI (post a CAG completion to it). Can only be
	 * issued from a PF.
	 */
	#define CMDQ_COMPLETE_VF_REQUEST_OPCODE_COMPLETE_VF_REQUEST UINT32_C(0x88)
	#define CMDQ_COMPLETE_VF_REQUEST_OPCODE_LAST		CMDQ_COMPLETE_VF_REQUEST_OPCODE_COMPLETE_VF_REQUEST
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/*
	 * Optional address of extended response in VF space to write. Length is
	 * in resp_size in 16 byte units.
	 */
	uint64_t	addr;
	/* Completion misc field to VF CREQ */
	uint32_t	vf_misc;
	/* VF id, as provided in 0xC0 VF request notification */
	uint16_t	vf_id;
	/* Completion cookie for the VF command, goes to VF CREQ */
	uint16_t	vf_cookie;
	/* Completion status for the VF command, goes to VF CREQ */
	uint8_t	vf_status;
	uint8_t	unused_0[3];
	uint32_t	unused_1;
} cmdq_complete_vf_request_t, *pcmdq_complete_vf_request_t;

/*****************************
 * orchestrate_qid_migration *
 *****************************/


/* cmdq_orchestrate_qid_migration (size:256b/32B) */

typedef struct cmdq_orchestrate_qid_migration {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * This command updates the QP context id ranges on the PF,
	 * to orchestrate QP context id range migration for devices that
	 * support the pseudo-static QP allocation feature.
	 */
	#define CMDQ_ORCHESTRATE_QID_MIGRATION_OPCODE_ORCHESTRATE_QID_MIGRATION UINT32_C(0x93)
	#define CMDQ_ORCHESTRATE_QID_MIGRATION_OPCODE_LAST			CMDQ_ORCHESTRATE_QID_MIGRATION_OPCODE_ORCHESTRATE_QID_MIGRATION
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	uint8_t	qid_migration_flags;
	/* Flags to orchestrate QP context ID range migration amongst PFs. */
	#define CMDQ_ORCHESTRATE_QID_MIGRATION_QID_MIGRATION_FLAGS_MASK			UINT32_C(0xf)
	#define CMDQ_ORCHESTRATE_QID_MIGRATION_QID_MIGRATION_FLAGS_SFT			0
	/* Enable the PF's native QP context ID range. */
		#define CMDQ_ORCHESTRATE_QID_MIGRATION_QID_MIGRATION_FLAGS_ENABLE_NATIVE_QID_RANGE	UINT32_C(0x0)
	/* Enable the PF's extended QP context ID range. */
		#define CMDQ_ORCHESTRATE_QID_MIGRATION_QID_MIGRATION_FLAGS_ENABLE_EXTENDED_QID_RANGE   UINT32_C(0x1)
	/* Disable the PF's native QP context ID range. */
		#define CMDQ_ORCHESTRATE_QID_MIGRATION_QID_MIGRATION_FLAGS_DISABLE_NATIVE_QID_RANGE	UINT32_C(0x2)
	/* Disable the PF's extended QP context ID range. */
		#define CMDQ_ORCHESTRATE_QID_MIGRATION_QID_MIGRATION_FLAGS_DISABLE_EXTENDED_QID_RANGE  UINT32_C(0x3)
		#define CMDQ_ORCHESTRATE_QID_MIGRATION_QID_MIGRATION_FLAGS_LAST			CMDQ_ORCHESTRATE_QID_MIGRATION_QID_MIGRATION_FLAGS_DISABLE_EXTENDED_QID_RANGE
	/* unused4 is 4 b */
	#define CMDQ_ORCHESTRATE_QID_MIGRATION_UNUSED4_MASK				UINT32_C(0xf0)
	#define CMDQ_ORCHESTRATE_QID_MIGRATION_UNUSED4_SFT				4
	uint8_t	reserved56[7];
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_orchestrate_qid_migration_t, *pcmdq_orchestrate_qid_migration_t;

/* creq_orchestrate_qid_migration_resp (size:128b/16B) */

typedef struct creq_orchestrate_qid_migration_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_ORCHESTRATE_QID_MIGRATION_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_ORCHESTRATE_QID_MIGRATION_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_ORCHESTRATE_QID_MIGRATION_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_ORCHESTRATE_QID_MIGRATION_RESP_TYPE_LAST	CREQ_ORCHESTRATE_QID_MIGRATION_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_ORCHESTRATE_QID_MIGRATION_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Orchestrate QPID migration command response. */
	#define CREQ_ORCHESTRATE_QID_MIGRATION_RESP_EVENT_ORCHESTRATE_QID_MIGRATION UINT32_C(0x93)
	#define CREQ_ORCHESTRATE_QID_MIGRATION_RESP_EVENT_LAST			CREQ_ORCHESTRATE_QID_MIGRATION_RESP_EVENT_ORCHESTRATE_QID_MIGRATION
	uint8_t	reserved48[6];
} creq_orchestrate_qid_migration_resp_t, *pcreq_orchestrate_qid_migration_resp_t;

/*******************
 * create_qp_batch *
 *******************/


/* cmdq_create_qp_batch (size:384b/48B) */

typedef struct cmdq_create_qp_batch {
	/* Command opcode. */
	uint8_t	opcode;
	/* This command allocates a batch of QPs in a sequential range. */
	#define CMDQ_CREATE_QP_BATCH_OPCODE_CREATE_QP_BATCH UINT32_C(0x94)
	#define CMDQ_CREATE_QP_BATCH_OPCODE_LAST	CMDQ_CREATE_QP_BATCH_OPCODE_CREATE_QP_BATCH
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Starting QP context id to be used for the sequential range. */
	uint32_t	start_xid;
	/* Count of QPs to be allocated */
	uint32_t	count;
	/* Size of an individual element of the qp_params_array. */
	uint32_t	per_qp_param_size;
	uint32_t	reserved32;
	/*
	 * Host DMA address of the array of per-QP parameters.
	 * Per-QP parameters are identical to those of the
	 * `create_qp` command and specified by the
	 * `create_qp_batch_data` structure.
	 */
	uint64_t	qp_params_array;
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_create_qp_batch_t, *pcmdq_create_qp_batch_t;

/* creq_create_qp_batch_resp (size:128b/16B) */

typedef struct creq_create_qp_batch_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_QP_BATCH_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_QP_BATCH_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_QP_BATCH_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_QP_BATCH_RESP_TYPE_LAST	CREQ_CREATE_QP_BATCH_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_QP_BATCH_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create batch QPs command response. */
	#define CREQ_CREATE_QP_BATCH_RESP_EVENT_CREATE_QP_BATCH UINT32_C(0x94)
	#define CREQ_CREATE_QP_BATCH_RESP_EVENT_LAST	CREQ_CREATE_QP_BATCH_RESP_EVENT_CREATE_QP_BATCH
	uint16_t	reserved16;
	/* Count of QPs successfully created. */
	uint32_t	count;
} creq_create_qp_batch_resp_t, *pcreq_create_qp_batch_resp_t;

/********************
 * destroy_qp_batch *
 ********************/


/* cmdq_destroy_qp_batch (size:256b/32B) */

typedef struct cmdq_destroy_qp_batch {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * This command deletes the batch of requested count of QPs.
	 * The starting QP ID can be specified to request a batch deletion
	 * of a sequential range.
	 */
	#define CMDQ_DESTROY_QP_BATCH_OPCODE_DESTROY_QP_BATCH UINT32_C(0x95)
	#define CMDQ_DESTROY_QP_BATCH_OPCODE_LAST		CMDQ_DESTROY_QP_BATCH_OPCODE_DESTROY_QP_BATCH
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Starting QP context id to be used for the sequential range. */
	uint32_t	start_xid;
	/*
	 * Count of QPs to be deleted. A value of zero implies all QPs
	 * are to be deleted.
	 */
	uint32_t	count;
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_destroy_qp_batch_t, *pcmdq_destroy_qp_batch_t;

/* creq_destroy_qp_batch_resp (size:128b/16B) */

typedef struct creq_destroy_qp_batch_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_QP_BATCH_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_QP_BATCH_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_QP_BATCH_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_QP_BATCH_RESP_TYPE_LAST	CREQ_DESTROY_QP_BATCH_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_QP_BATCH_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy batch QPs command response. */
	#define CREQ_DESTROY_QP_BATCH_RESP_EVENT_DESTROY_QP_BATCH UINT32_C(0x95)
	#define CREQ_DESTROY_QP_BATCH_RESP_EVENT_LAST		CREQ_DESTROY_QP_BATCH_RESP_EVENT_DESTROY_QP_BATCH
	uint16_t	reserved16;
	/* Count of QPs successfully destroyed. */
	uint32_t	count;
} creq_destroy_qp_batch_resp_t, *pcreq_destroy_qp_batch_resp_t;

/*******************************
 * allocate_roce_stats_ext_ctx *
 *******************************/


/* cmdq_allocate_roce_stats_ext_ctx (size:256b/32B) */

typedef struct cmdq_allocate_roce_stats_ext_ctx {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * This command allocates an extended RoCE statistics context
	 * that supports periodic DMA to a host address. The extended
	 * statistics context id can be assigned by the driver,
	 * via `create_qp`, `create_qp_batch` or `modify_qp` to a
	 * specific QP, a subset of QPs or to all QPs of a specific function.
	 * These statistics can be queried via `query_roce_stats_ext_v2`.
	 */
	#define CMDQ_ALLOCATE_ROCE_STATS_EXT_CTX_OPCODE_ALLOCATE_ROCE_STATS_EXT_CTX UINT32_C(0x96)
	#define CMDQ_ALLOCATE_ROCE_STATS_EXT_CTX_OPCODE_LAST			CMDQ_ALLOCATE_ROCE_STATS_EXT_CTX_OPCODE_ALLOCATE_ROCE_STATS_EXT_CTX
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/*
	 * This is the address to be programmed in the statistic block
	 * by the firmware to support periodic DMA of the statistics.
	 */
	uint64_t	stats_dma_addr;
	/*
	 * The statistic block update period in ms.
	 * e.g. 250ms, 500ms, 750ms, 1000ms.
	 * If update_period_ms is 0, then the stats update
	 * shall be never done and the DMA address shall not be used.
	 * In this case, the statistics can only be read by
	 * `query_roce_stats_ext_v2` command.
	 */
	uint32_t	update_period_ms;
	/* Steering tag to use for memory transactions. */
	uint16_t	steering_tag;
	uint16_t	reserved16;
} cmdq_allocate_roce_stats_ext_ctx_t, *pcmdq_allocate_roce_stats_ext_ctx_t;

/* creq_allocate_roce_stats_ext_ctx_resp (size:128b/16B) */

typedef struct creq_allocate_roce_stats_ext_ctx_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_LAST	CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Extended RoCE statistics context id. */
	uint32_t	roce_stats_ext_xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Allocate extended RoCE statistics context command response. */
	#define CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_EVENT_ALLOCATE_ROCE_STATS_EXT_CTX UINT32_C(0x96)
	#define CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_EVENT_LAST			CREQ_ALLOCATE_ROCE_STATS_EXT_CTX_RESP_EVENT_ALLOCATE_ROCE_STATS_EXT_CTX
	uint8_t	reserved48[6];
} creq_allocate_roce_stats_ext_ctx_resp_t, *pcreq_allocate_roce_stats_ext_ctx_resp_t;

/*********************************
 * deallocate_roce_stats_ext_ctx *
 *********************************/


/* cmdq_deallocate_roce_stats_ext_ctx (size:256b/32B) */

typedef struct cmdq_deallocate_roce_stats_ext_ctx {
	/* Command opcode. */
	uint8_t	opcode;
	/* This command deallocates an extended RoCE statistics context. */
	#define CMDQ_DEALLOCATE_ROCE_STATS_EXT_CTX_OPCODE_DEALLOCATE_ROCE_STATS_EXT_CTX UINT32_C(0x97)
	#define CMDQ_DEALLOCATE_ROCE_STATS_EXT_CTX_OPCODE_LAST			CMDQ_DEALLOCATE_ROCE_STATS_EXT_CTX_OPCODE_DEALLOCATE_ROCE_STATS_EXT_CTX
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Extended RoCE statistics context id. */
	uint32_t	roce_stats_ext_xid;
	uint32_t	reserved32;
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_deallocate_roce_stats_ext_ctx_t, *pcmdq_deallocate_roce_stats_ext_ctx_t;

/* creq_deallocate_roce_stats_ext_ctx_resp (size:128b/16B) */

typedef struct creq_deallocate_roce_stats_ext_ctx_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_LAST	CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Extended RoCE statistics context id. */
	uint32_t	roce_stats_ext_xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Deallocate extended RoCE statistics context command response. */
	#define CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_EVENT_DEALLOCATE_ROCE_STATS_EXT_CTX UINT32_C(0x97)
	#define CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_EVENT_LAST			CREQ_DEALLOCATE_ROCE_STATS_EXT_CTX_RESP_EVENT_DEALLOCATE_ROCE_STATS_EXT_CTX
	uint8_t	reserved48[6];
} creq_deallocate_roce_stats_ext_ctx_resp_t, *pcreq_deallocate_roce_stats_ext_ctx_resp_t;

/***************************
 * query_roce_stats_ext_v2 *
 ***************************/


/* cmdq_query_roce_stats_ext_v2 (size:256b/32B) */

typedef struct cmdq_query_roce_stats_ext_v2 {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Query extended RoCE statistics for devices that support
	 * `roce_stats_ext_ctx_supported` feature.
	 */
	#define CMDQ_QUERY_ROCE_STATS_EXT_V2_OPCODE_QUERY_ROCE_STATS_EXT_V2 UINT32_C(0x98)
	#define CMDQ_QUERY_ROCE_STATS_EXT_V2_OPCODE_LAST		CMDQ_QUERY_ROCE_STATS_EXT_V2_OPCODE_QUERY_ROCE_STATS_EXT_V2
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Extended RoCE statistics context id. */
	uint32_t	roce_stats_ext_xid;
	uint32_t	reserved32;
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_query_roce_stats_ext_v2_t, *pcmdq_query_roce_stats_ext_v2_t;

/* creq_query_roce_stats_ext_v2_resp (size:128b/16B) */

typedef struct creq_query_roce_stats_ext_v2_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_TYPE_LAST	CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query extended RoCE statistics v2. */
	#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_EVENT_QUERY_ROCE_STATS_EXT_V2 UINT32_C(0x98)
	#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_EVENT_LAST		CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_EVENT_QUERY_ROCE_STATS_EXT_V2
	uint8_t	reserved48[6];
} creq_query_roce_stats_ext_v2_resp_t, *pcreq_query_roce_stats_ext_v2_resp_t;

/* Query extended RoCE Stats command response side buffer structure. */
/* creq_query_roce_stats_ext_v2_resp_sb (size:1920b/240B) */

typedef struct creq_query_roce_stats_ext_v2_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query extended RoCE statistics v2. */
	#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_SB_OPCODE_QUERY_ROCE_STATS_EXT_V2 UINT32_C(0x98)
	#define CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_SB_OPCODE_LAST		CREQ_QUERY_ROCE_STATS_EXT_V2_RESP_SB_OPCODE_QUERY_ROCE_STATS_EXT_V2
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	rsvd;
	/* Number of transmitted Atomic request packets without errors. */
	uint64_t	tx_atomic_req_pkts;
	/* Number of transmitted Read request packets without errors. */
	uint64_t	tx_read_req_pkts;
	/* Number of transmitted Read response packets without errors. */
	uint64_t	tx_read_res_pkts;
	/* Number of transmitted Write request packets without errors. */
	uint64_t	tx_write_req_pkts;
	/* Number of transmitted RC Send packets without errors. */
	uint64_t	tx_rc_send_req_pkts;
	/*
	 * Number of transmitted UD Send (including QP1) packets
	 * without errors.
	 */
	uint64_t	tx_ud_send_req_pkts;
	/* Number of transmitted CNPs. Includes DCN_CNPs. */
	uint64_t	tx_cnp_pkts;
	/*
	 * Number of transmitted RoCE packets.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	tx_roce_pkts;
	/*
	 * Number of transmitted RoCE header and payload bytes.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	tx_roce_bytes;
	/*
	 * Number of drops that occurred to lack of buffers.
	 * This count includes RC sends, RC writes with immediate,
	 * UD sends, RawEth, and QP1 packets dropped due to lack of buffers.
	 */
	uint64_t	rx_out_of_buffer_pkts;
	/* Number of packets that were received out of sequence. */
	uint64_t	rx_out_of_sequence_pkts;
	/*
	 * Number of duplicate read/atomic requests resulting in responder
	 * hardware retransmission.
	 */
	uint64_t	dup_req;
	/*
	 * Number of missing response packets resulting in hardware
	 * retransmission.
	 */
	uint64_t	missing_resp;
	/*
	 * Number of sequence error NAKs received resulting in hardware
	 * retransmission.
	 */
	uint64_t	seq_err_naks_rcvd;
	/* Number of RNR NAKs received resulting in hardware retransmission. */
	uint64_t	rnr_naks_rcvd;
	/* Number of timeouts resulting in hardware retransmission. */
	uint64_t	to_retransmits;
	/* Number of received Atomic request packets without errors. */
	uint64_t	rx_atomic_req_pkts;
	/* Number of received Read request packets without errors. */
	uint64_t	rx_read_req_pkts;
	/* Number of received Read response packets without errors. */
	uint64_t	rx_read_res_pkts;
	/* Number of received Write request packets without errors. */
	uint64_t	rx_write_req_pkts;
	/* Number of received RC Send packets without errors. */
	uint64_t	rx_rc_send_pkts;
	/* Number of received UD Send packets without errors. */
	uint64_t	rx_ud_send_pkts;
	/* Number of received DCN payload cut packets. */
	uint64_t	rx_dcn_payload_cut;
	/* Number of received ECN-marked packets. */
	uint64_t	rx_ecn_marked_pkts;
	/* Number of received CNP packets. Includes DCN_CNPs. */
	uint64_t	rx_cnp_pkts;
	/*
	 * Number of received RoCE packets including RoCE packets with errors.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	rx_roce_pkts;
	/*
	 * Number of received RoCE header and payload bytes including RoCE
	 * packets with errors.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	rx_roce_bytes;
	/*
	 * Number of received RoCE packets without errors.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	rx_roce_good_pkts;
	/*
	 * Number of received RoCE header and payload bytes without errors.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	rx_roce_good_bytes;
} creq_query_roce_stats_ext_v2_resp_sb_t, *pcreq_query_roce_stats_ext_v2_resp_sb_t;

/* RoCE function async event notifications. */
/* creq_func_event (size:128b/16B) */

typedef struct creq_func_event {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_FUNC_EVENT_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_FUNC_EVENT_TYPE_SFT	0
	/* Function Async Notification */
		#define CREQ_FUNC_EVENT_TYPE_FUNC_EVENT  UINT32_C(0x3a)
		#define CREQ_FUNC_EVENT_TYPE_LAST	CREQ_FUNC_EVENT_TYPE_FUNC_EVENT
	uint8_t	reserved56[7];
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_FUNC_EVENT_V	UINT32_C(0x1)
	/*
	 * This value defines what type of async event has occurred
	 * on the function.
	 */
	uint8_t	event;
	/*
	 * Invalid PBL or PCIE UR response occurred
	 * in SQ WQE or IRRQ read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_TX_WQE_ERROR	UINT32_C(0x1)
	/*
	 * Invalid PBL or PCIE UR response occurred
	 * during data read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_TX_DATA_ERROR	UINT32_C(0x2)
	/*
	 * Invalid PBL or PCIE UR response occurred
	 * in RQ/SRQ WQE or ORRQ read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_RX_WQE_ERROR	UINT32_C(0x3)
	/* Invalid PBL occurred during data write access. */
	#define CREQ_FUNC_EVENT_EVENT_RX_DATA_ERROR	UINT32_C(0x4)
	/* Invalid PBL occurred during CQ write access. */
	#define CREQ_FUNC_EVENT_EVENT_CQ_ERROR	UINT32_C(0x5)
	/*
	 * Invalid PBL or PCIE UR response occurred in TQM
	 * read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_TQM_ERROR	UINT32_C(0x6)
	/* PCIE UR response occurred in CFC read access. */
	#define CREQ_FUNC_EVENT_EVENT_CFCQ_ERROR	UINT32_C(0x7)
	/* PCIE UR response occurred in CFC read access. */
	#define CREQ_FUNC_EVENT_EVENT_CFCS_ERROR	UINT32_C(0x8)
	/* PCIE UR response occurred in CFC read access. */
	#define CREQ_FUNC_EVENT_EVENT_CFCC_ERROR	UINT32_C(0x9)
	/* PCIE UR response occurred in CFC read access. */
	#define CREQ_FUNC_EVENT_EVENT_CFCM_ERROR	UINT32_C(0xa)
	/*
	 * Invalid PBL or
	 * PCIE UR response
	 * occurred on timer read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_TIM_ERROR	UINT32_C(0xb)
	/* A VF sent a backchannel command request */
	#define CREQ_FUNC_EVENT_EVENT_VF_COMM_REQUEST	UINT32_C(0x80)
	/*
	 * Communication resource (QPC, CQ, SRQ, MRW) exhausted, and resource
	 * array extension is enabled.
	 */
	#define CREQ_FUNC_EVENT_EVENT_RESOURCE_EXHAUSTED UINT32_C(0x81)
	#define CREQ_FUNC_EVENT_EVENT_LAST		CREQ_FUNC_EVENT_EVENT_RESOURCE_EXHAUSTED
	uint8_t	reserved48[6];
} creq_func_event_t, *pcreq_func_event_t;

/* RoCE slowpath command completion events. */
/* creq_qp_event (size:128b/16B) */

typedef struct creq_qp_event {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QP_EVENT_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QP_EVENT_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QP_EVENT_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QP_EVENT_TYPE_LAST	CREQ_QP_EVENT_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Success. */
	#define CREQ_QP_EVENT_STATUS_SUCCESS	UINT32_C(0x0)
	/* Fail. */
	#define CREQ_QP_EVENT_STATUS_FAIL		UINT32_C(0x1)
	/* Resources. */
	#define CREQ_QP_EVENT_STATUS_RESOURCES	UINT32_C(0x2)
	/* Invalid command. */
	#define CREQ_QP_EVENT_STATUS_INVALID_CMD	UINT32_C(0x3)
	/* Not implemented. */
	#define CREQ_QP_EVENT_STATUS_NOT_IMPLEMENTED   UINT32_C(0x4)
	/* Invalid parameter. */
	#define CREQ_QP_EVENT_STATUS_INVALID_PARAMETER UINT32_C(0x5)
	/* Hardware operation failed. */
	#define CREQ_QP_EVENT_STATUS_HARDWARE_ERROR	UINT32_C(0x6)
	/* Firmware operation failed due to internal error. */
	#define CREQ_QP_EVENT_STATUS_INTERNAL_ERROR	UINT32_C(0x7)
	#define CREQ_QP_EVENT_STATUS_LAST		CREQ_QP_EVENT_STATUS_INTERNAL_ERROR
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QP_EVENT_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create QP command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_QP		UINT32_C(0x1)
	/* Destroy QP command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_QP		UINT32_C(0x2)
	/* Modify QP command response. */
	#define CREQ_QP_EVENT_EVENT_MODIFY_QP		UINT32_C(0x3)
	/* Query QP command response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_QP		UINT32_C(0x4)
	/* Create SRQ command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_SRQ		UINT32_C(0x5)
	/* Destroy SRQ command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_SRQ	UINT32_C(0x6)
	/* Query SRQ command response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_SRQ		UINT32_C(0x8)
	/* Create CQ command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_CQ		UINT32_C(0x9)
	/* Destroy CQ command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_CQ		UINT32_C(0xa)
	/* Resize CQ command response. */
	#define CREQ_QP_EVENT_EVENT_RESIZE_CQ		UINT32_C(0xc)
	/* Allocate MRW command response. */
	#define CREQ_QP_EVENT_EVENT_ALLOCATE_MRW	UINT32_C(0xd)
	/* De-allocate key command response. */
	#define CREQ_QP_EVENT_EVENT_DEALLOCATE_KEY	UINT32_C(0xe)
	/* Register MR command response. */
	#define CREQ_QP_EVENT_EVENT_REGISTER_MR	UINT32_C(0xf)
	/* Deregister MR command response. */
	#define CREQ_QP_EVENT_EVENT_DEREGISTER_MR	UINT32_C(0x10)
	/* Add GID command response. */
	#define CREQ_QP_EVENT_EVENT_ADD_GID		UINT32_C(0x11)
	/* Delete GID command response. */
	#define CREQ_QP_EVENT_EVENT_DELETE_GID		UINT32_C(0x12)
	/* Modify GID command response. */
	#define CREQ_QP_EVENT_EVENT_MODIFY_GID		UINT32_C(0x17)
	/* Query GID command response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_GID		UINT32_C(0x18)
	/* Create QP1 command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_QP1		UINT32_C(0x13)
	/* Destroy QP1 command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_QP1	UINT32_C(0x14)
	/* Create AH command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_AH		UINT32_C(0x15)
	/* Destroy AH command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_AH		UINT32_C(0x16)
	/* Initialize firmware command response. */
	#define CREQ_QP_EVENT_EVENT_INITIALIZE_FW	UINT32_C(0x80)
	/* De-initialize firmware command response. */
	#define CREQ_QP_EVENT_EVENT_DEINITIALIZE_FW	UINT32_C(0x81)
	/* Stop PF command response. */
	#define CREQ_QP_EVENT_EVENT_STOP_FUNC		UINT32_C(0x82)
	/* Query info PF command response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_FUNC		UINT32_C(0x83)
	/* Set function resources command response. */
	#define CREQ_QP_EVENT_EVENT_SET_FUNC_RESOURCES	UINT32_C(0x84)
	/*
	 * Read the current state of any internal resource context. Can only be
	 * issued from a PF.
	 */
	#define CREQ_QP_EVENT_EVENT_READ_CONTEXT	UINT32_C(0x85)
	/* Map TC to COS response. */
	#define CREQ_QP_EVENT_EVENT_MAP_TC_TO_COS	UINT32_C(0x8a)
	/* Query firmware and interface version response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_VERSION	UINT32_C(0x8b)
	/* Modify congestion control response. */
	#define CREQ_QP_EVENT_EVENT_MODIFY_CC		UINT32_C(0x8c)
	/* Query congestion control response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_CC		UINT32_C(0x8d)
	/* Query RoCE statistics. */
	#define CREQ_QP_EVENT_EVENT_QUERY_ROCE_STATS	UINT32_C(0x8e)
	/* Set LAG mode. */
	#define CREQ_QP_EVENT_EVENT_SET_LINK_AGGR_MODE	UINT32_C(0x8f)
	/*
	 * Query QP for a PF other than the requesting PF. Also can query for
	 * more than one QP.
	 */
	#define CREQ_QP_EVENT_EVENT_QUERY_QP_EXTEND	UINT32_C(0x91)
	/* QP error notification event. */
	#define CREQ_QP_EVENT_EVENT_QP_ERROR_NOTIFICATION UINT32_C(0xc0)
	/* CQ error notification event. */
	#define CREQ_QP_EVENT_EVENT_CQ_ERROR_NOTIFICATION UINT32_C(0xc1)
	#define CREQ_QP_EVENT_EVENT_LAST		CREQ_QP_EVENT_EVENT_CQ_ERROR_NOTIFICATION
	uint8_t	reserved48[6];
} creq_qp_event_t, *pcreq_qp_event_t;

/* QP error notification event. */
/* creq_qp_error_notification (size:128b/16B) */

typedef struct creq_qp_error_notification {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QP_ERROR_NOTIFICATION_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QP_ERROR_NOTIFICATION_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QP_ERROR_NOTIFICATION_TYPE_LAST	CREQ_QP_ERROR_NOTIFICATION_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* requestor slow path state */
	uint8_t	req_slow_path_state;
	/* requestor error reason */
	uint8_t	req_err_state_reason;
	/* No error. */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_NO_ERROR			UINT32_C(0x0)
	/*
	 * Requester detected opcode error.
	 * * First, only, middle, last for incoming RDMA read
	 *   responses are improperly ordered with respect to previous
	 *   (PSN) packet.
	 * * First or middle packet is not full MTU size.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_OPCODE_ERROR		UINT32_C(0x1)
	/*
	 * Transport timeout retry limit exceeded.
	 * The requestor retried the same unacked PSN request packet
	 * too many times.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_TIMEOUT_RETRY_LIMIT	UINT32_C(0x2)
	/*
	 * RNR NAK retry limit exceeded.
	 * The requestor received an RNR NAK with the same NAK PSN
	 * too many times.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_RNR_TIMEOUT_RETRY_LIMIT UINT32_C(0x3)
	/*
	 * NAK arrival, When NAK code is 1, Invalid Request.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_NAK_ARRIVAL_1	UINT32_C(0x4)
	/*
	 * NAK arrival, When NAK code is 2, Remote Access Error.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_NAK_ARRIVAL_2	UINT32_C(0x5)
	/*
	 * NAK arrival, When NAK code is 3, Remote Operational Error.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_NAK_ARRIVAL_3	UINT32_C(0x6)
	/*
	 * NAK arrival. When NAK code is 4, Invalid RD Request.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_NAK_ARRIVAL_4	UINT32_C(0x7)
	/*
	 * Local memory error.
	 * An SGE described an inaccessible memory.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_RX_MEMORY_ERROR	UINT32_C(0x8)
	/*
	 * Local memory error.
	 * An SGE described an inaccessible memory.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_TX_MEMORY_ERROR	UINT32_C(0x9)
	/*
	 * Read response length error.
	 * The read response payload size does not match the read
	 * length of the request.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_READ_RESP_LENGTH	UINT32_C(0xa)
	/*
	 * Invalid read response.
	 * A read response arrived and had a PSN that was not in the
	 * reply range of any outstanding read request on the ORRQ.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_INVALID_READ_RESP	UINT32_C(0xb)
	/*
	 * Illegal bind.
	 * * No MW with the specified R_Key exists.
	 * * No MR with the specified L_Key exists.
	 * * A bind request was performed on a window that was already
	 *   bound.
	 * * A bind request was performed for an underlying MR that
	 *   is not registered.
	 * * A bind request was performed for a memory area that exceeds
	 *   the range of the underlying MR.
	 * * A bind request was performed with a set of permissions
	 *   that are looser than the permissions of the underlying MR.
	 * * Domain error MW - When QP's PD does not match MW PD.
	 * * Domain error MR - When QP's PD does not match parent MR's
	 *   PD.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_ILLEGAL_BIND		UINT32_C(0xc)
	/*
	 * Illegal fast register.
	 * * No MR with the specified L_Key exists.
	 * * A fast register request was performed on a non-
	 *   physical MR.
	 * * A fast register request was performed on a physical MR
	 *   that is already registered.
	 * * A fast register request was performed on a physical MR
	 *   that does not have a page list allocated (has not been
	 *   initialized).
	 * * The number of pages being registered exceeds the capacity
	 *   of the physical MR.
	 * * The length of the registration is not possible with the
	 *   actual number of pages provided.
	 * * Domain error - when QP's PD does not match PMR PD.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_ILLEGAL_FAST_REG	UINT32_C(0xd)
	/*
	 * Illegal invalidate.
	 * * No MR with the specified L_Key exists.
	 * * No MW with the specified R_Key exists.
	 * * An invalidate was performed against a non-physical MR.
	 * * An invalidate was performed against a physical MR that
	 *   is not registered.
	 * * An invalidate was performed against a MW that is not
	 *   bound.
	 * * The PD of the MR/MW being invalidated does not match the PD
	 *   of the QP.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_ILLEGAL_INVALIDATE	UINT32_C(0xe)
	/*
	 * Completion Error.
	 * No CQE space available on queue, or CQ not in VALID state.
	 * This is a Completion Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_CMP_ERROR		UINT32_C(0xf)
	/*
	 * Local memory error while retransmitting WQE.
	 * An SQ SGE described an inaccessible memory.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_RETRAN_LOCAL_ERROR	UINT32_C(0x10)
	/*
	 * Problem found in the format of a WQE in the SQ.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_WQE_FORMAT_ERROR	UINT32_C(0x11)
	/*
	 * Problem was found in the format of an ORRQ entry.
	 * This is a RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_ORRQ_FORMAT_ERROR	UINT32_C(0x12)
	/*
	 * A UD send attempted to use an invalid AVID.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_INVALID_AVID_ERROR	UINT32_C(0x13)
	/*
	 * A UD send attempted to use an AVID that is outside of its
	 * QP's protection domain.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_AV_DOMAIN_ERROR	UINT32_C(0x14)
	/*
	 * A load error occurred on an attempt to load the CQ Context.
	 * This is a Completion Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_CQ_LOAD_ERROR	UINT32_C(0x15)
	/*
	 * There was an attempt to process a WQE from the SQ that
	 * corresponds to an operation that is unsupported for the
	 * corresponding QP.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_SERV_TYPE_ERROR	UINT32_C(0x16)
	/*
	 * There was an attempt to process a WQE from the SQ that
	 * corresponds to an operation that is unsupported for the
	 * corresponding QP, according to the supported_operations QPC
	 * field.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_INVALID_OP_ERROR	UINT32_C(0x17)
	/*
	 * A fatal error was detected on an attempt to read from
	 * or write to PCIe on the transmit side. This error is
	 * detected by the TX side (or CAGR), but has the priority
	 * of a Completion Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_TX_PCI_ERROR		UINT32_C(0x18)
	/*
	 * A fatal error was detected on an attempt to read from
	 * or write to PCIe on the receive side. This error is detected
	 * by the RX side (or CAGR), but has the priority of a
	 * Completion Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_RX_PCI_ERROR		UINT32_C(0x19)
	/*
	 * When processing a WQE from the SQ, TWE detected an error
	 * such that the wqe_size given in the header is larger than
	 * the delta between sq_work_idx and sq_prod_idx. This error
	 * has priority over the non-error case that occurs when TWE
	 * detects that it simply doesn't have enough slots fetched
	 * to execute the WQE during the current residency.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_PROD_WQE_MSMTCH_ERROR   UINT32_C(0x1a)
	/*
	 * When reading the MSN table to initiate HW retransmit, RWE
	 * found that to_retransmit_psn was not within the range defined
	 * by start_psn and next_psn in the corresponding MSN table
	 * entry. To_retransmit_psn must be greater than or equal to
	 * start_psn and less than next_psn in order for the range check
	 * to succeed.
	 * This is a RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_PSN_RANGE_CHECK_ERROR   UINT32_C(0x1b)
	/*
	 * While retransmitting, TWE detected one of several possible
	 * error detection scenarios related to the improper setup of
	 * retransmission. These include a category or errors known as
	 * retx_end_error where the retransmission end does not line up
	 * sequentially with the WQE index and PSN upon continuing on
	 * with the regular transmission that follows the
	 * retransmission. It also includes the error condition in which
	 * the retransmission Work Request has gen_dup_read_request set
	 * and the WQE fetched by TWE is not an RDMA Read or Atomic WQE.
	 * Please see TWE requirements for a full list of the various
	 * possible retransmit setup error cases. These error cases
	 * apply to H/W and F/W retransmission, alike.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_RETX_SETUP_ERROR	UINT32_C(0x1c)
	/*
	 * An express doorbell was posted that overflowed the SQ. The
	 * doorbell is dropped, along with all subsequent doorbells for
	 * this SQ. This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_SQ_OVERFLOW		UINT32_C(0x1d)
	#define CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_LAST			CREQ_QP_ERROR_NOTIFICATION_REQ_ERR_STATE_REASON_REQ_SQ_OVERFLOW
	/* QP context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* QP error notification event. */
	#define CREQ_QP_ERROR_NOTIFICATION_EVENT_QP_ERROR_NOTIFICATION UINT32_C(0xc0)
	#define CREQ_QP_ERROR_NOTIFICATION_EVENT_LAST		CREQ_QP_ERROR_NOTIFICATION_EVENT_QP_ERROR_NOTIFICATION
	/* responder slow path state */
	uint8_t	res_slow_path_state;
	uint8_t	res_err_state_reason;
	/* No error. */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_NO_ERROR			UINT32_C(0x0)
	/*
	 * Incoming Send, RDMA write, or RDMA read exceeds the maximum
	 * transfer length. Detected on RX first and only packets for
	 * write. Detected on RX request for read.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_EXCEED_MAX		UINT32_C(0x1)
	/*
	 * RDMA write payload size does not match write length. Detected
	 * when total write payload is not equal to the RDMA write
	 * length that was given in the first or only packet of the
	 * request.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_PAYLOAD_LENGTH_MISMATCH   UINT32_C(0x2)
	/*
	 * Send payload exceeds RQ/SRQ WQE buffer capacity. The total
	 * send payload that arrived is more than the size of the WQE
	 * buffer that was fetched from the RQ/SRQ.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_EXCEEDS_WQE		UINT32_C(0x3)
	/*
	 * Responder detected opcode error.
	 * * First, only, middle, last or incoming requests are
	 *   improperly ordered with respect to previous (PSN) packet.
	 * * First or middle packet is not full MTU size.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_OPCODE_ERROR		UINT32_C(0x4)
	/*
	 * PSN sequence error retry limit exceeded.
	 * The responder encountered a PSN sequence error for the
	 * same PSN too many times. This can occur via implicit or
	 * explicit NAK.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_PSN_SEQ_ERROR_RETRY_LIMIT UINT32_C(0x5)
	/*
	 * Invalid R_Key.
	 * An incoming request contained an R_Key that did not reference
	 * a valid MR/MW. This error may be detected by the RX engine
	 * for RDMA write or by the TX engine for RDMA read
	 * (detected while servicing IRRQ).
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_RX_INVALID_R_KEY	UINT32_C(0x6)
	/*
	 * Domain error.
	 * An incoming request specified an R_Key which
	 * referenced a MR/MW that was not in the same PD as the QP on
	 * which the request arrived.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_RX_DOMAIN_ERROR	UINT32_C(0x7)
	/*
	 * No permission.
	 * An incoming request contained an R_Key that referenced a
	 * MR/MW which did not have the access permission needed for
	 * the operation.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_RX_NO_PERMISSION	UINT32_C(0x8)
	/*
	 * Range error.
	 * An incoming request had a combination of R_Key,VA, and
	 * length that was out of bounds of the associated MR/MW.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_RX_RANGE_ERROR		UINT32_C(0x9)
	/*
	 * Invalid R_Key.
	 * An incoming request contained an R_Key that did not
	 * reference a valid MR/MW. This error may be detected
	 * by the RX engine for RDMA write or by the TX engine
	 * for RDMA read (detected while servicing IRRQ).
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_TX_INVALID_R_KEY	UINT32_C(0xa)
	/*
	 * Domain error.
	 * An incoming request specified an R_Key which referenced
	 * a MR/MW that was not in the same PD as the QP on
	 * which the request arrived.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_TX_DOMAIN_ERROR	UINT32_C(0xb)
	/*
	 * No permission.
	 * An incoming request contained an R_Key that referenced a
	 * MR/MW which did not have the access permission needed for
	 * the operation.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_TX_NO_PERMISSION	UINT32_C(0xc)
	/*
	 * Range error.
	 * An incoming request had a combination of R_Key, VA, and
	 * length that was out of bounds of the associated MR/MW.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_TX_RANGE_ERROR		UINT32_C(0xd)
	/*
	 * IRRQ overflow.
	 * The peer sent us more RDMA read or atomic requests than
	 * the negotiated maximum.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_IRRQ_OFLOW		UINT32_C(0xe)
	/*
	 * Unsupported opcode.
	 * The peer sent us a request with an opcode for a request
	 * type that is not supported on this QP.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_UNSUPPORTED_OPCODE	UINT32_C(0xf)
	/*
	 * Unaligned atomic operation. The VA of an atomic request
	 * is on a memory boundary that prevents atomic execution.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_UNALIGN_ATOMIC		UINT32_C(0x10)
	/*
	 * Remote invalidate error.
	 * A send with invalidate request arrived in which the
	 * R_Key to invalidate did not describe a MR/MW which could
	 * be invalidated. RQ WQE completes with error status.
	 * This error is only reported if the send operation did
	 * not fail. If the send operation failed then the remote
	 * invalidate error is not reported.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_REM_INVALIDATE		UINT32_C(0x11)
	/*
	 * Local memory error. An RQ/SRQ SGE described an inaccessible
	 * memory.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_MEMORY_ERROR		UINT32_C(0x12)
	/*
	 * SRQ in error. The QP is moving to error state because it
	 * found SRQ it uses in error.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_SRQ_ERROR		UINT32_C(0x13)
	/*
	 * Completion error. No CQE space available on queue or CQ not
	 * in VALID state.
	 * This is a Completion Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_CMP_ERROR		UINT32_C(0x14)
	/*
	 * Invalid R_Key while resending responses to duplicate request.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_INVALID_DUP_RKEY	UINT32_C(0x15)
	/*
	 * Problem was found in the format of a WQE in the RQ/SRQ.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_WQE_FORMAT_ERROR	UINT32_C(0x16)
	/*
	 * Problem was found in the format of an IRRQ entry.
	 * This is a TX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_IRRQ_FORMAT_ERROR	UINT32_C(0x17)
	/*
	 * A load error occurred on an attempt to load the CQ Context.
	 * This is a Completion Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_CQ_LOAD_ERROR		UINT32_C(0x18)
	/*
	 * A load error occurred on an attempt to load the SRQ Context.
	 * This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_SRQ_LOAD_ERROR		UINT32_C(0x19)
	/*
	 * A fatal error was detected on an attempt to read from or
	 * write to PCIe on the transmit side. This error is detected
	 * by the TX side, but has the priority of a Completion
	 * Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_TX_PCI_ERROR		UINT32_C(0x1b)
	/*
	 * A fatal error was detected on an attempt to read from or
	 * write to PCIe on the receive side. This error is detected
	 * by the RX side (or CAGR), but has the priority of a Completion
	 * Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_RX_PCI_ERROR		UINT32_C(0x1c)
	/*
	 * When searching the IRRQ to respond to a duplicate request,
	 * RWE could not find the duplicate request in the entire IRRQ.
	 * This is a RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_PSN_NOT_FOUND		UINT32_C(0x1d)
	/*
	 * An express doorbell was posted that overflowed the RQ. The
	 * doorbell is dropped, along with all subsequent doorbells for
	 * this RQ. This is an RX Detected Error.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_RQ_OVERFLOW		UINT32_C(0x1e)
	#define CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_LAST			CREQ_QP_ERROR_NOTIFICATION_RES_ERR_STATE_REASON_RES_RQ_OVERFLOW
	/*
	 * Final SQ Consumer Index value. Any additional SQ WQEs will
	 * have to be completed by the user provider.
	 */
	uint16_t	sq_cons_idx;
	/*
	 * Final RQ Consumer Index value. Any additional RQ WQEs will
	 * have to be completed by the user provider.
	 */
	uint16_t	rq_cons_idx;
} creq_qp_error_notification_t, *pcreq_qp_error_notification_t;

/* CQ error notification event. */
/* creq_cq_error_notification (size:128b/16B) */

typedef struct creq_cq_error_notification {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CQ_ERROR_NOTIFICATION_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CQ_ERROR_NOTIFICATION_TYPE_SFT	0
	/* CQ Async Notification */
		#define CREQ_CQ_ERROR_NOTIFICATION_TYPE_CQ_EVENT  UINT32_C(0x38)
		#define CREQ_CQ_ERROR_NOTIFICATION_TYPE_LAST	CREQ_CQ_ERROR_NOTIFICATION_TYPE_CQ_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* CQ error reason code. */
	uint8_t	cq_err_reason;
	/* Requester completion error for invalid CQ state. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_REQ_CQ_INVALID_ERROR  UINT32_C(0x1)
	/* Requester completion error for CQ overflow. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_REQ_CQ_OVERFLOW_ERROR UINT32_C(0x2)
	/* Attempt to load CQ context resulted in error. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_REQ_CQ_LOAD_ERROR	UINT32_C(0x3)
	/* Responder completion error for invalid CQ state. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_RES_CQ_INVALID_ERROR  UINT32_C(0x4)
	/* Responder completion error for CQ overflow. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_RES_CQ_OVERFLOW_ERROR UINT32_C(0x5)
	/* Attempt to load CQ context resulted in error. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_RES_CQ_LOAD_ERROR	UINT32_C(0x6)
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_LAST		CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_RES_CQ_LOAD_ERROR
	uint8_t	reserved8;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CQ_ERROR_NOTIFICATION_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* CQ error notification event. */
	#define CREQ_CQ_ERROR_NOTIFICATION_EVENT_CQ_ERROR_NOTIFICATION UINT32_C(0xc1)
	#define CREQ_CQ_ERROR_NOTIFICATION_EVENT_LAST		CREQ_CQ_ERROR_NOTIFICATION_EVENT_CQ_ERROR_NOTIFICATION
	uint8_t	reserved48[6];
} creq_cq_error_notification_t, *pcreq_cq_error_notification_t;

/* sq_base (size:64b/8B) */

typedef struct sq_base {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_BASE_WQE_TYPE_SEND		UINT32_C(0x0)
	/*
	 * Send with Immediate
	 *
	 * Allowed only on reliable connection (RC) and
	 * unreliable datagram (UD) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_SEND_W_IMMEAD	UINT32_C(0x1)
	/*
	 * Send with Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_SEND_W_INVALID	UINT32_C(0x2)
	/*
	 * RDMA Write.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_WRITE_WQE		UINT32_C(0x4)
	/*
	 * RDMA Write with Immediate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_WRITE_W_IMMEAD	UINT32_C(0x5)
	/*
	 * RDMA Read.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_READ_WQE		UINT32_C(0x6)
	/*
	 * Atomic Compare/Swap.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_ATOMIC_CS		UINT32_C(0x8)
	/*
	 * Atomic Fetch/Add.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_ATOMIC_FA		UINT32_C(0xb)
	/*
	 * Local Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_LOCAL_INVALID	UINT32_C(0xc)
	/*
	 * FR-PMR (Fast Register Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_FR_PMR		UINT32_C(0xd)
	/*
	 * Memory Bind
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_BIND		UINT32_C(0xe)
	/*
	 * FR-PPMR (Fast Register Proxy Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_FR_PPMR		UINT32_C(0xf)
	/* Send V3 */
	#define SQ_BASE_WQE_TYPE_SEND_V3		UINT32_C(0x10)
	/*
	 * Send with Immediate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_SEND_W_IMMED_V3	UINT32_C(0x11)
	/*
	 * Send with Invalidate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_SEND_W_INVALID_V3	UINT32_C(0x12)
	/*
	 * UD Send V3
	 *
	 * Allowed only on unreliable datagram (UD) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_UDSEND_V3		UINT32_C(0x13)
	/*
	 * UD Send with Immediate V3
	 *
	 * Allowed only on unreliable datagram (UD) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_UDSEND_W_IMMED_V3	UINT32_C(0x14)
	/*
	 * RDMA Write V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_WRITE_WQE_V3	UINT32_C(0x15)
	/*
	 * RDMA Write with Immediate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_WRITE_W_IMMED_V3	UINT32_C(0x16)
	/*
	 * RDMA Read V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_READ_WQE_V3	UINT32_C(0x17)
	/*
	 * Atomic Compare/Swap V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_ATOMIC_CS_V3	UINT32_C(0x18)
	/*
	 * Atomic Fetch/Add V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_ATOMIC_FA_V3	UINT32_C(0x19)
	/*
	 * Local Invalidate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_LOCAL_INVALID_V3	UINT32_C(0x1a)
	/*
	 * FR-PMR (Fast Register Physical Memory Region) V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_FR_PMR_V3		UINT32_C(0x1b)
	/*
	 * Memory Bind V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_BIND_V3		UINT32_C(0x1c)
	/* RawEth/QP1 Send V3 */
	#define SQ_BASE_WQE_TYPE_RAWQP1SEND_V3	UINT32_C(0x1d)
	/* Change UDP Source Port V3 */
	#define SQ_BASE_WQE_TYPE_CHANGE_UDPSRCPORT_V3 UINT32_C(0x1e)
	#define SQ_BASE_WQE_TYPE_LAST		SQ_BASE_WQE_TYPE_CHANGE_UDPSRCPORT_V3
	uint8_t	unused_0[7];
} sq_base_t, *psq_base_t;

/*
 * Most SQ WQEs contain SGEs used to define the SGL used to map payload
 * data in host memory. The number of SGE structures is defined by the
 * wqe_size field. SGE structures are aligned to 16B boundaries.
 *
 * In backward-compatible modes there can be 2, 4 or 6 SGEs (based on
 * the mode). In variable-sized WQE mode there can be 0-30 SGE
 * structures.
 */
/* sq_sge (size:128b/16B) */

typedef struct sq_sge {
	/*
	 * The virtual address in local memory or a physical address
	 * when l_key value is a reserved value of a physical address.
	 * Driver configures this value in the chip and the chip compares
	 * l_key in SGEs with that reserved value, if equal it access
	 * the physical address specified. The chip however MUST verify
	 * that the QP allows the use reserved key.
	 */
	uint64_t	va_or_pa;
	/*
	 * Local Key associated with this registered MR; The 24 msb of
	 * the key used to index the MRW Table and the 8 lsb are compared
	 * with the 8 bits key part stored in the MRWC. The PBL in the
	 * MRW Context is used to translate the above VA to physical
	 * address.
	 */
	uint32_t	l_key;
	/*
	 * Size of SGE in bytes; Based on page size of the system the
	 * chip knows how many entries are in the PBL
	 */
	uint32_t	size;
} sq_sge_t, *psq_sge_t;

/* sq_psn_search (size:64b/8B) */

typedef struct sq_psn_search {
	/* Start PSN. */
	uint32_t	opcode_start_psn;
	/* Start PSN. */
	#define SQ_PSN_SEARCH_START_PSN_MASK UINT32_C(0xffffff)
	#define SQ_PSN_SEARCH_START_PSN_SFT 0
	/* The opcodes are software defined. */
	#define SQ_PSN_SEARCH_OPCODE_MASK   UINT32_C(0xff000000)
	#define SQ_PSN_SEARCH_OPCODE_SFT	24
	uint32_t	flags_next_psn;
	/* Next PSN. Equal to the start PSN of the next WQE. */
	#define SQ_PSN_SEARCH_NEXT_PSN_MASK UINT32_C(0xffffff)
	#define SQ_PSN_SEARCH_NEXT_PSN_SFT 0
	/* Opcode specific flags. */
	#define SQ_PSN_SEARCH_FLAGS_MASK   UINT32_C(0xff000000)
	#define SQ_PSN_SEARCH_FLAGS_SFT	24
} sq_psn_search_t, *psq_psn_search_t;

/* This PSN table structure is used only on devices where variable size WQEs are supported. */
/* sq_psn_search_ext (size:128b/16B) */

typedef struct sq_psn_search_ext {
	/* Start PSN. */
	uint32_t	opcode_start_psn;
	/* Start PSN. */
	#define SQ_PSN_SEARCH_EXT_START_PSN_MASK UINT32_C(0xffffff)
	#define SQ_PSN_SEARCH_EXT_START_PSN_SFT 0
	/* The opcodes are software defined. */
	#define SQ_PSN_SEARCH_EXT_OPCODE_MASK   UINT32_C(0xff000000)
	#define SQ_PSN_SEARCH_EXT_OPCODE_SFT	24
	uint32_t	flags_next_psn;
	/* Next PSN. Equal to the start PSN of the next WQE. */
	#define SQ_PSN_SEARCH_EXT_NEXT_PSN_MASK UINT32_C(0xffffff)
	#define SQ_PSN_SEARCH_EXT_NEXT_PSN_SFT 0
	/* Opcode specific flags. */
	#define SQ_PSN_SEARCH_EXT_FLAGS_MASK   UINT32_C(0xff000000)
	#define SQ_PSN_SEARCH_EXT_FLAGS_SFT	24
	/*
	 * This field is used only when variable sized WQEs are being used.
	 * This indicates the starting slot index of the corresponding WQE.
	 */
	uint16_t	start_slot_idx;
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	/* reserved32 is 32 b */
	uint32_t	reserved32;
} sq_psn_search_ext_t, *psq_psn_search_ext_t;

/* This MSN table structure is used only on devices where Hardware based Requester retransmission is used. */
/* sq_msn_search (size:64b/8B) */

typedef struct sq_msn_search {
	/* MSN search entry. */
	uint64_t	start_idx_next_psn_start_psn;
	/* Start PSN. */
	#define SQ_MSN_SEARCH_START_PSN_MASK UINT32_C(0xffffff)
	#define SQ_MSN_SEARCH_START_PSN_SFT 0
	/* Next PSN. Equal to the start PSN of the next WQE. */
	#define SQ_MSN_SEARCH_NEXT_PSN_MASK 0xffffff000000ULL
	#define SQ_MSN_SEARCH_NEXT_PSN_SFT  24
	/*
	 * For variable-size WQEs, this field indicates the starting
	 * slot index that corresponds to the WQE.
	 * In backward-compatible mode, this is the starting WQE index.
	 */
	#define SQ_MSN_SEARCH_START_IDX_MASK 0xffff000000000000ULL
	#define SQ_MSN_SEARCH_START_IDX_SFT 48
} sq_msn_search_t, *psq_msn_search_t;

/* Send SQ WQE */
/* sq_send (size:1024b/128B) */

typedef struct sq_send {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_SEND_WQE_TYPE_SEND	UINT32_C(0x0)
	/*
	 * Send with Immediate
	 *
	 * Allowed only on reliable connection (RC) and
	 * unreliable datagram (UD) SQs.
	 */
	#define SQ_SEND_WQE_TYPE_SEND_W_IMMEAD  UINT32_C(0x1)
	/*
	 * Send with Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_SEND_WQE_TYPE_SEND_W_INVALID UINT32_C(0x2)
	#define SQ_SEND_WQE_TYPE_LAST	SQ_SEND_WQE_TYPE_SEND_W_INVALID
	uint8_t	flags;
	#define SQ_SEND_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_SEND_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * For local invalidate request. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE. This bit should be set only in the last (or only) packet
	 * of the message.
	 */
	#define SQ_SEND_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size. The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8_1;
	/*
	 * Either invalidate key (R_Key of the remote host) that will
	 * be send with IETH (Invalidate ETH) if wqe_type is of Send
	 * with Invalidate, or immediate value that will be sent with
	 * ImmDt header if wqe_type is Send with Immediate.
	 */
	uint32_t	inv_key_or_imm_data;
	/* This field represents a 32-bit total data length, in bytes. */
	uint32_t	length;
	/*
	 * When in the SQ of a UD QP, indicates the q_key to be used in
	 * the transmitted packet. However, if the most significant bit
	 * of this field is set, then the q_key will be taken from QP
	 * context, rather than from this field.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	q_key;
	/*
	 * When in the SQ of a UD QP, indicates the destination QP to be
	 * used in the transmitted packet.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	dst_qp;
	#define SQ_SEND_DST_QP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_DST_QP_SFT 0
	uint32_t	avid;
	/*
	 * If the serv_type is 'UD', then this field supplies the AVID
	 * (Address Vector ID).
	 */
	#define SQ_SEND_AVID_MASK UINT32_C(0xfffff)
	#define SQ_SEND_AVID_SFT 0
	uint32_t	reserved32;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 6
	 * SGEs based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * send based on the length_or_AVID field. Bits [7:0] of word 0
	 * hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_send_t, *psq_send_t;

/* Send SQ WQE header. */
/* sq_send_hdr (size:256b/32B) */

typedef struct sq_send_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_SEND_HDR_WQE_TYPE_SEND	UINT32_C(0x0)
	/*
	 * Send with Immediate
	 *
	 * Allowed only on reliable connection (RC) and
	 * unreliable datagram (UD) SQs.
	 */
	#define SQ_SEND_HDR_WQE_TYPE_SEND_W_IMMEAD  UINT32_C(0x1)
	/*
	 * Send with Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_SEND_HDR_WQE_TYPE_SEND_W_INVALID UINT32_C(0x2)
	#define SQ_SEND_HDR_WQE_TYPE_LAST	SQ_SEND_HDR_WQE_TYPE_SEND_W_INVALID
	uint8_t	flags;
	#define SQ_SEND_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_SEND_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * For local invalidate request. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE. This bit should be set only in the last (or only) packet
	 * of the message.
	 */
	#define SQ_SEND_HDR_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size. The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8_1;
	/*
	 * Either invalidate key (R_Key of the remote host) that will
	 * be send with IETH (Invalidate ETH) if wqe_type is of Send
	 * with Invalidate, or immediate value that will be sent with
	 * ImmDt header if wqe_type is Send with Immediate.
	 */
	uint32_t	inv_key_or_imm_data;
	/* This field represents a 32-bit total data length, in bytes. */
	uint32_t	length;
	/*
	 * When in the SQ of a UD QP, indicates the q_key to be used in
	 * the transmitted packet. However, if the most significant bit
	 * of this field is set, then the q_key will be taken from QP
	 * context, rather than from this field.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	q_key;
	/*
	 * When in the SQ of a UD QP, indicates the destination QP to be
	 * used in the transmitted packet.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	dst_qp;
	#define SQ_SEND_HDR_DST_QP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_HDR_DST_QP_SFT 0
	uint32_t	avid;
	/*
	 * If the serv_type is 'UD', then this field supplies the AVID
	 * (Address Vector ID).
	 */
	#define SQ_SEND_HDR_AVID_MASK UINT32_C(0xfffff)
	#define SQ_SEND_HDR_AVID_SFT 0
	uint32_t	reserved32;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_HDR_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_HDR_TIMESTAMP_SFT 0
} sq_send_hdr_t, *psq_send_hdr_t;

/* Send Raw Ethernet and QP1 SQ WQE */
/* sq_send_raweth_qp1 (size:1024b/128B) */

typedef struct sq_send_raweth_qp1 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_SEND_RAWETH_QP1_WQE_TYPE_SEND UINT32_C(0x0)
	#define SQ_SEND_RAWETH_QP1_WQE_TYPE_LAST SQ_SEND_RAWETH_QP1_WQE_TYPE_SEND
	uint8_t	flags;
	#define SQ_SEND_RAWETH_QP1_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_SEND_RAWETH_QP1_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_RAWETH_QP1_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_FLAGS_UC_FENCE								UINT32_C(0x4)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_RAWETH_QP1_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_RAWETH_QP1_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_RAWETH_QP1_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size. The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor. In case of
	 * VXLAN, the controller also replaces the outer header UDP
	 * checksum with hardware calculated UDP checksum for the packet
	 * associated with this descriptor.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This field represents a 32-bit total data length, in bytes.
	 * Note, however, that the length cannot exceed the MTU.
	 */
	uint32_t	length;
	uint32_t	reserved32_1;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_DE	UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID88A8  (UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID8100  (UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9100  (UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9200  (UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9300  (UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPIDCFG   (UINT32_C(0x5) << 16)
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_LAST	SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_RESERVED_MASK UINT32_C(0xff80000)
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_RESERVED_SFT 19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_MASK	UINT32_C(0xf0000000)
	#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_SFT	28
	/* No editing */
		#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
		#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_LAST	SQ_SEND_RAWETH_QP1_CFA_META_KEY_VLAN_TAG
	uint32_t	reserved32_2;
	uint32_t	reserved32_3;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_RAWETH_QP1_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_RAWETH_QP1_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 6
	 * SGEs based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * send based on the length_or_AVID field. Bits [7:0] of word 0
	 * hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_send_raweth_qp1_t, *psq_send_raweth_qp1_t;

/* Send Raw Ethernet and QP1 SQ WQE header. */
/* sq_send_raweth_qp1_hdr (size:256b/32B) */

typedef struct sq_send_raweth_qp1_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_SEND_RAWETH_QP1_HDR_WQE_TYPE_SEND UINT32_C(0x0)
	#define SQ_SEND_RAWETH_QP1_HDR_WQE_TYPE_LAST SQ_SEND_RAWETH_QP1_HDR_WQE_TYPE_SEND
	uint8_t	flags;
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size. The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor. In case of
	 * VXLAN, the controller also replaces the outer header UDP
	 * checksum with hardware calculated UDP checksum for the packet
	 * associated with this descriptor.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This field represents a 32-bit total data length, in bytes.
	 * Note, however, that the length cannot exceed the MTU.
	 */
	uint32_t	length;
	uint32_t	reserved32_1;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_DE	UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID88A8  (UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID8100  (UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID9100  (UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID9200  (UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID9300  (UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPIDCFG   (UINT32_C(0x5) << 16)
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_LAST	SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_RESERVED_MASK UINT32_C(0xff80000)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_RESERVED_SFT 19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_MASK	UINT32_C(0xf0000000)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_SFT	28
	/* No editing */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_LAST	SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_VLAN_TAG
	uint32_t	reserved32_2;
	uint32_t	reserved32_3;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_RAWETH_QP1_HDR_TIMESTAMP_SFT 0
} sq_send_raweth_qp1_hdr_t, *psq_send_raweth_qp1_hdr_t;

/* RDMA SQ WQE */
/* sq_rdma (size:1024b/128B) */

typedef struct sq_rdma {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * RDMA Write.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_WQE_TYPE_WRITE_WQE	UINT32_C(0x4)
	/*
	 * RDMA Write with Immediate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_WQE_TYPE_WRITE_W_IMMEAD UINT32_C(0x5)
	/*
	 * RDMA Read.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_WQE_TYPE_READ_WQE	UINT32_C(0x6)
	#define SQ_RDMA_WQE_TYPE_LAST	SQ_RDMA_WQE_TYPE_READ_WQE
	uint8_t	flags;
	#define SQ_RDMA_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_RDMA_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_RDMA_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_RDMA_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_RDMA_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_RDMA_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ following
	 * this WQE. This bit may be 1 only for write operations.
	 */
	#define SQ_RDMA_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_RDMA_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_RDMA_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * wqe of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size. The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	/*
	 * Immediate data - valid for RDMA Write with immediate and
	 * causes the controller to add immDt header with this value
	 */
	uint32_t	imm_data;
	/* Total data length in bytes */
	uint32_t	length;
	uint32_t	reserved32_1;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the RETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_RDMA_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_RDMA_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 6
	 * SGEs based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * write based on the length field. Bits [7:0] of word 0
	 * hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_rdma_t, *psq_rdma_t;

/* RDMA SQ WQE header. */
/* sq_rdma_hdr (size:256b/32B) */

typedef struct sq_rdma_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * RDMA Write.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_WQE_TYPE_WRITE_WQE	UINT32_C(0x4)
	/*
	 * RDMA Write with Immediate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_WQE_TYPE_WRITE_W_IMMEAD UINT32_C(0x5)
	/*
	 * RDMA Read.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_WQE_TYPE_READ_WQE	UINT32_C(0x6)
	#define SQ_RDMA_HDR_WQE_TYPE_LAST	SQ_RDMA_HDR_WQE_TYPE_READ_WQE
	uint8_t	flags;
	#define SQ_RDMA_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_RDMA_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_RDMA_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_RDMA_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_RDMA_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_RDMA_HDR_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ following
	 * this WQE. This bit may be 1 only for write operations.
	 */
	#define SQ_RDMA_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_RDMA_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_RDMA_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * wqe of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size. The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	/*
	 * Immediate data - valid for RDMA Write with immediate and
	 * causes the controller to add immDt header with this value
	 */
	uint32_t	imm_data;
	/* Total data length in bytes */
	uint32_t	length;
	uint32_t	reserved32_1;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the RETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_RDMA_HDR_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_RDMA_HDR_TIMESTAMP_SFT 0
} sq_rdma_hdr_t, *psq_rdma_hdr_t;

/* Atomic SQ WQE */
/* sq_atomic (size:1024b/128B) */

typedef struct sq_atomic {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Atomic Compare/Swap.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_WQE_TYPE_ATOMIC_CS UINT32_C(0x8)
	/*
	 * Atomic Fetch/Add.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_WQE_TYPE_ATOMIC_FA UINT32_C(0xb)
	#define SQ_ATOMIC_WQE_TYPE_LAST	SQ_ATOMIC_WQE_TYPE_ATOMIC_FA
	uint8_t	flags;
	#define SQ_ATOMIC_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_ATOMIC_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_ATOMIC_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_ATOMIC_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_ATOMIC_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_ATOMIC_FLAGS_SE									UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_ATOMIC_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * The atomic WQE does not have a timestamp field, so this field is
	 * ignored and should be zero.
	 */
	#define SQ_ATOMIC_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_ATOMIC_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	uint16_t	reserved16;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the AETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/* Data value to be placed in remote host specified address */
	uint64_t	swap_data;
	/*
	 * Data value to be compared with the value in the remote host
	 * specified address
	 */
	uint64_t	cmp_data;
	/*
	 * The first 16B of the data field must be filled with a single
	 * SGE. This will be used to store the return value from the
	 * Atomic Ack response. The size of the single SGE must be 8B.
	 */
	uint32_t	data[24];
} sq_atomic_t, *psq_atomic_t;

/* Atomic SQ WQE header. */
/* sq_atomic_hdr (size:256b/32B) */

typedef struct sq_atomic_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Atomic Compare/Swap.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_HDR_WQE_TYPE_ATOMIC_CS UINT32_C(0x8)
	/*
	 * Atomic Fetch/Add.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_HDR_WQE_TYPE_ATOMIC_FA UINT32_C(0xb)
	#define SQ_ATOMIC_HDR_WQE_TYPE_LAST	SQ_ATOMIC_HDR_WQE_TYPE_ATOMIC_FA
	uint8_t	flags;
	#define SQ_ATOMIC_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_ATOMIC_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_ATOMIC_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_ATOMIC_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_ATOMIC_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_ATOMIC_HDR_FLAGS_SE									UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_ATOMIC_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * The atomic WQE does not have a timestamp field, so this field is
	 * ignored and should be zero.
	 */
	#define SQ_ATOMIC_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_ATOMIC_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	uint16_t	reserved16;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the AETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/* Data value to be placed in remote host specified address */
	uint64_t	swap_data;
	/*
	 * Data value to be compared with the value in the remote host
	 * specified address
	 */
	uint64_t	cmp_data;
} sq_atomic_hdr_t, *psq_atomic_hdr_t;

/* Local Invalidate SQ WQE */
/* sq_localinvalidate (size:1024b/128B) */

typedef struct sq_localinvalidate {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Local Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_LOCALINVALIDATE_WQE_TYPE_LOCAL_INVALID UINT32_C(0xc)
	#define SQ_LOCALINVALIDATE_WQE_TYPE_LAST	SQ_LOCALINVALIDATE_WQE_TYPE_LOCAL_INVALID
	uint8_t	flags;
	#define SQ_LOCALINVALIDATE_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_LOCALINVALIDATE_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_SE									UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_LOCALINVALIDATE_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	uint16_t	reserved16;
	/*
	 * The local key for the MR/W to invalidate; 24 msb of the key
	 * are used to index the MRW table, 8 lsb are compared with the
	 * 8 bit key in the MRWC
	 */
	uint32_t	inv_l_key;
	uint64_t	reserved64;
	uint8_t	reserved128[16];
	/* The data field for local invalidate is not used. */
	uint32_t	data[24];
} sq_localinvalidate_t, *psq_localinvalidate_t;

/* Local Invalidate SQ WQE header. */
/* sq_localinvalidate_hdr (size:256b/32B) */

typedef struct sq_localinvalidate_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Local Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_LOCALINVALIDATE_HDR_WQE_TYPE_LOCAL_INVALID UINT32_C(0xc)
	#define SQ_LOCALINVALIDATE_HDR_WQE_TYPE_LAST	SQ_LOCALINVALIDATE_HDR_WQE_TYPE_LOCAL_INVALID
	uint8_t	flags;
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_SE									UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	uint16_t	reserved16;
	/*
	 * The local key for the MR/W to invalidate; 24 msb of the key
	 * are used to index the MRW table, 8 lsb are compared with the
	 * 8 bit key in the MRWC
	 */
	uint32_t	inv_l_key;
	uint64_t	reserved64;
	uint8_t	reserved128[16];
} sq_localinvalidate_hdr_t, *psq_localinvalidate_hdr_t;

/* FR-PMR SQ WQE */
/* sq_fr_pmr (size:1024b/128B) */

typedef struct sq_fr_pmr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PMR (Fast Register Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PMR_WQE_TYPE_FR_PMR UINT32_C(0xd)
	#define SQ_FR_PMR_WQE_TYPE_LAST  SQ_FR_PMR_WQE_TYPE_FR_PMR
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_FR_PMR_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PMR_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PMR_FLAGS_UC_FENCE		UINT32_C(0x4)
	/* Not Applicable for FR_PMR. Nothing is sent */
	#define SQ_FR_PMR_FLAGS_SE			UINT32_C(0x8)
	/* NA */
	#define SQ_FR_PMR_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PMR_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PMR_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PMR_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PMR_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PMR_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PMR_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	uint8_t	zero_based_page_size_log;
	/* Page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PMR_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8T
	/* Indicate the MR is ZBVA (Zero Base VA) */
	#define SQ_FR_PMR_ZERO_BASED		UINT32_C(0x20)
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	/* Length in bytes of registered MR */
	uint8_t	length[5];
	uint8_t	reserved8_1;
	uint8_t	reserved8_2;
	uint8_t	numlevels_pbl_page_size_log;
	/* PBL page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Number of levels of PBL for translation */
	#define SQ_FR_PMR_NUMLEVELS_MASK		UINT32_C(0xc0)
	#define SQ_FR_PMR_NUMLEVELS_SFT		6
	/*
	 * A zero level PBL means that the VA is the physical address used
	 * for the operation. No translation is done by the PTU.
	 */
		#define SQ_FR_PMR_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 6)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PBE values that point to actual pg_size physical pages.
	 */
		#define SQ_FR_PMR_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 6)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PDE values that in turn point to pbl_pg_size physical
	 * pages that contain PBE values that point to actual physical
	 * pages.
	 */
		#define SQ_FR_PMR_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 6)
		#define SQ_FR_PMR_NUMLEVELS_LAST		SQ_FR_PMR_NUMLEVELS_LAYER2
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pblptr;
	/* Local Virtual Address */
	uint64_t	va;
	/* The data field for FR-PMR is not used. */
	uint32_t	data[24];
} sq_fr_pmr_t, *psq_fr_pmr_t;

/* FR-PMR SQ WQE header. */
/* sq_fr_pmr_hdr (size:256b/32B) */

typedef struct sq_fr_pmr_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PMR (Fast Register Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PMR_HDR_WQE_TYPE_FR_PMR UINT32_C(0xd)
	#define SQ_FR_PMR_HDR_WQE_TYPE_LAST  SQ_FR_PMR_HDR_WQE_TYPE_FR_PMR
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_FR_PMR_HDR_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PMR_HDR_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PMR_HDR_FLAGS_UC_FENCE		UINT32_C(0x4)
	/* Not Applicable for FR_PMR. Nothing is sent */
	#define SQ_FR_PMR_HDR_FLAGS_SE			UINT32_C(0x8)
	/* NA */
	#define SQ_FR_PMR_HDR_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_HDR_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PMR_HDR_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	uint8_t	zero_based_page_size_log;
	/* Page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8T
	/* Indicate the MR is ZBVA (Zero Base VA) */
	#define SQ_FR_PMR_HDR_ZERO_BASED		UINT32_C(0x20)
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	/* Length in bytes of registered MR */
	uint8_t	length[5];
	uint8_t	reserved8_1;
	uint8_t	reserved8_2;
	uint8_t	numlevels_pbl_page_size_log;
	/* PBL page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Number of levels of PBL for translation */
	#define SQ_FR_PMR_HDR_NUMLEVELS_MASK		UINT32_C(0xc0)
	#define SQ_FR_PMR_HDR_NUMLEVELS_SFT		6
	/*
	 * A zero level PBL means that the VA is the physical address used
	 * for the operation. No translation is done by the PTU.
	 */
		#define SQ_FR_PMR_HDR_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 6)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PBE values that point to actual pg_size physical pages.
	 */
		#define SQ_FR_PMR_HDR_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 6)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PDE values that in turn point to pbl_pg_size physical
	 * pages that contain PBE values that point to actual physical
	 * pages.
	 */
		#define SQ_FR_PMR_HDR_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 6)
		#define SQ_FR_PMR_HDR_NUMLEVELS_LAST		SQ_FR_PMR_HDR_NUMLEVELS_LAYER2
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pblptr;
	/* Local Virtual Address */
	uint64_t	va;
} sq_fr_pmr_hdr_t, *psq_fr_pmr_hdr_t;

/* FR-PPMR SQ WQE */
/* sq_fr_ppmr (size:1024b/128B) */

typedef struct sq_fr_ppmr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PPMR (Fast Register Proxy Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PPMR_WQE_TYPE_FR_PPMR UINT32_C(0xf)
	#define SQ_FR_PPMR_WQE_TYPE_LAST   SQ_FR_PPMR_WQE_TYPE_FR_PPMR
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_FR_PPMR_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PPMR_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PPMR_FLAGS_UC_FENCE		UINT32_C(0x4)
	/* Not Applicable for FR_PPMR. Nothing is sent */
	#define SQ_FR_PPMR_FLAGS_SE			UINT32_C(0x8)
	/* NA */
	#define SQ_FR_PPMR_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PPMR_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PPMR_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PPMR_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PPMR_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PPMR_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PPMR_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PPMR_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	uint8_t	zero_based_page_size_log;
	/* Page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PPMR_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PPMR_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_LAST	SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8T
	/* Indicate the MR is ZBVA (Zero Base VA) */
	#define SQ_FR_PPMR_ZERO_BASED		UINT32_C(0x20)
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	/* Length in bytes of registered MR */
	uint32_t	length;
	/* Sets the proxy_vfid field of the physical memory region. */
	uint16_t	proxy_vfid;
	/* Sets the proxy_pfid field of the physical memory region. */
	uint8_t	proxy_pfid;
	uint8_t	numlevels_pbl_page_size_log;
	/* PBL page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Sets the proxy_vf_valid field of the physical memory region. */
	#define SQ_FR_PPMR_PROXY_VF_VALID		UINT32_C(0x20)
	/* Number of levels of PBL for translation */
	#define SQ_FR_PPMR_NUMLEVELS_MASK		UINT32_C(0xc0)
	#define SQ_FR_PPMR_NUMLEVELS_SFT		6
	/*
	 * A zero level PBL means that the VA is the physical address used
	 * for the operation. No translation is done by the PTU.
	 */
		#define SQ_FR_PPMR_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 6)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PBE values that point to actual pg_size physical pages.
	 */
		#define SQ_FR_PPMR_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 6)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PDE values that in turn point to pbl_pg_size physical
	 * pages that contain PBE values that point to actual physical
	 * pages.
	 */
		#define SQ_FR_PPMR_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 6)
		#define SQ_FR_PPMR_NUMLEVELS_LAST		SQ_FR_PPMR_NUMLEVELS_LAYER2
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pblptr;
	/* Local Virtual Address */
	uint64_t	va;
	/* The data field for FR-PPMR is not used. */
	uint32_t	data[24];
} sq_fr_ppmr_t, *psq_fr_ppmr_t;

/* FR-PPMR SQ WQE header. */
/* sq_fr_ppmr_hdr (size:256b/32B) */

typedef struct sq_fr_ppmr_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PPMR (Fast Register Proxy Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PPMR_HDR_WQE_TYPE_FR_PPMR UINT32_C(0xf)
	#define SQ_FR_PPMR_HDR_WQE_TYPE_LAST   SQ_FR_PPMR_HDR_WQE_TYPE_FR_PPMR
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_UC_FENCE		UINT32_C(0x4)
	/* Not Applicable for FR_PPMR. Nothing is sent */
	#define SQ_FR_PPMR_HDR_FLAGS_SE			UINT32_C(0x8)
	/* NA */
	#define SQ_FR_PPMR_HDR_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	uint8_t	zero_based_page_size_log;
	/* Page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_LAST	SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8T
	/* Indicate the MR is ZBVA (Zero Base VA) */
	#define SQ_FR_PPMR_HDR_ZERO_BASED		UINT32_C(0x20)
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	/* Length in bytes of registered MR */
	uint32_t	length;
	/* Sets the proxy_vfid field of the physical memory region. */
	uint16_t	proxy_vfid;
	/* Sets the proxy_pfid field of the physical memory region. */
	uint8_t	proxy_pfid;
	uint8_t	numlevels_pbl_page_size_log;
	/* PBL page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Sets the proxy_vf_valid field of the physical memory region. */
	#define SQ_FR_PPMR_HDR_PROXY_VF_VALID		UINT32_C(0x20)
	/* Number of levels of PBL for translation */
	#define SQ_FR_PPMR_HDR_NUMLEVELS_MASK		UINT32_C(0xc0)
	#define SQ_FR_PPMR_HDR_NUMLEVELS_SFT		6
	/*
	 * A zero level PBL means that the VA is the physical address used
	 * for the operation. No translation is done by the PTU.
	 */
		#define SQ_FR_PPMR_HDR_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 6)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PBE values that point to actual pg_size physical pages.
	 */
		#define SQ_FR_PPMR_HDR_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 6)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PDE values that in turn point to pbl_pg_size physical
	 * pages that contain PBE values that point to actual physical
	 * pages.
	 */
		#define SQ_FR_PPMR_HDR_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 6)
		#define SQ_FR_PPMR_HDR_NUMLEVELS_LAST		SQ_FR_PPMR_HDR_NUMLEVELS_LAYER2
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pblptr;
	/* Local Virtual Address */
	uint64_t	va;
} sq_fr_ppmr_hdr_t, *psq_fr_ppmr_hdr_t;

/*
 * Bind SQ WQE. This WQE can perform either:
 * * type1 "bind memory window", if mw_type==Type1
 * * type2 "post send bind memory window", if mw_type==Type2
 */
/* sq_bind (size:1024b/128B) */

typedef struct sq_bind {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Memory Bind
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BIND_WQE_TYPE_BIND UINT32_C(0xe)
	#define SQ_BIND_WQE_TYPE_LAST SQ_BIND_WQE_TYPE_BIND
	uint8_t	flags;
	#define SQ_BIND_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_BIND_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_BIND_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_BIND_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_BIND_FLAGS_UC_FENCE								UINT32_C(0x4)
	/* NA, nothing is sent. */
	#define SQ_BIND_FLAGS_SE									UINT32_C(0x8)
	/* NA */
	#define SQ_BIND_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_BIND_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	#define SQ_BIND_ACCESS_CNTL_WINDOW_BIND_REMOTE_ATOMIC_REMOTE_WRITE_REMOTE_READ_LOCAL_WRITE_MASK		UINT32_C(0xff)
	#define SQ_BIND_ACCESS_CNTL_WINDOW_BIND_REMOTE_ATOMIC_REMOTE_WRITE_REMOTE_READ_LOCAL_WRITE_SFT		0
	/*
	 * Local Write Access.
	 *
	 * Local accesses are never allowed for memory windows, so this
	 * bit must always be zero in a bind WQE. If this bit is ever
	 * set, the bind will fail with an errored completion.
	 */
	#define SQ_BIND_ACCESS_CNTL_LOCAL_WRITE									UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_BIND_ACCESS_CNTL_REMOTE_READ									UINT32_C(0x2)
	/*
	 * Remote Write Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes. If this is
	 * not the case, then the bind will fail with an errored
	 * completion.
	 */
	#define SQ_BIND_ACCESS_CNTL_REMOTE_WRITE									UINT32_C(0x4)
	/*
	 * Remote Atomic Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes. If this is
	 * not the case, then the bind will fail with an errored
	 * completion.
	 */
	#define SQ_BIND_ACCESS_CNTL_REMOTE_ATOMIC									UINT32_C(0x8)
	/*
	 * Window Binding Allowed.
	 *
	 * It is never allowed to bind windows to windows, so this bit
	 * must always be zero in a bind WQE. If this bit is ever set,
	 * the bind will fail with an errored completion.
	 */
	#define SQ_BIND_ACCESS_CNTL_WINDOW_BIND									UINT32_C(0x10)
	/* reserved8_1 is 8 b */
	uint8_t	reserved8_1;
	uint8_t	mw_type_zero_based;
	/*
	 * If this bit is set, then the newly-bound memory window will be
	 * zero-based. If clear, then the newly-bound memory window will be
	 * non-zero-based.
	 */
	#define SQ_BIND_ZERO_BASED	UINT32_C(0x1)
	/*
	 * If type1 is specified, then this WQE performs a "bind memory
	 * window" operation on a type1 window. If type2 is specified, then
	 * this WQE performs a "post send bind memory window" operation on a
	 * type2 window.
	 *
	 * Note that the bind WQE cannot change the type of the memory
	 * window.
	 *
	 * If a "bind memory window" operation is attempted on a memory
	 * window that was allocated as type2, then the bind will fail with
	 * an errored completion, as "bind memory window" is allowed only on
	 * type1 memory windows.
	 *
	 * Similarly, if a "post send bind memory window" operation is
	 * attempted on a memory window that was allocated as type1, then the
	 * bind will fail with an errored completions, as "post send bind
	 * memory window" is allowed only on type2 memory windows.
	 */
	#define SQ_BIND_MW_TYPE	UINT32_C(0x2)
	/* Type 1 Bind Memory Window */
		#define SQ_BIND_MW_TYPE_TYPE1	(UINT32_C(0x0) << 1)
	/* Type 2 Post Send Bind Memory Window */
		#define SQ_BIND_MW_TYPE_TYPE2	(UINT32_C(0x1) << 1)
		#define SQ_BIND_MW_TYPE_LAST	SQ_BIND_MW_TYPE_TYPE2
	uint8_t	reserved8_2;
	uint16_t	reserved16;
	/*
	 * The L_Key of the parent MR; 24 msb of the key are used to
	 * index the MRW table, 8 lsb are compared with the 8 bit key
	 * in the MRWC.
	 */
	uint32_t	parent_l_key;
	/*
	 * Local Key; 24 msb of the key are used to index the memory
	 * window being bound in the MRW table, 8 lsb are assign to the
	 * 8 bit key_lsb field in the MRWC.
	 */
	uint32_t	l_key;
	/* Local Virtual Address */
	uint64_t	va;
	/*
	 * Length in bytes of registered MW; 40 bits as this is the max
	 * size of an MR/W
	 */
	uint8_t	length[5];
	uint8_t	reserved24[3];
	/* The data field for Bind is not used. */
	uint32_t	data[24];
} sq_bind_t, *psq_bind_t;

/*
 * Bind SQ WQE header. This WQE can perform either:
 * * type1 "bind memory window", if mw_type==Type1
 * * type2 "post send bind memory window", if mw_type==Type2
 */
/* sq_bind_hdr (size:256b/32B) */

typedef struct sq_bind_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Memory Bind
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BIND_HDR_WQE_TYPE_BIND UINT32_C(0xe)
	#define SQ_BIND_HDR_WQE_TYPE_LAST SQ_BIND_HDR_WQE_TYPE_BIND
	uint8_t	flags;
	#define SQ_BIND_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_BIND_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_BIND_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_BIND_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_BIND_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/* NA, nothing is sent. */
	#define SQ_BIND_HDR_FLAGS_SE									UINT32_C(0x8)
	/* NA */
	#define SQ_BIND_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_BIND_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	#define SQ_BIND_HDR_ACCESS_CNTL_WINDOW_BIND_REMOTE_ATOMIC_REMOTE_WRITE_REMOTE_READ_LOCAL_WRITE_MASK		UINT32_C(0xff)
	#define SQ_BIND_HDR_ACCESS_CNTL_WINDOW_BIND_REMOTE_ATOMIC_REMOTE_WRITE_REMOTE_READ_LOCAL_WRITE_SFT		0
	/*
	 * Local Write Access.
	 *
	 * Local accesses are never allowed for memory windows, so this
	 * bit must always be zero in a bind WQE. If this bit is ever
	 * set, the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_ACCESS_CNTL_LOCAL_WRITE									UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_BIND_HDR_ACCESS_CNTL_REMOTE_READ									UINT32_C(0x2)
	/*
	 * Remote Write Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes. If this is
	 * not the case, then the bind will fail with an errored
	 * completion.
	 */
	#define SQ_BIND_HDR_ACCESS_CNTL_REMOTE_WRITE									UINT32_C(0x4)
	/*
	 * Remote Atomic Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes. If this is
	 * not the case, then the bind will fail with an errored
	 * completion.
	 */
	#define SQ_BIND_HDR_ACCESS_CNTL_REMOTE_ATOMIC									UINT32_C(0x8)
	/*
	 * Window Binding Allowed.
	 *
	 * It is never allowed to bind windows to windows, so this bit
	 * must always be zero in a bind WQE. If this bit is ever set,
	 * the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_ACCESS_CNTL_WINDOW_BIND									UINT32_C(0x10)
	/* reserved8_1 is 8 b */
	uint8_t	reserved8_1;
	uint8_t	mw_type_zero_based;
	/*
	 * If this bit is set, then the newly-bound memory window will be
	 * zero-based. If clear, then the newly-bound memory window will be
	 * non-zero-based.
	 */
	#define SQ_BIND_HDR_ZERO_BASED	UINT32_C(0x1)
	/*
	 * If type1 is specified, then this WQE performs a "bind memory
	 * window" operation on a type1 window. If type2 is specified, then
	 * this WQE performs a "post send bind memory window" operation on a
	 * type2 window.
	 *
	 * Note that the bind WQE cannot change the type of the memory
	 * window.
	 *
	 * If a "bind memory window" operation is attempted on a memory
	 * window that was allocated as type2, then the bind will fail with
	 * an errored completion, as "bind memory window" is allowed only on
	 * type1 memory windows.
	 *
	 * Similarly, if a "post send bind memory window" operation is
	 * attempted on a memory window that was allocated as type1, then the
	 * bind will fail with an errored completions, as "post send bind
	 * memory window" is allowed only on type2 memory windows.
	 */
	#define SQ_BIND_HDR_MW_TYPE	UINT32_C(0x2)
	/* Type 1 Bind Memory Window */
		#define SQ_BIND_HDR_MW_TYPE_TYPE1	(UINT32_C(0x0) << 1)
	/* Type 2 Post Send Bind Memory Window */
		#define SQ_BIND_HDR_MW_TYPE_TYPE2	(UINT32_C(0x1) << 1)
		#define SQ_BIND_HDR_MW_TYPE_LAST	SQ_BIND_HDR_MW_TYPE_TYPE2
	uint8_t	reserved8_2;
	uint16_t	reserved16;
	/*
	 * The L_Key of the parent MR; 24 msb of the key are used to
	 * index the MRW table, 8 lsb are compared with the 8 bit key
	 * in the MRWC.
	 */
	uint32_t	parent_l_key;
	/*
	 * Local Key; 24 msb of the key are used to index the memory
	 * window being bound in the MRW table, 8 lsb are assign to the
	 * 8 bit key_lsb field in the MRWC.
	 */
	uint32_t	l_key;
	/* Local Virtual Address */
	uint64_t	va;
	/*
	 * Length in bytes of registered MW; 40 bits as this is the max
	 * size of an MR/W
	 */
	uint8_t	length[5];
	uint8_t	reserved24[3];
} sq_bind_hdr_t, *psq_bind_hdr_t;

/*
 * This V3 version of structure is not accessible from host software, but is documented here (in the SW section) anyway.
 * This is the MSN Table (located in IQM). The table is written by the RoCE transmitter when sending wire operation WQEs. It is used to provide the RoCE receiver with information about the SQ WQEs in order to make requester completions and to perform requester HW retransmission. The number of entries in the table is configured in the QPC and must be equal to the maximum number of WQEs that can be present in the SQ at one time, rounded up to the nearest power of two.
 */
/* sq_msn_search_v3 (size:128b/16B) */

typedef struct sq_msn_search_v3 {
	uint64_t	idx_psn;
	/* Start PSN of the WQE. */
	#define SQ_MSN_SEARCH_V3_START_PSN_MASK UINT32_C(0xffffff)
	#define SQ_MSN_SEARCH_V3_START_PSN_SFT 0
	/* Next PSN. Equal to the start PSN of the next WQE. */
	#define SQ_MSN_SEARCH_V3_NEXT_PSN_MASK UINT32_C(0xffffff000000)L
	#define SQ_MSN_SEARCH_V3_NEXT_PSN_SFT  24
	/*
	 * Start index. For variable-size WQEs, this field indicates the
	 * starting slot index that corresponds to the WQE. In
	 * backward-compatible mode, this is the starting WQE index.
	 */
	#define SQ_MSN_SEARCH_V3_START_IDX_MASK UINT32_C(0xffff000000000000)L
	#define SQ_MSN_SEARCH_V3_START_IDX_SFT 48
	/*
	 * This value will be returned in the completion if the completion
	 * is signaled.
	 */
	uint32_t	wqe_opaque;
	/* The size of the WQE in units of 16B chunks. */
	uint8_t	wqe_size;
	uint8_t	signal;
	/* Set if completion signaling is requested. */
	#define SQ_MSN_SEARCH_V3_SGNLD			UINT32_C(0x1)
	/*
	 * Set if at least one signaled local memory operation WQE is
	 * present in the SQ between the previous wire-operation WQE
	 * and this WQE.
	 */
	#define SQ_MSN_SEARCH_V3_PREV_SGNLD_LOCAL_MEM_WQE	UINT32_C(0x2)
	uint16_t	reserved;
} sq_msn_search_v3_t, *psq_msn_search_v3_t;

/* SQ Send WQE V3 for RC SQs. */
/* sq_send_v3 (size:1024b/128B) */

typedef struct sq_send_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send V3 */
	#define SQ_SEND_V3_WQE_TYPE_SEND_V3	UINT32_C(0x10)
	/*
	 * Send with Immediate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_SEND_V3_WQE_TYPE_SEND_W_IMMED_V3   UINT32_C(0x11)
	/*
	 * Send with Invalidate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_SEND_V3_WQE_TYPE_SEND_W_INVALID_V3 UINT32_C(0x12)
	#define SQ_SEND_V3_WQE_TYPE_LAST		SQ_SEND_V3_WQE_TYPE_SEND_W_INVALID_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE.
	 */
	#define SQ_SEND_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * Note: Since the WQE header consumes only one slot (16 bytes)
	 * for this type of WQE, and the maximum number of SGEs supported
	 * by the device is 30, this field must never exceed 31.
	 */
	#define SQ_SEND_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_SEND_V3_WQE_SIZE_SFT 0
	uint8_t	inline_length;
	/*
	 * When inline flag is '1', this field determines the number of
	 * bytes that are valid in the last 16B unit of the inline WQE.
	 * Zero means all 16 bytes are valid. One means only bits 7:0 of
	 * the last 16B unit are valid. This means the total size of the
	 * inline data is determined by a combination of the wqe_size field
	 * and this inline_length field.
	 *
	 * `inline_size = ((wqe_size - 1) * 16) - data_offset_in_bytes +
	 * ((inline_length == 0 ) ? 16 : inline_length)
	 *
	 * Where data_offset_in_bytes is the offset within the WQE where
	 * the data field starts.
	 *
	 * Note that this field is not applicable for zero-length inline
	 * WQEs.
	 */
	#define SQ_SEND_V3_INLINE_LENGTH_MASK UINT32_C(0xf)
	#define SQ_SEND_V3_INLINE_LENGTH_SFT 0
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * Either invalidate key (R_Key of the remote host) that will
	 * be send with IETH (Invalidate ETH) if wqe_type is of Send
	 * with Invalidate, or immediate value that will be sent with
	 * ImmDt header if wqe_type is Send with Immediate.
	 */
	uint32_t	inv_key_or_imm_data;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_V3_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_V3_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 30 SGEs
	 * based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * send. Length of data is described in the inline_length field.
	 * Bits [7:0] of word 0 hold the first byte to go out on the wire.
	 */
	uint32_t	data[28];
} sq_send_v3_t, *psq_send_v3_t;

/* Send SQ WQE V3 header. */
/* sq_send_hdr_v3 (size:128b/16B) */

typedef struct sq_send_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send V3 */
	#define SQ_SEND_HDR_V3_WQE_TYPE_SEND_V3	UINT32_C(0x10)
	/*
	 * Send with Immediate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_SEND_HDR_V3_WQE_TYPE_SEND_W_IMMED_V3   UINT32_C(0x11)
	/*
	 * Send with Invalidate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_SEND_HDR_V3_WQE_TYPE_SEND_W_INVALID_V3 UINT32_C(0x12)
	#define SQ_SEND_HDR_V3_WQE_TYPE_LAST		SQ_SEND_HDR_V3_WQE_TYPE_SEND_W_INVALID_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE.
	 */
	#define SQ_SEND_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * Note: Since the WQE header consumes only one slot (16 bytes)
	 * for this type of WQE, and the maximum number of SGEs supported
	 * by the device is 30, this field must never exceed 31.
	 */
	#define SQ_SEND_HDR_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_SEND_HDR_V3_WQE_SIZE_SFT 0
	uint8_t	inline_length;
	/*
	 * When inline flag is '1', this field determines the number of
	 * bytes that are valid in the last 16B unit of the inline WQE.
	 * Zero means all 16 bytes are valid. One means only bits 7:0 of
	 * the last 16B unit are valid. This means the total size of the
	 * inline data is determined by a combination of the wqe_size field
	 * and this inline_length field.
	 *
	 * `inline_size = ((wqe_size - 1) * 16) - data_offset_in_bytes +
	 * ((inline_length == 0 ) ? 16 : inline_length)
	 *
	 * Where data_offset_in_bytes is the offset within the WQE where
	 * the data field starts.
	 *
	 * Note that this field is not applicable for zero-length inline
	 * WQEs.
	 */
	#define SQ_SEND_HDR_V3_INLINE_LENGTH_MASK UINT32_C(0xf)
	#define SQ_SEND_HDR_V3_INLINE_LENGTH_SFT 0
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * Either invalidate key (R_Key of the remote host) that will
	 * be send with IETH (Invalidate ETH) if wqe_type is of Send
	 * with Invalidate, or immediate value that will be sent with
	 * ImmDt header if wqe_type is Send with Immediate.
	 */
	uint32_t	inv_key_or_imm_data;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_HDR_V3_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_HDR_V3_TIMESTAMP_SFT 0
} sq_send_hdr_v3_t, *psq_send_hdr_v3_t;

/* SQ WQE V3 for Raw Ethernet and QP1 */
/* sq_rawqp1send_v3 (size:1024b/128B) */

typedef struct sq_rawqp1send_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* RawEth/QP1 Send V3 */
	#define SQ_RAWQP1SEND_V3_WQE_TYPE_RAWQP1SEND_V3 UINT32_C(0x1d)
	#define SQ_RAWQP1SEND_V3_WQE_TYPE_LAST	SQ_RAWQP1SEND_V3_WQE_TYPE_RAWQP1SEND_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_RAWQP1SEND_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a QP1 send.
	 */
	#define SQ_RAWQP1SEND_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a QP1 send.
	 */
	#define SQ_RAWQP1SEND_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE.
	 *
	 * This flag must be zero for a QP1 send.
	 */
	#define SQ_RAWQP1SEND_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_RAWQP1SEND_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_RAWQP1SEND_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_RAWQP1SEND_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * This field shall never exceed 32 for WQEs of this type.
	 */
	#define SQ_RAWQP1SEND_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_RAWQP1SEND_V3_WQE_SIZE_SFT 0
	uint8_t	inline_length;
	/*
	 * When inline flag is '1', this field determines the number of
	 * bytes that are valid in the last 16B unit of the inline WQE.
	 * Zero means all 16 bytes are valid. One means only bits 7:0 of
	 * the last 16B unit are valid. This means the total size of the
	 * inline data is determined by a combination of the wqe_size field
	 * and this inline_length field.
	 *
	 * `inline_size = ((wqe_size - 1) * 16) - data_offset_in_bytes +
	 * ((inline_length == 0 ) ? 16 : inline_length)
	 *
	 * Where data_offset_in_bytes is the offset within the WQE where
	 * the data field starts.
	 *
	 * Note that this field is not applicable for zero-length inline
	 * WQEs.
	 */
	#define SQ_RAWQP1SEND_V3_INLINE_LENGTH_MASK UINT32_C(0xf)
	#define SQ_RAWQP1SEND_V3_INLINE_LENGTH_SFT 0
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_RAWQP1SEND_V3_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_RAWQP1SEND_V3_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define SQ_RAWQP1SEND_V3_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor. In case of
	 * VXLAN, the controller also replaces the outer header UDP
	 * checksum with hardware calculated UDP checksum for the packet
	 * associated with this descriptor.
	 */
	#define SQ_RAWQP1SEND_V3_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to 1, The controller replaces the Outer-tunnel IP
	 * checksum field with hardware calculated IP checksum for the IP
	 * header of the packet associated with this descriptor.
	 *
	 * For outer UDP checksum, it will be the following behavior for
	 * all cases independent of settings of inner LSO and checksum
	 * offload BD flags:
	 *
	 * - If outer UDP checksum is 0, then do not update it.
	 * - If outer UDP checksum is non zero, then the hardware should
	 *   compute and update it.
	 */
	#define SQ_RAWQP1SEND_V3_LFLAGS_OT_IP_CHKSUM	UINT32_C(0x20)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define SQ_RAWQP1SEND_V3_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define SQ_RAWQP1SEND_V3_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action_high;
	/*
	 * This value selects bits 25:16 of the CFA action to perform on
	 * the packet. See the cfa_action field for more information.
	 */
	#define SQ_RAWQP1SEND_V3_CFA_ACTION_HIGH_MASK UINT32_C(0x3ff)
	#define SQ_RAWQP1SEND_V3_CFA_ACTION_HIGH_SFT 0
	uint16_t	reserved_2;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_DE	UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_TPID88A8  (UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_TPID8100  (UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_TPID9100  (UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_TPID9200  (UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_TPID9300  (UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_TPIDCFG   (UINT32_C(0x5) << 16)
		#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_LAST	SQ_RAWQP1SEND_V3_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_RESERVED_MASK UINT32_C(0xff80000)
	#define SQ_RAWQP1SEND_V3_CFA_META_VLAN_RESERVED_SFT 19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define SQ_RAWQP1SEND_V3_CFA_META_KEY_MASK	UINT32_C(0xf0000000)
	#define SQ_RAWQP1SEND_V3_CFA_META_KEY_SFT	28
	/* No editing */
		#define SQ_RAWQP1SEND_V3_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define SQ_RAWQP1SEND_V3_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
		#define SQ_RAWQP1SEND_V3_CFA_META_KEY_LAST	SQ_RAWQP1SEND_V3_CFA_META_KEY_VLAN_TAG
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_RAWQP1SEND_V3_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_RAWQP1SEND_V3_TIMESTAMP_SFT 0
	uint64_t	reserved_3;
	/*
	 * When inline=0, then this area is filled with from 1 to 6 SGEs
	 * based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * send. Length of data is described in the inline_length field.
	 * Bits [7:0] of word 0 hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_rawqp1send_v3_t, *psq_rawqp1send_v3_t;

/* SQ WQE V3 structure for Raw Ethernet and QP1 SQs. */
/* sq_rawqp1send_hdr_v3 (size:256b/32B) */

typedef struct sq_rawqp1send_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* RawEth/QP1 Send V3 */
	#define SQ_RAWQP1SEND_HDR_V3_WQE_TYPE_RAWQP1SEND_V3 UINT32_C(0x1d)
	#define SQ_RAWQP1SEND_HDR_V3_WQE_TYPE_LAST	SQ_RAWQP1SEND_HDR_V3_WQE_TYPE_RAWQP1SEND_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_RAWQP1SEND_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a QP1 send.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a QP1 send.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE.
	 *
	 * This flag must be zero for a QP1 send.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * This field shall never exceed 32 for WQEs of this type.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_RAWQP1SEND_HDR_V3_WQE_SIZE_SFT 0
	uint8_t	inline_length;
	/*
	 * When inline flag is '1', this field determines the number of
	 * bytes that are valid in the last 16B unit of the inline WQE.
	 * Zero means all 16 bytes are valid. One means only bits 7:0 of
	 * the last 16B unit are valid. This means the total size of the
	 * inline data is determined by a combination of the wqe_size field
	 * and this inline_length field.
	 *
	 * `inline_size = ((wqe_size - 1) * 16) - data_offset_in_bytes +
	 * ((inline_length == 0 ) ? 16 : inline_length)
	 *
	 * Where data_offset_in_bytes is the offset within the WQE where
	 * the data field starts.
	 *
	 * Note that this field is not applicable for zero-length inline
	 * WQEs.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_INLINE_LENGTH_MASK UINT32_C(0xf)
	#define SQ_RAWQP1SEND_HDR_V3_INLINE_LENGTH_SFT 0
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor. In case of
	 * VXLAN, the controller also replaces the outer header UDP
	 * checksum with hardware calculated UDP checksum for the packet
	 * associated with this descriptor.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to 1, The controller replaces the Outer-tunnel IP
	 * checksum field with hardware calculated IP checksum for the IP
	 * header of the packet associated with this descriptor.
	 *
	 * For outer UDP checksum, it will be the following behavior for
	 * all cases independent of settings of inner LSO and checksum
	 * offload BD flags:
	 *
	 * - If outer UDP checksum is 0, then do not update it.
	 * - If outer UDP checksum is non zero, then the hardware should
	 *   compute and update it.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_LFLAGS_OT_IP_CHKSUM	UINT32_C(0x20)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action_high;
	/*
	 * This value selects bits 25:16 of the CFA action to perform on
	 * the packet. See the cfa_action field for more information.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_CFA_ACTION_HIGH_MASK UINT32_C(0x3ff)
	#define SQ_RAWQP1SEND_HDR_V3_CFA_ACTION_HIGH_SFT 0
	uint16_t	reserved_2;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_DE	UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_TPID88A8  (UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_TPID8100  (UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_TPID9100  (UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_TPID9200  (UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_TPID9300  (UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_TPIDCFG   (UINT32_C(0x5) << 16)
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_LAST	SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_RESERVED_MASK UINT32_C(0xff80000)
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_VLAN_RESERVED_SFT 19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_KEY_MASK	UINT32_C(0xf0000000)
	#define SQ_RAWQP1SEND_HDR_V3_CFA_META_KEY_SFT	28
	/* No editing */
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
		#define SQ_RAWQP1SEND_HDR_V3_CFA_META_KEY_LAST	SQ_RAWQP1SEND_HDR_V3_CFA_META_KEY_VLAN_TAG
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_RAWQP1SEND_HDR_V3_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_RAWQP1SEND_HDR_V3_TIMESTAMP_SFT 0
	uint64_t	reserved_3;
} sq_rawqp1send_hdr_v3_t, *psq_rawqp1send_hdr_v3_t;

/* SQ Send WQE V3 for UD SQs. */
/* sq_udsend_v3 (size:1024b/128B) */

typedef struct sq_udsend_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * UD Send V3
	 *
	 * Allowed only on unreliable datagram (UD) SQs.
	 */
	#define SQ_UDSEND_V3_WQE_TYPE_UDSEND_V3	UINT32_C(0x13)
	/*
	 * UD Send with Immediate V3
	 *
	 * Allowed only on unreliable datagram (UD) SQs.
	 */
	#define SQ_UDSEND_V3_WQE_TYPE_UDSEND_W_IMMED_V3 UINT32_C(0x14)
	#define SQ_UDSEND_V3_WQE_TYPE_LAST		SQ_UDSEND_V3_WQE_TYPE_UDSEND_W_IMMED_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_UDSEND_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_UDSEND_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_UDSEND_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE.
	 */
	#define SQ_UDSEND_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_UDSEND_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_UDSEND_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_UDSEND_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * This field shall never exceed 32 for WQEs of this type.
	 */
	#define SQ_UDSEND_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_UDSEND_V3_WQE_SIZE_SFT 0
	uint8_t	inline_length;
	/*
	 * When inline flag is '1', this field determines the number of
	 * bytes that are valid in the last 16B unit of the inline WQE.
	 * Zero means all 16 bytes are valid. One means only bits 7:0 of
	 * the last 16B unit are valid. This means the total size of the
	 * inline data is determined by a combination of the wqe_size field
	 * and this inline_length field.
	 *
	 * `inline_size = ((wqe_size - 1) * 16) - data_offset_in_bytes +
	 * ((inline_length == 0 ) ? 16 : inline_length)
	 *
	 * Where data_offset_in_bytes is the offset within the WQE where
	 * the data field starts.
	 *
	 * Note that this field is not applicable for zero-length inline
	 * WQEs.
	 */
	#define SQ_UDSEND_V3_INLINE_LENGTH_MASK UINT32_C(0xf)
	#define SQ_UDSEND_V3_INLINE_LENGTH_SFT 0
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * Immediate value that will be sent with ImmDt header if wqe_type is
	 * UD Send with Immediate.
	 */
	uint32_t	imm_data;
	/*
	 * When in the SQ of a UD QP, indicates the q_key to be used in
	 * the transmitted packet. However, if the most significant bit
	 * of this field is set, then the q_key will be taken from QP
	 * context, rather than from this field.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	q_key;
	/*
	 * When in the SQ of a UD QP, indicates the destination QP to be
	 * used in the transmitted packet.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	dst_qp;
	#define SQ_UDSEND_V3_DST_QP_MASK UINT32_C(0xffffff)
	#define SQ_UDSEND_V3_DST_QP_SFT 0
	uint32_t	avid;
	/*
	 * If the serv_type is 'UD', then this field supplies the AVID
	 * (Address Vector ID).
	 */
	#define SQ_UDSEND_V3_AVID_MASK UINT32_C(0x3ff)
	#define SQ_UDSEND_V3_AVID_SFT 0
	uint32_t	reserved2;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_UDSEND_V3_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_UDSEND_V3_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 30 SGEs
	 * based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * send. Length of data is described in the inline_length field.
	 * Bits [7:0] of word 0 hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_udsend_v3_t, *psq_udsend_v3_t;

/* SQ WQE V3 header for UD SQs. */
/* sq_udsend_hdr_v3 (size:256b/32B) */

typedef struct sq_udsend_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * UD Send V3
	 *
	 * Allowed only on unreliable datagram (UD) SQs.
	 */
	#define SQ_UDSEND_HDR_V3_WQE_TYPE_UDSEND_V3	UINT32_C(0x13)
	/*
	 * UD Send with Immediate V3
	 *
	 * Allowed only on unreliable datagram (UD) SQs.
	 */
	#define SQ_UDSEND_HDR_V3_WQE_TYPE_UDSEND_W_IMMED_V3 UINT32_C(0x14)
	#define SQ_UDSEND_HDR_V3_WQE_TYPE_LAST		SQ_UDSEND_HDR_V3_WQE_TYPE_UDSEND_W_IMMED_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_UDSEND_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_UDSEND_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_UDSEND_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE.
	 */
	#define SQ_UDSEND_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_UDSEND_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_UDSEND_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_UDSEND_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * This field shall never exceed 32 for WQEs of this type.
	 */
	#define SQ_UDSEND_HDR_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_UDSEND_HDR_V3_WQE_SIZE_SFT 0
	uint8_t	inline_length;
	/*
	 * When inline flag is '1', this field determines the number of
	 * bytes that are valid in the last 16B unit of the inline WQE.
	 * Zero means all 16 bytes are valid. One means only bits 7:0 of
	 * the last 16B unit are valid. This means the total size of the
	 * inline data is determined by a combination of the wqe_size field
	 * and this inline_length field.
	 *
	 * `inline_size = ((wqe_size - 1) * 16) - data_offset_in_bytes +
	 * ((inline_length == 0 ) ? 16 : inline_length)
	 *
	 * Where data_offset_in_bytes is the offset within the WQE where
	 * the data field starts.
	 *
	 * Note that this field is not applicable for zero-length inline
	 * WQEs.
	 */
	#define SQ_UDSEND_HDR_V3_INLINE_LENGTH_MASK UINT32_C(0xf)
	#define SQ_UDSEND_HDR_V3_INLINE_LENGTH_SFT 0
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * Immediate value that will be sent with ImmDt header if wqe_type is
	 * UD Send with Immediate.
	 */
	uint32_t	imm_data;
	/*
	 * When in the SQ of a UD QP, indicates the q_key to be used in
	 * the transmitted packet. However, if the most significant bit
	 * of this field is set, then the q_key will be taken from QP
	 * context, rather than from this field.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	q_key;
	/*
	 * When in the SQ of a UD QP, indicates the destination QP to be
	 * used in the transmitted packet.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	dst_qp;
	#define SQ_UDSEND_HDR_V3_DST_QP_MASK UINT32_C(0xffffff)
	#define SQ_UDSEND_HDR_V3_DST_QP_SFT 0
	uint32_t	avid;
	/*
	 * If the serv_type is 'UD', then this field supplies the AVID
	 * (Address Vector ID).
	 */
	#define SQ_UDSEND_HDR_V3_AVID_MASK UINT32_C(0x3ff)
	#define SQ_UDSEND_HDR_V3_AVID_SFT 0
	uint32_t	reserved2;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_UDSEND_HDR_V3_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_UDSEND_HDR_V3_TIMESTAMP_SFT 0
} sq_udsend_hdr_v3_t, *psq_udsend_hdr_v3_t;

/* SQ RDMA WQE V3 for RC SQs. */
/* sq_rdma_v3 (size:1024b/128B) */

typedef struct sq_rdma_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * RDMA Write V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_V3_WQE_TYPE_WRITE_WQE_V3	UINT32_C(0x15)
	/*
	 * RDMA Write with Immediate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_V3_WQE_TYPE_WRITE_W_IMMED_V3 UINT32_C(0x16)
	/*
	 * RDMA Read V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_V3_WQE_TYPE_READ_WQE_V3	UINT32_C(0x17)
	#define SQ_RDMA_V3_WQE_TYPE_LAST		SQ_RDMA_V3_WQE_TYPE_READ_WQE_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_RDMA_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_RDMA_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_RDMA_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE.
	 */
	#define SQ_RDMA_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ following
	 * this WQE. This bit may be 1 only for write operations.
	 */
	#define SQ_RDMA_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_RDMA_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_RDMA_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * This field shall never exceed 32 for WQEs of this type.
	 */
	#define SQ_RDMA_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_RDMA_V3_WQE_SIZE_SFT 0
	uint8_t	inline_length;
	/*
	 * When inline flag is '1', this field determines the number of
	 * bytes that are valid in the last 16B unit of the inline WQE.
	 * Zero means all 16 bytes are valid. One means only bits 7:0 of
	 * the last 16B unit are valid. This means the total size of the
	 * inline data is determined by a combination of the wqe_size field
	 * and this inline_length field.
	 *
	 * `inline_size = ((wqe_size - 1) * 16) - data_offset_in_bytes +
	 * ((inline_length == 0 ) ? 16 : inline_length)
	 *
	 * Where data_offset_in_bytes is the offset within the WQE where
	 * the data field starts.
	 *
	 * Note that this field is not applicable for zero-length inline
	 * WQEs.
	 */
	#define SQ_RDMA_V3_INLINE_LENGTH_MASK UINT32_C(0xf)
	#define SQ_RDMA_V3_INLINE_LENGTH_SFT 0
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * Immediate data - valid for RDMA Write with immediate and
	 * causes the controller to add immDt header with this value
	 */
	uint32_t	imm_data;
	uint32_t	reserved2;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the RETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_RDMA_V3_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_RDMA_V3_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 30 SGEs
	 * based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the send.
	 * Length of data is described in the inline_length field. Bits [7:0]
	 * of word 0 hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_rdma_v3_t, *psq_rdma_v3_t;

/* SQ RDMA WQE V3 header for RC SQs. */
/* sq_rdma_hdr_v3 (size:256b/32B) */

typedef struct sq_rdma_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * RDMA Write V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_V3_WQE_TYPE_WRITE_WQE_V3	UINT32_C(0x15)
	/*
	 * RDMA Write with Immediate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_V3_WQE_TYPE_WRITE_W_IMMED_V3 UINT32_C(0x16)
	/*
	 * RDMA Read V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_V3_WQE_TYPE_READ_WQE_V3	UINT32_C(0x17)
	#define SQ_RDMA_HDR_V3_WQE_TYPE_LAST		SQ_RDMA_HDR_V3_WQE_TYPE_READ_WQE_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_RDMA_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_RDMA_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_RDMA_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE.
	 */
	#define SQ_RDMA_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ following
	 * this WQE. This bit may be 1 only for write operations.
	 */
	#define SQ_RDMA_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_RDMA_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_RDMA_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * This field shall never exceed 32 for WQEs of this type.
	 */
	#define SQ_RDMA_HDR_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_RDMA_HDR_V3_WQE_SIZE_SFT 0
	uint8_t	inline_length;
	/*
	 * When inline flag is '1', this field determines the number of
	 * bytes that are valid in the last 16B unit of the inline WQE.
	 * Zero means all 16 bytes are valid. One means only bits 7:0 of
	 * the last 16B unit are valid. This means the total size of the
	 * inline data is determined by a combination of the wqe_size field
	 * and this inline_length field.
	 *
	 * `inline_size = ((wqe_size - 1) * 16) - data_offset_in_bytes +
	 * ((inline_length == 0 ) ? 16 : inline_length)
	 *
	 * Where data_offset_in_bytes is the offset within the WQE where
	 * the data field starts.
	 *
	 * Note that this field is not applicable for zero-length inline
	 * WQEs.
	 */
	#define SQ_RDMA_HDR_V3_INLINE_LENGTH_MASK UINT32_C(0xf)
	#define SQ_RDMA_HDR_V3_INLINE_LENGTH_SFT 0
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * Immediate data - valid for RDMA Write with immediate and
	 * causes the controller to add immDt header with this value
	 */
	uint32_t	imm_data;
	uint32_t	reserved2;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the RETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_RDMA_HDR_V3_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_RDMA_HDR_V3_TIMESTAMP_SFT 0
} sq_rdma_hdr_v3_t, *psq_rdma_hdr_v3_t;

/* SQ Atomic V3 WQE for RC SQs. */
/* sq_atomic_v3 (size:448b/56B) */

typedef struct sq_atomic_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Atomic Compare/Swap V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_V3_WQE_TYPE_ATOMIC_CS_V3 UINT32_C(0x18)
	/*
	 * Atomic Fetch/Add V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_V3_WQE_TYPE_ATOMIC_FA_V3 UINT32_C(0x19)
	#define SQ_ATOMIC_V3_WQE_TYPE_LAST	SQ_ATOMIC_V3_WQE_TYPE_ATOMIC_FA_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_ATOMIC_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_ATOMIC_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_ATOMIC_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE.
	 */
	#define SQ_ATOMIC_V3_FLAGS_SE			UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_ATOMIC_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * The atomic WQE does not have a timestamp field, so this field is
	 * ignored and should be zero.
	 */
	#define SQ_ATOMIC_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_ATOMIC_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the Atomic WQE, this field will always have a value of 4.
	 */
	#define SQ_ATOMIC_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_ATOMIC_V3_WQE_SIZE_SFT 0
	uint8_t	reserved1;
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the AETH header. It identifies the
	 * MRW on the remote host.
	 */
	uint32_t	remote_key;
	uint32_t	reserved2;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/*
	 * For compare/swap, this is the data value to be placed in the
	 * remote host at the specified remote_VA if the comparison succeeds.
	 *
	 * For fetch/add, this is the value to be added to the data in the
	 * remote host at the specified remote_VA.
	 */
	uint64_t	swap_data;
	/*
	 * For compare/swap, this is the data value to be compared with the
	 * value in the remote host at the specified remote_VA.
	 *
	 * This field is not used for fetch/add.
	 */
	uint64_t	cmp_data;
	/*
	 * The virtual address in local memory or a physical address when
	 * l_key value is a reserved value of a physical address. Driver
	 * configures this value in the chip and the chip compares l_key in
	 * SGEs with that reserved value, if equal it access the physical
	 * address specified. The chip however MUST verify that the QP allows
	 * the use reserved key.
	 */
	uint64_t	va_or_pa;
	/*
	 * Local Key associated with this registered MR; The 24 msb of the
	 * key used to index the MRW Table and the 8 lsb are compared with
	 * the 8 bits key part stored in the MRWC. The PBL in the MRW Context
	 * is used to translate the above VA to physical address.
	 */
	uint32_t	l_key;
	/*
	 * Size of SGE in bytes; Based on page size of the system the chip
	 * knows how many entries are in the PBL
	 *
	 * This field must have a value of 8 for an Atomic WQE.
	 */
	uint32_t	size;
} sq_atomic_v3_t, *psq_atomic_v3_t;

/* SQ Atomic WQE V3 header for RC SQs. */
/* sq_atomic_hdr_v3 (size:320b/40B) */

typedef struct sq_atomic_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Atomic Compare/Swap V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_HDR_V3_WQE_TYPE_ATOMIC_CS_V3 UINT32_C(0x18)
	/*
	 * Atomic Fetch/Add V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_HDR_V3_WQE_TYPE_ATOMIC_FA_V3 UINT32_C(0x19)
	#define SQ_ATOMIC_HDR_V3_WQE_TYPE_LAST	SQ_ATOMIC_HDR_V3_WQE_TYPE_ATOMIC_FA_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_ATOMIC_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_ATOMIC_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_ATOMIC_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE.
	 */
	#define SQ_ATOMIC_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_ATOMIC_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * The atomic WQE does not have a timestamp field, so this field is
	 * ignored and should be zero.
	 */
	#define SQ_ATOMIC_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_ATOMIC_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the Atomic WQE, this field will always have a value of 4.
	 */
	#define SQ_ATOMIC_HDR_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_ATOMIC_HDR_V3_WQE_SIZE_SFT 0
	uint8_t	reserved1;
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the AETH header. It identifies the
	 * MRW on the remote host.
	 */
	uint32_t	remote_key;
	uint32_t	reserved2;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/*
	 * For compare/swap, this is the data value to be placed in the
	 * remote host at the specified remote_VA if the comparison succeeds.
	 *
	 * For fetch/add, this is the value to be added to the data in the
	 * remote host at the specified remote_VA.
	 */
	uint64_t	swap_data;
	/*
	 * For compare/swap, this is the data value to be compared with the
	 * value in the remote host at the specified remote_VA.
	 *
	 * This field is not used for fetch/add.
	 */
	uint64_t	cmp_data;
} sq_atomic_hdr_v3_t, *psq_atomic_hdr_v3_t;

/* SQ Local Invalidate WQE V3 for RC SQs. */
/* sq_localinvalidate_v3 (size:128b/16B) */

typedef struct sq_localinvalidate_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Local Invalidate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_LOCALINVALIDATE_V3_WQE_TYPE_LOCAL_INVALID_V3 UINT32_C(0x1a)
	#define SQ_LOCALINVALIDATE_V3_WQE_TYPE_LAST		SQ_LOCALINVALIDATE_V3_WQE_TYPE_LOCAL_INVALID_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_LOCALINVALIDATE_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_LOCALINVALIDATE_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_LOCALINVALIDATE_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_LOCALINVALIDATE_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the Local Invalidate WQE, this field will always have
	 * a value of 1.
	 */
	#define SQ_LOCALINVALIDATE_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_LOCALINVALIDATE_V3_WQE_SIZE_SFT 0
	uint8_t	reserved1;
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * The local key for the MR/W to invalidate; 24 msb of the key
	 * are used to index the MRW table, 8 lsb are compared with the
	 * 8 bit key in the MRWC
	 */
	uint32_t	inv_l_key;
	uint32_t	reserved2;
} sq_localinvalidate_v3_t, *psq_localinvalidate_v3_t;

/* SQ Local Invalidate WQE V3 header for RC SQs. */
/* sq_localinvalidate_hdr_v3 (size:128b/16B) */

typedef struct sq_localinvalidate_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Local Invalidate V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_WQE_TYPE_LOCAL_INVALID_V3 UINT32_C(0x1a)
	#define SQ_LOCALINVALIDATE_HDR_V3_WQE_TYPE_LAST		SQ_LOCALINVALIDATE_HDR_V3_WQE_TYPE_LOCAL_INVALID_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the Local Invalidate WQE, this field will always have
	 * a value of 1.
	 */
	#define SQ_LOCALINVALIDATE_HDR_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_LOCALINVALIDATE_HDR_V3_WQE_SIZE_SFT 0
	uint8_t	reserved1;
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * The local key for the MR/W to invalidate; 24 msb of the key
	 * are used to index the MRW table, 8 lsb are compared with the
	 * 8 bit key in the MRWC
	 */
	uint32_t	inv_l_key;
	uint32_t	reserved2;
} sq_localinvalidate_hdr_v3_t, *psq_localinvalidate_hdr_v3_t;

/*
 * SQ FR-PMR WQE V3 for RC SQs.
 *
 * The FR-PMR WQE must be padded to 3 slots (48 bytes) in the SQ, even
 * though the final 8 bytes are not shown here.
 */
/* sq_fr_pmr_v3 (size:320b/40B) */

typedef struct sq_fr_pmr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PMR (Fast Register Physical Memory Region) V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PMR_V3_WQE_TYPE_FR_PMR_V3 UINT32_C(0x1b)
	#define SQ_FR_PMR_V3_WQE_TYPE_LAST	SQ_FR_PMR_V3_WQE_TYPE_FR_PMR_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_FR_PMR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PMR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PMR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PMR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size_zero_based;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the FR-PMR WQE, this field will always have a value of 3.
	 */
	#define SQ_FR_PMR_V3_WQE_SIZE_MASK  UINT32_C(0x3f)
	#define SQ_FR_PMR_V3_WQE_SIZE_SFT   0
	/*
	 * If this is set, the PMR will be zero-based. If clear, the PMR
	 * will be non-zero-based.
	 */
	#define SQ_FR_PMR_V3_ZERO_BASED	UINT32_C(0x40)
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PMR_V3_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PMR_V3_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PMR_V3_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PMR_V3_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PMR_V3_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	uint16_t	page_size_log;
	/*
	 * This value controls the page size for leaf memory pages in
	 * a PBL. While many page sizes are supported only the following
	 * should be tested - 4k, 8k, 64k, 256k, 1m, 2m, 4m, 1g
	 */
	#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_16K	UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_32K	UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_64K	UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_128K	UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_256K	UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_512K	UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_16M	UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_32M	UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_64M	UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_128M	UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_256M	UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_512M	UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_16G	UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_32G	UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_64G	UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_128G	UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_256G	UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_512G	UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_V3_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_V3_PAGE_SIZE_LOG_PGSZ_8T
	/*
	 * This value controls the page size for page table elements
	 * within a PBL. While many page sizes are supported only the
	 * following should be tested - 4k, 8k, 64k, 256k, 1m, 2m, 4m, 1g
	 */
	#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x3e0)
	#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_SFT	5
	/* Page size is 4KB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_4K	(UINT32_C(0x0) << 5)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8K	(UINT32_C(0x1) << 5)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_16K   (UINT32_C(0x2) << 5)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_32K   (UINT32_C(0x3) << 5)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_64K   (UINT32_C(0x4) << 5)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_128K  (UINT32_C(0x5) << 5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_256K  (UINT32_C(0x6) << 5)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_512K  (UINT32_C(0x7) << 5)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_1M	(UINT32_C(0x8) << 5)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_2M	(UINT32_C(0x9) << 5)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_4M	(UINT32_C(0xa) << 5)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8M	(UINT32_C(0xb) << 5)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_16M   (UINT32_C(0xc) << 5)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_32M   (UINT32_C(0xd) << 5)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_64M   (UINT32_C(0xe) << 5)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_128M  (UINT32_C(0xf) << 5)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_256M  (UINT32_C(0x10) << 5)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_512M  (UINT32_C(0x11) << 5)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_1G	(UINT32_C(0x12) << 5)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_2G	(UINT32_C(0x13) << 5)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_4G	(UINT32_C(0x14) << 5)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8G	(UINT32_C(0x15) << 5)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_16G   (UINT32_C(0x16) << 5)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_32G   (UINT32_C(0x17) << 5)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_64G   (UINT32_C(0x18) << 5)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_128G  (UINT32_C(0x19) << 5)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_256G  (UINT32_C(0x1a) << 5)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_512G  (UINT32_C(0x1b) << 5)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_1T	(UINT32_C(0x1c) << 5)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_2T	(UINT32_C(0x1d) << 5)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_4T	(UINT32_C(0x1e) << 5)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8T	(UINT32_C(0x1f) << 5)
		#define SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Number of levels of PBL for translation */
	#define SQ_FR_PMR_V3_NUMLEVELS_MASK		UINT32_C(0xc00)
	#define SQ_FR_PMR_V3_NUMLEVELS_SFT		10
	/*
	 * A zero level PBL means that the VA is the physical address
	 * used for the operation. No translation is done by the PTU.
	 */
		#define SQ_FR_PMR_V3_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 10)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PBE values that point to actual pg_size physical
	 * pages.
	 */
		#define SQ_FR_PMR_V3_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 10)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PDE values that in turn point to pbl_pg_size
	 * physical pages that contain PBE values that point to actual
	 * physical pages.
	 */
		#define SQ_FR_PMR_V3_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 10)
		#define SQ_FR_PMR_V3_NUMLEVELS_LAST		SQ_FR_PMR_V3_NUMLEVELS_LAYER2
	uint16_t	reserved;
	/* Local Virtual Address */
	uint64_t	va;
	/* Length in bytes of registered MR */
	uint64_t	length;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pbl_ptr;
} sq_fr_pmr_v3_t, *psq_fr_pmr_v3_t;

/* SQ FR-PMR WQE V3 header for RC SQs. */
/* sq_fr_pmr_hdr_v3 (size:320b/40B) */

typedef struct sq_fr_pmr_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PMR (Fast Register Physical Memory Region) V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PMR_HDR_V3_WQE_TYPE_FR_PMR_V3 UINT32_C(0x1b)
	#define SQ_FR_PMR_HDR_V3_WQE_TYPE_LAST	SQ_FR_PMR_HDR_V3_WQE_TYPE_FR_PMR_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_FR_PMR_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PMR_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PMR_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PMR_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*  */
	uint8_t	wqe_size_zero_based;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the FR-PMR WQE, this field will always have a value of 3.
	 */
	#define SQ_FR_PMR_HDR_V3_WQE_SIZE_MASK  UINT32_C(0x3f)
	#define SQ_FR_PMR_HDR_V3_WQE_SIZE_SFT   0
	/*
	 * If this is set, the PMR will be zero-based. If clear, the PMR
	 * will be non-zero-based.
	 */
	#define SQ_FR_PMR_HDR_V3_ZERO_BASED	UINT32_C(0x40)
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PMR_HDR_V3_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PMR_HDR_V3_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PMR_HDR_V3_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PMR_HDR_V3_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PMR_HDR_V3_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	uint16_t	page_size_log;
	/*
	 * This value controls the page size for leaf memory pages in
	 * a PBL. While many page sizes are supported only the following
	 * should be tested - 4k, 8k, 64k, 256k, 1m, 2m, 4m, 1g
	 */
	#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_16K	UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_32K	UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_64K	UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_128K	UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_256K	UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_512K	UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_16M	UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_32M	UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_64M	UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_128M	UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_256M	UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_512M	UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_16G	UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_32G	UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_64G	UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_128G	UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_256G	UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_512G	UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_HDR_V3_PAGE_SIZE_LOG_PGSZ_8T
	/*
	 * This value controls the page size for page table elements
	 * within a PBL. While many page sizes are supported only the
	 * following should be tested - 4k, 8k, 64k, 256k, 1m, 2m, 4m, 1g
	 */
	#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x3e0)
	#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_SFT	5
	/* Page size is 4KB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_4K	(UINT32_C(0x0) << 5)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8K	(UINT32_C(0x1) << 5)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_16K   (UINT32_C(0x2) << 5)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_32K   (UINT32_C(0x3) << 5)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_64K   (UINT32_C(0x4) << 5)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_128K  (UINT32_C(0x5) << 5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_256K  (UINT32_C(0x6) << 5)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_512K  (UINT32_C(0x7) << 5)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_1M	(UINT32_C(0x8) << 5)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_2M	(UINT32_C(0x9) << 5)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_4M	(UINT32_C(0xa) << 5)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8M	(UINT32_C(0xb) << 5)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_16M   (UINT32_C(0xc) << 5)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_32M   (UINT32_C(0xd) << 5)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_64M   (UINT32_C(0xe) << 5)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_128M  (UINT32_C(0xf) << 5)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_256M  (UINT32_C(0x10) << 5)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_512M  (UINT32_C(0x11) << 5)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_1G	(UINT32_C(0x12) << 5)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_2G	(UINT32_C(0x13) << 5)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_4G	(UINT32_C(0x14) << 5)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8G	(UINT32_C(0x15) << 5)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_16G   (UINT32_C(0x16) << 5)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_32G   (UINT32_C(0x17) << 5)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_64G   (UINT32_C(0x18) << 5)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_128G  (UINT32_C(0x19) << 5)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_256G  (UINT32_C(0x1a) << 5)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_512G  (UINT32_C(0x1b) << 5)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_1T	(UINT32_C(0x1c) << 5)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_2T	(UINT32_C(0x1d) << 5)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_4T	(UINT32_C(0x1e) << 5)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8T	(UINT32_C(0x1f) << 5)
		#define SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_HDR_V3_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Number of levels of PBL for translation */
	#define SQ_FR_PMR_HDR_V3_NUMLEVELS_MASK		UINT32_C(0xc00)
	#define SQ_FR_PMR_HDR_V3_NUMLEVELS_SFT		10
	/*
	 * A zero level PBL means that the VA is the physical address
	 * used for the operation. No translation is done by the PTU.
	 */
		#define SQ_FR_PMR_HDR_V3_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 10)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PBE values that point to actual pg_size physical
	 * pages.
	 */
		#define SQ_FR_PMR_HDR_V3_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 10)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that
	 * contains PDE values that in turn point to pbl_pg_size
	 * physical pages that contain PBE values that point to actual
	 * physical pages.
	 */
		#define SQ_FR_PMR_HDR_V3_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 10)
		#define SQ_FR_PMR_HDR_V3_NUMLEVELS_LAST		SQ_FR_PMR_HDR_V3_NUMLEVELS_LAYER2
	uint16_t	reserved;
	/* Local Virtual Address */
	uint64_t	va;
	/* Length in bytes of registered MR */
	uint64_t	length;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pbl_ptr;
} sq_fr_pmr_hdr_v3_t, *psq_fr_pmr_hdr_v3_t;

/*
 * SQ Bind WQE V3. This WQE can perform either:
 * * type1 "bind memory window", if mw_type==Type1
 * * type2 "post send bind memory window", if mw_type==Type2
 */
/* sq_bind_v3 (size:256b/32B) */

typedef struct sq_bind_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Memory Bind V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BIND_V3_WQE_TYPE_BIND_V3 UINT32_C(0x1c)
	#define SQ_BIND_V3_WQE_TYPE_LAST   SQ_BIND_V3_WQE_TYPE_BIND_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_BIND_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_BIND_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_BIND_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_BIND_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	uint8_t	wqe_size_zero_based_mw_type;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the Bind WQE, this field will always have a value of 2.
	 */
	#define SQ_BIND_V3_WQE_SIZE_MASK  UINT32_C(0x3f)
	#define SQ_BIND_V3_WQE_SIZE_SFT   0
	/*
	 * If this bit is set, then the newly-bound memory window will be
	 * zero-based. If clear, then the newly-bound memory window will be
	 * non-zero-based.
	 */
	#define SQ_BIND_V3_ZERO_BASED	UINT32_C(0x40)
	/*
	 * If type1 is specified, then this WQE performs a "bind memory
	 * window" operation on a type1 window. If type2 is specified, then
	 * this WQE performs a "post send bind memory window" operation on a
	 * type2 window.
	 *
	 * Note that the bind WQE cannot change the type of the memory
	 * window.
	 *
	 * If a "bind memory window" operation is attempted on a memory
	 * window that was allocated as type2, then the bind will fail with
	 * an errored completion, as "bind memory window" is allowed only on
	 * type1 memory windows.
	 *
	 * Similarly, if a "post send bind memory window" operation is
	 * attempted on a memory window that was allocated as type1, then the
	 * bind will fail with an errored completions, as "post send bind
	 * memory window" is allowed only on type2 memory windows.
	 */
	#define SQ_BIND_V3_MW_TYPE	UINT32_C(0x80)
	/* Type 1 Bind Memory Window */
		#define SQ_BIND_V3__TYPE1	(UINT32_C(0x0) << 7)
	/* Type 2 Post Send Bind Memory Window */
		#define SQ_BIND_V3__TYPE2	(UINT32_C(0x1) << 7)
		#define SQ_BIND_V3__LAST	SQ_BIND_V3__TYPE2
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/*
	 * Local Write Access.
	 *
	 * Local accesses are never allowed for memory windows, so this
	 * bit must always be zero in a bind WQE. If this bit is ever
	 * set, the bind will fail with an errored completion.
	 */
	#define SQ_BIND_V3_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_BIND_V3_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/*
	 * Remote Write Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes. If this is not
	 * the case, then the bind will fail with an errored completion.
	 */
	#define SQ_BIND_V3_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/*
	 * Remote Atomic Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes. If this is not
	 * the case, then the bind will fail with an errored completion.
	 */
	#define SQ_BIND_V3_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/*
	 * Window Binding Allowed.
	 *
	 * It is never allowed to bind windows to windows, so this bit
	 * must always be zero in a bind WQE. If this bit is ever set,
	 * the bind will fail with an errored completion.
	 */
	#define SQ_BIND_V3_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * The L_Key of the parent MR; 24 msb of the key are used to
	 * index the MRW table, 8 lsb are compared with the 8 bit key
	 * in the MRWC.
	 */
	uint32_t	parent_l_key;
	/*
	 * Local Key; 24 msb of the key are used to index the memory
	 * window being bound in the MRW table, 8 lsb are assign to the
	 * 8 bit key_lsb field in the MRWC.
	 */
	uint32_t	l_key;
	/* Local Virtual Address */
	uint64_t	va;
	/*
	 * Length in bytes of registered MW; 40 bits as this is the max
	 * size of an MR/W
	 */
	uint64_t	length;
} sq_bind_v3_t, *psq_bind_v3_t;

/*
 * SQ Bind WQE V3 header. This WQE can perform either:
 * * type1 "bind memory window", if mw_type==Type1
 * * type2 "post send bind memory window", if mw_type==Type2
 */
/* sq_bind_hdr_v3 (size:256b/32B) */

typedef struct sq_bind_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Memory Bind V3
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BIND_HDR_V3_WQE_TYPE_BIND_V3 UINT32_C(0x1c)
	#define SQ_BIND_HDR_V3_WQE_TYPE_LAST   SQ_BIND_HDR_V3_WQE_TYPE_BIND_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_BIND_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_BIND_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_BIND_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_BIND_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	uint8_t	wqe_size_zero_based_mw_type;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the Bind WQE, this field will always have a value of 2.
	 */
	#define SQ_BIND_HDR_V3_WQE_SIZE_MASK  UINT32_C(0x3f)
	#define SQ_BIND_HDR_V3_WQE_SIZE_SFT   0
	/*
	 * If this bit is set, then the newly-bound memory window will be
	 * zero-based. If clear, then the newly-bound memory window will be
	 * non-zero-based.
	 */
	#define SQ_BIND_HDR_V3_ZERO_BASED	UINT32_C(0x40)
	/*
	 * If type1 is specified, then this WQE performs a "bind memory
	 * window" operation on a type1 window. If type2 is specified, then
	 * this WQE performs a "post send bind memory window" operation on a
	 * type2 window.
	 *
	 * Note that the bind WQE cannot change the type of the memory
	 * window.
	 *
	 * If a "bind memory window" operation is attempted on a memory
	 * window that was allocated as type2, then the bind will fail with
	 * an errored completion, as "bind memory window" is allowed only on
	 * type1 memory windows.
	 *
	 * Similarly, if a "post send bind memory window" operation is
	 * attempted on a memory window that was allocated as type1, then the
	 * bind will fail with an errored completions, as "post send bind
	 * memory window" is allowed only on type2 memory windows.
	 */
	#define SQ_BIND_HDR_V3_MW_TYPE	UINT32_C(0x80)
	/* Type 1 Bind Memory Window */
		#define SQ_BIND_HDR_V3__TYPE1	(UINT32_C(0x0) << 7)
	/* Type 2 Post Send Bind Memory Window */
		#define SQ_BIND_HDR_V3__TYPE2	(UINT32_C(0x1) << 7)
		#define SQ_BIND_HDR_V3__LAST	SQ_BIND_HDR_V3__TYPE2
	/*
	 * This is the new access control for the MR. '1' means
	 * the operation is allowed. '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/*
	 * Local Write Access.
	 *
	 * Local accesses are never allowed for memory windows, so this
	 * bit must always be zero in a bind WQE. If this bit is ever
	 * set, the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_V3_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_BIND_HDR_V3_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/*
	 * Remote Write Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes. If this is not
	 * the case, then the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_V3_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/*
	 * Remote Atomic Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes. If this is not
	 * the case, then the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_V3_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/*
	 * Window Binding Allowed.
	 *
	 * It is never allowed to bind windows to windows, so this bit
	 * must always be zero in a bind WQE. If this bit is ever set,
	 * the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_V3_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/*
	 * The L_Key of the parent MR; 24 msb of the key are used to
	 * index the MRW table, 8 lsb are compared with the 8 bit key
	 * in the MRWC.
	 */
	uint32_t	parent_l_key;
	/*
	 * Local Key; 24 msb of the key are used to index the memory
	 * window being bound in the MRW table, 8 lsb are assign to the
	 * 8 bit key_lsb field in the MRWC.
	 */
	uint32_t	l_key;
	/* Local Virtual Address */
	uint64_t	va;
	/*
	 * Length in bytes of registered MW; 40 bits as this is the max
	 * size of an MR/W
	 */
	uint64_t	length;
} sq_bind_hdr_v3_t, *psq_bind_hdr_v3_t;

/*
 * This is the Change UDP Source Port WQE V3 structure. It is supported
 * for both RC and UD QP's.
 *
 * It is recommended to set the uc_fence flag for this WQE, so that the
 * source port does not change while there are unacknowledged packets.
 */
/* sq_change_udpsrcport_v3 (size:128b/16B) */

typedef struct sq_change_udpsrcport_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Change UDP Source Port V3 */
	#define SQ_CHANGE_UDPSRCPORT_V3_WQE_TYPE_CHANGE_UDPSRCPORT_V3 UINT32_C(0x1e)
	#define SQ_CHANGE_UDPSRCPORT_V3_WQE_TYPE_LAST		SQ_CHANGE_UDPSRCPORT_V3_WQE_TYPE_CHANGE_UDPSRCPORT_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_CHANGE_UDPSRCPORT_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_CHANGE_UDPSRCPORT_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 *
	 * It is recommended to set this flag for Change UDP Source Port
	 * WQE's.
	 */
	#define SQ_CHANGE_UDPSRCPORT_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_CHANGE_UDPSRCPORT_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_CHANGE_UDPSRCPORT_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_CHANGE_UDPSRCPORT_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_CHANGE_UDPSRCPORT_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	uint8_t	wqe_size;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the Change UDP Source Port WQE, this field will always have
	 * a value of 1.
	 */
	#define SQ_CHANGE_UDPSRCPORT_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_CHANGE_UDPSRCPORT_V3_WQE_SIZE_SFT 0
	uint8_t	reserved_1;
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/* The new value for the QP's UDP source port. */
	uint16_t	udp_src_port;
	uint16_t	reserved_2;
	uint32_t	reserved_3;
} sq_change_udpsrcport_v3_t, *psq_change_udpsrcport_v3_t;

/* SQ Change UDP Source Port WQE V3 header */
/* sq_change_udpsrcport_hdr_v3 (size:128b/16B) */

typedef struct sq_change_udpsrcport_hdr_v3 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Change UDP Source Port V3 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_WQE_TYPE_CHANGE_UDPSRCPORT_V3 UINT32_C(0x1e)
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_WQE_TYPE_LAST		SQ_CHANGE_UDPSRCPORT_HDR_V3_WQE_TYPE_CHANGE_UDPSRCPORT_V3
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (The se flag refers to the receiver side).
	 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 *
	 * It is recommended to set this flag for Change UDP Source Port
	 * WQE's.
	 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_FLAGS_UC_FENCE		UINT32_C(0x4)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_FLAGS_SE			UINT32_C(0x8)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	uint8_t	wqe_size;
	/*
	 * The size of the WQE in units of 16B chunks.
	 *
	 * For the Change UDP Source Port WQE, this field will always have
	 * a value of 1.
	 */
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_WQE_SIZE_MASK UINT32_C(0x3f)
	#define SQ_CHANGE_UDPSRCPORT_HDR_V3_WQE_SIZE_SFT 0
	uint8_t	reserved_1;
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
	/* The new value for the QP's UDP source port. */
	uint16_t	udp_src_port;
	uint16_t	reserved_2;
	uint32_t	reserved_3;
} sq_change_udpsrcport_hdr_v3_t, *psq_change_udpsrcport_hdr_v3_t;

/* RQ/SRQ WQE */
/* rq_wqe (size:1024b/128B) */

typedef struct rq_wqe {
	/* wqe_type is 8 b */
	uint8_t	wqe_type;
	/*
	 * RQ/SRQ WQE. This WQE is used for posting buffers on
	 * an RQ or SRQ.
	 */
	#define RQ_WQE_WQE_TYPE_RCV UINT32_C(0x80)
	#define RQ_WQE_WQE_TYPE_LAST RQ_WQE_WQE_TYPE_RCV
	/* No flags supported for this WQE type. */
	uint8_t	flags;
	/*
	 * Specify the total number 16B chunks that make up the valid
	 * portion of the WQE. This includes the first chunk that is the
	 * WQE structure and up to 6 SGE structures.
	 *
	 * While the valid area is defined by the wqe_size field, the
	 * actual WQE size is fixed at 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	uint32_t	reserved32;
	uint64_t	wr_id;
	/*
	 * Opaque value used by upper layer SW to identify the id of the
	 * WR which generated the WQE. Used in CQE. Valid in the first
	 * SGE of an SRQ WQE.
	 */
	#define RQ_WQE_WR_ID_MASK UINT32_C(0xfffff)
	#define RQ_WQE_WR_ID_SFT 0
	uint8_t	reserved128[16];
	/*
	 * The data field for RQ WQE is filled with from 1 to 6 SGE
	 * structures as defined by the wqe_size field.
	 */
	uint32_t	data[24];
} rq_wqe_t, *prq_wqe_t;

/* RQ/SRQ WQE header. */
/* rq_wqe_hdr (size:256b/32B) */

typedef struct rq_wqe_hdr {
	/* wqe_type is 8 b */
	uint8_t	wqe_type;
	/*
	 * RQ/SRQ WQE. This WQE is used for posting buffers on
	 * an RQ or SRQ.
	 */
	#define RQ_WQE_HDR_WQE_TYPE_RCV UINT32_C(0x80)
	#define RQ_WQE_HDR_WQE_TYPE_LAST RQ_WQE_HDR_WQE_TYPE_RCV
	/* No flags supported for this WQE type. */
	uint8_t	flags;
	/*
	 * Specify the total number 16B chunks that make up the valid
	 * portion of the WQE. This includes the first chunk that is the
	 * WQE structure and up to 6 SGE structures.
	 *
	 * While the valid area is defined by the wqe_size field, the
	 * actual WQE size is fixed at 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	uint32_t	reserved32;
	uint64_t	wr_id;
	/*
	 * Opaque value used by upper layer SW to identify the id of the
	 * WR which generated the WQE. Used in CQE. Valid in the first
	 * SGE of an SRQ WQE.
	 */
	#define RQ_WQE_HDR_WR_ID_MASK UINT32_C(0xfffff)
	#define RQ_WQE_HDR_WR_ID_SFT 0
	uint8_t	reserved128[16];
} rq_wqe_hdr_t, *prq_wqe_hdr_t;

/* RQ/SRQ WQE V3 */
/* rq_wqe_v3 (size:4096b/512B) */

typedef struct rq_wqe_v3 {
	/* wqe_type is 8 b */
	uint8_t	wqe_type;
	/*
	 * RQ/SRQ WQE V3. This WQE is used for posting buffers on
	 * an RQ or SRQ.
	 */
	#define RQ_WQE_V3_WQE_TYPE_RCV_V3 UINT32_C(0x90)
	#define RQ_WQE_V3_WQE_TYPE_LAST  RQ_WQE_V3_WQE_TYPE_RCV_V3
	/* No flags supported for this WQE type. */
	uint8_t	flags;
	/*
	 * Specify the total number 16B chunks that make up the valid portion
	 * of the WQE. This includes the first chunk that is the WQE
	 * structure and up to 30 SGE structures. The maximum value for this
	 * field is 32, representing a maximum-sized WQE of 512B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved1;
	/* This value will be returned in the completion. */
	uint32_t	opaque;
	uint64_t	reserved2;
	/*
	 * The data field for RQ WQE is filled with from 1 to 30 SGE
	 * structures as defined by the wqe_size field.
	 */
	uint32_t	data[124];
} rq_wqe_v3_t, *prq_wqe_v3_t;

/* RQ/SRQ WQE V3 header. */
/* rq_wqe_hdr_v3 (size:128b/16B) */

typedef struct rq_wqe_hdr_v3 {
	/* wqe_type is 8 b */
	uint8_t	wqe_type;
	/*
	 * RQ/SRQ WQE V3. This WQE is used for posting buffers on
	 * an RQ or SRQ.
	 */
	#define RQ_WQE_HDR_V3_WQE_TYPE_RCV_V3 UINT32_C(0x90)
	#define RQ_WQE_HDR_V3_WQE_TYPE_LAST  RQ_WQE_HDR_V3_WQE_TYPE_RCV_V3
	/* No flags supported for this WQE type. */
	uint8_t	flags;
	/*
	 * Specify the total number 16B chunks that make up the valid portion
	 * of the WQE. This includes the first chunk that is the WQE
	 * structure and up to 30 SGE structures. The maximum value for this
	 * field is 32, representing a maximum-sized WQE of 512B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved1;
	/* This value will be returned in the completion. */
	uint32_t	opaque;
	uint64_t	reserved2;
} rq_wqe_hdr_v3_t, *prq_wqe_hdr_v3_t;

/* cq_base (size:256b/32B) */

typedef struct cq_base {
	uint64_t	reserved64_1;
	uint64_t	reserved64_2;
	uint64_t	reserved64_3;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. The NIC
	 * toggle this bit each time it finished consuming all PBL
	 * entries.
	 */
	#define CQ_BASE_TOGGLE			UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_BASE_CQE_TYPE_MASK		UINT32_C(0x1e)
	#define CQ_BASE_CQE_TYPE_SFT		1
	/*
	 * Requester completion - This is used for both RC and UD SQ
	 * completions.
	 */
		#define CQ_BASE_CQE_TYPE_REQ		(UINT32_C(0x0) << 1)
	/*
	 * Responder RC Completion - This is used for both RQ and SRQ
	 * completions for RC service QPs.
	 */
		#define CQ_BASE_CQE_TYPE_RES_RC		(UINT32_C(0x1) << 1)
	/*
	 * Responder UD Completion - This is used for both RQ and SRQ
	 * completion for UD service QPs.
	 */
		#define CQ_BASE_CQE_TYPE_RES_UD		(UINT32_C(0x2) << 1)
	/*
	 * Responder RawEth and QP1 Completion - This is used for RQ
	 * completion for RawEth service and QP1 service QPs.
	 */
		#define CQ_BASE_CQE_TYPE_RES_RAWETH_QP1	(UINT32_C(0x3) << 1)
	/*
	 * Responder UD completion with CFA. This is used for both RQ
	 * and SQ completion for UD service QPs. It includes cfa fields
	 * (some of which carry VLAN information), in place of QP handle.
	 */
		#define CQ_BASE_CQE_TYPE_RES_UD_CFA	(UINT32_C(0x4) << 1)
	/*
	 * Requester completion V3 - This is used for both RC and UD SQ
	 * completions.
	 */
		#define CQ_BASE_CQE_TYPE_REQ_V3		(UINT32_C(0x8) << 1)
	/*
	 * Responder RC Completion V3 - This is used for both RQ and SRQ
	 * completions for RC service QPs.
	 */
		#define CQ_BASE_CQE_TYPE_RES_RC_V3	(UINT32_C(0x9) << 1)
	/*
	 * Responder UD Completion V3 - This is used for both RQ and SRQ
	 * completion for UD service QPs. It is also used for QP1 QPs
	 * that are treated as UD.
	 */
		#define CQ_BASE_CQE_TYPE_RES_UD_V3	(UINT32_C(0xa) << 1)
	/*
	 * Responder RawEth and QP1 Completion V3 - This is used for RQ and
	 * SRQ completion for RawEth service. It is also used for QP1 QPs
	 * that are treated as RawEth.
	 */
		#define CQ_BASE_CQE_TYPE_RES_RAWETH_QP1_V3  (UINT32_C(0xb) << 1)
	/*
	 * Responder UD Completion with CFA V3 - This is used for both RQ
	 * and SRQ completion for UD service QPs. It includes CFA fields
	 * (some of which carry VLAN information), in place of the QP
	 * handle. It is also used for QP1 QPs that are treated as UD.
	 */
		#define CQ_BASE_CQE_TYPE_RES_UD_CFA_V3	(UINT32_C(0xc) << 1)
	/*
	 * NO_OP completion - This is used to indicate that no
	 * operation completed.
	 */
		#define CQ_BASE_CQE_TYPE_NO_OP		(UINT32_C(0xd) << 1)
	/*
	 * Terminal completion - This is used to indicate that no
	 * further completions will be made for this QP on this CQ.
	 */
		#define CQ_BASE_CQE_TYPE_TERMINAL	(UINT32_C(0xe) << 1)
	/*
	 * Cut off CQE; for CQ resize. This CQE is written to the "old"
	 * CQ as the last CQE written. SW may use this to know when the
	 * "old" CQ can be destroyed.
	 */
		#define CQ_BASE_CQE_TYPE_CUT_OFF		(UINT32_C(0xf) << 1)
		#define CQ_BASE_CQE_TYPE_LAST		CQ_BASE_CQE_TYPE_CUT_OFF
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_BASE_STATUS_OK			UINT32_C(0x0)
	/*
	 * An unexpected BTH opcode or a First/Middle packet that is not
	 * the full MTU size was returned by the responder.
	 *
	 * This is a fatal error detected by the requester Rx.
	 */
	#define CQ_BASE_STATUS_BAD_RESPONSE_ERR	UINT32_C(0x1)
	/*
	 * Generated for a WQE posted to the local SQ when the sum of the
	 * lengths of the SGEs in the WQE exceeds the maximum message
	 * length of 2^31 bytes.
	 *
	 * Generated for a WQE posted to the local RQ/SRQ when the sum of
	 * the lengths of the SGEs in the WQE is too small to receive the
	 * (valid) incoming message or the length of the incoming message
	 * is greater than the maximum message size supported.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_BASE_STATUS_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/*
	 * This indicates that the packet was too long for the WQE provided
	 * on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields in the CQE are valid.
	 */
	#define CQ_BASE_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x3)
	/*
	 * An internal QP consistency error was detected while processing
	 * this Work Request. For requester, this could be an SQ WQE format
	 * error or an operation specified in the WQE that is not supported
	 * for the QP. For responder, this is an RQ/SRQ WQE format error.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_BASE_STATUS_LOCAL_QP_OPERATION_ERR	UINT32_C(0x4)
	/*
	 * An SGE in the locally posted WQE does not reference a Memory
	 * Region that is valid for the requested operation. If this error
	 * is generated for an SGE using the reserved l_key, this means
	 * that the reserved l_key is not enabled.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_BASE_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x5)
	/*
	 * A protection error occurred on a local data buffer during the
	 * processing of a RDMA Write with Immediate Data operation sent
	 * from the remote node.
	 *
	 * This is a fatal error detected by the responder Rx. Only the
	 * opaque field in the CQE is valid.
	 */
	#define CQ_BASE_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x6)
	/*
	 * The SSC detected an error on a local memory operation from the
	 * SQ (fast-register, local invalidate, or bind).
	 *
	 * This is a fatal error detected by the requester Tx.
	 */
	#define CQ_BASE_STATUS_MEMORY_MGT_OPERATION_ERR   UINT32_C(0x7)
	/*
	 * An invalid message was received by the responder. This could be
	 * an operation that is not supported by this QP, an IRRQ overflow
	 * error, or the length in an RDMA operation is greater than the
	 * maximum message size (2^31 bytes).
	 *
	 * This is a fatal error detected by the responder and communicated
	 * back to the requester using a NAK-Invalid Request. For responder
	 * CQEs, only the opaque field is valid.
	 */
	#define CQ_BASE_STATUS_REMOTE_INVALID_REQUEST_ERR UINT32_C(0x8)
	/*
	 * A protection error occurred on a remote data buffer to be read
	 * by an RDMA Read, written by an RDMA Write or accessed by an
	 * atomic operation. This error is reported only on RDMA operations
	 * or atomic operations.
	 *
	 * This is a fatal error detected by the responder and communicated
	 * back to the requester using a NAK-Remote Access Violation.
	 */
	#define CQ_BASE_STATUS_REMOTE_ACCESS_ERR	UINT32_C(0x9)
	/*
	 * The operation could not be completed successfully by the
	 * responder. Possible causes include an RQ/SRQ WQE format error,
	 * an SSC error when validating an SGE from an RQ/SRQ WQE, or the
	 * message received was too long for the RQ/SRQ WQE.
	 *
	 * This is a fatal error detected by the responder and communicated
	 * back to the requester using a NAK-Remote Operation Error.
	 */
	#define CQ_BASE_STATUS_REMOTE_OPERATION_ERR	UINT32_C(0xa)
	/*
	 * The RNR NAK retry count was exceeded while trying to send this
	 * message.
	 *
	 * This is a fatal error detected by the requester.
	 */
	#define CQ_BASE_STATUS_RNR_NAK_RETRY_CNT_ERR	UINT32_C(0xb)
	/*
	 * The local transport timeout retry counter was exceeded while
	 * trying to send this message.
	 *
	 * This is a fatal error detected by the requester.
	 */
	#define CQ_BASE_STATUS_TRANSPORT_RETRY_CNT_ERR	UINT32_C(0xc)
	/*
	 * A WQE was in process or outstanding when the QP transitioned
	 * into the Error State.
	 */
	#define CQ_BASE_STATUS_WORK_REQUEST_FLUSHED_ERR   UINT32_C(0xd)
	/*
	 * A WQE had already been taken off the RQ/SRQ when a fatal error
	 * was detected on responder Rx. Only the opaque field in the CQE
	 * is valid.
	 */
	#define CQ_BASE_STATUS_HW_FLUSH_ERR		UINT32_C(0xe)
	/*
	 * A WQE was posted to the SQ/RQ that caused it to overflow. For
	 * requester CQEs, it was the SQ that overflowed. For responder
	 * CQEs, it was the RQ that overflowed.
	 */
	#define CQ_BASE_STATUS_OVERFLOW_ERR		UINT32_C(0xf)
	#define CQ_BASE_STATUS_LAST			CQ_BASE_STATUS_OVERFLOW_ERR
	uint16_t	reserved16;
	/*
	 * This value is from the WQE that is being completed. This field is
	 * only applicable to V3 version of CQEs.
	 */
	uint32_t	opaque;
} cq_base_t, *pcq_base_t;

/* Requester CQ CQE */
/* cq_req (size:256b/32B) */

typedef struct cq_req {
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * SQ Consumer Index - points to the entry just past the last WQE
	 * that has been completed by the chip. Wraps around at
	 * QPC.sq_size (i.e. the valid range of the SQ Consumer Index is 0
	 * to (QPC.sq_size - 1)).
	 */
	uint16_t	sq_cons_idx;
	uint16_t	reserved16_1;
	uint32_t	reserved32_2;
	uint64_t	reserved64;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_REQ_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_REQ_CQE_TYPE_MASK UINT32_C(0x1e)
	#define CQ_REQ_CQE_TYPE_SFT 1
	/*
	 * Requester completion - This is used for both RC and UD SQ
	 * completions.
	 */
		#define CQ_REQ_CQE_TYPE_REQ   (UINT32_C(0x0) << 1)
		#define CQ_REQ_CQE_TYPE_LAST CQ_REQ_CQE_TYPE_REQ
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push accelerated data provided by
	 * the driver. When this bit is '0', it indicates that the packet
	 * had not push acceleration data written or was executed as a
	 * normal packet even though push data was provided.
	 * This field is intended to be used for driver-generated push
	 * statistics. It is not applicable for RC since not all RC packets
	 * return a CQE.
	 */
	#define CQ_REQ_PUSH	UINT32_C(0x20)
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* OK is 0 */
	#define CQ_REQ_STATUS_OK			UINT32_C(0x0)
	/* BAD_RESPONSE_ERR is 1 */
	#define CQ_REQ_STATUS_BAD_RESPONSE_ERR	UINT32_C(0x1)
	/* LOCAL_LENGTH_ERR is 2 */
	#define CQ_REQ_STATUS_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_QP_OPERATION_ERR is 3 */
	#define CQ_REQ_STATUS_LOCAL_QP_OPERATION_ERR	UINT32_C(0x3)
	/* LOCAL_PROTECTION_ERR is 4 */
	#define CQ_REQ_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_REQ_STATUS_MEMORY_MGT_OPERATION_ERR   UINT32_C(0x5)
	/* REMOTE_INVALID_REQUEST_ERR is 6 */
	#define CQ_REQ_STATUS_REMOTE_INVALID_REQUEST_ERR UINT32_C(0x6)
	/* REMOTE_ACCESS_ERR is 7 */
	#define CQ_REQ_STATUS_REMOTE_ACCESS_ERR	UINT32_C(0x7)
	/* REMOTE_OPERATION_ERR is 8 */
	#define CQ_REQ_STATUS_REMOTE_OPERATION_ERR	UINT32_C(0x8)
	/* RNR_NAK_RETRY_CNT_ERR is 9 */
	#define CQ_REQ_STATUS_RNR_NAK_RETRY_CNT_ERR	UINT32_C(0x9)
	/* TRANSPORT_RETRY_CNT_ERR is 10 */
	#define CQ_REQ_STATUS_TRANSPORT_RETRY_CNT_ERR	UINT32_C(0xa)
	/* WORK_REQUEST_FLUSHED_ERR is 11 */
	#define CQ_REQ_STATUS_WORK_REQUEST_FLUSHED_ERR   UINT32_C(0xb)
	#define CQ_REQ_STATUS_LAST			CQ_REQ_STATUS_WORK_REQUEST_FLUSHED_ERR
	uint16_t	reserved16_2;
	uint32_t	reserved32_1;
} cq_req_t, *pcq_req_t;

/* Responder RC CQE */
/* cq_res_rc (size:256b/32B) */

typedef struct cq_res_rc {
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	uint32_t	length;
	/*
	 * Immediate data in case the imm_flag set, R_Key to be
	 * invalidated in case inv_flag is set.
	 */
	uint32_t	imm_data_or_inv_r_key;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Opaque value - valid when inv_flag is set. Used by driver
	 * to reference the buffer used to store PBL when the MR was
	 * fast registered. The driver can reclaim this buffer after
	 * an MR was remotely invalidated. The controller take that
	 * value from the MR referenced by R_Key
	 */
	uint64_t	mr_handle;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_RC_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_RC_CQE_TYPE_MASK  UINT32_C(0x1e)
	#define CQ_RES_RC_CQE_TYPE_SFT   1
	/*
	 * Responder RC Completion - This is used for both RQ and SRQ
	 * completions for RC service QPs.
	 */
		#define CQ_RES_RC_CQE_TYPE_RES_RC  (UINT32_C(0x1) << 1)
		#define CQ_RES_RC_CQE_TYPE_LAST   CQ_RES_RC_CQE_TYPE_RES_RC
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* OK is 0 */
	#define CQ_RES_RC_STATUS_OK			UINT32_C(0x0)
	/* LOCAL_ACCESS_ERROR is 1 */
	#define CQ_RES_RC_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/* LOCAL_LENGTH_ERR is 2 */
	#define CQ_RES_RC_STATUS_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_RC_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_RC_STATUS_LOCAL_QP_OPERATION_ERR	UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_RC_STATUS_MEMORY_MGT_OPERATION_ERR   UINT32_C(0x5)
	/* REMOTE_INVALID_REQUEST_ERR is 6 */
	#define CQ_RES_RC_STATUS_REMOTE_INVALID_REQUEST_ERR UINT32_C(0x6)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_RC_STATUS_WORK_REQUEST_FLUSHED_ERR   UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_RC_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_RC_STATUS_LAST			CQ_RES_RC_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_RC_FLAGS_SRQ		UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_RC_FLAGS_SRQ_RQ	UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_RC_FLAGS_SRQ_SRQ	UINT32_C(0x1)
		#define CQ_RES_RC_FLAGS_SRQ_LAST	CQ_RES_RC_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_RC_FLAGS_IMM		UINT32_C(0x2)
	/* R_Key invalidate indicator */
	#define CQ_RES_RC_FLAGS_INV		UINT32_C(0x4)
	#define CQ_RES_RC_FLAGS_RDMA	UINT32_C(0x8)
	/* CQE relates to an incoming Send request */
		#define CQ_RES_RC_FLAGS_RDMA_SEND	(UINT32_C(0x0) << 3)
	/* CQE relates to incoming RDMA Write request */
		#define CQ_RES_RC_FLAGS_RDMA_RDMA_WRITE  (UINT32_C(0x1) << 3)
		#define CQ_RES_RC_FLAGS_RDMA_LAST	CQ_RES_RC_FLAGS_RDMA_RDMA_WRITE
	uint32_t	srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_RC_SRQ_OR_RQ_WR_ID_MASK UINT32_C(0xfffff)
	#define CQ_RES_RC_SRQ_OR_RQ_WR_ID_SFT 0
} cq_res_rc_t, *pcq_res_rc_t;

/* Responder UD CQE */
/* cq_res_ud (size:256b/32B) */

typedef struct cq_res_ud {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_LENGTH_SFT 0
	/*
	 * This is data from the CFA or VNIC block as indicated by the
	 * ext_meta_format and meta_format fields.
	 */
	uint16_t	cfa_metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_CFA_METADATA_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_CFA_METADATA_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_CFA_METADATA_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_CFA_METADATA_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_CFA_METADATA_PRI_SFT 13
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_UD_CQE_TYPE_MASK  UINT32_C(0x1e)
	#define CQ_RES_UD_CQE_TYPE_SFT   1
	/*
	 * Responder UD Completion - This is used for both RQ and SRQ
	 * completion for UD service QPs.
	 */
		#define CQ_RES_UD_CQE_TYPE_RES_UD  (UINT32_C(0x2) << 1)
		#define CQ_RES_UD_CQE_TYPE_LAST   CQ_RES_UD_CQE_TYPE_RES_UD
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_UD_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error. Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_UD_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields are valid.
	 */
	#define CQ_RES_UD_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_UD_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_UD_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_UD_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_UD_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_UD_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_UD_STATUS_LAST			CQ_RES_UD_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_FLAGS_SRQ		UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_FLAGS_SRQ_LAST		CQ_RES_UD_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_FLAGS_IMM		UINT32_C(0x2)
	#define CQ_RES_UD_FLAGS_UNUSED_MASK	UINT32_C(0xc)
	#define CQ_RES_UD_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV6
	/*
	 * The combination of this value and ext_meta_format indicates
	 * what format the metadata field is.
	 */
	#define CQ_RES_UD_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_FLAGS_META_FORMAT_SFT	6
	/* No metadata information. Value is zero. */
		#define CQ_RES_UD_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 */
		#define CQ_RES_UD_FLAGS_META_FORMAT_VLAN	(UINT32_C(0x1) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] -> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_FLAGS_META_FORMAT_TUNNEL_ID   (UINT32_C(0x2) << 6)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define CQ_RES_UD_FLAGS_META_FORMAT_CHDR_DATA   (UINT32_C(0x3) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset and lower 7 bits of the inner_l2_offset,
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[15:9] contains the inner_l2_offset[6:0]
	 */
		#define CQ_RES_UD_FLAGS_META_FORMAT_HDR_OFFSET  (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_FLAGS_META_FORMAT_LAST	CQ_RES_UD_FLAGS_META_FORMAT_HDR_OFFSET
	/*
	 * The combination of this value and meta_format indicates what
	 * format the metadata field is
	 */
	#define CQ_RES_UD_FLAGS_EXT_META_FORMAT_MASK  UINT32_C(0xc00)
	#define CQ_RES_UD_FLAGS_EXT_META_FORMAT_SFT   10
	uint32_t	src_qp_high_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_UD_SRQ_OR_RQ_WR_ID_MASK UINT32_C(0xfffff)
	#define CQ_RES_UD_SRQ_OR_RQ_WR_ID_SFT 0
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_SRC_QP_HIGH_MASK	UINT32_C(0xff000000)
	#define CQ_RES_UD_SRC_QP_HIGH_SFT	24
} cq_res_ud_t, *pcq_res_ud_t;

/* Responder UD CQE version 2 */
/* cq_res_ud_v2 (size:256b/32B) */

typedef struct cq_res_ud_v2 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_V2_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_V2_LENGTH_SFT 0
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	cfa_metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_V2_CFA_METADATA0_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_V2_CFA_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_V2_CFA_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_V2_CFA_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_V2_CFA_METADATA0_PRI_SFT 13
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_V2_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_UD_V2_CQE_TYPE_MASK  UINT32_C(0x1e)
	#define CQ_RES_UD_V2_CQE_TYPE_SFT   1
	/*
	 * Responder UD Completion - This is used for both RQ and SRQ
	 * completion for UD service QPs.
	 */
		#define CQ_RES_UD_V2_CQE_TYPE_RES_UD  (UINT32_C(0x2) << 1)
		#define CQ_RES_UD_V2_CQE_TYPE_LAST   CQ_RES_UD_V2_CQE_TYPE_RES_UD
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_UD_V2_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error. Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_UD_V2_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields are valid.
	 */
	#define CQ_RES_UD_V2_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_UD_V2_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_UD_V2_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_UD_V2_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_UD_V2_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_UD_V2_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_UD_V2_STATUS_LAST			CQ_RES_UD_V2_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_V2_FLAGS_SRQ			UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_V2_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_V2_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_V2_FLAGS_SRQ_LAST		CQ_RES_UD_V2_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_V2_FLAGS_IMM			UINT32_C(0x2)
	#define CQ_RES_UD_V2_FLAGS_UNUSED_MASK		UINT32_C(0xc)
	#define CQ_RES_UD_V2_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_V2IPV6
	/* The field indicates what format the metadata field is. */
	#define CQ_RES_UD_V2_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_V2_FLAGS_META_FORMAT_SFT	6
	/* No metadata information. Value is zero. */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_ACT_REC_PTR  (UINT32_C(0x1) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB. i
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the
	 * prepended header (chdr_data).
	 */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset and lower 7 bits of the inner_l2_offset,
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[15:9] contains the inner_l2_offset[6:0]
	 */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_HDR_OFFSET   (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_LAST	CQ_RES_UD_V2_FLAGS_META_FORMAT_HDR_OFFSET
	uint32_t	src_qp_high_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_UD_V2_SRQ_OR_RQ_WR_ID_MASK	UINT32_C(0xfffff)
	#define CQ_RES_UD_V2_SRQ_OR_RQ_WR_ID_SFT		0
	#define CQ_RES_UD_V2_CFA_METADATA1_MASK		UINT32_C(0xf00000)
	#define CQ_RES_UD_V2_CFA_METADATA1_SFT		20
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_MASK	UINT32_C(0x700000)
	#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_SFT	20
	/* 0x88a8 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 20)
	/* 0x8100 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 20)
	/* 0x9100 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 20)
	/* 0x9200 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 20)
	/* 0x9300 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 20)
	/* Value programmed in CFA VLANTPID register. */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 20)
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_LAST	CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define CQ_RES_UD_V2_CFA_METADATA1_VALID		UINT32_C(0x800000)
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_V2_SRC_QP_HIGH_MASK		UINT32_C(0xff000000)
	#define CQ_RES_UD_V2_SRC_QP_HIGH_SFT		24
} cq_res_ud_v2_t, *pcq_res_ud_v2_t;

/* Responder UD with CFA CQE */
/* cq_res_ud_cfa (size:256b/32B) */

typedef struct cq_res_ud_cfa {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_CFA_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_CFA_LENGTH_SFT 0
	/*
	 * This field identifies the CFA action rule that was used
	 * for this packet.
	 */
	uint16_t	cfa_code;
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	uint32_t	qid;
	/*
	 * This value indicates the QPID associated with this operation.
	 * The driver will use the qid from this CQE to map a QP handle
	 * in the completion record returned to the application.
	 */
	#define CQ_RES_UD_CFA_QID_MASK UINT32_C(0xfffff)
	#define CQ_RES_UD_CFA_QID_SFT 0
	/*
	 * This is data from the CFA or VNIC block as indicated by the
	 * ext_meta_format and meta_format fields.
	 */
	uint32_t	cfa_metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_CFA_CFA_METADATA_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_CFA_CFA_METADATA_VID_SFT  0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_CFA_CFA_METADATA_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_CFA_CFA_METADATA_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_CFA_CFA_METADATA_PRI_SFT  13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define CQ_RES_UD_CFA_CFA_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define CQ_RES_UD_CFA_CFA_METADATA_TPID_SFT 16
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_CFA_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_UD_CFA_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_UD_CFA_CQE_TYPE_SFT	1
	/*
	 * Responder UD Completion with CFA - This is used for both RQ
	 * and SRQ completion for UD service QPs. It includes cfa fields
	 * (some of which carry VLAN information), in place of the QP
	 * handle. It is also used for QP1 QPs that are treated as UD.
	 */
		#define CQ_RES_UD_CFA_CQE_TYPE_RES_UD_CFA  (UINT32_C(0x4) << 1)
		#define CQ_RES_UD_CFA_CQE_TYPE_LAST	CQ_RES_UD_CFA_CQE_TYPE_RES_UD_CFA
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_UD_CFA_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error. Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_UD_CFA_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields are valid.
	 */
	#define CQ_RES_UD_CFA_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_UD_CFA_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_UD_CFA_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_UD_CFA_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_UD_CFA_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_UD_CFA_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_UD_CFA_STATUS_LAST			CQ_RES_UD_CFA_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_CFA_FLAGS_SRQ		UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_CFA_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_CFA_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_CFA_FLAGS_SRQ_LAST		CQ_RES_UD_CFA_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_CFA_FLAGS_IMM		UINT32_C(0x2)
	#define CQ_RES_UD_CFA_FLAGS_UNUSED_MASK	UINT32_C(0xc)
	#define CQ_RES_UD_CFA_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_V2IPV6
	/*
	 * The combination of this value and ext_meta_format indicates
	 * what format the metadata field is.
	 */
	#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_SFT	6
	/*
	 * If ext_meta_format is equal to 0, there is no metadata
	 * information. Value is zero.
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * If ext_meta_format is equal to 0, the metadata field contains
	 * the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_VLAN	(UINT32_C(0x1) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the Tunnel ID value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] -> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_TUNNEL_ID   (UINT32_C(0x2) << 6)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_CHDR_DATA   (UINT32_C(0x3) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset, inner_l2_offset, inner_l3_offset, and
	 * inner_l4_size.
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[17:9] contains the inner_l2_offset.
	 * - metadata[26:18] contains the inner_l3_offset.
	 * - metadata[31:27] contains the inner_l4_size.
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_HDR_OFFSET  (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_LAST	CQ_RES_UD_CFA_FLAGS_META_FORMAT_HDR_OFFSET
	/*
	 * The combination of this value and meta_format indicates what
	 * format the metadata field is
	 */
	#define CQ_RES_UD_CFA_FLAGS_EXT_META_FORMAT_MASK  UINT32_C(0xc00)
	#define CQ_RES_UD_CFA_FLAGS_EXT_META_FORMAT_SFT   10
	uint32_t	src_qp_high_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_UD_CFA_SRQ_OR_RQ_WR_ID_MASK UINT32_C(0xfffff)
	#define CQ_RES_UD_CFA_SRQ_OR_RQ_WR_ID_SFT 0
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_CFA_SRC_QP_HIGH_MASK	UINT32_C(0xff000000)
	#define CQ_RES_UD_CFA_SRC_QP_HIGH_SFT	24
} cq_res_ud_cfa_t, *pcq_res_ud_cfa_t;

/* Responder UD with CFA CQE version 2 */
/* cq_res_ud_cfa_v2 (size:256b/32B) */

typedef struct cq_res_ud_cfa_v2 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_CFA_V2_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_CFA_V2_LENGTH_SFT 0
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	cfa_metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_PRI_SFT 13
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	uint32_t	qid;
	/*
	 * This value indicates the QPID associated with this operation.
	 * The driver will use the qid from this CQE to map a QP handle
	 * in the completion record returned to the application.
	 */
	#define CQ_RES_UD_CFA_V2_QID_MASK UINT32_C(0xfffff)
	#define CQ_RES_UD_CFA_V2_QID_SFT 0
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	cfa_metadata2;
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_CFA_V2_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_UD_CFA_V2_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_UD_CFA_V2_CQE_TYPE_SFT	1
	/*
	 * Responder UD Completion with CFA - This is used for both RQ
	 * and SRQ completion for UD service QPs. It includes cfa fields
	 * (some of which carry VLAN information), in place of the QP
	 * handle. It is also used for QP1 QPs that are treated as UD.
	 */
		#define CQ_RES_UD_CFA_V2_CQE_TYPE_RES_UD_CFA  (UINT32_C(0x4) << 1)
		#define CQ_RES_UD_CFA_V2_CQE_TYPE_LAST	CQ_RES_UD_CFA_V2_CQE_TYPE_RES_UD_CFA
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_UD_CFA_V2_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error. Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_UD_CFA_V2_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields are valid.
	 */
	#define CQ_RES_UD_CFA_V2_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_UD_CFA_V2_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_UD_CFA_V2_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_UD_CFA_V2_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_UD_CFA_V2_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_UD_CFA_V2_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_UD_CFA_V2_STATUS_LAST			CQ_RES_UD_CFA_V2_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_CFA_V2_FLAGS_SRQ			UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_CFA_V2_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_CFA_V2_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_CFA_V2_FLAGS_SRQ_LAST		CQ_RES_UD_CFA_V2_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_CFA_V2_FLAGS_IMM			UINT32_C(0x2)
	#define CQ_RES_UD_CFA_V2_FLAGS_UNUSED_MASK		UINT32_C(0xc)
	#define CQ_RES_UD_CFA_V2_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_V2IPV6
	/* The field indicates what format the metadata field is. */
	#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_SFT	6
	/* No metadata information. Value is zero. */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_ACT_REC_PTR  (UINT32_C(0x1) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB. i
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the
	 * prepended header (chdr_data).
	 */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset and lower 7 bits of the inner_l2_offset,
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[15:9] contains the inner_l2_offset[6:0]
	 */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_HDR_OFFSET   (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_LAST	CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_HDR_OFFSET
	uint32_t	src_qp_high_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_UD_CFA_V2_SRQ_OR_RQ_WR_ID_MASK	UINT32_C(0xfffff)
	#define CQ_RES_UD_CFA_V2_SRQ_OR_RQ_WR_ID_SFT		0
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_MASK		UINT32_C(0xf00000)
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_SFT		20
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_MASK	UINT32_C(0x700000)
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_SFT	20
	/* 0x88a8 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 20)
	/* 0x8100 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 20)
	/* 0x9100 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 20)
	/* 0x9200 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 20)
	/* 0x9300 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 20)
	/* Value programmed in CFA VLANTPID register. */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 20)
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_LAST	CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_VALID		UINT32_C(0x800000)
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_CFA_V2_SRC_QP_HIGH_MASK		UINT32_C(0xff000000)
	#define CQ_RES_UD_CFA_V2_SRC_QP_HIGH_SFT		24
} cq_res_ud_cfa_v2_t, *pcq_res_ud_cfa_v2_t;

/* Responder RawEth and QP1 CQE */
/* cq_res_raweth_qp1 (size:256b/32B) */

typedef struct cq_res_raweth_qp1 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_RAWETH_QP1_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_RAWETH_QP1_LENGTH_SFT 0
	uint16_t	raweth_qp1_flags;
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_MASK		UINT32_C(0x3ff)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_SFT		0
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * raweth_qp1_errors.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ERROR		UINT32_C(0x1)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_MASK		UINT32_C(0x3c0)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_SFT		6
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_NOT_KNOWN	(UINT32_C(0x0) << 6)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_IP		(UINT32_C(0x1) << 6)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 6)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 6)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the raweth_qp1_payload_offset field
	 * is valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 6)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the raweth_qp1_payload_offset field
	 * is valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 6)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 6)
	/*
	 * PtP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_WO_TIMESTAMP   (UINT32_C(0x8) << 6)
	/*
	 * PtP packet w/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 6)
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_LAST		CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP
	uint16_t	raweth_qp1_errors;
	/*
	 * This indicates that there was an error in the IP header
	 * checksum.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_IP_CS_ERROR			UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP
	 * or ICMP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_L4_CS_ERROR			UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel
	 * IP header checksum.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_IP_CS_ERROR			UINT32_C(0x40)
	/*
	 * This indicates that there was an error in the tunnel
	 * UDP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_L4_CS_ERROR			UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_SFT		9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6
	 * in the tunnel header.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the
	 * tunnel header. Valid for
	 * IPv4.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the PPPoE header length for a tunnel PPPoE
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6
	 * tunnel packet packets.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel UDP header length for a tunnel
	 * UDP packet that is not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 9)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0) in the tunnel header. Valid
	 * for IPv4, and IPv6.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x6) << 9)
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_LAST		CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL  (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_LAST			CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	raweth_qp1_cfa_code;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	uint32_t	raweth_qp1_flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the ip_cs_error field indicates if there
	 * was an error.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the l4_cs_error field
	 * indicates if there was an error.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the t_ip_cs_error field indicates if
	 * there was an error.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the t_l4_cs_error
	 * field indicates if there was an error.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/*
	 * This value indicates what format the raweth_qp1_metadata field
	 * is.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_SFT		4
	/* No metadata information. Value is zero. */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The raweth_qp1_metadata field contains the VLAN tag and TPID
	 * value.
	 * - raweth_qp1_metadata[11:0] contains the vlan VID value.
	 * - raweth_qp1_metadata[12] contains the vlan DE value.
	 * - raweth_qp1_metadata[15:13] contains the vlan PRI value.
	 * - raweth_qp1_metadata[31:16] contains the vlan TPID value.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_VLAN		(UINT32_C(0x1) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] -> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset and lower 7 bits of the inner_l2_offset,
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[15:9] contains the inner_l2_offset[6:0]
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_LAST		CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * The combination of this value and meta_format indicated what
	 * format the metadata field is.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_EXT_META_FORMAT_MASK	UINT32_C(0xc00)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_EXT_META_FORMAT_SFT	10
	/*
	 * This value is the complete 1's complement checksum calculated
	 * from the start of the outer L3 header to the end of the packet
	 * (not including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	raweth_qp1_metadata;
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_DE_VID_MASK	UINT32_C(0xffff)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_DE_VID_SFT	0
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_VID_MASK	UINT32_C(0xfff)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_VID_SFT		0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_DE		UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_MASK	UINT32_C(0xe000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_SFT		13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_TPID_MASK	UINT32_C(0xffff0000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_TPID_SFT	16
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_RAWETH_QP1_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_RAWETH_QP1_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_RAWETH_QP1_CQE_TYPE_SFT	1
	/*
	 * Responder RawEth and QP1 Completion - This is used for RQ
	 * completion for RawEth service and QP1 service QPs.
	 */
		#define CQ_RES_RAWETH_QP1_CQE_TYPE_RES_RAWETH_QP1  (UINT32_C(0x3) << 1)
		#define CQ_RES_RAWETH_QP1_CQE_TYPE_LAST	CQ_RES_RAWETH_QP1_CQE_TYPE_RES_RAWETH_QP1
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_RAWETH_QP1_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error. Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_RAWETH_QP1_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the RQ.
	 *
	 * This is not a fatal error. All the fields are valid.
	 */
	#define CQ_RES_RAWETH_QP1_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_RAWETH_QP1_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_RAWETH_QP1_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_RAWETH_QP1_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_RAWETH_QP1_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_RAWETH_QP1_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_RAWETH_QP1_STATUS_LAST			CQ_RES_RAWETH_QP1_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_RAWETH_QP1_FLAGS_SRQ	UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_RAWETH_QP1_FLAGS_SRQ_RQ	UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_RAWETH_QP1_FLAGS_SRQ_SRQ   UINT32_C(0x1)
		#define CQ_RES_RAWETH_QP1_FLAGS_SRQ_LAST CQ_RES_RAWETH_QP1_FLAGS_SRQ_SRQ
	uint32_t	raweth_qp1_payload_offset_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_RAWETH_QP1_SRQ_OR_RQ_WR_ID_MASK	UINT32_C(0xfffff)
	#define CQ_RES_RAWETH_QP1_SRQ_OR_RQ_WR_ID_SFT	0
	/*
	 * This value indicates the offset in bytes from the beginning of the
	 * packet where the inner payload starts. This value is valid for
	 * TCP, UDP, FCoE, and RoCE packets.
	 * A value of zero indicates an offset of 256 bytes.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_PAYLOAD_OFFSET_MASK UINT32_C(0xff000000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_PAYLOAD_OFFSET_SFT 24
} cq_res_raweth_qp1_t, *pcq_res_raweth_qp1_t;

/* Responder RawEth and QP1 CQE version 2 */
/* cq_res_raweth_qp1_v2 (size:256b/32B) */

typedef struct cq_res_raweth_qp1_v2 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_RAWETH_QP1_V2_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_RAWETH_QP1_V2_LENGTH_SFT 0
	uint16_t	raweth_qp1_flags;
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_MASK		UINT32_C(0x3ff)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_SFT		0
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * raweth_qp1_errors.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ERROR		UINT32_C(0x1)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_MASK		UINT32_C(0x3c0)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_SFT		6
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_NOT_KNOWN	(UINT32_C(0x0) << 6)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_IP		(UINT32_C(0x1) << 6)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 6)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 6)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the raweth_qp1_payload_offset field
	 * is valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 6)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the raweth_qp1_payload_offset field
	 * is valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 6)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 6)
	/*
	 * PtP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_PTP_WO_TIMESTAMP   (UINT32_C(0x8) << 6)
	/*
	 * PtP packet w/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 6)
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_LAST		CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP
	uint16_t	raweth_qp1_errors;
	/*
	 * This indicates that there was an error in the IP header
	 * checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_IP_CS_ERROR			UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP
	 * or ICMP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_L4_CS_ERROR			UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel
	 * IP header checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_IP_CS_ERROR			UINT32_C(0x40)
	/*
	 * This indicates that there was an error in the tunnel
	 * UDP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_L4_CS_ERROR			UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_SFT		9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6
	 * in the tunnel header.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the
	 * tunnel header. Valid for
	 * IPv4.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the PPPoE header length for a tunnel PPPoE
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6
	 * tunnel packet packets.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel UDP header length for a tunnel
	 * UDP packet that is not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 9)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0) in the tunnel header. Valid
	 * for IPv4, and IPv6.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x6) << 9)
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_LAST		CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL  (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_LAST			CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	cfa_metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_PRI_SFT 13
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	uint32_t	raweth_qp1_flags2;
	/*
	 * When this bit is '0', the cs_ok field has the following
	 * definition:- ip_cs_ok[2:0] = The number of header groups with a
	 * valid IP checksum in the delivered packet, counted from the
	 * outer-most header group to the inner-most header group, stopping
	 * at the first error. - l4_cs_ok[5:3] = The number of header groups
	 * with a valid L4 checksum in the delivered packet, counted from
	 * the outer-most header group to the inner-most header group,
	 * stopping at the first error. When this bit is '1', the cs_ok
	 * field has the following definition: - hdr_cnt[2:0] = The number of
	 * header groups that were parsed by the chip and passed in the
	 * delivered packet. - ip_cs_all_ok[3] =This bit will be '1' if all
	 * the parsed header groups with an IP checksum are valid.
	 * - l4_cs_all_ok[4] = This bit will be '1' if all the parsed header
	 * groups with an L4 checksum are valid.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_CS_ALL_OK_MODE		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_SFT		4
	/* There is no metadata information. Values are zero. */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB. i
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_LAST		CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_CS_OK_MASK		UINT32_C(0xfc00)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_CS_OK_SFT		10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	cfa_metadata2;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_RAWETH_QP1_V2_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_RAWETH_QP1_V2_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_RAWETH_QP1_V2_CQE_TYPE_SFT	1
	/*
	 * Responder RawEth and QP1 Completion - This is used for RQ
	 * completion for RawEth service and QP1 service QPs.
	 */
		#define CQ_RES_RAWETH_QP1_V2_CQE_TYPE_RES_RAWETH_QP1  (UINT32_C(0x3) << 1)
		#define CQ_RES_RAWETH_QP1_V2_CQE_TYPE_LAST	CQ_RES_RAWETH_QP1_V2_CQE_TYPE_RES_RAWETH_QP1
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error. Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the RQ.
	 *
	 * This is not a fatal error. All the fields are valid.
	 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_RAWETH_QP1_V2_STATUS_LAST			CQ_RES_RAWETH_QP1_V2_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ	UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ_RQ	UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ_SRQ   UINT32_C(0x1)
		#define CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ_LAST CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ_SRQ
	uint32_t	raweth_qp1_payload_offset_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_RAWETH_QP1_V2_SRQ_OR_RQ_WR_ID_MASK	UINT32_C(0xfffff)
	#define CQ_RES_RAWETH_QP1_V2_SRQ_OR_RQ_WR_ID_SFT		0
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_MASK		UINT32_C(0xf00000)
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_SFT		20
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_MASK	UINT32_C(0x700000)
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_SFT	20
	/* 0x88a8 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 20)
	/* 0x8100 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 20)
	/* 0x9100 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 20)
	/* 0x9200 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 20)
	/* 0x9300 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 20)
	/* Value programmed in CFA VLANTPID register. */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 20)
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_LAST	CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_VALID		UINT32_C(0x800000)
	/*
	 * This value indicates the offset in bytes from the beginning of
	 * the packet where the inner payload starts. This value is valid
	 * for TCP, UDP, FCoE, and RoCE packets.
	 *
	 * A value of zero indicates an offset of 256 bytes.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_PAYLOAD_OFFSET_MASK UINT32_C(0xff000000)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_PAYLOAD_OFFSET_SFT  24
} cq_res_raweth_qp1_v2_t, *pcq_res_raweth_qp1_v2_t;

/*
 * This is the terminal CQE structure. This CQE is generated to
 * indicate that no further completions will be generated for this QP.
 */
/* cq_terminal (size:256b/32B) */

typedef struct cq_terminal {
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Final SQ Consumer Index value. Any additional SQ WQEs will
	 * have to be completed by the user provider.
	 */
	uint16_t	sq_cons_idx;
	/*
	 * Final RQ Consumer Index value. Any additional RQ WQEs will
	 * have to be completed by the user provider.
	 */
	uint16_t	rq_cons_idx;
	uint32_t	reserved32_1;
	uint64_t	reserved64_3;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_TERMINAL_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_TERMINAL_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_TERMINAL_CQE_TYPE_SFT	1
	/*
	 * Terminal completion - This is used to indicate that no
	 * further completions will be made for this QP on this CQ.
	 */
		#define CQ_TERMINAL_CQE_TYPE_TERMINAL  (UINT32_C(0xe) << 1)
		#define CQ_TERMINAL_CQE_TYPE_LAST	CQ_TERMINAL_CQE_TYPE_TERMINAL
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_TERMINAL_STATUS_OK UINT32_C(0x0)
	#define CQ_TERMINAL_STATUS_LAST CQ_TERMINAL_STATUS_OK
	uint16_t	reserved16;
	uint32_t	reserved32_2;
} cq_terminal_t, *pcq_terminal_t;

/* Cutoff CQE */
/* cq_cutoff (size:256b/32B) */

typedef struct cq_cutoff {
	uint64_t	reserved64_1;
	uint64_t	reserved64_2;
	uint64_t	reserved64_3;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. The NIC
	 * toggles this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_CUTOFF_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_CUTOFF_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_CUTOFF_CQE_TYPE_SFT	1
	/* Cut off CQE; for CQ resize see CQ and SRQ Resize */
		#define CQ_CUTOFF_CQE_TYPE_CUT_OFF	(UINT32_C(0xf) << 1)
		#define CQ_CUTOFF_CQE_TYPE_LAST	CQ_CUTOFF_CQE_TYPE_CUT_OFF
	/*
	 * This field carries the toggle value that must be used to
	 * acknowledge this CQ resize operation. When this CQE is
	 * processed, the driver should send a CQ_CUTOFF_ACK doorbell
	 * to the chip to let the chip know that the resize operation
	 * is complete.
	 *
	 * This value is used by HW to detect old and
	 * stale CQ_CUTOFF_ACK doorbells that are caused by having
	 * a backup doorbell location or by PCI or other reordering
	 * problems. Only doorbells with the latest value will be honored.
	 * This field is needed only for devices that use the hardware
	 * based doorbell drop recovery feature.
	 */
	#define CQ_CUTOFF_RESIZE_TOGGLE_MASK UINT32_C(0x60)
	#define CQ_CUTOFF_RESIZE_TOGGLE_SFT 5
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_CUTOFF_STATUS_OK UINT32_C(0x0)
	#define CQ_CUTOFF_STATUS_LAST CQ_CUTOFF_STATUS_OK
	uint16_t	reserved16;
	uint32_t	reserved32;
} cq_cutoff_t, *pcq_cutoff_t;

/* No-Op CQE */
/* cq_no_op (size:256b/32B) */

typedef struct cq_no_op {
	uint64_t	reserved64_1;
	uint64_t	reserved64_2;
	uint64_t	reserved64_3;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. The NIC
	 * toggles this bit each time it finished consuming all PBL
	 * entries.
	 */
	#define CQ_NO_OP_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_NO_OP_CQE_TYPE_MASK UINT32_C(0x1e)
	#define CQ_NO_OP_CQE_TYPE_SFT  1
	/*
	 * NO-OP completion - This is used to indicate that no operation
	 * completed.
	 */
		#define CQ_NO_OP_CQE_TYPE_NO_OP  (UINT32_C(0xd) << 1)
		#define CQ_NO_OP_CQE_TYPE_LAST  CQ_NO_OP_CQE_TYPE_NO_OP
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_NO_OP_STATUS_OK UINT32_C(0x0)
	#define CQ_NO_OP_STATUS_LAST CQ_NO_OP_STATUS_OK
	uint16_t	reserved16;
	uint32_t	reserved32;
} cq_no_op_t, *pcq_no_op_t;

/*
 * This is the Requester CQE V3 structure. This is used to complete each
 * signaled SQ WQE. The sq_cons_idx and opaque is used to indicate
 * which WQE has been completed. When a WQE is completed, it indicates
 * that all WQEs before it in the SQ are also completed without error.
 * Space freed by completed WQEs can be used for new WQEs.
 */
/* cq_req_v3 (size:256b/32B) */

typedef struct cq_req_v3 {
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * SQ Consumer Index - points to the entry just past the last WQE
	 * that has been completed by the chip. Wraps around at QPC.sq_size
	 * (i.e. the valid range of the SQ Consumer Index is 0 to
	 * (QPC.sq_size - 1)). The sq_cons_idx is in 16B units (as is
	 * QPC.sq_size).
	 *
	 * User can determine available space in the SQ by comparing
	 * sq_cons_idx to a sq_prod_idx maintained by the user. When the two
	 * values are equal, the SQ is empty. When
	 * (sq_prod_idx+1)%QPC.sq_size==sq_cons_idx, the queue is full.
	 */
	uint16_t	sq_cons_idx;
	uint16_t	reserved1;
	uint32_t	reserved2;
	uint64_t	reserved3;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. The NIC
	 * toggles this bit each time it finished consuming all PBL
	 * entries.
	 */
	#define CQ_REQ_V3_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_REQ_V3_CQE_TYPE_MASK  UINT32_C(0x1e)
	#define CQ_REQ_V3_CQE_TYPE_SFT   1
	/*
	 * Requester completion V3 - This is used for both RC and UD SQ
	 * completions.
	 */
		#define CQ_REQ_V3_CQE_TYPE_REQ_V3  (UINT32_C(0x8) << 1)
		#define CQ_REQ_V3_CQE_TYPE_LAST   CQ_REQ_V3_CQE_TYPE_REQ_V3
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push accelerated data provided by
	 * the driver. When this bit is '0', it indicates that the packet
	 * had not push acceleration data written or was executed as a
	 * normal packet even though push data was provided.
	 *
	 * Note: This field is intended to be used for driver-generated push
	 * statistics. As such, It is not applicable for RC since not all
	 * RC packets return a CQE.
	 */
	#define CQ_REQ_V3_PUSH	UINT32_C(0x20)
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_REQ_V3_STATUS_OK			UINT32_C(0x0)
	/*
	 * An unexpected BTH opcode or a First/Middle packet that is not
	 * the full MTU size was returned by the responder.
	 *
	 * This is a fatal error detected by the requester Rx.
	 */
	#define CQ_REQ_V3_STATUS_BAD_RESPONSE_ERR	UINT32_C(0x1)
	/*
	 * Generated for a WQE posted to the local SQ when the sum of the
	 * lengths of the SGEs in the WQE exceeds the maximum message
	 * length of 2^31 bytes.
	 *
	 * Generated for a WQE posted to the local RQ/SRQ when the sum of
	 * the lengths of the SGEs in the WQE is too small to receive the
	 * (valid) incoming message or the length of the incoming message
	 * is greater than the maximum message size supported.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_REQ_V3_STATUS_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/*
	 * An internal QP consistency error was detected while processing
	 * this Work Request. For requester, this could be an SQ WQE format
	 * error or an operation specified in the WQE that is not supported
	 * for the QP. For responder, this is an RQ/SRQ WQE format error.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_REQ_V3_STATUS_LOCAL_QP_OPERATION_ERR	UINT32_C(0x4)
	/*
	 * An SGE in the locally posted WQE does not reference a Memory
	 * Region that is valid for the requested operation. If this error
	 * is generated for an SGE using the reserved l_key, this means
	 * that the reserved l_key is not enabled.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_REQ_V3_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x5)
	/*
	 * The SSC detected an error on a local memory operation from the
	 * SQ (fast-register, local invalidate, or bind).
	 *
	 * This is a fatal error detected by the requester Tx.
	 */
	#define CQ_REQ_V3_STATUS_MEMORY_MGT_OPERATION_ERR   UINT32_C(0x7)
	/*
	 * An invalid message was received by the responder. This could be
	 * an operation that is not supported by this QP, an IRRQ overflow
	 * error, or the length in an RDMA operation is greater than the
	 * maximum message size (2^31 bytes).
	 *
	 * This is a fatal error detected by the responder and communicated
	 * back to the requester using a NAK-Invalid Request. For responder
	 * CQEs, only the opaque field is valid.
	 */
	#define CQ_REQ_V3_STATUS_REMOTE_INVALID_REQUEST_ERR UINT32_C(0x8)
	/*
	 * A protection error occurred on a remote data buffer to be read
	 * by an RDMA Read, written by an RDMA Write or accessed by an
	 * atomic operation. This error is reported only on RDMA operations
	 * or atomic operations.
	 *
	 * This is a fatal error detected by the responder and communicated
	 * back to the requester using a NAK-Remote Access Violation.
	 */
	#define CQ_REQ_V3_STATUS_REMOTE_ACCESS_ERR	UINT32_C(0x9)
	/*
	 * The operation could not be completed successfully by the
	 * responder. Possible causes include an RQ/SRQ WQE format error,
	 * an SSC error when validating an SGE from an RQ/SRQ WQE, or the
	 * message received was too long for the RQ/SRQ WQE.
	 *
	 * This is a fatal error detected by the responder and communicated
	 * back to the requester using a NAK-Remote Operation Error.
	 */
	#define CQ_REQ_V3_STATUS_REMOTE_OPERATION_ERR	UINT32_C(0xa)
	/*
	 * The RNR NAK retry count was exceeded while trying to send this
	 * message.
	 *
	 * This is a fatal error detected by the requester.
	 */
	#define CQ_REQ_V3_STATUS_RNR_NAK_RETRY_CNT_ERR	UINT32_C(0xb)
	/*
	 * The local transport timeout retry counter was exceeded while
	 * trying to send this message.
	 *
	 * This is a fatal error detected by the requester.
	 */
	#define CQ_REQ_V3_STATUS_TRANSPORT_RETRY_CNT_ERR	UINT32_C(0xc)
	/*
	 * A WQE was in process or outstanding when the QP transitioned
	 * into the Error State.
	 */
	#define CQ_REQ_V3_STATUS_WORK_REQUEST_FLUSHED_ERR   UINT32_C(0xd)
	/*
	 * A WQE was posted to the SQ/RQ that caused it to overflow. For
	 * requester CQEs, it was the SQ that overflowed. For responder
	 * CQEs, it was the RQ that overflowed.
	 */
	#define CQ_REQ_V3_STATUS_OVERFLOW_ERR		UINT32_C(0xf)
	#define CQ_REQ_V3_STATUS_LAST			CQ_REQ_V3_STATUS_OVERFLOW_ERR
	uint16_t	reserved4;
	/* This value is from the WQE that is being completed. */
	uint32_t	opaque;
} cq_req_v3_t, *pcq_req_v3_t;

/*
 * This is the Responder RQ/SRQ CQE V3 structure for RC QPs. This is
 * used to complete each RQ/SRQ WQE. When the WQE is completed, it
 * indicates that there is room for one more WQE on the corresponding
 * RQ/SRQ.
 *
 * User can determine available space in the RQ/SRQ by comparing
 * a rq_cons_idx to a rq_prod_idx, both maintained by the user. The
 * range for rq_prod/cons_idx is from 0 to QPC.rq_size-1. The
 * rq_prod_idx value increments by one for each WQE that is added to
 * the RQ/SRQ by the user. Value must be wrapped at rq_size. The
 * rq_cons_idx value increments by one for each WQE that is completed
 * from that particular RQ/SRQ. The qp_handle can be used by the user
 * to determine what RQ/SRQ to increment. Value must also be wrapped at
 * rq_size. When the two values are equal, the RQ/SRQ is empty. When
 * (rq_prod_idx+1)%QPC.rq_size==rq_cons_idx, the queue is full.
 */
/* cq_res_rc_v3 (size:256b/32B) */

typedef struct cq_res_rc_v3 {
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	uint32_t	length;
	/*
	 * Immediate data in case the imm_flag set, R_Key to be
	 * invalidated in case inv_flag is set.
	 */
	uint32_t	imm_data_or_inv_r_key;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Opaque value - valid when inv_flag is set. Used by driver
	 * to reference the buffer used to store PBL when the MR was
	 * fast registered. The driver can reclaim this buffer after
	 * an MR was remotely invalidated. The controller take that
	 * value from the MR referenced by R_Key
	 */
	uint64_t	mr_handle;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. The NIC
	 * toggles this bit each time it finished consuming all PBL
	 * entries.
	 */
	#define CQ_RES_RC_V3_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_RC_V3_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_RC_V3_CQE_TYPE_SFT	1
	/*
	 * Responder RC Completion - This is used for both RQ and SRQ
	 * completions for RC service QPs.
	 */
		#define CQ_RES_RC_V3_CQE_TYPE_RES_RC_V3  (UINT32_C(0x9) << 1)
		#define CQ_RES_RC_V3_CQE_TYPE_LAST	CQ_RES_RC_V3_CQE_TYPE_RES_RC_V3
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_RES_RC_V3_STATUS_OK			UINT32_C(0x0)
	/*
	 * Generated for a WQE posted to the local SQ when the sum of the
	 * lengths of the SGEs in the WQE exceeds the maximum message
	 * length of 2^31 bytes.
	 *
	 * Generated for a WQE posted to the local RQ/SRQ when the sum of
	 * the lengths of the SGEs in the WQE is too small to receive the
	 * (valid) incoming message or the length of the incoming message
	 * is greater than the maximum message size supported.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_RC_V3_STATUS_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/*
	 * An internal QP consistency error was detected while processing
	 * this Work Request. For requester, this could be an SQ WQE format
	 * error or an operation specified in the WQE that is not supported
	 * for the QP. For responder, this is an RQ/SRQ WQE format error.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_RC_V3_STATUS_LOCAL_QP_OPERATION_ERR	UINT32_C(0x4)
	/*
	 * An SGE in the locally posted WQE does not reference a Memory
	 * Region that is valid for the requested operation. If this error
	 * is generated for an SGE using the reserved l_key, this means
	 * that the reserved l_key is not enabled.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_RC_V3_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x5)
	/*
	 * A protection error occurred on a local data buffer during the
	 * processing of a RDMA Write with Immediate Data operation sent
	 * from the remote node.
	 *
	 * This is a fatal error detected by the responder Rx. Only the
	 * opaque field in the CQE is valid.
	 */
	#define CQ_RES_RC_V3_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x6)
	/*
	 * An invalid message was received by the responder. This could be
	 * an operation that is not supported by this QP, an IRRQ overflow
	 * error, or the length in an RDMA operation is greater than the
	 * maximum message size (2^31 bytes).
	 *
	 * This is a fatal error detected by the responder and communicated
	 * back to the requester using a NAK-Invalid Request. For responder
	 * CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_RC_V3_STATUS_REMOTE_INVALID_REQUEST_ERR UINT32_C(0x8)
	/*
	 * A WQE was in process or outstanding when the QP transitioned
	 * into the Error State.
	 */
	#define CQ_RES_RC_V3_STATUS_WORK_REQUEST_FLUSHED_ERR   UINT32_C(0xd)
	/*
	 * A WQE had already been taken off the RQ/SRQ when a fatal error
	 * was detected on responder Rx. Only the opaque field in the CQE
	 * is valid.
	 */
	#define CQ_RES_RC_V3_STATUS_HW_FLUSH_ERR		UINT32_C(0xe)
	/*
	 * A WQE was posted to the SQ/RQ that caused it to overflow. For
	 * requester CQEs, it was the SQ that overflowed. For responder
	 * CQEs, it was the RQ that overflowed.
	 */
	#define CQ_RES_RC_V3_STATUS_OVERFLOW_ERR		UINT32_C(0xf)
	#define CQ_RES_RC_V3_STATUS_LAST			CQ_RES_RC_V3_STATUS_OVERFLOW_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_RC_V3_FLAGS_SRQ		UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_RC_V3_FLAGS_SRQ_RQ	UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_RC_V3_FLAGS_SRQ_SRQ	UINT32_C(0x1)
		#define CQ_RES_RC_V3_FLAGS_SRQ_LAST	CQ_RES_RC_V3_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_RC_V3_FLAGS_IMM		UINT32_C(0x2)
	/* R_Key invalidate indicator */
	#define CQ_RES_RC_V3_FLAGS_INV		UINT32_C(0x4)
	#define CQ_RES_RC_V3_FLAGS_RDMA	UINT32_C(0x8)
	/* CQE relates to an incoming Send request */
		#define CQ_RES_RC_V3_FLAGS_RDMA_SEND	(UINT32_C(0x0) << 3)
	/* CQE relates to incoming RDMA Write request */
		#define CQ_RES_RC_V3_FLAGS_RDMA_RDMA_WRITE  (UINT32_C(0x1) << 3)
		#define CQ_RES_RC_V3_FLAGS_RDMA_LAST	CQ_RES_RC_V3_FLAGS_RDMA_RDMA_WRITE
	/* This value is from the WQE that is being completed. */
	uint32_t	opaque;
} cq_res_rc_v3_t, *pcq_res_rc_v3_t;

/*
 * This is the Responder RQ/SRQ CQE V3 structure for UD QPs and QP1 QPs
 * that are treated as UD. This is used to complete RQ/SRQ WQE's. When
 * the WQE is completed, it indicates that there is room for one more
 * WQE on the corresponding RQ/SRQ.
 *
 * User can determine available space in the RQ/SRQ by comparing
 * a rq_cons_idx to a rq_prod_idx, both maintained by the user. The
 * range for rq_prod/cons_idx is from 0 to QPC.rq_size-1. The
 * rq_prod_idx value increments by one for each WQE that is added to
 * the RQ/SRQ by the user. Value must be wrapped at rq_size. The
 * rq_cons_idx value increments by one for each WQE that is completed
 * from that particular RQ/SRQ. The qp_handle can be used by the user
 * to determine what RQ/SRQ to increment. Value must also be wrapped at
 * rq_size. When the two values are equal, the RQ/SRQ is empty. When
 * (rq_prod_idx+1)%QPC.rq_size==rq_cons_idx, the queue is full.
 */
/* cq_res_ud_v3 (size:256b/32B) */

typedef struct cq_res_ud_v3 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_V3_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_V3_LENGTH_SFT 0
	uint8_t	reserved1;
	/* Upper 8b of the Source QP value from the DETH header. */
	uint8_t	src_qp_high;
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. The NIC
	 * toggles this bit each time it finished consuming all PBL
	 * entries.
	 */
	#define CQ_RES_UD_V3_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_UD_V3_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_UD_V3_CQE_TYPE_SFT	1
	/*
	 * Responder UD Completion - This is used for both RQ and SRQ
	 * completion for UD service QPs. It is also used for QP1 QPs
	 * that are treated as UD.
	 */
		#define CQ_RES_UD_V3_CQE_TYPE_RES_UD_V3  (UINT32_C(0xa) << 1)
		#define CQ_RES_UD_V3_CQE_TYPE_LAST	CQ_RES_UD_V3_CQE_TYPE_RES_UD_V3
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_RES_UD_V3_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that the packet was too long for the WQE provided
	 * on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields in the CQE are valid.
	 */
	#define CQ_RES_UD_V3_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x3)
	/*
	 * An internal QP consistency error was detected while processing
	 * this Work Request. For requester, this could be an SQ WQE format
	 * error or an operation specified in the WQE that is not supported
	 * for the QP. For responder, this is an RQ/SRQ WQE format error.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_UD_V3_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/*
	 * An SGE in the locally posted WQE does not reference a Memory
	 * Region that is valid for the requested operation. If this error
	 * is generated for an SGE using the reserved l_key, this means
	 * that the reserved l_key is not enabled.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_UD_V3_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x5)
	/*
	 * A WQE was in process or outstanding when the QP transitioned
	 * into the Error State.
	 */
	#define CQ_RES_UD_V3_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0xd)
	/*
	 * A WQE had already been taken off the RQ/SRQ when a fatal error
	 * was detected on responder Rx. Only the opaque field in the CQE
	 * is valid.
	 */
	#define CQ_RES_UD_V3_STATUS_HW_FLUSH_ERR		UINT32_C(0xe)
	/*
	 * A WQE was posted to the SQ/RQ that caused it to overflow. For
	 * requester CQEs, it was the SQ that overflowed. For responder
	 * CQEs, it was the RQ that overflowed.
	 */
	#define CQ_RES_UD_V3_STATUS_OVERFLOW_ERR		UINT32_C(0xf)
	#define CQ_RES_UD_V3_STATUS_LAST			CQ_RES_UD_V3_STATUS_OVERFLOW_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_V3_FLAGS_SRQ		UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_V3_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_V3_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_V3_FLAGS_SRQ_LAST	CQ_RES_UD_V3_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_V3_FLAGS_IMM		UINT32_C(0x2)
	#define CQ_RES_UD_V3_FLAGS_UNUSED_MASK	UINT32_C(0xc)
	#define CQ_RES_UD_V3_FLAGS_UNUSED_SFT	2
	#define CQ_RES_UD_V3_FLAGS_ROCE_IP_VER_MASK  UINT32_C(0x30)
	#define CQ_RES_UD_V3_FLAGS_ROCE_IP_VER_SFT   4
	/* RoCEv1 Message */
		#define CQ_RES_UD_V3_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_V3_FLAGS_ROCE_IP_VER_V2IPV4  (UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_V3_FLAGS_ROCE_IP_VER_V2IPV6  (UINT32_C(0x3) << 4)
		#define CQ_RES_UD_V3_FLAGS_ROCE_IP_VER_LAST   CQ_RES_UD_V3_FLAGS_ROCE_IP_VER_V2IPV6
	/* This value is from the WQE that is being completed. */
	uint32_t	opaque;
} cq_res_ud_v3_t, *pcq_res_ud_v3_t;

/*
 * This is the Responder RQ/SRQ CQE V3 structure for RawEth. This is
 * used to complete RQ/SRQ WQE's. When the WQE is completed, it
 * indicates that there is room for one more WQE on the corresponding
 * RQ/SRQ.
 *
 * User can determine available space in the RQ/SRQ by comparing
 * a rq_cons_idx to a rq_prod_idx, both maintained by the user. The
 * range for rq_prod/cons_idx is from 0 to QPC.rq_size-1. The
 * rq_prod_idx value increments by one for each WQE that is added to
 * the RQ/SRQ by the user. Value must be wrapped at rq_size. The
 * rq_cons_idx value increments by one for each WQE that is completed
 * from that particular RQ/SRQ. The qp_handle can be used by the user
 * to determine what RQ/SRQ to increment. Value must also be wrapped at
 * rq_size. When the two values are equal, the RQ/SRQ is empty. When
 * (rq_prod_idx+1)%QPC.rq_size==rq_cons_idx, the queue is full.
 */
/* cq_res_raweth_qp1_v3 (size:256b/32B) */

typedef struct cq_res_raweth_qp1_v3 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_RAWETH_QP1_V3_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_RAWETH_QP1_V3_LENGTH_SFT 0
	uint16_t	raweth_qp1_flags_cfa_metadata1;
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * raweth_qp1_errors.
	 */
	#define CQ_RES_RAWETH_QP1_V3_ERROR			UINT32_C(0x1)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define CQ_RES_RAWETH_QP1_V3_ITYPE_MASK		UINT32_C(0x3c0)
	#define CQ_RES_RAWETH_QP1_V3_ITYPE_SFT		6
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_NOT_KNOWN		(UINT32_C(0x0) << 6)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_IP			(UINT32_C(0x1) << 6)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_TCP			(UINT32_C(0x2) << 6)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_UDP			(UINT32_C(0x3) << 6)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_FCOE		(UINT32_C(0x4) << 6)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_ROCE		(UINT32_C(0x5) << 6)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_ICMP		(UINT32_C(0x7) << 6)
	/*
	 * PtP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_PTP_WO_TIMESTAMP	(UINT32_C(0x8) << 6)
	/*
	 * PtP packet w/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 6)
		#define CQ_RES_RAWETH_QP1_V3_ITYPE_LAST		CQ_RES_RAWETH_QP1_V3_ITYPE_PTP_W_TIMESTAMP
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA1_MASK	UINT32_C(0xf000)
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA1_SFT	12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA1_TPID_SEL_MASK UINT32_C(0x7000)
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA1_TPID_SEL_SFT  12
	/* When meta_format != 0, this value is the VLAN valid. */
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA1_VALID	UINT32_C(0x8000)
	uint16_t	raweth_qp1_errors;
	/*
	 * This indicates that there was an error in the IP header
	 * checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_IP_CS_ERROR			UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP
	 * or ICMP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_L4_CS_ERROR			UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel
	 * IP header checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_IP_CS_ERROR			UINT32_C(0x40)
	/*
	 * This indicates that there was an error in the tunnel
	 * UDP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_L4_CS_ERROR			UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_SFT		9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6
	 * in the tunnel header.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the
	 * tunnel header. Valid for
	 * IPv4.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6
	 * tunnel packet packets.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel UDP header length for a tunnel
	 * UDP packet that is not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0) in the tunnel header. Valid
	 * for IPv4, and IPv6.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x5) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel header length. Valid for GTPv1-U
	 * packets.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_TOTAL_ERROR	(UINT32_C(0x6) << 9)
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_LAST		CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_TOTAL_ERROR
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL  (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_LAST			CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	cfa_metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA0_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_RAWETH_QP1_V3_CFA_METADATA0_PRI_SFT 13
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	uint32_t	raweth_qp1_flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the ip_cs_error field indicates if there
	 * was an error.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the l4_cs_error field
	 * indicates if there was an error.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the t_ip_cs_error field indicates if
	 * there was an error.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the t_l4_cs_error
	 * field indicates if there was an error.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/* The field indicates what format the metadata field is. */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_SFT		4
	/* No metadata information. Values are zero. */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 *
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 *
	 * The metadata2 field contains the table scope
	 * and action record pointer.
	 *
	 * - metadata2[25:0] contains the action record pointer.
	 * - metadata2[31:26] contains the table scope.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 *
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 *
	 * The metadata2 field contains the Tunnel ID value, justified
	 * to LSB.
	 *
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 *
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 *
	 * The metadata2 field contains the 32b metadata from the
	 * prepended header (chdr_data).
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 *
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 *
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 *
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_LAST		CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_T_IP_TYPE		UINT32_C(0x400)
	/* Indicates that the Tunnel IP type was IPv4. */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_T_IP_TYPE_IPV4		(UINT32_C(0x0) << 10)
	/* Indicates that the Tunnel IP type was IPv6. */
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_T_IP_TYPE_IPV6		(UINT32_C(0x1) << 10)
		#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_T_IP_TYPE_LAST		CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_T_IP_TYPE_IPV6
	/*
	 * This value is the complete 1's complement checksum calculated
	 * from the start of the outer L3 header to the end of the packet
	 * (not including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define CQ_RES_RAWETH_QP1_V3_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 *
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 */
	uint32_t	cfa_metadata2;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. The NIC
	 * toggles this bit each time it finished consuming all PBL
	 * entries.
	 */
	#define CQ_RES_RAWETH_QP1_V3_TOGGLE			UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_RAWETH_QP1_V3_CQE_TYPE_MASK		UINT32_C(0x1e)
	#define CQ_RES_RAWETH_QP1_V3_CQE_TYPE_SFT		1
	/*
	 * Responder RawEth and QP1 Completion - This is used for RQ and
	 * SRQ completion for RawEth service. It is also used for QP1 QPs
	 * that are treated as RawEth.
	 */
		#define CQ_RES_RAWETH_QP1_V3_CQE_TYPE_RES_RAWETH_QP1_V3  (UINT32_C(0xb) << 1)
		#define CQ_RES_RAWETH_QP1_V3_CQE_TYPE_LAST		CQ_RES_RAWETH_QP1_V3_CQE_TYPE_RES_RAWETH_QP1_V3
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_RES_RAWETH_QP1_V3_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that the packet was too long for the WQE provided
	 * on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields in the CQE are valid.
	 */
	#define CQ_RES_RAWETH_QP1_V3_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x3)
	/*
	 * An internal QP consistency error was detected while processing
	 * this Work Request. For requester, this could be an SQ WQE format
	 * error or an operation specified in the WQE that is not supported
	 * for the QP. For responder, this is an RQ/SRQ WQE format error.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_RAWETH_QP1_V3_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/*
	 * An SGE in the locally posted WQE does not reference a Memory
	 * Region that is valid for the requested operation. If this error
	 * is generated for an SGE using the reserved l_key, this means
	 * that the reserved l_key is not enabled.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_RAWETH_QP1_V3_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x5)
	/*
	 * A WQE was in process or outstanding when the QP transitioned
	 * into the Error State.
	 */
	#define CQ_RES_RAWETH_QP1_V3_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0xd)
	/*
	 * A WQE had already been taken off the RQ/SRQ when a fatal error
	 * was detected on responder Rx. Only the opaque field in the CQE
	 * is valid.
	 */
	#define CQ_RES_RAWETH_QP1_V3_STATUS_HW_FLUSH_ERR		UINT32_C(0xe)
	/*
	 * A WQE was posted to the SQ/RQ that caused it to overflow. For
	 * requester CQEs, it was the SQ that overflowed. For responder
	 * CQEs, it was the RQ that overflowed.
	 */
	#define CQ_RES_RAWETH_QP1_V3_STATUS_OVERFLOW_ERR		UINT32_C(0xf)
	#define CQ_RES_RAWETH_QP1_V3_STATUS_LAST			CQ_RES_RAWETH_QP1_V3_STATUS_OVERFLOW_ERR
	uint8_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_RAWETH_QP1_V3_FLAGS_SRQ	UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_RAWETH_QP1_V3_FLAGS_SRQ_RQ	UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_RAWETH_QP1_V3_FLAGS_SRQ_SRQ   UINT32_C(0x1)
		#define CQ_RES_RAWETH_QP1_V3_FLAGS_SRQ_LAST CQ_RES_RAWETH_QP1_V3_FLAGS_SRQ_SRQ
	/*
	 * This value indicates the offset in bytes from the beginning of the
	 * packet where the inner payload starts. This value is valid for
	 * TCP, UDP, FCoE, and RoCE packets.
	 *
	 * A value of zero indicates an offset of 256 bytes.
	 */
	uint8_t	raweth_qp1_payload_offset;
	/* This value is from the WQE that is being completed. */
	uint32_t	opaque;
} cq_res_raweth_qp1_v3_t, *pcq_res_raweth_qp1_v3_t;

/*
 * This is the Responder RQ/SRQ CQE V3 structure for UD QPs and QP1 QPs
 * treated as UD. This is used to complete RQ/SRQ WQE's. It differs
 * from the Res_UD CQE in that it carries additional CFA fields, in
 * place of the QP handle. (Instead of the QP handle, this CQE carries
 * the QID. It is up to the user to map the QID back to a QP handle.)
 * When the WQE is completed, it indicates that there is room for one
 * more WQE on the corresponding RQ/SRQ.
 *
 * User can determine available space in the RQ/SRQ by comparing
 * a rq_cons_idx to a rq_prod_idx, both maintained by the user. The
 * range for rq_prod/cons_idx is from 0 to QPC.rq_size-1. The
 * rq_prod_idx value increments by one for each WQE that is added to
 * the RQ/SRQ by the user. Value must be wrapped at rq_size. The
 * rq_cons_idx value increments by one for each WQE that is completed
 * from that particular RQ/SRQ. The qp_handle can be used by the user
 * to determine what RQ/SRQ to increment. Value must also be wrapped at
 * rq_size. When the two values are equal, the RQ/SRQ is empty. When
 * (rq_prod_idx+1)%QPC.rq_size==rq_cons_idx, the queue is full.
 */
/* cq_res_ud_cfa_v3 (size:256b/32B) */

typedef struct cq_res_ud_cfa_v3 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_CFA_V3_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_CFA_V3_LENGTH_SFT 0
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	cfa_metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_CFA_V3_CFA_METADATA0_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_CFA_V3_CFA_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_CFA_V3_CFA_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_CFA_V3_CFA_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_CFA_V3_CFA_METADATA0_PRI_SFT 13
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	uint32_t	qid_cfa_metadata1_src_qp_high;
	/*
	 * This value indicates the QPID associated with this operation.
	 *
	 * The driver will use the qid from this CQE to map a QP handle
	 * in the completion record returned to the application.
	 */
	#define CQ_RES_UD_CFA_V3_QID_MASK		UINT32_C(0x7ff)
	#define CQ_RES_UD_CFA_V3_QID_SFT			0
	#define CQ_RES_UD_CFA_V3_UNUSED_MASK		UINT32_C(0xff800)
	#define CQ_RES_UD_CFA_V3_UNUSED_SFT		11
	#define CQ_RES_UD_CFA_V3_CFA_METADATA1_MASK	UINT32_C(0xf00000)
	#define CQ_RES_UD_CFA_V3_CFA_METADATA1_SFT	20
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define CQ_RES_UD_CFA_V3_CFA_METADATA1_TPID_SEL_MASK UINT32_C(0x700000)
	#define CQ_RES_UD_CFA_V3_CFA_METADATA1_TPID_SEL_SFT  20
	/* When meta_format != 0, this value is the VLAN valid. */
	#define CQ_RES_UD_CFA_V3_CFA_METADATA1_VALID	UINT32_C(0x800000)
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_CFA_V3_SRC_QP_HIGH_MASK	UINT32_C(0xff000000)
	#define CQ_RES_UD_CFA_V3_SRC_QP_HIGH_SFT		24
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 *
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 */
	uint32_t	cfa_metadata2;
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. The NIC
	 * toggles this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_CFA_V3_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of CQE. */
	#define CQ_RES_UD_CFA_V3_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_UD_CFA_V3_CQE_TYPE_SFT	1
	/*
	 * Responder UD Completion with CFA - This is used for both RQ
	 * and SRQ completion for UD service QPs. It includes cfa fields
	 * (some of which carry VLAN information), in place of the QP
	 * handle. It is also used for QP1 QPs that are treated as UD.
	 */
		#define CQ_RES_UD_CFA_V3_CQE_TYPE_RES_UD_CFA_V3  (UINT32_C(0xc) << 1)
		#define CQ_RES_UD_CFA_V3_CQE_TYPE_LAST	CQ_RES_UD_CFA_V3_CQE_TYPE_RES_UD_CFA_V3
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* The operation completed successfully. */
	#define CQ_RES_UD_CFA_V3_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that the packet was too long for the WQE provided
	 * on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields in the CQE are valid.
	 */
	#define CQ_RES_UD_CFA_V3_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x3)
	/*
	 * An internal QP consistency error was detected while processing
	 * this Work Request. For requester, this could be an SQ WQE format
	 * error or an operation specified in the WQE that is not supported
	 * for the QP. For responder, this is an RQ/SRQ WQE format error.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_UD_CFA_V3_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/*
	 * An SGE in the locally posted WQE does not reference a Memory
	 * Region that is valid for the requested operation. If this error
	 * is generated for an SGE using the reserved l_key, this means
	 * that the reserved l_key is not enabled.
	 *
	 * This is a fatal error detected by the requester Tx or responder
	 * Rx. For responder CQEs, only the opaque field is valid.
	 */
	#define CQ_RES_UD_CFA_V3_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x5)
	/*
	 * A WQE was in process or outstanding when the QP transitioned
	 * into the Error State.
	 */
	#define CQ_RES_UD_CFA_V3_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0xd)
	/*
	 * A WQE had already been taken off the RQ/SRQ when a fatal error
	 * was detected on responder Rx. Only the opaque field in the CQE
	 * is valid.
	 */
	#define CQ_RES_UD_CFA_V3_STATUS_HW_FLUSH_ERR		UINT32_C(0xe)
	/*
	 * A WQE was posted to the SQ/RQ that caused it to overflow. For
	 * requester CQEs, it was the SQ that overflowed. For responder
	 * CQEs, it was the RQ that overflowed.
	 */
	#define CQ_RES_UD_CFA_V3_STATUS_OVERFLOW_ERR		UINT32_C(0xf)
	#define CQ_RES_UD_CFA_V3_STATUS_LAST			CQ_RES_UD_CFA_V3_STATUS_OVERFLOW_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_CFA_V3_FLAGS_SRQ			UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_CFA_V3_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_CFA_V3_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_CFA_V3_FLAGS_SRQ_LAST		CQ_RES_UD_CFA_V3_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_CFA_V3_FLAGS_IMM			UINT32_C(0x2)
	#define CQ_RES_UD_CFA_V3_FLAGS_UNUSED_MASK		UINT32_C(0xc)
	#define CQ_RES_UD_CFA_V3_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_CFA_V3_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_CFA_V3_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_CFA_V3_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_CFA_V3_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_CFA_V3_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_CFA_V3_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_CFA_V3_FLAGS_ROCE_IP_VER_V2IPV6
	/* The field indicates what format the metadata field is. */
	#define CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_SFT	6
	/* No metadata information. Value is zero. */
		#define CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 *
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 *
	 * The metadata2 field contains the table scope
	 * and action record pointer.
	 *
	 * - metadata2[25:0] contains the action record pointer.
	 * - metadata2[31:26] contains the table scope.
	 */
		#define CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_ACT_REC_PTR  (UINT32_C(0x1) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 *
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 *
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB.
	 *
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 *
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 *
	 * The metadata2 field contains the 32b metadata from the
	 * prepended header (chdr_data).
	 */
		#define CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 *
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 *
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 *
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_HDR_OFFSET   (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_LAST	CQ_RES_UD_CFA_V3_FLAGS_META_FORMAT_HDR_OFFSET
	/*
	 * This value will be returned in the completion if the completion is
	 * signaled.
	 */
	uint32_t	opaque;
} cq_res_ud_cfa_v3_t, *pcq_res_ud_cfa_v3_t;

/* nq_base (size:128b/16B) */

typedef struct nq_base {
	uint16_t	info10_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define NQ_BASE_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_BASE_TYPE_SFT		0
	/* CQ Notification */
		#define NQ_BASE_TYPE_CQ_NOTIFICATION  UINT32_C(0x30)
	/* SRQ Threshold Event */
		#define NQ_BASE_TYPE_SRQ_EVENT	UINT32_C(0x32)
	/* DBQ Threshold Event */
		#define NQ_BASE_TYPE_DBQ_EVENT	UINT32_C(0x34)
	/* QP Async Notification */
		#define NQ_BASE_TYPE_QP_EVENT	UINT32_C(0x38)
	/* Function Async Notification */
		#define NQ_BASE_TYPE_FUNC_EVENT	UINT32_C(0x3a)
	/* NQ Reassign Notification */
		#define NQ_BASE_TYPE_NQ_REASSIGN	UINT32_C(0x3c)
		#define NQ_BASE_TYPE_LAST		NQ_BASE_TYPE_NQ_REASSIGN
	/* info10 is 10 b */
	#define NQ_BASE_INFO10_MASK	UINT32_C(0xffc0)
	#define NQ_BASE_INFO10_SFT	6
	/* info16 is 16 b */
	uint16_t	info16;
	/* info32 is 32 b */
	uint32_t	info32;
	/* info32 is 32 b */
	uint64_t	info63_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define NQ_BASE_V	UINT32_C(0x1)
	/* info63 is 63 b */
	#define NQ_BASE_INFO63_MASK UINT32_C(0xfffffffe)
	#define NQ_BASE_INFO63_SFT 1
} nq_base_t, *pnq_base_t;

/* Completion Queue Notification */
/* nq_cn (size:128b/16B) */

typedef struct nq_cn {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define NQ_CN_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_CN_TYPE_SFT		0
	/* CQ Notification */
		#define NQ_CN_TYPE_CQ_NOTIFICATION  UINT32_C(0x30)
		#define NQ_CN_TYPE_LAST		NQ_CN_TYPE_CQ_NOTIFICATION
	/*
	 * This field carries the toggle value that must be used to
	 * re-arm this CQ. The toggle value should be copied into the
	 * doorbell used to CQ_ARMENA, CQ_ARMALL or CQ_ARMSE doorbells.
	 *
	 * This value is used by HW to detect old and stale CQ_ARMENA,
	 * CQ_ARMALL, or CQ_ARMSE doorbells that are caused by having
	 * a backup doorbell location or by PCI or other reordering
	 * problems. Only the doorbells that match the latest value of
	 * toggle will be honored.
	 */
	#define NQ_CN_TOGGLE_MASK	UINT32_C(0xc0)
	#define NQ_CN_TOGGLE_SFT	6
	uint16_t	reserved16;
	/*
	 * This is an application level ID used to identify the
	 * CQ. This field carries the lower 32b of the value.
	 */
	uint32_t	cq_handle_low;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define NQ_CN_V	UINT32_C(0x1)
	/*
	 * This is an application level ID used to identify the
	 * CQ. This field carries the upper 32b of the value.
	 */
	uint32_t	cq_handle_high;
} nq_cn_t, *pnq_cn_t;

/* SRQ Event Notification */
/* nq_srq_event (size:128b/16B) */

typedef struct nq_srq_event {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B records.
	 */
	#define NQ_SRQ_EVENT_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_SRQ_EVENT_TYPE_SFT	0
	/* SRQ Threshold Event */
		#define NQ_SRQ_EVENT_TYPE_SRQ_EVENT  UINT32_C(0x32)
		#define NQ_SRQ_EVENT_TYPE_LAST	NQ_SRQ_EVENT_TYPE_SRQ_EVENT
	/*
	 * This field carries the toggle value that must be used
	 * to re-arm this SRQ. The toggle value should be copied
	 * into the doorbell used to SRQ_ARMENA or SRQ_ARM doorbells.
	 */
	#define NQ_SRQ_EVENT_TOGGLE_MASK   UINT32_C(0xc0)
	#define NQ_SRQ_EVENT_TOGGLE_SFT	6
	/*
	 * This value define what type of async event has occurred
	 * on the SRQ.
	 */
	uint8_t	event;
	/* The threshold event has occurred on the specified SRQ. */
	#define NQ_SRQ_EVENT_EVENT_SRQ_THRESHOLD_EVENT UINT32_C(0x1)
	#define NQ_SRQ_EVENT_EVENT_LAST		NQ_SRQ_EVENT_EVENT_SRQ_THRESHOLD_EVENT
	uint16_t	reserved16;
	/*
	 * This is the SRQ handle value for the queue that has
	 * reached it's event threshold. This field carries the
	 * lower 32b of the value.
	 */
	uint32_t	srq_handle_low;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define NQ_SRQ_EVENT_V	UINT32_C(0x1)
	/*
	 * This is the SRQ handle value for the queue that has
	 * reached it's event threshold. This field carries the
	 * upper 32b of the value.
	 */
	uint32_t	srq_handle_high;
} nq_srq_event_t, *pnq_srq_event_t;

/* DBQ Async Event Notification */
/* nq_dbq_event (size:128b/16B) */

typedef struct nq_dbq_event {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define NQ_DBQ_EVENT_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_DBQ_EVENT_TYPE_SFT	0
	/* DBQ Threshold Event */
		#define NQ_DBQ_EVENT_TYPE_DBQ_EVENT  UINT32_C(0x34)
		#define NQ_DBQ_EVENT_TYPE_LAST	NQ_DBQ_EVENT_TYPE_DBQ_EVENT
	/* This value define what type of action the driver should take. */
	uint8_t	event;
	/*
	 * The driver should start writing dummy values to the
	 * the doorbell in an attempt to consume all the PCIE
	 * posted write resources and prevent doorbell overflow.
	 */
	#define NQ_DBQ_EVENT_EVENT_DBQ_THRESHOLD_EVENT UINT32_C(0x1)
	#define NQ_DBQ_EVENT_EVENT_LAST		NQ_DBQ_EVENT_EVENT_DBQ_THRESHOLD_EVENT
	uint16_t	db_pfid;
	/*
	 * This is the PFID of function that wrote the doorbell that
	 * crossed the async event threshold.
	 */
	#define NQ_DBQ_EVENT_DB_PFID_MASK UINT32_C(0xf)
	#define NQ_DBQ_EVENT_DB_PFID_SFT 0
	uint32_t	db_dpi;
	/*
	 * This is the DPI of the doorbell write that crossed
	 * the async event threshold.
	 */
	#define NQ_DBQ_EVENT_DB_DPI_MASK UINT32_C(0xfffff)
	#define NQ_DBQ_EVENT_DB_DPI_SFT 0
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define NQ_DBQ_EVENT_V	UINT32_C(0x1)
	uint32_t	db_type_db_xid;
	/*
	 * DB 'XID' field from doorbell that crossed the async event
	 * threshold. This is a QPID, SID, or CID, depending on
	 * the db_type field.
	 */
	#define NQ_DBQ_EVENT_DB_XID_MASK UINT32_C(0xfffff)
	#define NQ_DBQ_EVENT_DB_XID_SFT  0
	/*
	 * DB 'type' field from doorbell that crossed the async event
	 * threshold.
	 */
	#define NQ_DBQ_EVENT_DB_TYPE_MASK UINT32_C(0xf0000000)
	#define NQ_DBQ_EVENT_DB_TYPE_SFT 28
} nq_dbq_event_t, *pnq_dbq_event_t;

/*
 * This completion indicates that the NQ Reassign doorbell has been
 * executed by the CQ processing block and no further NQE will arrive
 * for this CQ on this NQ.
 */
/* nq_reassign (size:128b/16B) */

typedef struct nq_reassign {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B records.
	 */
	#define NQ_REASSIGN_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_REASSIGN_TYPE_SFT	0
	/* NQ Reassign Notification */
		#define NQ_REASSIGN_TYPE_NQ_REASSIGN  UINT32_C(0x3c)
		#define NQ_REASSIGN_TYPE_LAST	NQ_REASSIGN_TYPE_NQ_REASSIGN
	uint16_t	reserved16;
	/*
	 * This is an application level ID used to identify the
	 * CQ. This field carries the lower 32b of the value.
	 */
	uint32_t	cq_handle_low;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define NQ_REASSIGN_V	UINT32_C(0x1)
	/*
	 * This is an application level ID used to identify the
	 * CQ. This field carries the upper 32b of the value.
	 */
	uint32_t	cq_handle_high;
} nq_reassign_t, *pnq_reassign_t;

/* Input Read Request Queue (IRRQ) Message */
/* xrrq_irrq (size:256b/32B) */

typedef struct xrrq_irrq {
	uint16_t	credits_type;
	/* Type indication */
	#define XRRQ_IRRQ_TYPE	UINT32_C(0x1)
	/* RDMA Read */
		#define XRRQ_IRRQ_TYPE_READ_REQ	UINT32_C(0x0)
	/* Atomic */
		#define XRRQ_IRRQ_TYPE_ATOMIC_REQ  UINT32_C(0x1)
		#define XRRQ_IRRQ_TYPE_LAST	XRRQ_IRRQ_TYPE_ATOMIC_REQ
	/*
	 * The credit code calculated by Rx path when receiving the
	 * request. It will be placed in the syndrome credit code with
	 * the acks on first and last response.
	 */
	#define XRRQ_IRRQ_CREDITS_MASK   UINT32_C(0xf800)
	#define XRRQ_IRRQ_CREDITS_SFT	11
	uint16_t	reserved16;
	uint32_t	reserved32;
	uint32_t	psn;
	/* The PSN of the outstanding incoming request */
	#define XRRQ_IRRQ_PSN_MASK UINT32_C(0xffffff)
	#define XRRQ_IRRQ_PSN_SFT 0
	uint32_t	msn;
	/*
	 * The value of QPC.pending_ack_msn after it is incremented as a
	 * result of receiving the read/atomic request. IRRQ.msn-1 will
	 * be placed in the MSN field of the first response and IRRQ.msn
	 * will placed in the MSN field of the last or only response.
	 */
	#define XRRQ_IRRQ_MSN_MASK UINT32_C(0xffffff)
	#define XRRQ_IRRQ_MSN_SFT 0
	/*
	 * Virtual address on local host for RDMA READ
	 *
	 * In case of duplicate Atomic, the VA is not required to
	 * be validated, only the PSN is, thus this field is used
	 * to store the value returned in the Ack to the atomic
	 * request, and if duplicate arrives, this value is used
	 * again for resending the ack.
	 */
	uint64_t	va_or_atomic_result;
	/* The key to the MR/W in the request */
	uint32_t	rdma_r_key;
	/*
	 * Length in bytes of the data requested. Length must be 8 if type is
	 * atomic.
	 */
	uint32_t	length;
} xrrq_irrq_t, *pxrrq_irrq_t;

/* Output Read Request Queue (ORRQ) Message */
/* xrrq_orrq (size:256b/32B) */

typedef struct xrrq_orrq {
	uint16_t	num_sges_type;
	/* Type indication */
	#define XRRQ_ORRQ_TYPE	UINT32_C(0x1)
	/* RDMA Read */
		#define XRRQ_ORRQ_TYPE_READ_REQ	UINT32_C(0x0)
	/* Atomic */
		#define XRRQ_ORRQ_TYPE_ATOMIC_REQ  UINT32_C(0x1)
		#define XRRQ_ORRQ_TYPE_LAST	XRRQ_ORRQ_TYPE_ATOMIC_REQ
	/*
	 * Up to 6 SGEs. This value is 1 if type is atomic as one
	 * SGE is required to store Atomic response result field. 2
	 * more bits allocated for future growth.
	 *
	 * Note that, if num_sges is 1 for an RDMA Read request, then
	 * the first_sge_phy_or_sing_sge_va, single_sge_l_key, and
	 * single_sge_size fields will be populated from the single
	 * SGE.
	 *
	 * If num_sges is 2 or more for an RDMA Read request, then
	 * the first_sge_phy_or_sing_sge_va field carries the
	 * physical address in host memory where the first sge is
	 * stored. The single_sge_l_key and single_sge_size fields
	 * are unused in this case.
	 *
	 * A special case is a zero-length, zero-sge RDMA read request
	 * WQE. In this situation, num_sges will be 1. However,
	 * first_sge_phy_or_sing_sge_va, single_sge_l_key, and
	 * single_sge_size will all be populated with zeros.
	 */
	#define XRRQ_ORRQ_NUM_SGES_MASK  UINT32_C(0xf800)
	#define XRRQ_ORRQ_NUM_SGES_SFT   11
	uint16_t	reserved16;
	/*
	 * Length in bytes of the data requested. Length must be 8 if type is
	 * atomic.
	 */
	uint32_t	length;
	uint32_t	psn;
	/* The PSN of the outstanding outgoing request */
	#define XRRQ_ORRQ_PSN_MASK UINT32_C(0xffffff)
	#define XRRQ_ORRQ_PSN_SFT 0
	uint32_t	end_psn;
	/*
	 * The expected last PSN on a response to this request where
	 * an ack with response, rather than just response, should
	 * arrive. If ack arrive with smaller PSN than end_psn then it
	 * is considered a NAK.
	 */
	#define XRRQ_ORRQ_END_PSN_MASK UINT32_C(0xffffff)
	#define XRRQ_ORRQ_END_PSN_SFT 0
	/*
	 * If num_sges == 1 this is the va of that SGE. Otherwise,
	 * physical address to the first SGE specified by the WQE.
	 * Points to the first SGE in the Request's WQE in the SQ.
	 * It is assumed that WQE does not cross page boundaries!
	 * Driver is responsible to enforce that. SGEs are 16B
	 * aligned 0b0000 lsb added to get 64 bit address.
	 */
	uint64_t	first_sge_phy_or_sing_sge_va;
	/* The L_Key of a single SGE if used */
	uint32_t	single_sge_l_key;
	/* The size in bytes of the single SGE if used */
	uint32_t	single_sge_size;
} xrrq_orrq_t, *pxrrq_orrq_t;

/* Page Table Entry (PTE) */
/* ptu_pte (size:64b/8B) */

typedef struct ptu_pte {
	uint64_t	page_next_to_last_last_valid;
	/*
	 * This field indicates if the PTE is valid. A value of '0'
	 * indicates that the page is not valid. A value of '1'
	 * indicates that the page is valid. A reference to an
	 * invalid page will return a PTU error.
	 */
	#define PTU_PTE_VALID		UINT32_C(0x1)
	/*
	 * This field is used only for "ring" PBLs that are used for
	 * SQ, RQ, SRQ, or CQ structures. For all other PBL structures,
	 * this bit should be zero. When this bit is '1', it indicates
	 * that the page pointed to by this PTE is the last page in the
	 * ring. A prefetch for the ring should use the first PTE in
	 * the PBL.
	 */
	#define PTU_PTE_LAST		UINT32_C(0x2)
	/*
	 * This field is used only for "ring" PBLs that are used for
	 * SQ, RQ, SRQ, or CQ structures. For all other PBL structures,
	 * this bit should be zero. When this bit is '1', it indicates
	 * that this is the next-to-last page of the PBL.
	 */
	#define PTU_PTE_NEXT_TO_LAST	UINT32_C(0x4)
	/* These bits should be programmed to zero. */
	#define PTU_PTE_UNUSED_MASK	UINT32_C(0xff8)
	#define PTU_PTE_UNUSED_SFT	3
	/*
	 * This is the upper bits of the physical page controlled by
	 * this PTE. If the page is larger than 4KB, then the unused
	 * lower bits of the page address should be zero.
	 */
	#define PTU_PTE_PAGE_MASK	UINT32_C(0xfffffffffffff000)L
	#define PTU_PTE_PAGE_SFT	12
} ptu_pte_t, *pptu_pte_t;

/* Page Directory Entry (PDE) */
/* ptu_pde (size:64b/8B) */

typedef struct ptu_pde {
	uint64_t	page_valid;
	/*
	 * This field indicates if the PTE is valid. A value of '0'
	 * indicates that the page is not valid. A value of '1'
	 * indicates that the page is valid. A reference to an
	 * invalid page will return a PTU error.
	 */
	#define PTU_PDE_VALID	UINT32_C(0x1)
	/* These bits should be programmed to zero. */
	#define PTU_PDE_UNUSED_MASK UINT32_C(0xffe)
	#define PTU_PDE_UNUSED_SFT 1
	/*
	 * This is the upper bits of the physical page controlled by
	 * this PTE. If the page is larger than 4KB, then the unused
	 * lower bits of the page address should be zero.
	 */
	#define PTU_PDE_PAGE_MASK  UINT32_C(0xfffffffffffff000)L
	#define PTU_PDE_PAGE_SFT   12
} ptu_pde_t, *pptu_pde_t;

/*
 * This is the 64b doorbell format. The host writes this message
 * format directly to byte offset 0 of the appropriate doorbell page.
 */
/* dbc_dbc (size:64b/8B) */

typedef struct dbc_dbc {
	uint32_t	index;
	/*
	 * This value is the index being written.
	 *
	 * For SQ, RQ, and SRQ, this is the producer index and the unit is
	 * 16B of queue space for L2 path and for the Engine path. For RoCE
	 * path there is a legacy mode with 128B unit size and a variable
	 * size WQE mode with 16B unit size of queue space. This mode is
	 * configured in the QP.
	 *
	 * For CQ this is the consumer index and the unit is 32B of queue
	 * space for the RoCE/Engine path and the CQ index unit is 16B of
	 * queue space for the L2 path.
	 *
	 * For NQ this is the consumer index and the unit is always 16B of
	 * queue space.
	 *
	 * The index size is 24b for L2 and engine paths and 16b for the
	 * RoCE path. Unused bits should be written as zero.
	 */
	#define DBC_DBC_INDEX_MASK UINT32_C(0xffffff)
	#define DBC_DBC_INDEX_SFT  0
	/*
	 * The epoch bit provides a frame of reference for the queue index.
	 * S/W will toggle this bit in the doorbell each time index range is
	 * wrapped. This allows the receiving HW block to more efficiently
	 * detect out-of-order doorbells and to ignore the older doorbells.
	 * Out-of-order doorbells occur normally during dropped doorbell
	 * recovery.
	 */
	#define DBC_DBC_EPOCH	UINT32_C(0x1000000)
	/*
	 * The toggle value is used in CQ_ARMENA, CQ_ARMSE, CQ_ARMALL,
	 * SRQ_ARMENA, SRQ_ARM, and CQ_CUTOFF_ACK doorbells to qualify the
	 * doorbell as valid. This value should be taken from the latest
	 * NQE or cutoff completion.
	 *
	 * Doorbells of the above types with the wrong toggle value will
	 * be ignored. This is how old values in of backup doorbells
	 * are ignored.
	 */
	#define DBC_DBC_TOGGLE_MASK UINT32_C(0x6000000)
	#define DBC_DBC_TOGGLE_SFT 25
	uint32_t	type_path_xid;
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ and RQ, this is the QPID. For SRQ, this is the SID. For
	 * CQ, this is the CID. For NQ, this is the NID.
	 *
	 * Bits [19:16] of this values must be zero for a SID value.
	 */
	#define DBC_DBC_XID_MASK	UINT32_C(0xfffff)
	#define DBC_DBC_XID_SFT	0
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_DBC_PATH_MASK	UINT32_C(0x3000000)
	#define DBC_DBC_PATH_SFT	24
	/* This is a RoCE doorbell message. */
		#define DBC_DBC_PATH_ROCE	(UINT32_C(0x0) << 24)
	/* This is a L2 doorbell message. */
		#define DBC_DBC_PATH_L2		(UINT32_C(0x1) << 24)
	/* Engine path doorbell. */
		#define DBC_DBC_PATH_ENGINE	(UINT32_C(0x2) << 24)
		#define DBC_DBC_PATH_LAST	DBC_DBC_PATH_ENGINE
	/*
	 * This indicates it is valid doorbell update. It should be set for
	 * each doorbell written to the chip and set when doorbell message is
	 * written to the backup doorbell location. The bit should be cleared
	 * in the backup doorbell location at time zero to indicate that the
	 * backup doorbell has not yet been written.
	 */
	#define DBC_DBC_VALID		UINT32_C(0x4000000)
	/*
	 * When this bit is set to one, the chip will capture debug
	 * information for the doorbell ring. This is intended to only be
	 * used on SQ doorbell rings.
	 */
	#define DBC_DBC_DEBUG_TRACE	UINT32_C(0x8000000)
	/* This value identifies the type of doorbell being written. */
	#define DBC_DBC_TYPE_MASK	UINT32_C(0xf0000000)
	#define DBC_DBC_TYPE_SFT	28
	/*
	 * This is a SQ producer index update. It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_DBC_TYPE_SQ		(UINT32_C(0x0) << 28)
	/*
	 * This is a RQ producer index update. It indicates one or more
	 * new entries have been written to the RQ for the QPID indicated
	 * on the xID field. This type is valid for RoCE path.
	 */
		#define DBC_DBC_TYPE_RQ		(UINT32_C(0x1) << 28)
	/*
	 * This is a SRQ producer index update. It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_TYPE_SRQ		(UINT32_C(0x2) << 28)
	/*
	 * This doorbell command arms the SRQ async event.
	 * The xID field must identify the SID that is begin armed.
	 * The index field is will set the arm threshold such that
	 * a notification will be generated if less than that number
	 * or SRQ entries are posted. This type is valid for RoCE path.
	 */
		#define DBC_DBC_TYPE_SRQ_ARM	(UINT32_C(0x3) << 28)
	/*
	 * This is a CQ consumer index update. It indicates one or more
	 * entries have been processed off the CQ indicated on the xID
	 * field.This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_CQ		(UINT32_C(0x4) << 28)
	/*
	 * this is a CQ consumer index update that also arms the CQ for
	 * solicited events. This type is valid for RoCE path.
	 */
		#define DBC_DBC_TYPE_CQ_ARMSE	(UINT32_C(0x5) << 28)
	/*
	 * This is a CQ consumer index update that also arms the CQ
	 * for any new CQE. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_DBC_TYPE_CQ_ARMALL	(UINT32_C(0x6) << 28)
	/*
	 * This is a CQ arm enable message. This message must be sent
	 * from the privileged driver before a new CQ_ARMSE or CQ_ARMALL
	 * message will be accepted.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_DBC_TYPE_CQ_ARMENA	(UINT32_C(0x7) << 28)
	/*
	 * This doorbell command enables the SRQ async event
	 * to be armed. This message must be sent from the privileged
	 * driver before a new SRQ_ARM message will be accepted.
	 * The xID field must identify the SID that is begin enabled
	 * for arm.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_DBC_TYPE_SRQ_ARMENA	(UINT32_C(0x8) << 28)
	/*
	 * This doorbell command indicates that the cutoff CQE has
	 * been processed and the driver is now processing completions
	 * from the new CQ.
	 *
	 * The index field for this doorbell type must be zero.
	 */
		#define DBC_DBC_TYPE_CQ_CUTOFF_ACK  (UINT32_C(0x9) << 28)
	/*
	 * This is a NQ consumer index update. It indicates one or more
	 * entries have been processed off the NQ indicated on the xID
	 * field. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_NQ		(UINT32_C(0xa) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_NQ_ARM	(UINT32_C(0xb) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. It is used for the legacy INT mask. This type
	 * is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_NQ_MASK	(UINT32_C(0xe) << 28)
	/*
	 * This doorbell command is used during doorbell moderation
	 * to consume system BW and help prevent doorbell FIFO
	 * overflow.
	 *
	 * All other fields should be zero for NULL doorbell.
	 * For doorbell recovery, NULL doorbell type in the Application
	 * table indicates that it is the last QP entry for the function.
	 * This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_NULL	(UINT32_C(0xf) << 28)
		#define DBC_DBC_TYPE_LAST	DBC_DBC_TYPE_NULL
} dbc_dbc_t, *pdbc_dbc_t;

/*
 * This is the 64b doorbell copy format. The host writes this DB to
 * the doorbell copy memory. Upon a HW Doorbell Drop Recovery process,
 * it would be DMAed into HW for recovering the dropped doorbell.
 */
/* dbc_dbc64 (size:64b/8B) */

typedef struct dbc_dbc64 {
	uint64_t	dbc;
	/*
	 * This value is the index being written.
	 *
	 * For SQ, RQ, and SRQ, this is the producer index and the unit is
	 * 16B of queue space for L2 path and for the Engine path. For RoCE
	 * path there is a legacy mode with 128B unit size and a variable
	 * size WQE mode with 16B unit size of queue space. This mode is
	 * configured in the QP.
	 *
	 * For CQ this is the consumer index and the unit is 32B of queue
	 * space for the RoCE/Engine path and the CQ index unit is 16B of
	 * queue space for the L2 path.
	 *
	 * For NQ this is the consumer index and the unit is always 16B of
	 * queue space.
	 *
	 * The index size is 24b for L2 and engine paths and 16b for the
	 * RoCE path. Unused bits should be written as zero.
	 */
	#define DBC_DBC64_INDEX_MASK	UINT32_C(0xffffff)
	#define DBC_DBC64_INDEX_SFT	0
	/*
	 * The epoch bit provides a frame of reference for the queue index.
	 * S/W will toggle this bit in the doorbell each time index range is
	 * wrapped. This allows the receiving HW block to more efficiently
	 * detect out-of-order doorbells and to ignore the older doorbells.
	 * Out-of-order doorbells occur normally during dropped doorbell
	 * recovery.
	 */
	#define DBC_DBC64_EPOCH		UINT32_C(0x1000000)
	/*
	 * The toggle value is used in CQ_ARMENA, CQ_ARMSE, CQ_ARMALL,
	 * SRQ_ARMENA, SRQ_ARM, and CQ_CUTOFF_ACK doorbells to qualify the
	 * doorbell as valid. This value should be taken from the latest
	 * NQE or cutoff completion.
	 *
	 * Doorbells of the above types with the wrong toggle value will
	 * be ignored. This is how old values in of backup doorbells
	 * are ignored.
	 */
	#define DBC_DBC64_TOGGLE_MASK	UINT32_C(0x6000000)
	#define DBC_DBC64_TOGGLE_SFT	25
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ and RQ, this is the QPID. For SRQ, this is the SID. For
	 * CQ, this is the CID. For NQ, this is the NID.
	 *
	 * Bits [51:48] of this values must be zero for a SID value.
	 */
	#define DBC_DBC64_XID_MASK	UINT32_C(0xfffff00000000)L
	#define DBC_DBC64_XID_SFT	32
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_DBC64_PATH_MASK	UINT32_C(0x300000000000000)L
	#define DBC_DBC64_PATH_SFT	56
	/* This is a RoCE doorbell message. */
		#define DBC_DBC64_PATH_ROCE	(UINT32_C(0x0)L << 56)
	/* This is a L2 doorbell message. */
		#define DBC_DBC64_PATH_L2		(UINT32_C(0x1)L << 56)
	/* Engine path doorbell. */
		#define DBC_DBC64_PATH_ENGINE	(UINT32_C(0x2)L << 56)
		#define DBC_DBC64_PATH_LAST	DBC_DBC64_PATH_ENGINE
	/*
	 * This indicates it is valid doorbell update. It should be set for
	 * each doorbell written to the chip and set when doorbell message is
	 * written to the backup doorbell location. The bit should be cleared
	 * in the backup doorbell location at time zero to indicate that the
	 * backup doorbell has not yet been written.
	 */
	#define DBC_DBC64_VALID		UINT32_C(0x400000000000000)L
	/*
	 * When this bit is set to one, the chip will capture debug
	 * information for the doorbell ring. This is intended to only be
	 * used on SQ doorbell rings.
	 */
	#define DBC_DBC64_DEBUG_TRACE	UINT32_C(0x800000000000000)L
	/* This value identifies the type of doorbell being written. */
	#define DBC_DBC64_TYPE_MASK	UINT32_C(0xf000000000000000)L
	#define DBC_DBC64_TYPE_SFT	60
	/*
	 * This is a SQ producer index update. It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_DBC64_TYPE_SQ		(UINT32_C(0x0)L << 60)
	/*
	 * This is a RQ producer index update. It indicates one or more
	 * new entries have been written to the RQ for the QPID indicated
	 * on the xID field. This type is valid for RoCE path.
	 */
		#define DBC_DBC64_TYPE_RQ		(UINT32_C(0x1)L << 60)
	/*
	 * This is a SRQ producer index update. It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC64_TYPE_SRQ		(UINT32_C(0x2)L << 60)
	/*
	 * This doorbell command arms the SRQ async event.
	 * The xID field must identify the SID that is begin armed.
	 * The index field is will set the arm threshold such that
	 * a notification will be generated if less than that number
	 * or SRQ entries are posted. This type is valid for RoCE path.
	 */
		#define DBC_DBC64_TYPE_SRQ_ARM	(UINT32_C(0x3)L << 60)
	/*
	 * This is a CQ consumer index update. It indicates one or more
	 * entries have been processed off the CQ indicated on the xID
	 * field.This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC64_TYPE_CQ		(UINT32_C(0x4)L << 60)
	/*
	 * this is a CQ consumer index update that also arms the CQ for
	 * solicited events. This type is valid for RoCE path.
	 */
		#define DBC_DBC64_TYPE_CQ_ARMSE	(UINT32_C(0x5)L << 60)
	/*
	 * This is a CQ consumer index update that also arms the CQ
	 * for any new CQE. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_DBC64_TYPE_CQ_ARMALL	(UINT32_C(0x6)L << 60)
	/*
	 * This is a CQ arm enable message. This message must be sent
	 * from the privileged driver before a new CQ_ARMSE or CQ_ARMALL
	 * message will be accepted.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_DBC64_TYPE_CQ_ARMENA	(UINT32_C(0x7)L << 60)
	/*
	 * This doorbell command enables the SRQ async event
	 * to be armed. This message must be sent from the privileged
	 * driver before a new SRQ_ARM message will be accepted.
	 * The xID field must identify the SID that is begin enabled
	 * for arm.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_DBC64_TYPE_SRQ_ARMENA	(UINT32_C(0x8)L << 60)
	/*
	 * This doorbell command indicates that the cutoff CQE has
	 * been processed and the driver is now processing completions
	 * from the new CQ.
	 *
	 * The index field for this doorbell type must be zero.
	 */
		#define DBC_DBC64_TYPE_CQ_CUTOFF_ACK  (UINT32_C(0x9)L << 60)
	/*
	 * This is a NQ consumer index update. It indicates one or more
	 * entries have been processed off the NQ indicated on the xID
	 * field. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC64_TYPE_NQ		(UINT32_C(0xa)L << 60)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC64_TYPE_NQ_ARM	(UINT32_C(0xb)L << 60)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. It is used for the legacy INT mask. This type
	 * is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC64_TYPE_NQ_MASK	(UINT32_C(0xe)L << 60)
	/*
	 * This doorbell command is used during doorbell moderation
	 * to consume system BW and help prevent doorbell FIFO
	 * overflow.
	 *
	 * All other fields should be zero for NULL doorbell.
	 * For doorbell recovery, NULL doorbell type in the Application
	 * table indicates that it is the last QP entry for the function.
	 * This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC64_TYPE_NULL	(UINT32_C(0xf)L << 60)
		#define DBC_DBC64_TYPE_LAST	DBC_DBC64_TYPE_NULL
} dbc_dbc64_t, *pdbc_dbc64_t;

/*
 * This is the 32b doorbell format. The host writes this message
 * format directly to byte offset 8 of the appropriate doorbell page.
 */
/* dbc_dbc32 (size:32b/4B) */

typedef struct dbc_dbc32 {
	uint32_t	type_abs_incr_xid;
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ and RQ, this is the QPID. For SRQ, this is the SID. For
	 * CQ, this is the CID.
	 *
	 * Bits [19:16] of this values must be zero for a SID value.
	 */
	#define DBC_DBC32_XID_MASK UINT32_C(0xfffff)
	#define DBC_DBC32_XID_SFT  0
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_DBC32_PATH_MASK UINT32_C(0xc00000)
	#define DBC_DBC32_PATH_SFT 22
	/* This is a RoCE doorbell message. */
		#define DBC_DBC32_PATH_ROCE  (UINT32_C(0x0) << 22)
	/* This is a L2 doorbell message. */
		#define DBC_DBC32_PATH_L2	(UINT32_C(0x1) << 22)
		#define DBC_DBC32_PATH_LAST DBC_DBC32_PATH_L2
	/*
	 * When abs=0, this value is the value to add to the appropriate
	 * index value.
	 *
	 * When abs=1, this value is the new value for the index. Absolute
	 * value is used when the queue is being wrapped. When abs=1,
	 * the incr value follows the same rules as the index value
	 * in the 64b doorbell.
	 */
	#define DBC_DBC32_INCR_MASK UINT32_C(0xf000000)
	#define DBC_DBC32_INCR_SFT 24
	/* This value defines how the incr value will be interpreted. */
	#define DBC_DBC32_ABS	UINT32_C(0x10000000)
	/* This value identifies the type of doorbell being written. */
	#define DBC_DBC32_TYPE_MASK UINT32_C(0xe0000000)
	#define DBC_DBC32_TYPE_SFT 29
	/*
	 * This is a SQ producer index update. It indicates one or more
	 * new entries have been written to the SQ for the QPID
	 * indicated on the xID field.
	 */
		#define DBC_DBC32_TYPE_SQ	(UINT32_C(0x0) << 29)
		#define DBC_DBC32_TYPE_LAST DBC_DBC32_TYPE_SQ
} dbc_dbc32_t, *pdbc_dbc32_t;

/*
 * This is the 64b Push Start doorbell format. The host writes this
 * message format directly to offset of each push associated WCB (write
 * combine buffer) within doorbell page. WCB#0 = offset 16, WCB#1 =
 * offset 24, WCB#2 = offset 32, ... The start doorbell is followed by
 * write combining data to the WCB and then that is followed by a end
 * doorbell.
 */
/* db_push_start (size:64b/8B) */

typedef struct db_push_start {
	uint64_t	db;
	/*
	 * This is the push index and should be the SQ slot index,
	 * aligned to the start of the corresponding push WQE/packet in
	 * the Send Queue.
	 *
	 * The index size is 16b for RoCE path and 24b for L2 and Engine
	 * paths. Any unused bits should be written as zero.
	 *
	 * The index unit is 16B for L2 path. For RoCE there is a legacy
	 * mode with 128B unit size and a variable size mode with 16B
	 * unit size. For Engine mode, the unit size is 16B, where RQEs
	 * are always 128B - so it always increments by eight 16B slots
	 * per RQE.
	 *
	 * > This field is not used by the older versions of the chip,
	 * > but is used in this and future revisions of the chip. In
	 * > older versions of the chip, the driver is required to
	 * > complete the push doorbell operation by following it with a
	 * > regular doorbell which will be used to properly increment
	 * > the producer index. This extra doorbell write is not needed
	 * > on this and future versions of the chip.
	 */
	#define DB_PUSH_START_DB_INDEX_MASK	UINT32_C(0xffffff)
	#define DB_PUSH_START_DB_INDEX_SFT	0
	/*
	 * This value is the PI index (lower 8bits) within 4K DPI
	 * associated with push write. It is the doorbell page that
	 * contains the WCB that will be used.
	 */
	#define DB_PUSH_START_DB_PI_LO_MASK	UINT32_C(0xff000000)
	#define DB_PUSH_START_DB_PI_LO_SFT	24
	/*
	 * This value identifies the resource that the doorbell is
	 * intended to notify.
	 *
	 * This is the QPID.
	 */
	#define DB_PUSH_START_DB_XID_MASK	UINT32_C(0xfffff00000000)L
	#define DB_PUSH_START_DB_XID_SFT	32
	/*
	 * This value is the PI index (upper 4bits) within 4K DPI
	 * associated with push write. It is the doorbell page that
	 * contains the WCB that will be used.
	 */
	#define DB_PUSH_START_DB_PI_HI_MASK	UINT32_C(0xf0000000000000)L
	#define DB_PUSH_START_DB_PI_HI_SFT	52
	/* This value identifies the type of doorbell being written. */
	#define DB_PUSH_START_DB_TYPE_MASK	UINT32_C(0xf000000000000000)L
	#define DB_PUSH_START_DB_TYPE_SFT	60
	/*
	 * This is a SQ producer index update for Push. It indicates
	 * one or more new entries have been written to the SQ for
	 * the QPID indicated on the `xid` field.
	 */
		#define DB_PUSH_START_DB_TYPE_PUSH_START  (UINT32_C(0xc)L << 60)
	/*
	 * This is a SQ producer index update for Push. It indicates
	 * one or more new entries have been written to the SQ for
	 * the QPID indicated on the `xid` field.
	 */
		#define DB_PUSH_START_DB_TYPE_PUSH_END	(UINT32_C(0xd)L << 60)
		#define DB_PUSH_START_DB_TYPE_LAST	DB_PUSH_START_DB_TYPE_PUSH_END
} db_push_start_t, *pdb_push_start_t;

/*
 * This is the 64b Push End doorbell format. The host writes this message
 * format directly to offset of each push associated WCB (write combine
 * buffer) within doorbell page. WCB#0 = offset 16, WCB#1 = offset 24,
 * WCB#2 = offset 32, ... The start doorbell is followed by write
 * combining data to the WCB and then that is followed by a end doorbell.
 */
/* db_push_end (size:64b/8B) */

typedef struct db_push_end {
	uint64_t	db;
	/*
	 * This is the producer index and should be the queue index of
	 * the last WQE written plus the length field contained in that
	 * WQE. For example, if the length is 8 index units and the WQE
	 * was written to the first location in the queue (zero), this
	 * index should be written to 8. The index should point to the
	 * start of the first location that has not been filled in with
	 * WQE data.
	 *
	 * For L2 and Engine SQ, the index unit is 16B. For RoCE there
	 * are two modes. For Legacy fixed size RQE mode, the unit is
	 * 128B. For variable size RQE mode, the unit is 16B.
	 *
	 * The index size is 24b for L2 and engine paths and 16b for the
	 * RoCE path. Unused bits should be written as zero.
	 *
	 * > In past revisions of this chip, this field was the push
	 * > index rather than the producer index. For this version of
	 * > the chip and future versions of the chip, this field must be
	 * > the producer index, as described above.
	 * >
	 * > Also, in past revisions of this chip, an additional
	 * > doorbell write was needed to communicate the producer index.
	 * > In this and future versions of the chip, this extra doorbell
	 * > write is no longer needed.
	 */
	#define DB_PUSH_END_DB_INDEX_MASK	UINT32_C(0xffffff)
	#define DB_PUSH_END_DB_INDEX_SFT	0
	/*
	 * This value is the PI index (lower 8bits) within 4K DPI
	 * associated with push write. It is the doorbell page that
	 * contains the WCB that will be used.
	 */
	#define DB_PUSH_END_DB_PI_LO_MASK	UINT32_C(0xff000000)
	#define DB_PUSH_END_DB_PI_LO_SFT	24
	/*
	 * This value identifies the resource that the doorbell is
	 * intended to notify.
	 *
	 * This is the QPID.
	 */
	#define DB_PUSH_END_DB_XID_MASK	UINT32_C(0xfffff00000000)L
	#define DB_PUSH_END_DB_XID_SFT	32
	/*
	 * This value is the PI index (upper 4bits) within 4K DPI
	 * associated with push write. It is the doorbell page that
	 * contains the WCB that will be used.
	 */
	#define DB_PUSH_END_DB_PI_HI_MASK	UINT32_C(0xf0000000000000)L
	#define DB_PUSH_END_DB_PI_HI_SFT	52
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DB_PUSH_END_DB_PATH_MASK	UINT32_C(0x300000000000000)L
	#define DB_PUSH_END_DB_PATH_SFT	56
	/* This is a RoCE doorbell message. */
		#define DB_PUSH_END_DB_PATH_ROCE	(UINT32_C(0x0)L << 56)
	/* This is a L2 doorbell message. */
		#define DB_PUSH_END_DB_PATH_L2	(UINT32_C(0x1)L << 56)
	/* Engine path doorbell. */
		#define DB_PUSH_END_DB_PATH_ENGINE	(UINT32_C(0x2)L << 56)
		#define DB_PUSH_END_DB_PATH_LAST	DB_PUSH_END_DB_PATH_ENGINE
	/*
	 * When this bit is set to one, the chip will capture debug
	 * information for the doorbell ring. This is intended to only be
	 * used on SQ doorbell rings.
	 */
	#define DB_PUSH_END_DB_DEBUG_TRACE	UINT32_C(0x800000000000000)L
	/* This value identifies the type of doorbell being written. */
	#define DB_PUSH_END_DB_TYPE_MASK	UINT32_C(0xf000000000000000)L
	#define DB_PUSH_END_DB_TYPE_SFT	60
	/*
	 * This is a SQ producer index update for Push. It indicates
	 * one or more new entries have been written to the SQ for
	 * the QPID indicated on the `xid` field.
	 */
		#define DB_PUSH_END_DB_TYPE_PUSH_START   (UINT32_C(0xc)L << 60)
	/*
	 * This is a SQ producer index update for Push. It indicates
	 * one or more new entries have been written to the SQ for
	 * the QPID indicated on the `xid` field.
	 */
		#define DB_PUSH_END_DB_TYPE_PUSH_END	(UINT32_C(0xd)L << 60)
		#define DB_PUSH_END_DB_TYPE_LAST	DB_PUSH_END_DB_TYPE_PUSH_END
} db_push_end_t, *pdb_push_end_t;

/*
 * This is the Push information that is the second 8B of the Push
 * Doorbell.
 */
/* db_push_info (size:64b/8B) */

typedef struct db_push_info {
	uint32_t	push_size_push_index;
	/*
	 * This value is the index for the push being started. For
	 * example, if the push_size is 8 index units and the WQE was
	 * written to the first location in the queue (zero), this
	 * push_index should be written to 0. The push_index should point
	 * to the start of the first location that the push is started.
	 *
	 * The push_index unit is 16B, except in RoCE legacy WQE mode, in
	 * which case the unit is 128B.
	 *
	 * The push_index size is 24b for L2 and 16b for the RoCE path.
	 * Unused bits should be written as zero.
	 */
	#define DB_PUSH_INFO_PUSH_INDEX_MASK UINT32_C(0xffffff)
	#define DB_PUSH_INFO_PUSH_INDEX_SFT 0
	/*
	 * This value defines the size of push. The unit is 8B. The value
	 * 0 means 256B size of push. The push write is done in 8B units
	 * by the SW.
	 *
	 * Note: For packet rate performance reasons, it is recommended
	 * that SW aligns push requests with a granularity of 16B.
	 */
	#define DB_PUSH_INFO_PUSH_SIZE_MASK UINT32_C(0x1f000000)
	#define DB_PUSH_INFO_PUSH_SIZE_SFT  24
	uint32_t	reserved32;
} db_push_info_t, *pdb_push_info_t;

/*
 * This is the "Absolute" 32b Doorbell format. The host writes this
 * message format directly to byte offset 0xC of the appropriate
 * doorbell page.
 *
 * Absolute doorbells are supported for only a limited number of
 * functions and for a limited number of xID values within each
 * function.
 *
 * Doorbell recovery can be supported for absolute 32b doorbells.
 */
/* dbc_absolute_db_32 (size:32b/4B) */

typedef struct dbc_absolute_db_32 {
	uint32_t	index;
	/*
	 * This value is the index being written. For SQ, RQ, SRQ, this is
	 * the producer index and should be the queue index of the last WQE
	 * or BD written plus the length field contained in that WQE/BD.
	 * For example, if the length is 8 index units and the WQE was
	 * written to the first location in the queue (zero), this index
	 * should be written to 8. The index should point to the start of
	 * the first location that has not been filled in with WQE/BD data.
	 *
	 * For CQ, this is the consumer index and should be the starting
	 * queue index of the last CQE processed plus the size of the last
	 * processed CQE in index units. The index should point to the start
	 * of the first CQE in the queue that has not been processed.
	 *
	 * For NQ, this is the consumer index and should be the starting
	 * queue index of the last NQE processed plus the size of the last
	 * processed NQE in index units. The index should point to the start
	 * of the first NQE in the queue that has not been processed.
	 *
	 * For L2 and Engine SQ, the index unit is 16B. For RoCE there are
	 * two modes. For Legacy fixed size RQE mode, the unit is 128B. For
	 * variable size RQE mode, the unit is 16B. For RoCE and engine CQs,
	 * the index unit is 32B. For L2 CQs, the index unit is 16B.
	 *
	 * For NQ this is the consumer index and the unit is always 16B of
	 * queue space.
	 *
	 * The index size is 16b for all queue types. This limits the size
	 * of some queues when absolute doorbells are in use. Unused bits
	 * should be written as zero.
	 */
	#define DBC_ABSOLUTE_DB_32_INDEX_MASK	UINT32_C(0xffff)
	#define DBC_ABSOLUTE_DB_32_INDEX_SFT	0
	/*
	 * The epoch bit provides a frame of reference for the queue index.
	 * S/W will toggle this bit in the doorbell each time index range is
	 * wrapped. This allows the receiving HW block to more efficiently
	 * detect out-of-order doorbells and to ignore the older doorbells.
	 * Out-of-order doorbells occur normally during dropped doorbell
	 * recovery.
	 */
	#define DBC_ABSOLUTE_DB_32_EPOCH	UINT32_C(0x10000)
	/*
	 * The toggle value is used in CQ_ARMENA, CQ_ARMSE, CQ_ARMALL,
	 * SRQ_ARMENA, SRQ_ARM, and CQ_CUTOFF_ACK doorbells to qualify the
	 * doorbell as valid. This value should be taken from the latest NQE
	 * or cutoff completion.
	 *
	 * Doorbells of the above types with the wrong toggle value will be
	 * ignored. This is how old values in of backup doorbells are
	 * ignored.
	 */
	#define DBC_ABSOLUTE_DB_32_TOGGLE_MASK	UINT32_C(0x60000)
	#define DBC_ABSOLUTE_DB_32_TOGGLE_SFT	17
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * This is a "modified" xID value. The DBR block will convert this
	 * value into the full xID value by looking up the base xID for this
	 * particular function and adding the mxID value to that base value.
	 */
	#define DBC_ABSOLUTE_DB_32_MXID_MASK	UINT32_C(0x1f80000)
	#define DBC_ABSOLUTE_DB_32_MXID_SFT	19
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_ABSOLUTE_DB_32_PATH_MASK	UINT32_C(0x6000000)
	#define DBC_ABSOLUTE_DB_32_PATH_SFT	25
	/* This is a RoCE doorbell message. */
		#define DBC_ABSOLUTE_DB_32_PATH_ROCE	(UINT32_C(0x0) << 25)
	/* This is a L2 doorbell message. */
		#define DBC_ABSOLUTE_DB_32_PATH_L2	(UINT32_C(0x1) << 25)
		#define DBC_ABSOLUTE_DB_32_PATH_LAST	DBC_ABSOLUTE_DB_32_PATH_L2
	/*
	 * This indicates it is valid doorbell update. It should be set for
	 * each doorbell written to the chip and set when doorbell message is
	 * written to the backup doorbell location. The bit should be cleared
	 * in the backup doorbell location at time zero to indicate that the
	 * backup doorbell has not yet been written.
	 */
	#define DBC_ABSOLUTE_DB_32_VALID	UINT32_C(0x8000000)
	/* This value identifies the type of doorbell being written. */
	#define DBC_ABSOLUTE_DB_32_TYPE_MASK	UINT32_C(0xf0000000)
	#define DBC_ABSOLUTE_DB_32_TYPE_SFT	28
	/*
	 * This is a SQ producer index update. It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_SQ	(UINT32_C(0x0) << 28)
	/*
	 * This is a RQ producer index update. It indicates one or more
	 * new entries have been written to the RQ for the QPID indicated
	 * on the xID field. This type is valid for RoCE path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_RQ	(UINT32_C(0x1) << 28)
	/*
	 * This is a SRQ producer index update. It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_SRQ	(UINT32_C(0x2) << 28)
	/*
	 * This doorbell command arms the SRQ async event.
	 * The xID field must identify the SID that is begin armed.
	 * The index field is will set the arm threshold such that
	 * a notification will be generated if less than that number
	 * or SRQ entries are posted. This type is valid for RoCE path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_SRQ_ARM	(UINT32_C(0x3) << 28)
	/*
	 * This is a CQ consumer index update. It indicates one or more
	 * entries have been processed off the CQ indicated on the xID
	 * field.This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_CQ	(UINT32_C(0x4) << 28)
	/*
	 * this is a CQ consumer index update that also arms the CQ for
	 * solicited events. This type is valid for RoCE path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_CQ_ARMSE	(UINT32_C(0x5) << 28)
	/*
	 * This is a CQ consumer index update that also arms the CQ
	 * for any new CQE. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_CQ_ARMALL   (UINT32_C(0x6) << 28)
	/*
	 * This is a CQ arm enable message. This message must be sent from
	 * the privileged driver before a new CQ_ARMSE or CQ_ARMALL message
	 * will be accepted from user space (non-privileged doorbell page).
	 * The index and epoch for this doorbell type are unused.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_CQ_ARMENA   (UINT32_C(0x7) << 28)
	/*
	 * This doorbell command enables the SRQ async event to be armed.
	 * This message must be sent from the privileged driver before a
	 * new SRQ_ARM message will be accepted from user space.
	 * The xID field must identify the SID that is being enabled for
	 * arm. The index and epoch for this doorbell type are unused.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_SRQ_ARMENA  (UINT32_C(0x8) << 28)
	/*
	 * This is a NQ consumer index update. It indicates one or more
	 * entries have been processed off the NQ indicated on the xID
	 * field. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_NQ	(UINT32_C(0xa) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_NQ_ARM	(UINT32_C(0xb) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. It is used for the legacy INT mask. This type
	 * is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_NQ_MASK	(UINT32_C(0xe) << 28)
	/*
	 * This doorbell command is used during doorbell moderation
	 * to consume system BW and help prevent doorbell FIFO
	 * overflow.
	 *
	 * All other fields should be zero for NULL doorbell.
	 * For doorbell recovery, NULL doorbell type in the Application
	 * table indicates that it is the last QP entry for the function.
	 * This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_NULL	(UINT32_C(0xf) << 28)
		#define DBC_ABSOLUTE_DB_32_TYPE_LAST	DBC_ABSOLUTE_DB_32_TYPE_NULL
} dbc_absolute_db_32_t, *pdbc_absolute_db_32_t;

/*
 * This is the "Relative" 32b Doorbell format. The host writes this
 * message format directly to byte offset 8 of the appropriate doorbell
 * page.
 *
 * Doorbell recovery can not be supported for relative doorbells. So
 * relative doorbells are only safe to use when SOC is supporting the
 * context backing store in local DDR. If that is the case, it is safe
 * to turn off doorbell drops and use this type of doorbell.
 */
/* dbc_relative_db_32 (size:32b/4B) */

typedef struct dbc_relative_db_32 {
	uint32_t	xid;
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ, this is the QPID value.
	 */
	#define DBC_RELATIVE_DB_32_XID_MASK	UINT32_C(0xfffff)
	#define DBC_RELATIVE_DB_32_XID_SFT	0
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_RELATIVE_DB_32_PATH_MASK	UINT32_C(0xc00000)
	#define DBC_RELATIVE_DB_32_PATH_SFT	22
	/* This is a RoCE doorbell message. */
		#define DBC_RELATIVE_DB_32_PATH_ROCE	(UINT32_C(0x0) << 22)
	/* This is a L2 doorbell message. */
		#define DBC_RELATIVE_DB_32_PATH_L2	(UINT32_C(0x1) << 22)
		#define DBC_RELATIVE_DB_32_PATH_LAST	DBC_RELATIVE_DB_32_PATH_L2
	/*
	 * This value is the value to add to the appropriate index value.
	 *
	 * The increment unit is 16B for L2 path. For RoCE there is a
	 * legacy mode with 128B unit size and a variable size mode with
	 * 32B unit size. For Engine mode, the unit size is always 128B.
	 */
	#define DBC_RELATIVE_DB_32_INCR_MASK	UINT32_C(0x1f000000)
	#define DBC_RELATIVE_DB_32_INCR_SFT	24
	/* This value identifies the type of doorbell being written. */
	#define DBC_RELATIVE_DB_32_TYPE_MASK	UINT32_C(0xe0000000)
	#define DBC_RELATIVE_DB_32_TYPE_SFT	29
	/*
	 * This is a SQ producer index update. It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_SQ	(UINT32_C(0x0) << 29)
	/*
	 * This is a SRQ producer index update. It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_SRQ	(UINT32_C(0x1) << 29)
	/*
	 * This is a CQ consumer index update. It indicates one or more
	 * entries have been processed off the CQ indicated on the xID
	 * field.This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_CQ	(UINT32_C(0x2) << 29)
	/*
	 * This is a CQ consumer index update that also arms the CQ
	 * for any new CQE. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_CQ_ARMALL  (UINT32_C(0x3) << 29)
	/*
	 * This is a NQ consumer index update. It indicates one or more
	 * entries have been processed off the NQ indicated on the xID
	 * field. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_NQ	(UINT32_C(0x4) << 29)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_NQ_ARM	(UINT32_C(0x5) << 29)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. It is used for the legacy INT mask. This type
	 * is valid for L2, RoCE and Engine path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_NQ_MASK	(UINT32_C(0x6) << 29)
		#define DBC_RELATIVE_DB_32_TYPE_LAST	DBC_RELATIVE_DB_32_TYPE_NQ_MASK
} dbc_relative_db_32_t, *pdbc_relative_db_32_t;

/*
 * The kernel memory structure is per-type (SQ, RQ, SRQ/SRQ_ARM and
 * CQ/CQ_ARMSE/CQ_ARMALL). Each kernel driver will support a table for
 * the doorbell recovery.
 */
/* dbc_drk (size:128b/16B) */

typedef struct dbc_drk {
	uint32_t	db_format_linked_last_valid_stride_size;
	/*
	 * This indicates it is valid entry. It should be set for each
	 * doorbell written to the chip. The bit should be cleared at time
	 * zero to indicate that it has not yet been written. The bit i
	 * should be cleared when the function for the table is disabled.
	 */
	#define DBC_DRK_VALID	UINT32_C(0x1)
	/* This indicates it is last entry for the table. */
	#define DBC_DRK_LAST	UINT32_C(0x2)
	/* This indicates it is entry for the next 4KB kernel memory pointer. */
	#define DBC_DRK_LINKED	UINT32_C(0x4)
	/*
	 * This field indicates if the doorbells in the table are 32b
	 * absolute or 64b format.
	 */
	#define DBC_DRK_DB_FORMAT	UINT32_C(0x8)
	/* The doorbells are 64b format. */
		#define DBC_DRK_DB_FORMAT_B64   (UINT32_C(0x0) << 3)
	/*
	 * The doorbells are in the absolute 32b format. The doorbell
	 * is in the right-most half of the 64b space provided in the
	 * application table entry.
	 */
		#define DBC_DRK_DB_FORMAT_B32A  (UINT32_C(0x1) << 3)
		#define DBC_DRK_DB_FORMAT_LAST DBC_DRK_DB_FORMAT_B32A
	/*
	 * This field controls the stride feature. The stride feature is
	 * more bandwidth efficient on the PCIE bus when only a small number
	 * of doorbells are used in each cache line.
	 */
	#define DBC_DRK_STRIDE_MASK   UINT32_C(0x300)
	#define DBC_DRK_STRIDE_SFT	8
	/*
	 * When stride is off, the DBR will read all the bytes in
	 * an application page until a NULL doorbell is found or
	 * the end of the 4K page is reached.
	 */
		#define DBC_DRK_STRIDE_OFF	(UINT32_C(0x0) << 8)
	/*
	 * When stride is 1, the DBR will read the 'size' doorbells,
	 * starting at the next 64B cache line boundary or until
	 * a NULL doorbell is found in the application page or
	 * the end of the 4K page is reached.
	 */
		#define DBC_DRK_STRIDE_SZ64	(UINT32_C(0x1) << 8)
	/*
	 * When stride is 2, the DBR will read the 'size' doorbells,
	 * starting at the next 128B cache line boundary or until
	 * a NULL doorbell is found in the application page or
	 * the end of the 4K page is reached.
	 */
		#define DBC_DRK_STRIDE_SZ128	(UINT32_C(0x2) << 8)
		#define DBC_DRK_STRIDE_LAST	DBC_DRK_STRIDE_SZ128
	/*
	 * This value controls how many doorbells are read at each stride
	 * when stride mode is in use.
	 */
	#define DBC_DRK_SIZE_MASK	UINT32_C(0xc00)
	#define DBC_DRK_SIZE_SFT	10
	/* 4*8B is read at the start of each stride. */
		#define DBC_DRK_SIZE_FOUR	(UINT32_C(0x0) << 10)
	/* 1*8B is read at the start of each stride. */
		#define DBC_DRK_SIZE_ONE	(UINT32_C(0x1) << 10)
	/* 2*8B is read at the start of each stride. */
		#define DBC_DRK_SIZE_TWO	(UINT32_C(0x2) << 10)
	/* 3*8B is read at the start of each stride. */
		#define DBC_DRK_SIZE_THREE	(UINT32_C(0x3) << 10)
		#define DBC_DRK_SIZE_LAST	DBC_DRK_SIZE_THREE
	uint32_t	pi;
	/*
	 * Page Index portion of DPI{VF_VALID,VFID,PI}. The pi needs to match
	 * the value from the context DPI for the operation to be valid or
	 * the pi must be zero, indicating a write from the privileged
	 * driver.
	 *
	 * pi in the kernel memory table is there for DBR to generate the DPI
	 * message to the client.
	 */
	#define DBC_DRK_PI_MASK UINT32_C(0xffff)
	#define DBC_DRK_PI_SFT 0
	/*
	 * It is the application memory page(4KB) pointer when linked = 0.
	 * It is the next kernel memory page(4KB) pointer when linked = 1.
	 * The pointer doesn't have to be aligned to the page(4KB) but it
	 * should be aligned to 128B boundary. This means that the bottom
	 * 7b of the pointer must be zero.
	 */
	uint64_t	memptr;
} dbc_drk_t, *pdbc_drk_t;

/*
 * The kernel memory structure is per-type (SQ, RQ, SRQ/SRQ_ARM and
 * CQ/CQ_ARMSE/CQ_ARMALL). Each kernel driver will support a table for
 * the doorbell recovery.
 */
/* dbc_drk64 (size:128b/16B) */

typedef struct dbc_drk64 {
	uint64_t	flags;
	/*
	 * This indicates it is valid entry. It should be set for each
	 * doorbell written to the chip. The bit should be cleared at time
	 * zero to indicate that it has not yet been written. The bit i
	 * should be cleared when the function for the table is disabled.
	 */
	#define DBC_DRK64_VALID	UINT32_C(0x1)
	/* This indicates it is last entry for the table. */
	#define DBC_DRK64_LAST	UINT32_C(0x2)
	/* This indicates it is entry for the next 4KB kernel memory pointer. */
	#define DBC_DRK64_LINKED	UINT32_C(0x4)
	/*
	 * This field indicates if the doorbells in the table are 32b
	 * absolute or 64b format.
	 */
	#define DBC_DRK64_DB_FORMAT	UINT32_C(0x8)
	/* The doorbells are 64b format. */
		#define DBC_DRK64_DB_FORMAT_B64   (UINT32_C(0x0) << 3)
	/*
	 * The doorbells are in the absolute 32b format. The doorbell
	 * is in the right-most half of the 64b space provided in the
	 * application table entry.
	 */
		#define DBC_DRK64_DB_FORMAT_B32A  (UINT32_C(0x1) << 3)
		#define DBC_DRK64_DB_FORMAT_LAST DBC_DRK64_DB_FORMAT_B32A
	/*
	 * This field controls the stride feature. The stride feature is
	 * more bandwidth efficient on the PCIE bus when only a small number
	 * of doorbells are used in each cache line.
	 */
	#define DBC_DRK64_STRIDE_MASK   UINT32_C(0x300)
	#define DBC_DRK64_STRIDE_SFT	8
	/*
	 * When stride is off, the DBR will read all the bytes in
	 * an application page until a NULL doorbell is found or
	 * the end of the 4K page is reached.
	 */
		#define DBC_DRK64_STRIDE_OFF	(UINT32_C(0x0) << 8)
	/*
	 * When stride is 1, the DBR will read the 'size' doorbells,
	 * starting at the next 64B cache line boundary or until
	 * a NULL doorbell is found in the application page or
	 * the end of the 4K page is reached.
	 */
		#define DBC_DRK64_STRIDE_SZ64	(UINT32_C(0x1) << 8)
	/*
	 * When stride is 2, the DBR will read the 'size' doorbells,
	 * starting at the next 128B cache line boundary or until
	 * a NULL doorbell is found in the application page or
	 * the end of the 4K page is reached.
	 */
		#define DBC_DRK64_STRIDE_SZ128	(UINT32_C(0x2) << 8)
		#define DBC_DRK64_STRIDE_LAST	DBC_DRK64_STRIDE_SZ128
	/*
	 * This value controls how many doorbells are read at each stride
	 * when stride mode is in use.
	 */
	#define DBC_DRK64_SIZE_MASK	UINT32_C(0xc00)
	#define DBC_DRK64_SIZE_SFT	10
	/* 4*8B is read at the start of each stride. */
		#define DBC_DRK64_SIZE_FOUR	(UINT32_C(0x0) << 10)
	/* 1*8B is read at the start of each stride. */
		#define DBC_DRK64_SIZE_ONE	(UINT32_C(0x1) << 10)
	/* 2*8B is read at the start of each stride. */
		#define DBC_DRK64_SIZE_TWO	(UINT32_C(0x2) << 10)
	/* 3*8B is read at the start of each stride. */
		#define DBC_DRK64_SIZE_THREE	(UINT32_C(0x3) << 10)
		#define DBC_DRK64_SIZE_LAST	DBC_DRK64_SIZE_THREE
	/*
	 * Page Index portion of DPI{VF_VALID,VFID,PI}. The pi needs to match
	 * the value from the context DPI for the operation to be valid or
	 * the pi must be zero, indicating a write from the privileged
	 * driver.
	 *
	 * pi in the kernel memory table is there for DBR to generate the DPI
	 * message to the client.
	 */
	#define DBC_DRK64_PI_MASK	UINT32_C(0xffff00000000)L
	#define DBC_DRK64_PI_SFT	32
	/*
	 * It is the application memory page(4KB) pointer when linked = 0.
	 * It is the next kernel memory page(4KB) pointer when linked = 1.
	 * The pointer doesn't have to be aligned to the page(4KB) but it
	 * should be aligned to 128B boundary. This means that the bottom
	 * 7b of the pointer must be zero.
	 */
	uint64_t	memptr;
} dbc_drk64_t, *pdbc_drk64_t;

/*
 * This is the 64b doorbell format. The host writes this message
 * format directly to byte offset 0 of the appropriate doorbell page.
 */
/* dbc_dbc_v3 (size:64b/8B) */

typedef struct dbc_dbc_v3 {
	uint32_t	index;
	/*
	 * This value is the index being written.
	 *
	 * For SQ/RQ/SRQ, this is the producer index. It should be set to
	 * the queue index of the last WQE/BD written plus the number of
	 * index units in the WQE/BD. For example, if the number of index
	 * units in an SQ WQE is 8 and the WQE was written to the first
	 * location in the queue (zero), this index should be written to 8.
	 * The index should point to the start of the first location that
	 * has not been filled in with WQE/BD data. For SQ (both RoCE and
	 * L2), the index unit is 16B. For RQ/SRQ, the index unit is 1 WQE
	 * (RoCE) or 1 BD (L2).
	 *
	 * For CQ, this is the consumer index and should be the starting
	 * queue index of the last CQE processed plus the size of the last
	 * processed CQE in index units. The index should point to the
	 * start of the first CQE in the queue that has not been processed.
	 * The index unit is 16B.
	 *
	 * For NQ, this is the consumer index and should be the starting
	 * queue index of the last NQE processed plus the size of the last
	 * processed NQE in index units. The index should point to the
	 * start of the first NQE in the queue that has not been processed.
	 * The index unit is 16B.
	 */
	#define DBC_DBC_V3_INDEX_MASK UINT32_C(0xffffff)
	#define DBC_DBC_V3_INDEX_SFT  0
	/*
	 * The epoch bit provides a frame of reference for the queue index.
	 * S/W will toggle this bit in the doorbell each time index range is
	 * wrapped. This allows the receiving HW block to more efficiently
	 * detect out-of-order doorbells and to ignore the older doorbells.
	 * Out-of-order doorbells occur normally during dropped doorbell
	 * recovery.
	 */
	#define DBC_DBC_V3_EPOCH	UINT32_C(0x1000000)
	/*
	 * The toggle value is used in CQ_ARMENA, CQ_ARMSE, CQ_ARMALL,
	 * SRQ_ARMENA, SRQ_ARM, and CQ_CUTOFF_ACK doorbells to qualify the
	 * doorbell as valid. This value should be taken from the latest
	 * NQE or cutoff completion.
	 *
	 * Doorbells of the above types with the wrong toggle value will
	 * be ignored. This is how old values in of backup doorbells
	 * are ignored.
	 */
	#define DBC_DBC_V3_TOGGLE_MASK UINT32_C(0x6000000)
	#define DBC_DBC_V3_TOGGLE_SFT 25
	uint32_t	type_path_xid;
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ and RQ, this is the QPID. For SRQ, this is the SID. For
	 * CQ, this is the CID. For NQ, this is the NID.
	 *
	 * Unused bits (for example bits [11:7] of the SID value) must be
	 * zero.
	 */
	#define DBC_DBC_V3_XID_MASK	UINT32_C(0xfff)
	#define DBC_DBC_V3_XID_SFT	0
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_DBC_V3_PATH_MASK	UINT32_C(0x3000000)
	#define DBC_DBC_V3_PATH_SFT	24
	/* This is a RoCE doorbell message. */
		#define DBC_DBC_V3_PATH_ROCE	(UINT32_C(0x0) << 24)
	/* This is a L2 doorbell message. */
		#define DBC_DBC_V3_PATH_L2		(UINT32_C(0x1) << 24)
		#define DBC_DBC_V3_PATH_LAST	DBC_DBC_V3_PATH_L2
	/*
	 * This indicates it is valid doorbell update. It should be set for
	 * each doorbell written to the chip and set when doorbell message is
	 * written to the backup doorbell location. The bit should be cleared
	 * in the backup doorbell location at time zero to indicate that the
	 * backup doorbell has not yet been written.
	 */
	#define DBC_DBC_V3_VALID		UINT32_C(0x4000000)
	/*
	 * When this bit is set to one, the chip will capture debug
	 * information for the doorbell ring. This is intended to only be
	 * used on SQ doorbell rings.
	 */
	#define DBC_DBC_V3_DEBUG_TRACE	UINT32_C(0x8000000)
	/* This value identifies the type of doorbell being written. */
	#define DBC_DBC_V3_TYPE_MASK	UINT32_C(0xf0000000)
	#define DBC_DBC_V3_TYPE_SFT	28
	/*
	 * This is a SQ producer index update. It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_SQ		(UINT32_C(0x0) << 28)
	/*
	 * This is a RQ producer index update. It indicates one or more
	 * new entries have been written to the RQ for the QPID indicated
	 * on the xID field. This type is valid for RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_RQ		(UINT32_C(0x1) << 28)
	/*
	 * This is a SRQ producer index update. It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_SRQ		(UINT32_C(0x2) << 28)
	/*
	 * This doorbell command arms the SRQ async event. The xID field
	 * must identify the SID that is begin armed. The index field is
	 * will set the arm threshold such that a notification will be
	 * generated if less than that number or SRQ entries are posted.
	 *
	 * This type is valid for RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_SRQ_ARM	(UINT32_C(0x3) << 28)
	/*
	 * CQ doorbell is used to update the consumer index for the CQ
	 * for overflow detection. It should only be sent if overflow
	 * detection is enabled for the CQ. Keep in mind that if
	 * doorbells are being dropped due to PCIE ordering rules, you
	 * may get a false overflow detection if you are checking for CQ
	 * overflow.
	 *
	 * This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_CQ		(UINT32_C(0x4) << 28)
	/*
	 * This is a CQ consumer index update that also arms the CQ for
	 * solicited events. This is for roce only not for l2.
	 *
	 * The index is used as the location of the last CQE that was
	 * processed by the driver. The new interrupt will be generated
	 * based on this location.
	 *
	 * This type is valid for RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_CQ_ARMSE	(UINT32_C(0x5) << 28)
	/*
	 * This is a CQ consumer index update that also arms the CQ for
	 * any new CQE.
	 *
	 * The index is used as the location of the last CQE that was
	 * processed by the driver. The new interrupt will be generated
	 * based on this location.
	 *
	 * This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_CQ_ARMALL	(UINT32_C(0x6) << 28)
	/*
	 * This is a CQ arm enable message. This message must be sent
	 * from the privileged driver before a new CQ_ARMSE or CQ_ARMALL
	 * message will be accepted from user space (non-privileged
	 * doorbell page). The index and epoch for this doorbell type are
	 * unused.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_DBC_V3_TYPE_CQ_ARMENA	(UINT32_C(0x7) << 28)
	/*
	 * This doorbell command enables the SRQ async event to be armed.
	 * This message must be sent from the privileged driver before
	 * a new SRQ_ARM message will be accepted from user space. The
	 * xID field must identify the SID that is being enabled for arm.
	 * The index and epoch for this doorbell type are unused.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_DBC_V3_TYPE_SRQ_ARMENA	(UINT32_C(0x8) << 28)
	/*
	 * This doorbell type is used to acknowledge a cutoff completion
	 * in the CQ. The index and epoch for this doorbell type are
	 * unused. This doorbell is sent when the cutoff completion has
	 * been processed and the old CQ in a CQ resize operation is no
	 * longer needed.
	 *
	 * The index and epoch must be valid for this doorbell if
	 * overflow checking is enabled for the CQ.
	 */
		#define DBC_DBC_V3_TYPE_CQ_CUTOFF_ACK  (UINT32_C(0x9) << 28)
	/*
	 * This is a NQ consumer index update. It indicates one or more
	 * entries have been processed off the NQ indicated on the xID
	 * field. It will also mask the NQ for any new NQE. This type is
	 * valid for L2 and RoCE path.
	 *
	 * Thor is broken in that it doesn't mask a legacy INTA interrupt
	 * when used at the start of an ISR, as it is supposed to be.
	 *
	 * type=NQ masks the current interrupt. When the iSR starts, it
	 * writes a type=NQ with the current consumer index. For legacy
	 * PCI interrupts, this needs to mask the interrupt so the legacy
	 * interrupt is deasserted. Then the driver does some work and
	 * writes some more type=NQ. Finally the driver stops the ISR and
	 * does a type=NQ_ARM to get another interrupt (when needed). The
	 * only reason to use type=NQ_MASK is to back out of the armed
	 * state. In that request, the index update is not required.
	 */
		#define DBC_DBC_V3_TYPE_NQ		(UINT32_C(0xa) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE.
	 *
	 * This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_NQ_ARM	(UINT32_C(0xb) << 28)
	/*
	 * This doorbell will assign a new NQ to a CQ. This is handy if
	 * the user wants to change which interrupt handler is going to
	 * process a particular CQ. This doorbell must be sent from the
	 * privileged driver.
	 *
	 * The xID must be the CID for the CQ that needs to be changed.
	 * The index value is the NQID of the new NQ that will be used
	 * for future notifications. epoch and toggle are ignored for
	 * this doorbell type.
	 *
	 * The CQ will disarm notifications and generate a NQE to the old
	 * NQ with the nq_reassign type value. The chip will guarantee
	 * that no notification will be sent to the old NQ after the
	 * nq_reassign NQE has been sent.
	 *
	 * This type is valid for L2 and RoCE CQs.
	 */
		#define DBC_DBC_V3_TYPE_CQ_REASSIGN	(UINT32_C(0xc) << 28)
	/*
	 * This masks the NQ for any new NQE. This will NOT update the NQ
	 * consumer index.
	 *
	 * This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_NQ_MASK	(UINT32_C(0xe) << 28)
	/*
	 * All other fields should be zero for NULL doorbell.
	 *
	 * For doorbell recovery, NULL doorbell type in the Application
	 * table indicates that it is the last QP entry for the function.
	 * This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_V3_TYPE_NULL	(UINT32_C(0xf) << 28)
		#define DBC_DBC_V3_TYPE_LAST	DBC_DBC_V3_TYPE_NULL
} dbc_dbc_v3_t, *pdbc_dbc_v3_t;

/*
 * This is the RoCE Express Doorbell format. The host writes this
 * message format directly to offset 0x40 of the appropriate doorbell
 * page. Express doorbells are used when the chip will be owning the
 * SQ, RQ, and SRQ as well as the producer indexes for each queue. This
 * provides a simple fastpath programming model.
 *
 * Express doorbell must be received by the chip as a single TLP
 * message.
 */
/* dbc_xp (size:512b/64B) */

typedef struct dbc_xp {
	uint32_t	reserved;
	uint32_t	type_xid;
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ and RQ, this is the QPID. For SRQ, this is the SID. For
	 * CQ, this is the CID. For NQ, this is the NID.
	 *
	 * Unused bits (for example bits [11:7] of the SID value) must be
	 * zero.
	 */
	#define DBC_XP_XID_MASK	UINT32_C(0xfff)
	#define DBC_XP_XID_SFT	0
	/*
	 * When this bit is set to one, the chip will capture debug
	 * information for the doorbell ring. This is intended to only be
	 * used on SQ doorbell rings.
	 */
	#define DBC_XP_DEBUG_TRACE	UINT32_C(0x1000000)
	/* This value identifies the type of doorbell being written. */
	#define DBC_XP_TYPE_MASK	UINT32_C(0xf0000000)
	#define DBC_XP_TYPE_SFT	28
	/*
	 * This is a SQ producer index update. It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_XP_TYPE_SQ	(UINT32_C(0x0) << 28)
	/*
	 * This is a RQ producer index update. It indicates one or more
	 * new entries have been written to the RQ for the QPID indicated
	 * on the xID field. This type is valid for RoCE path.
	 */
		#define DBC_XP_TYPE_RQ	(UINT32_C(0x1) << 28)
	/*
	 * This is a SRQ producer index update. It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_XP_TYPE_SRQ	(UINT32_C(0x2) << 28)
		#define DBC_XP_TYPE_LAST	DBC_XP_TYPE_SRQ
	/*
	 * This field hold one express WQE. The WQE must be appropriate for
	 * the queue selected by the type field.
	 */
	uint32_t	wqe[14];
} dbc_xp_t, *pdbc_xp_t;

/*
 * This is a firmware status register that indicates the software status
 * exposed by the firmware to the host.
 *
 * > This register is not present in previous versions of this chip.
 */
/* fw_status_reg (size:32b/4B) */

typedef struct fw_status_reg {
	uint32_t	fw_status;
	/*
	 * These bits indicate the status as being reported by the firmware.
	 *
	 * The value should be interpreted as follows:
	 * A value below 0x8000 is an indication that the firmware is still
	 * in the process of starting up and is not ready. The host driver
	 * should continue waiting with a timeout for firmware status to be
	 * ready.
	 * >	0x0000 to 0x00FF : SBL state information
	 * >	0x0200 to 0x02FF : SBI state information
	 * >	0x0400 to 0x04FF : SRT state information
	 * >	0x0600 to 0x06FF : CRT/CHIMP state information
	 * >	0x0800 to 0x08FF : External Firmware state information
	 * >	0x0A00 to 0x0FFF : Reserved for future fw functionality
	 *
	 * A value of 0x8000 indicates firmware is ready and healthy. The
	 * host driver can start initiating HWRM commands to the firmware.
	 *
	 * A value over 0x8000 is an indication that the firmware has
	 * detected a fatal error, this error could be in one of the hardware
	 * block or in a software module. The lower 8 bits indicate a
	 * block/module specific error and the upper 8 bits identify the
	 * hardware block or firmware module that was the source of the
	 * error.
	 * >	0x81XX - 0xBFXX  : 63 ASIC blocks
	 * >	0xC0XX to 0xFDXX : 62 Firmware modules
	 * >	0xFE00 to 0xFEFF : External firmware module
	 * >	0xFFXX	: Reserved for future
	 */
	#define FW_STATUS_REG_CODE_MASK		UINT32_C(0xffff)
	#define FW_STATUS_REG_CODE_SFT		0
	/* Indicates firmware is ready. */
		#define FW_STATUS_REG_CODE_READY		UINT32_C(0x8000)
		#define FW_STATUS_REG_CODE_LAST		FW_STATUS_REG_CODE_READY
	/*
	 * Image Degraded bit. If set indicates that one of the firmware
	 * image is degraded.
	 *
	 * The firmware binary located on NVM has redundant copies to protect
	 * against corruption. When one of the primary or secondary copy is
	 * detected as corrupted, this bit will be set by the firmware either
	 * as part of power on from the context of hwrm_fw_health_check.
	 */
	#define FW_STATUS_REG_IMAGE_DEGRADED	UINT32_C(0x10000)
	/*
	 * Recoverable bit. If set indicates that the fatal error is
	 * recoverable with a full reset.
	 *
	 * This bit should be used by host software and deployment models
	 * that support error recovery by resetting the controller. A
	 * recovery should be attempted from a fatal error condition only if
	 * this bit is set. This bit is meaningful only when the code field
	 * is greater than 0x8000 (32768 decimal).
	 */
	#define FW_STATUS_REG_RECOVERABLE		UINT32_C(0x20000)
	/*
	 * Crash dump is in process. If set indicates that the firmware is
	 * currently recording a crash dump.
	 *
	 * This bit provides a hint to the host driver if the firmware is
	 * currently recording a crash dump. Host driers should avoid
	 * resetting the controller when a crash dump is in progress if
	 * possible. This bit is meaningful only when the code field is
	 * greater than 0x8000 (32768 decimal).
	 */
	#define FW_STATUS_REG_CRASHDUMP_ONGOING	UINT32_C(0x40000)
	/*
	 * Crash dump is available. If set indicates that a firmware crash
	 * dump was recorded before and is now available.
	 *
	 * This bit provides indication to the host driver that the firmware
	 * has completed a crash dump. This bit is meaningful only when the
	 * code field is greater than 0x8000 (32768 decimal).
	 */
	#define FW_STATUS_REG_CRASHDUMP_COMPLETE	UINT32_C(0x80000)
	/*
	 * This bit is used to indicate device state when it enters the
	 * shutdown mode and stopped the communication with the host. The
	 * host should initiate the reload of firmware image or initiate the
	 * reset to bring the device to the normal operational state and
	 * re-establish the communication.
	 *
	 * This bit is meaningful only when the code field is greater than
	 * 0x8000 (32768 decimal).
	 */
	#define FW_STATUS_REG_SHUTDOWN		UINT32_C(0x100000)
	/*
	 * This bit will be set to 1 by the FW when FW crashed without master
	 * function.
	 *
	 * This bit is controller specific, not all products will support
	 * this bit. This bit is valid only when the code field is greater
	 * than 0x8000 (32768 decimal).
	 */
	#define FW_STATUS_REG_CRASHED_NO_MASTER	UINT32_C(0x200000)
	/*
	 * The firmware sets this bit to 1 when the firmware has taken an
	 * exception and expects to initiate error recovery.
	 *
	 * This bit is valid only when the code field is greater than 0x8000
	 * (32768 decimal).
	 */
	#define FW_STATUS_REG_RECOVERING		UINT32_C(0x400000)
	/*
	 * The SBL sets this bit to indicate whether manu_debug pin is
	 * detected high or low.
	 */
	#define FW_STATUS_REG_MANU_DEBUG_STATUS	UINT32_C(0x800000)
} fw_status_reg_t, *pfw_status_reg_t;

/*
 * This structure is fixed at the beginning of the ChiMP SRAM (GRC
 * offset: 0x31001F0). Host software is expected to read from this
 * location for a defined signature. If it exists, the software can
 * assume the presence of this structure and the validity of the
 * FW_STATUS location in the next field.
 */
/* hcomm_status (size:64b/8B) */

typedef struct hcomm_status {
	uint32_t	sig_ver;
	/*
	 * This field defines the version of the structure. The latest
	 * version value is 1.
	 */
	#define HCOMM_STATUS_VER_MASK	UINT32_C(0xff)
	#define HCOMM_STATUS_VER_SFT	0
		#define HCOMM_STATUS_VER_LATEST	UINT32_C(0x1)
		#define HCOMM_STATUS_VER_LAST	HCOMM_STATUS_VER_LATEST
	/*
	 * This field is to store the signature value to indicate the
	 * presence of the structure.
	 */
	#define HCOMM_STATUS_SIGNATURE_MASK UINT32_C(0xffffff00)
	#define HCOMM_STATUS_SIGNATURE_SFT 8
		#define HCOMM_STATUS_SIGNATURE_VAL   (UINT32_C(0x484353) << 8)
		#define HCOMM_STATUS_SIGNATURE_LAST HCOMM_STATUS_SIGNATURE_VAL
	uint32_t	fw_status_loc;
	#define HCOMM_STATUS_TRUE_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HCOMM_STATUS_TRUE_ADDR_SPACE_SFT	0
	/* PCIE configuration space */
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/* GRC space */
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_GRC	UINT32_C(0x1)
	/* BAR0 space */
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/* BAR1 space */
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_LAST	HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR1
	/*
	 * This offset where the fw_status register is located. The value
	 * is generally 4-byte aligned.
	 */
	#define HCOMM_STATUS_TRUE_OFFSET_MASK	UINT32_C(0xfffffffc)
	#define HCOMM_STATUS_TRUE_OFFSET_SFT	2
} hcomm_status_t, *phcomm_status_t;

/* This is the GRC offset where the hcomm_status struct resides. */
#define HCOMM_STATUS_STRUCT_LOC 0x31001F0UL

/***********************
 * hwrm_selftest_qlist *
 ***********************/


/* hwrm_selftest_qlist_input (size:128b/16B) */

typedef struct hwrm_selftest_qlist_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_selftest_qlist_input_t, *phwrm_selftest_qlist_input_t;

/* hwrm_selftest_qlist_output (size:2240b/280B) */

typedef struct hwrm_selftest_qlist_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the number of tests available to be
	 * requested by a driver.
	 */
	uint8_t	num_tests;
	/* This field indicates which self-test is available to be run. */
	uint8_t	available_tests;
	/* Can run the NVM test. */
	#define HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_NVM_TEST		UINT32_C(0x1)
	/* Can run the link test. */
	#define HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_LINK_TEST		UINT32_C(0x2)
	/* Can run the register test. */
	#define HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_REGISTER_TEST		UINT32_C(0x4)
	/* Can run the memory test. */
	#define HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_MEMORY_TEST		UINT32_C(0x8)
	/* Can run the PCIe serdes test. (deprecated) */
	#define HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_PCIE_SERDES_TEST	UINT32_C(0x10)
	/* Can run the Ethernet serdes test. (deprecated) */
	#define HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_ETHERNET_SERDES_TEST	UINT32_C(0x20)
	uint8_t	offline_tests;
	/* The NVM test is an offline test. */
	#define HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_NVM_TEST		UINT32_C(0x1)
	/* The link test is an offline test. */
	#define HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_LINK_TEST		UINT32_C(0x2)
	/* The register test is an offline test. */
	#define HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_REGISTER_TEST		UINT32_C(0x4)
	/* The memory test is an offline test. */
	#define HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_MEMORY_TEST		UINT32_C(0x8)
	/* The PCIe serdes test is an offline test. (deprecated) */
	#define HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_PCIE_SERDES_TEST	UINT32_C(0x10)
	/* The Ethernet serdes test is an offline test. (deprecated) */
	#define HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_ETHERNET_SERDES_TEST	UINT32_C(0x20)
	uint8_t	unused_0;
	/*
	 * This field represents the maximum timeout for all the
	 * tests to complete in milliseconds.
	 */
	uint16_t	test_timeout;
	uint8_t	unused_1[2];
	/*
	 * This field represents array of 8 test name strings (ASCII chars
	 * with NULL at the end).
	 */
	char	test_name[8][32];
	/*
	 * The lowest available target BER that is supported by FW eyescope.
	 * A Value of 3 indicates that FW supports 1e-8, 1e-9, 1e-10, and
	 * 1e-11. (deprecated)
	 */
	uint8_t	eyescope_target_BER_support;
	/* Eyescope supports a target BER of 1e-8 */
	#define HWRM_SELFTEST_QLIST_OUTPUT_EYESCOPE_TARGET_BER_SUPPORT_BER_1E8_SUPPORTED  UINT32_C(0x0)
	/* Eyescope supports a target BER of 1e-9 */
	#define HWRM_SELFTEST_QLIST_OUTPUT_EYESCOPE_TARGET_BER_SUPPORT_BER_1E9_SUPPORTED  UINT32_C(0x1)
	/* Eyescope supports a target BER of 1e-10 */
	#define HWRM_SELFTEST_QLIST_OUTPUT_EYESCOPE_TARGET_BER_SUPPORT_BER_1E10_SUPPORTED UINT32_C(0x2)
	/* Eyescope supports a target BER of 1e-11 */
	#define HWRM_SELFTEST_QLIST_OUTPUT_EYESCOPE_TARGET_BER_SUPPORT_BER_1E11_SUPPORTED UINT32_C(0x3)
	/* Eyescope supports a target BER of 1e-12 */
	#define HWRM_SELFTEST_QLIST_OUTPUT_EYESCOPE_TARGET_BER_SUPPORT_BER_1E12_SUPPORTED UINT32_C(0x4)
	#define HWRM_SELFTEST_QLIST_OUTPUT_EYESCOPE_TARGET_BER_SUPPORT_LAST		HWRM_SELFTEST_QLIST_OUTPUT_EYESCOPE_TARGET_BER_SUPPORT_BER_1E12_SUPPORTED
	uint8_t	unused_2[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_selftest_qlist_output_t, *phwrm_selftest_qlist_output_t;

/**********************
 * hwrm_selftest_exec *
 **********************/


/* hwrm_selftest_exec_input (size:192b/24B) */

typedef struct hwrm_selftest_exec_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This field indicates which self-test is being requested to run. */
	uint8_t	flags;
	/* Run the NVM test. */
	#define HWRM_SELFTEST_EXEC_INPUT_FLAGS_NVM_TEST		UINT32_C(0x1)
	/* Run the link test. */
	#define HWRM_SELFTEST_EXEC_INPUT_FLAGS_LINK_TEST		UINT32_C(0x2)
	/* Run the register test. */
	#define HWRM_SELFTEST_EXEC_INPUT_FLAGS_REGISTER_TEST		UINT32_C(0x4)
	/* Run the memory test. */
	#define HWRM_SELFTEST_EXEC_INPUT_FLAGS_MEMORY_TEST		UINT32_C(0x8)
	/* Run the PCIe serdes test. (deprecated) */
	#define HWRM_SELFTEST_EXEC_INPUT_FLAGS_PCIE_SERDES_TEST	UINT32_C(0x10)
	/* Run the Ethernet serdes test. (deprecated) */
	#define HWRM_SELFTEST_EXEC_INPUT_FLAGS_ETHERNET_SERDES_TEST	UINT32_C(0x20)
	uint8_t	unused_0[7];
} hwrm_selftest_exec_input_t, *phwrm_selftest_exec_input_t;

/* hwrm_selftest_exec_output (size:128b/16B) */

typedef struct hwrm_selftest_exec_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The following tests were requested to be run. */
	uint8_t	requested_tests;
	/* A request was made to run the NVM test. */
	#define HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_NVM_TEST		UINT32_C(0x1)
	/* A request was made to run the link test. */
	#define HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_LINK_TEST		UINT32_C(0x2)
	/* A request was made to run the register test. */
	#define HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_REGISTER_TEST		UINT32_C(0x4)
	/* A request was made to run the memory test. */
	#define HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_MEMORY_TEST		UINT32_C(0x8)
	/* A request was made to run the PCIe serdes test. (deprecated) */
	#define HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_PCIE_SERDES_TEST	UINT32_C(0x10)
	/* A request was made to run the Ethernet serdes test. (deprecated) */
	#define HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_ETHERNET_SERDES_TEST	UINT32_C(0x20)
	/*
	 * If a test was requested to be run as seen in the requested_tests
	 * field, this bit indicates whether the test was successful(1) or
	 * failed(0).
	 */
	uint8_t	test_success;
	/*
	 * If requested, a value of 1 indicates the NVM test completed
	 * successfully.
	 */
	#define HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_NVM_TEST		UINT32_C(0x1)
	/*
	 * If requested, a value of 1 indicates the link test completed
	 * successfully.
	 */
	#define HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_LINK_TEST		UINT32_C(0x2)
	/*
	 * If requested, a value of 1 indicates the register test completed
	 * successfully.
	 */
	#define HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_REGISTER_TEST		UINT32_C(0x4)
	/*
	 * If requested, a value of 1 indicates the memory test completed
	 * successfully.
	 */
	#define HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_MEMORY_TEST		UINT32_C(0x8)
	/*
	 * If requested, a value of 1 indicates the PCIe serdes test
	 * completed successfully. (deprecated)
	 */
	#define HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_PCIE_SERDES_TEST	UINT32_C(0x10)
	/*
	 * If requested, a value of 1 indicates the Ethernet serdes test
	 * completed successfully. (deprecated)
	 */
	#define HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_ETHERNET_SERDES_TEST	UINT32_C(0x20)
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_selftest_exec_output_t, *phwrm_selftest_exec_output_t;

/*********************
 * hwrm_selftest_irq *
 *********************/


/* hwrm_selftest_irq_input (size:128b/16B) */

typedef struct hwrm_selftest_irq_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_selftest_irq_input_t, *phwrm_selftest_irq_input_t;

/* hwrm_selftest_irq_output (size:128b/16B) */

typedef struct hwrm_selftest_irq_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_selftest_irq_output_t, *phwrm_selftest_irq_output_t;

/**************************************
 * hwrm_selftest_retrieve_serdes_data *
 **************************************/


/* hwrm_selftest_retrieve_serdes_data_input (size:320b/40B) */

typedef struct hwrm_selftest_retrieve_serdes_data_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Host address data is to DMA'd to. */
	uint64_t	resp_data_addr;
	/*
	 * This field contains the offset into the captured data to begin
	 * copying the data to the host from. This should be set to 0 on the
	 * initial call to this command.
	 */
	uint32_t	resp_data_offset;
	/*
	 * Size of the buffer pointed to by resp_data_addr. The firmware may
	 * use this entire buffer or less than the entire buffer, but never
	 * more.
	 */
	uint16_t	data_len;
	/*
	 * This field allows this command to request the individual serdes
	 * tests to be run using this command.
	 */
	uint8_t	flags;
	/* Unused. */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_FLAGS_UNUSED_TEST_MASK	UINT32_C(0x7)
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_FLAGS_UNUSED_TEST_SFT	0
	/* Display eye_projection */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_FLAGS_EYE_PROJECTION	UINT32_C(0x8)
	/* Run the PCIe serdes test. */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_FLAGS_PCIE_SERDES_TEST	UINT32_C(0x10)
	/* Run the Ethernet serdes test. */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_FLAGS_ETHERNET_SERDES_TEST	UINT32_C(0x20)
	uint8_t	options;
	/*
	 * This field represents the PCIE lane number on which tools wants to
	 * retrieve eye plot. This field is valid only when 'pcie_serdes_test'
	 * flag is set.
	 * Valid values from 0 to 16.
	 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_PCIE_LANE_NO_MASK	UINT32_C(0xf)
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_PCIE_LANE_NO_SFT	0
	/* This value indicates the Horizontal or vertical plot direction. */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_DIRECTION		UINT32_C(0x10)
	/* Value 0 indicates Horizontal plot request. */
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_DIRECTION_HORIZONTAL	(UINT32_C(0x0) << 4)
	/* Value 1 indicates vertical plot request. */
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_DIRECTION_VERTICAL	(UINT32_C(0x1) << 4)
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_DIRECTION_LAST	HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_DIRECTION_VERTICAL
	/* This value indicates eye projection type */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_PROJ_TYPE		UINT32_C(0x20)
	/*
	 * Value 0 indicates left/top projection in horizontal/vertical
	 * This value is valid only when eye_projection flag was set.
	 */
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_PROJ_TYPE_LEFT_TOP	(UINT32_C(0x0) << 5)
	/*
	 * Value 1 indicates right/bottom projection in
	 * horizontal/vertical. This value is valid only when
	 * eye_projection flag was set.
	 */
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_PROJ_TYPE_RIGHT_BOTTOM  (UINT32_C(0x1) << 5)
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_PROJ_TYPE_LAST	HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_PROJ_TYPE_RIGHT_BOTTOM
	/* Reserved for future. */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_RSVD_MASK		UINT32_C(0xc0)
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_OPTIONS_RSVD_SFT		6
	/*
	 * This field allows this command to request a specific targetBER
	 * to be run using this command.
	 */
	uint8_t	targetBER;
	/* When collecting an eyescope, measure with a target BER of 1e-8 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_TARGETBER_BER_1E8  UINT32_C(0x0)
	/* When collecting an eyescope, measure with a target BER of 1e-9 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_TARGETBER_BER_1E9  UINT32_C(0x1)
	/* When collecting an eyescope, measure with a target BER of 1e-10 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_TARGETBER_BER_1E10 UINT32_C(0x2)
	/* When collecting an eyescope, measure with a target BER of 1e-11 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_TARGETBER_BER_1E11 UINT32_C(0x3)
	/* When collecting an eyescope, measure with a target BER of 1e-12 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_TARGETBER_BER_1E12 UINT32_C(0x4)
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_TARGETBER_LAST	HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_TARGETBER_BER_1E12
	/*
	 * This field allows this command to specify the action to take when
	 * collecting an eyescope.
	 */
	uint8_t	action;
	/*
	 * Value 0 indicates that collection of the eyescope should be
	 * returned synchronously in the output. This only applies to
	 * a targetBER of 1e-8.
	 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_ACTION_SYNCHRONOUS UINT32_C(0x0)
	/*
	 * Value 1 indicates to the firmware to start the collection of the
	 * eyescope.
	 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_ACTION_START	UINT32_C(0x1)
	/*
	 * Value 2 indicates to the firmware to respond with a progress
	 * percentage of the current eyescope collection from 0.0 to 100.0.
	 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_ACTION_PROGRESS	UINT32_C(0x2)
	/*
	 * Value 3 indicates to stop the eyescope. if the progress
	 * percentage is 100.0, the data will be DMAed back to
	 * resp_data_addr.
	 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_ACTION_STOP	UINT32_C(0x3)
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_ACTION_LAST	HWRM_SELFTEST_RETRIEVE_SERDES_DATA_INPUT_ACTION_STOP
	uint8_t	unused[6];
} hwrm_selftest_retrieve_serdes_data_input_t, *phwrm_selftest_retrieve_serdes_data_input_t;

/* hwrm_selftest_retrieve_serdes_data_output (size:192b/24B) */

typedef struct hwrm_selftest_retrieve_serdes_data_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of stored data. */
	uint16_t	total_data_len;
	/*
	 * Amount of data DMA'd to host by this call. The driver can use this
	 * field along with the total_data_len field above to determine the
	 * value to write to the resp_data_offset field in the next call
	 * if more than one call to these commands is required to retrieve all
	 * the stored data.
	 */
	uint16_t	copied_data_len;
	/*
	 * Percentage of completion of collection of BER values from the
	 * current eyescope operation in tenths of a percentage. 0 (0.0) to
	 * 1000 (100.0).
	 */
	uint16_t	progress_percent;
	/* Timeout in seconds for timeout of an individual BER point. */
	uint16_t	timeout;
	uint8_t	flags;
	/*
	 * This value indicates the structure of data returned by the
	 * firmware when DMA'ed to resp_data_addr.
	 */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_OUTPUT_FLAGS_BIT_COUNT_TYPE		UINT32_C(0x1)
	/*
	 * Value 0 indicates that bit_count value is a raw total
	 * such that BER = error_count / bit_count.
	 */
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_OUTPUT_FLAGS_BIT_COUNT_TYPE_BIT_COUNT_TOTAL  UINT32_C(0x0)
	/*
	 * Value 1 indicates that bit count is a power of
	 * 2 that bit_count is normalized to. A Value of 42 indicates
	 * that BER = error_count / 2^42
	 */
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_OUTPUT_FLAGS_BIT_COUNT_TYPE_BIT_COUNT_POW2   UINT32_C(0x1)
		#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_OUTPUT_FLAGS_BIT_COUNT_TYPE_LAST		HWRM_SELFTEST_RETRIEVE_SERDES_DATA_OUTPUT_FLAGS_BIT_COUNT_TYPE_BIT_COUNT_POW2
	/* Reserved for future. */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_OUTPUT_FLAGS_RSVD_MASK			UINT32_C(0xfe)
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA_OUTPUT_FLAGS_RSVD_SFT			1
	uint8_t	unused_0;
	/*
	 * Size of header prepended to the bit_count and error_count array.
	 * Use this value to skip forward to the bit_count and error_count
	 * array.
	 */
	uint16_t	hdr_size;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_selftest_retrieve_serdes_data_output_t, *phwrm_selftest_retrieve_serdes_data_output_t;

/******************************
 * hwrm_mfg_fru_write_control *
 ******************************/


/* hwrm_mfg_fru_write_control_input (size:192b/24B) */

typedef struct hwrm_mfg_fru_write_control_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This field indicates the lock/unlock operation. 0 means Unlock and
	 * 1 means Lock.
	 */
	uint32_t	fru_lock;
	uint32_t	unused_0;
} hwrm_mfg_fru_write_control_input_t, *phwrm_mfg_fru_write_control_input_t;

/* hwrm_mfg_fru_write_control_output (size:128b/16B) */

typedef struct hwrm_mfg_fru_write_control_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_fru_write_control_output_t, *phwrm_mfg_fru_write_control_output_t;

/*************************
 * hwrm_mfg_timers_query *
 *************************/


/* hwrm_mfg_timers_query_input (size:192b/24B) */

typedef struct hwrm_mfg_timers_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint64_t	unused_0;
} hwrm_mfg_timers_query_input_t, *phwrm_mfg_timers_query_input_t;

/* hwrm_mfg_timers_query_output (size:192b/24B) */

typedef struct hwrm_mfg_timers_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is free running counter value running at 1 usec per tick.
	 * The value can wrap around. On error, a value of 0 on all ticks
	 * will be returned.
	 */
	uint32_t	us_tick;
	/*
	 * This is free running counter value running at 1 msec per tick.
	 * The value can wrap around. On error, a value of 0 on all ticks
	 * will be returned.
	 */
	uint32_t	ms_tick;
	/*
	 * This is free running counter value running at 100 msec per tick.
	 * The value can wrap around. On error, a value of 0 on all ticks
	 * will be returned.
	 */
	uint32_t	ms100_tick;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_timers_query_output_t, *phwrm_mfg_timers_query_output_t;

/********************
 * hwrm_mfg_otp_cfg *
 ********************/


/* hwrm_mfg_otp_cfg_input (size:256b/32B) */

typedef struct hwrm_mfg_otp_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/*
	 * This bit must be '1' for the crid field to be
	 * configured.
	 */
	#define HWRM_MFG_OTP_CFG_INPUT_ENABLES_CRID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the srt_rev_id field to be
	 * configured.
	 */
	#define HWRM_MFG_OTP_CFG_INPUT_ENABLES_SRT_REV_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the crt_rev_id field to be
	 * configured.
	 */
	#define HWRM_MFG_OTP_CFG_INPUT_ENABLES_CRT_REV_ID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the sbi_rev_id field to be
	 * configured.
	 */
	#define HWRM_MFG_OTP_CFG_INPUT_ENABLES_SBI_REV_ID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the max_speed field to be
	 * configured.
	 */
	#define HWRM_MFG_OTP_CFG_INPUT_ENABLES_MAX_SPEED_SELECT	UINT32_C(0x10)
	/* This field indicates the crid value to be set. */
	uint16_t	crid_cfg_value;
	/* This field indicates the srt rev id value to be set. */
	uint16_t	srt_rev_id_cfg_value;
	/* This field indicates the crt rev id value to be set. */
	uint16_t	crt_rev_id_cfg_value;
	/* This field indicates the sbi rev id value to be set. */
	uint16_t	sbi_rev_id_cfg_value;
	/* This field indicates the max speed value to be set. */
	uint16_t	max_speed_cfg_value;
	/* max speed value not configured. */
	#define HWRM_MFG_OTP_CFG_INPUT_MAX_SPEED_CFG_VALUE_NOT_CONFIGURED UINT32_C(0x0)
	/* max speed value 50G. */
	#define HWRM_MFG_OTP_CFG_INPUT_MAX_SPEED_CFG_VALUE_50G		UINT32_C(0x1)
	/* max speed value 100G. */
	#define HWRM_MFG_OTP_CFG_INPUT_MAX_SPEED_CFG_VALUE_100G	UINT32_C(0x2)
	/* max speed value 200G. */
	#define HWRM_MFG_OTP_CFG_INPUT_MAX_SPEED_CFG_VALUE_200G	UINT32_C(0x3)
	#define HWRM_MFG_OTP_CFG_INPUT_MAX_SPEED_CFG_VALUE_LAST	HWRM_MFG_OTP_CFG_INPUT_MAX_SPEED_CFG_VALUE_200G
	uint8_t	unused_0[4];
} hwrm_mfg_otp_cfg_input_t, *phwrm_mfg_otp_cfg_input_t;

/* hwrm_mfg_otp_cfg_output (size:128b/16B) */

typedef struct hwrm_mfg_otp_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_otp_cfg_output_t, *phwrm_mfg_otp_cfg_output_t;

/*********************
 * hwrm_mfg_otp_qcfg *
 *********************/


/* hwrm_mfg_otp_qcfg_input (size:192b/24B) */

typedef struct hwrm_mfg_otp_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/*
	 * This bit must be '1' for the crid field to be
	 * queried.
	 */
	#define HWRM_MFG_OTP_QCFG_INPUT_ENABLES_CRID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the srt_rev_id field to be
	 * queried.
	 */
	#define HWRM_MFG_OTP_QCFG_INPUT_ENABLES_SRT_REV_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the crt_rev_id field to be
	 * queried.
	 */
	#define HWRM_MFG_OTP_QCFG_INPUT_ENABLES_CRT_REV_ID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the sbi_rev_id field to be
	 * queried.
	 */
	#define HWRM_MFG_OTP_QCFG_INPUT_ENABLES_SBI_REV_ID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the max_speed field to be
	 * queried.
	 */
	#define HWRM_MFG_OTP_QCFG_INPUT_ENABLES_MAX_SPEED_SELECT	UINT32_C(0x10)
	uint8_t	unused_0[6];
} hwrm_mfg_otp_qcfg_input_t, *phwrm_mfg_otp_qcfg_input_t;

/* hwrm_mfg_otp_qcfg_output (size:256b/32B) */

typedef struct hwrm_mfg_otp_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field contains the value of current device type. The
	 * value indicates the current chip mode (Unassigned/AB_PROD).
	 */
	uint32_t	enc_device_type;
	/* This field indicates the current crid value. */
	uint16_t	crid;
	/* This field indicates the current srt rev id value. */
	uint16_t	srt_rev_id;
	/* This field indicates the current crt rev id value. */
	uint16_t	crt_rev_id;
	/* This field indicates the current sbi rev id value. */
	uint16_t	sbi_rev_id;
	/* This field indicates the current max speed value. */
	uint16_t	max_speed;
	/* max speed value not configured. */
	#define HWRM_MFG_OTP_QCFG_OUTPUT_MAX_SPEED_NOT_CONFIGURED UINT32_C(0x0)
	/* max speed value 50G. */
	#define HWRM_MFG_OTP_QCFG_OUTPUT_MAX_SPEED_50G		UINT32_C(0x1)
	/* max speed value 100G. */
	#define HWRM_MFG_OTP_QCFG_OUTPUT_MAX_SPEED_100G	UINT32_C(0x2)
	/* max speed value 200G. */
	#define HWRM_MFG_OTP_QCFG_OUTPUT_MAX_SPEED_200G	UINT32_C(0x3)
	#define HWRM_MFG_OTP_QCFG_OUTPUT_MAX_SPEED_LAST	HWRM_MFG_OTP_QCFG_OUTPUT_MAX_SPEED_200G
	/* This field sets a bitmap for new enabled fields. */
	uint16_t	enables_bitmap;
	/* This bit checks max speed cfg enable. */
	#define HWRM_MFG_OTP_QCFG_OUTPUT_ENABLES_BITMAP_MAX_SPEED	UINT32_C(0x10)
	/* This bit validates this enable bitmap. */
	#define HWRM_MFG_OTP_QCFG_OUTPUT_ENABLES_BITMAP_ENABLES_VALID	UINT32_C(0x8000)
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_otp_qcfg_output_t, *phwrm_mfg_otp_qcfg_output_t;

/**********************
 * hwrm_mfg_hdma_test *
 **********************/


/* hwrm_mfg_hdma_test_input (size:384b/48B) */

typedef struct hwrm_mfg_hdma_test_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The host (DMA) buffer physical addr for the firmware to read from. */
	uint64_t	host_src_data_addr;
	/* The host (DMA) buffer physical addr for the firmware to write to. */
	uint64_t	host_dst_data_addr;
	/*
	 * The user provided data pattern which will be used in the DMA
	 * transfer.
	 */
	uint64_t	user_data_pattern;
	/* Timeout value to stop the test. */
	uint16_t	timeout;
	/* The number of DMA transfers to be done in the test. */
	uint16_t	repeat_count;
	/* Types can be any of "incremental", "fixed", or "random". */
	uint16_t	subtype;
	/* Test is run with the incremental data pattern. */
	#define HWRM_MFG_HDMA_TEST_INPUT_SUBTYPE_INCREMENTAL UINT32_C(0x1)
	/* Test is run with the fixed data pattern. */
	#define HWRM_MFG_HDMA_TEST_INPUT_SUBTYPE_FIXED	UINT32_C(0x2)
	/* Test is run with a random data pattern. */
	#define HWRM_MFG_HDMA_TEST_INPUT_SUBTYPE_RANDOM	UINT32_C(0x3)
	#define HWRM_MFG_HDMA_TEST_INPUT_SUBTYPE_LAST	HWRM_MFG_HDMA_TEST_INPUT_SUBTYPE_RANDOM
	/* The length of the data used in the DMA transfers. */
	uint16_t	data_len;
} hwrm_mfg_hdma_test_input_t, *phwrm_mfg_hdma_test_input_t;

/* hwrm_mfg_hdma_test_output (size:128b/16B) */

typedef struct hwrm_mfg_hdma_test_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_hdma_test_output_t, *phwrm_mfg_hdma_test_output_t;

/*****************************
 * hwrm_mfg_fru_eeprom_write *
 *****************************/


/* hwrm_mfg_fru_eeprom_write_input (size:256b/32B) */

typedef struct hwrm_mfg_fru_eeprom_write_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The host (DMA) buffer physical addr for the firmware to read from.
	 * This buffer is populated with the fru binary bits which is going
	 * to be programmed into the fru memory.
	 */
	uint64_t	data_addr;
	/* i2c slave address. If set to 0xffff, fw will decide what to use. */
	uint16_t	i2c_slave_addr;
	/* Size of the buffer pointed to by data_addr. */
	uint16_t	data_len;
	/* The offset within the SEEPROM to start programming. */
	uint16_t	offset;
	uint8_t	unused[2];
} hwrm_mfg_fru_eeprom_write_input_t, *phwrm_mfg_fru_eeprom_write_input_t;

/* hwrm_mfg_fru_eeprom_write_output (size:128b/16B) */

typedef struct hwrm_mfg_fru_eeprom_write_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of data written to the fru memory. */
	uint16_t	total_data_len;
	uint16_t	unused_0;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_fru_eeprom_write_output_t, *phwrm_mfg_fru_eeprom_write_output_t;

/****************************
 * hwrm_mfg_fru_eeprom_read *
 ****************************/


/* hwrm_mfg_fru_eeprom_read_input (size:256b/32B) */

typedef struct hwrm_mfg_fru_eeprom_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The host (DMA) buffer physical addr for the firmware to write to.
	 * This buffer is populated with the fru binary bits which is going
	 * to be read from the fru memory.
	 */
	uint64_t	data_addr;
	/* i2c slave address. If set to 0xffff, fw will decide what to use. */
	uint16_t	i2c_slave_addr;
	/*
	 * Size of the buffer pointed to by data_addr. The firmware may
	 * use this entire buffer or less than the entire buffer, but never
	 * more.
	 */
	uint16_t	data_len;
	/* The offset within the SEEPROM to start reading. */
	uint16_t	offset;
	uint8_t	unused[2];
} hwrm_mfg_fru_eeprom_read_input_t, *phwrm_mfg_fru_eeprom_read_input_t;

/* hwrm_mfg_fru_eeprom_read_output (size:128b/16B) */

typedef struct hwrm_mfg_fru_eeprom_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of data written to the host memory. */
	uint16_t	total_data_len;
	uint16_t	unused_0;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_fru_eeprom_read_output_t, *phwrm_mfg_fru_eeprom_read_output_t;

/**********************
 * hwrm_mfg_soc_image *
 **********************/


/* hwrm_mfg_soc_image_input (size:512b/64B) */

typedef struct hwrm_mfg_soc_image_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * TBD. Work in progress.
	 * This field is the signature value used by SoC UEFI.
	 */
	uint32_t	image_signature;
	/*
	 * TBD. Work in progress.
	 * This field is unused for now.
	 */
	uint32_t	image_type;
	/*
	 * The offset within the image content that is being provided by the
	 * current invocation of this HWRM command. The primate firmware does
	 * not offer any score boarding services to ensure entire image
	 * content is transferred, it is the responsibility of the caller to
	 * ensure image consistency.
	 */
	uint32_t	image_offset;
	/*
	 * Size in bytes for the image content. The maximum value this field
	 * can specify is 4096.
	 */
	uint32_t	image_length;
	/*
	 * Address in host memory where the image content is located. This
	 * location should be 4KB aligned.
	 */
	uint64_t	host_src_addr;
	/*
	 * Address in SoC address space where the provided image content is
	 * to be copied. Primate firmware will copy the image content from
	 * host memory to this location. If the image size is more than the
	 * maximum size that can be transferred with each invocation of this
	 * command, then this address should be updated by the caller for
	 * each invocation to copy the full image.
	 */
	uint64_t	soc_dest_addr;
	/*
	 * Indicates the entrypoint in the image that should be used. This
	 * field is optional. When set to 0, the SoC will determine the
	 * entrypoint on its own.
	 */
	uint32_t	entrypoint_offset;
	uint32_t	flags;
	/*
	 * This bit should be set to '1' only when an image transfer is
	 * being initiated for each unique image_signature.
	 */
	#define HWRM_MFG_SOC_IMAGE_INPUT_FLAGS_START	UINT32_C(0x1)
	/*
	 * This bit should be set to '1' only when an image transfer for a
	 * given image_signature is complete.
	 */
	#define HWRM_MFG_SOC_IMAGE_INPUT_FLAGS_END	UINT32_C(0x2)
	/*
	 * An incrementing number starting with 1 for each invocation of this
	 * HWRM command for any given image_id. No two invocation of this
	 * command for a given image_id shall carry the same seq_number. Each
	 * consecutive invocation of this command for any given image_id
	 * shall increment this number by 1. The value 0 is used when
	 * seq_number is invalid when no image content is being moved.
	 */
	uint32_t	seq_number;
	/*  */
	uint32_t	reserved1;
} hwrm_mfg_soc_image_input_t, *phwrm_mfg_soc_image_input_t;

/* hwrm_mfg_soc_image_output (size:128b/16B) */

typedef struct hwrm_mfg_soc_image_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_mfg_soc_image_output_t, *phwrm_mfg_soc_image_output_t;

/************************
 * hwrm_mfg_soc_qstatus *
 ************************/


/* hwrm_mfg_soc_qstatus_input (size:192b/24B) */

typedef struct hwrm_mfg_soc_qstatus_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*  */
	uint32_t	reserved1;
	/*  */
	uint32_t	reserved2;
} hwrm_mfg_soc_qstatus_input_t, *phwrm_mfg_soc_qstatus_input_t;

/* hwrm_mfg_soc_qstatus_output (size:576b/72B) */

typedef struct hwrm_mfg_soc_qstatus_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field describes capabilities of primate firmware for SoC
	 * image.
	 */
	uint32_t	primate_flags;
	/*  */
	uint32_t	reserved1;
	/* This field contains the current content of the AP_STATUS register. */
	uint32_t	ap_status;
	/*
	 * This field contains the current content of the CRMU_STATUS
	 * register.
	 */
	uint32_t	crmu_status;
	/*
	 * If an image provision operation is in process, this field will
	 * provide information on requested image signature else the contents
	 * are undefined.
	 */
	uint32_t	image_signature;
	/*
	 * If an image provision operation is in process, this field will
	 * provide information on requested image command else the contents
	 * are undefined.
	 */
	uint32_t	image_command;
	/*
	 * If an image provision operation is in process, this field will
	 * provide the requested image name else the contents are undefined.
	 */
	uint8_t	image_name[32];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_mfg_soc_qstatus_output_t, *phwrm_mfg_soc_qstatus_output_t;

/*****************************************
 * hwrm_mfg_param_critical_data_finalize *
 *****************************************/


/* hwrm_mfg_param_critical_data_finalize_input (size:192b/24B) */

typedef struct hwrm_mfg_param_critical_data_finalize_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/*
	 * Set to 1 if you wish to unlock and erase the region
	 * before finalizing the data.
	 */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_FINALIZE_INPUT_FLAGS_FORCE	UINT32_C(0x1)
	uint16_t	unused_0;
	uint32_t	unused_1;
} hwrm_mfg_param_critical_data_finalize_input_t, *phwrm_mfg_param_critical_data_finalize_input_t;

/* hwrm_mfg_param_critical_data_finalize_output (size:128b/16B) */

typedef struct hwrm_mfg_param_critical_data_finalize_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of data finalized. */
	uint32_t	total_data_len;
	uint16_t	error_status;
	/* Critical data region was already locked */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_FINALIZE_OUTPUT_ERROR_STATUS_ALREADY_LOCKED	UINT32_C(0x1)
	/* Flash region was not entirely empty */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_FINALIZE_OUTPUT_ERROR_STATUS_NOT_EMPTY		UINT32_C(0x2)
	/* FACT_CFG was missing for write to critical cfg */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_FINALIZE_OUTPUT_ERROR_STATUS_MISSING_FACT_CFG	UINT32_C(0x4)
	/* VPD was missing for write to critical cfg */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_FINALIZE_OUTPUT_ERROR_STATUS_MISSING_VPD	UINT32_C(0x8)
	uint8_t	unused_1;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_param_critical_data_finalize_output_t, *phwrm_mfg_param_critical_data_finalize_output_t;

/*************************************
 * hwrm_mfg_param_critical_data_read *
 *************************************/


/* hwrm_mfg_param_critical_data_read_input (size:256b/32B) */

typedef struct hwrm_mfg_param_critical_data_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The host (DMA) buffer physical addr for the firmware to write to.
	 * This buffer is populated with data read from the
	 * critical data storage location.
	 */
	uint64_t	data_addr;
	/*
	 * Size of the buffer pointed to by data_addr. The firmware may
	 * use this entire buffer or less than the entire buffer, but never
	 * more.
	 */
	uint32_t	data_len;
	/* The offset within the critical data to start reading. */
	uint32_t	offset;
} hwrm_mfg_param_critical_data_read_input_t, *phwrm_mfg_param_critical_data_read_input_t;

/* hwrm_mfg_param_critical_data_read_output (size:128b/16B) */

typedef struct hwrm_mfg_param_critical_data_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of data written to the host memory. */
	uint32_t	total_data_len;
	uint16_t	unused_0;
	uint8_t	unused_1;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_param_critical_data_read_output_t, *phwrm_mfg_param_critical_data_read_output_t;

/***************************************
 * hwrm_mfg_param_critical_data_health *
 ***************************************/


/* hwrm_mfg_param_critical_data_health_input (size:192b/24B) */

typedef struct hwrm_mfg_param_critical_data_health_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint64_t	unused_0;
} hwrm_mfg_param_critical_data_health_input_t, *phwrm_mfg_param_critical_data_health_input_t;

/* hwrm_mfg_param_critical_data_health_output (size:128b/16B) */

typedef struct hwrm_mfg_param_critical_data_health_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	health_status;
	/* region entirely empty */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_HEALTH_OUTPUT_HEALTH_STATUS_IS_EMPTY	UINT32_C(0x1)
	/* Data checksum fail */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_HEALTH_OUTPUT_HEALTH_STATUS_CHECKSUM_FAIL	UINT32_C(0x2)
	/* Malformed data (header/footer) */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_HEALTH_OUTPUT_HEALTH_STATUS_MALFORMED_DATA	UINT32_C(0x4)
	/* Critical data not locked */
	#define HWRM_MFG_PARAM_CRITICAL_DATA_HEALTH_OUTPUT_HEALTH_STATUS_NOT_LOCKED	UINT32_C(0x8)
	uint16_t	unused_1;
	uint8_t	unused_2;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_param_critical_data_health_output_t, *phwrm_mfg_param_critical_data_health_output_t;

/*****************************
 * hwrm_mfg_prvsn_export_csr *
 *****************************/


/* hwrm_mfg_prvsn_export_csr_input (size:256b/32B) */

typedef struct hwrm_mfg_prvsn_export_csr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host destination address. This is the host address where
	 * data will be written.
	 */
	uint64_t	host_dest_addr;
	/* Provisioning slot number. 0-indexed. */
	uint8_t	slot;
	uint8_t	unused_0;
	/* Size in bytes of the available host buffer. */
	uint16_t	host_buf_len;
	uint8_t	flags;
	/*
	 * This bit is only used when external secure SoC is used for
	 * secure boot. If this bit is set, export a certificate signing
	 * request (CSR) from the security SoC non-volatile storage on
	 * the device.
	 */
	#define HWRM_MFG_PRVSN_EXPORT_CSR_INPUT_FLAGS_SECURE_SOC_SUPPORT	UINT32_C(0x1)
	uint8_t	unused_1[3];
} hwrm_mfg_prvsn_export_csr_input_t, *phwrm_mfg_prvsn_export_csr_input_t;

/* hwrm_mfg_prvsn_export_csr_output (size:128b/16B) */

typedef struct hwrm_mfg_prvsn_export_csr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Provisioning slot number. 0-indexed. */
	uint8_t	slot;
	uint8_t	unused_0;
	/* Size in bytes of the exported CSR. */
	uint16_t	csr_len;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_mfg_prvsn_export_csr_output_t, *phwrm_mfg_prvsn_export_csr_output_t;

/* hwrm_mfg_prvsn_export_csr_cmd_err (size:64b/8B) */

typedef struct hwrm_mfg_prvsn_export_csr_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_MFG_PRVSN_EXPORT_CSR_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* Slot invalid */
	#define HWRM_MFG_PRVSN_EXPORT_CSR_CMD_ERR_CODE_SLOT_INVALID  UINT32_C(0x1)
	/* Host provided buffer is too small */
	#define HWRM_MFG_PRVSN_EXPORT_CSR_CMD_ERR_CODE_BUFFER_LENGTH UINT32_C(0x2)
	#define HWRM_MFG_PRVSN_EXPORT_CSR_CMD_ERR_CODE_LAST	HWRM_MFG_PRVSN_EXPORT_CSR_CMD_ERR_CODE_BUFFER_LENGTH
	uint8_t	unused_0[7];
} hwrm_mfg_prvsn_export_csr_cmd_err_t, *phwrm_mfg_prvsn_export_csr_cmd_err_t;

/******************************
 * hwrm_mfg_prvsn_import_cert *
 ******************************/


/* hwrm_mfg_prvsn_import_cert_input (size:256b/32B) */

typedef struct hwrm_mfg_prvsn_import_cert_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host source address. This is the host address where
	 * source data is located.
	 */
	uint64_t	host_src_addr;
	/* Provisioning slot number. 0-indexed. */
	uint8_t	slot;
	uint8_t	unused_0;
	/* Size in bytes of the certificate chain. */
	uint16_t	cert_len;
	uint8_t	flags;
	/*
	 * This bit is only used when external secure SoC is used for
	 * secure boot. If this bit is set, then import a HSM-signed
	 * certificate chain to security SoC non-volatile storage on
	 * the device.
	 */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_INPUT_FLAGS_SECURE_SOC_SUPPORT	UINT32_C(0x1)
	uint8_t	unused_1[3];
} hwrm_mfg_prvsn_import_cert_input_t, *phwrm_mfg_prvsn_import_cert_input_t;

/* hwrm_mfg_prvsn_import_cert_output (size:128b/16B) */

typedef struct hwrm_mfg_prvsn_import_cert_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Provisioning slot number. 0-indexed. */
	uint8_t	slot;
	/* Provisioned state */
	uint8_t	state;
	/* Certificate chain is not provisioned. */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_OUTPUT_STATE_NOT_PROVISIONED UINT32_C(0x0)
	/* Certificate chain successfully provisioned. */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_OUTPUT_STATE_PROVISIONED	UINT32_C(0x1)
	#define HWRM_MFG_PRVSN_IMPORT_CERT_OUTPUT_STATE_LAST	HWRM_MFG_PRVSN_IMPORT_CERT_OUTPUT_STATE_PROVISIONED
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_mfg_prvsn_import_cert_output_t, *phwrm_mfg_prvsn_import_cert_output_t;

/* hwrm_mfg_prvsn_import_cert_cmd_err (size:64b/8B) */

typedef struct hwrm_mfg_prvsn_import_cert_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_CMD_ERR_CODE_UNKNOWN		UINT32_C(0x0)
	/* Slot invalid */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_CMD_ERR_CODE_SLOT_INVALID	UINT32_C(0x1)
	/* Slot is provisioned and locked */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_CMD_ERR_CODE_SLOT_LOCKED	UINT32_C(0x2)
	/* Non-volatile storage is full or in error. */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_CMD_ERR_CODE_NO_STORAGE		UINT32_C(0x3)
	/* Certificate chain verification failed. */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_CMD_ERR_CODE_CERT_VERIFY_FAIL	UINT32_C(0x4)
	/* There is no self-signed device id certificate on device */
	#define HWRM_MFG_PRVSN_IMPORT_CERT_CMD_ERR_CODE_NO_SIGNED_DEVICE_CERT UINT32_C(0x5)
	#define HWRM_MFG_PRVSN_IMPORT_CERT_CMD_ERR_CODE_LAST		HWRM_MFG_PRVSN_IMPORT_CERT_CMD_ERR_CODE_NO_SIGNED_DEVICE_CERT
	uint8_t	unused_0[7];
} hwrm_mfg_prvsn_import_cert_cmd_err_t, *phwrm_mfg_prvsn_import_cert_cmd_err_t;

/****************************
 * hwrm_mfg_prvsn_get_state *
 ****************************/


/* hwrm_mfg_prvsn_get_state_input (size:128b/16B) */

typedef struct hwrm_mfg_prvsn_get_state_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_mfg_prvsn_get_state_input_t, *phwrm_mfg_prvsn_get_state_input_t;

/* hwrm_mfg_prvsn_get_state_output (size:128b/16B) */

typedef struct hwrm_mfg_prvsn_get_state_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Flag indicating if provision get state is valid. */
	uint8_t	get_state_valid;
	/*
	 * Provision get state is invalid. The attestation agent has not
	 * yet initialized and not completed verification of the
	 * provisioned certificate chain.
	 * The slot_status field is undetermined.
	 */
	#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_GET_STATE_VALID_INVALID  UINT32_C(0x0)
	/* Provision get state is valid for SPDM. */
	#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_GET_STATE_VALID_SPDM	UINT32_C(0x1)
	/* Provision get state is valid for Cerberus. */
	#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_GET_STATE_VALID_CERBERUS UINT32_C(0x2)
	/* Provision get state is valid. There is no attestation agent. */
	#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_GET_STATE_VALID_NONE	UINT32_C(0xff)
	#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_GET_STATE_VALID_LAST	HWRM_MFG_PRVSN_GET_STATE_OUTPUT_GET_STATE_VALID_NONE
	/*
	 * An 8-bit mask returning the provisioned state of the imported
	 * certificate chain on the device for each available slot.
	 * Bit-N corresponding to slot N.
	 * The slot_status field is undetermined if get_state_valid = 0.
	 */
	uint8_t	slot_status;
	/* Slot N entries */
	#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_SLOT_STATUS_SLOT_N_MASK	UINT32_C(0xff)
	#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_SLOT_STATUS_SLOT_N_SFT		0
	/* Slot N is not provisioned. */
		#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_SLOT_STATUS_SLOT_N_NOT_PROVISIONED  UINT32_C(0x0)
	/*
	 * Slot N is provisioned and certificate chain is loaded
	 * successfully by the attestation agent.
	 */
		#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_SLOT_STATUS_SLOT_N_PROVISIONED	UINT32_C(0x1)
		#define HWRM_MFG_PRVSN_GET_STATE_OUTPUT_SLOT_STATUS_SLOT_N_LAST		HWRM_MFG_PRVSN_GET_STATE_OUTPUT_SLOT_STATUS_SLOT_N_PROVISIONED
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_mfg_prvsn_get_state_output_t, *phwrm_mfg_prvsn_get_state_output_t;

/******************************
 * hwrm_mfg_prvsn_export_cert *
 ******************************/


/* hwrm_mfg_prvsn_export_cert_input (size:256b/32B) */

typedef struct hwrm_mfg_prvsn_export_cert_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host destination address. This is the host address where
	 * data will be written.
	 */
	uint64_t	host_dest_addr;
	/* Provisioning slot number. 0-indexed. */
	uint8_t	slot;
	uint8_t	unused_0;
	/* Size in bytes of the available host buffer. */
	uint16_t	host_buf_len;
	uint8_t	flags;
	/*
	 * This bit is only used when external secure SoC is used
	 * for secure boot. If this bit is set, then export the
	 * provisioned certificate from the security SoC non-volatile
	 * storage device.
	 */
	#define HWRM_MFG_PRVSN_EXPORT_CERT_INPUT_FLAGS_SECURE_SOC_SUPPORT	UINT32_C(0x1)
	uint8_t	unused_1[3];
} hwrm_mfg_prvsn_export_cert_input_t, *phwrm_mfg_prvsn_export_cert_input_t;

/* hwrm_mfg_prvsn_export_cert_output (size:128b/16B) */

typedef struct hwrm_mfg_prvsn_export_cert_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Provisioning slot number. 0-indexed. */
	uint8_t	slot;
	uint8_t	unused_0;
	/*
	 * Size in bytes of the exported certificate chain. If there are no
	 * certificates provisioned for the specified slot, the device will
	 * return a successful response with cert_len equal to 0.
	 */
	uint16_t	cert_len;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_mfg_prvsn_export_cert_output_t, *phwrm_mfg_prvsn_export_cert_output_t;

/* hwrm_mfg_prvsn_export_cert_cmd_err (size:64b/8B) */

typedef struct hwrm_mfg_prvsn_export_cert_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_MFG_PRVSN_EXPORT_CERT_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* Slot invalid */
	#define HWRM_MFG_PRVSN_EXPORT_CERT_CMD_ERR_CODE_SLOT_INVALID  UINT32_C(0x1)
	/*
	 * The provisioned certificates are invalid due to device ID change,
	 * NVRAM corruption or another reason.
	 */
	#define HWRM_MFG_PRVSN_EXPORT_CERT_CMD_ERR_CODE_CERT_INVALID  UINT32_C(0x2)
	/* Host provided buffer is too small */
	#define HWRM_MFG_PRVSN_EXPORT_CERT_CMD_ERR_CODE_BUFFER_LENGTH UINT32_C(0x3)
	#define HWRM_MFG_PRVSN_EXPORT_CERT_CMD_ERR_CODE_LAST	HWRM_MFG_PRVSN_EXPORT_CERT_CMD_ERR_CODE_BUFFER_LENGTH
	uint8_t	unused_0[7];
} hwrm_mfg_prvsn_export_cert_cmd_err_t, *phwrm_mfg_prvsn_export_cert_cmd_err_t;

/********************************
 * hwrm_mfg_get_nvm_measurement *
 ********************************/


/* hwrm_mfg_get_nvm_measurement_input (size:128b/16B) */

typedef struct hwrm_mfg_get_nvm_measurement_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_mfg_get_nvm_measurement_input_t, *phwrm_mfg_get_nvm_measurement_input_t;

/* hwrm_mfg_get_nvm_measurement_output (size:704b/88B) */

typedef struct hwrm_mfg_get_nvm_measurement_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Flag indicating if the hash returned is valid. */
	uint8_t	hash_state;
	/*
	 * Measurement hash is invalid. There was an error
	 * calculating the hash or firmware does not support NVM
	 * measurement.
	 */
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_STATE_INVALID UINT32_C(0x0)
	/* Measurement hash is valid. */
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_STATE_VALID   UINT32_C(0x1)
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_STATE_LAST   HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_STATE_VALID
	/*
	 * Flag indicating whether the measurement was calculated
	 * in real time or calculated during bootup time.
	 */
	uint8_t	calc_time;
	/* Measurement was calculated during bootup time. */
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_CALC_TIME_BOOTUP UINT32_C(0x0)
	/* Measurement is calculated in real time */
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_CALC_TIME_LIVE   UINT32_C(0x1)
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_CALC_TIME_LAST  HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_CALC_TIME_LIVE
	/* Flag indicating the hash type when hash_state is valid. */
	uint8_t	hash_type;
	/* Measurement hash is SHA256(32 bytes). */
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_TYPE_SHA256 UINT32_C(0x0)
	/* Measurement hash is SHA384(48 bytes). */
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_TYPE_SHA384 UINT32_C(0x1)
	/* Measurement hash is SHA512(64 bytes). */
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_TYPE_SHA512 UINT32_C(0x2)
	#define HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_TYPE_LAST  HWRM_MFG_GET_NVM_MEASUREMENT_OUTPUT_HASH_TYPE_SHA512
	uint8_t	unused_0[5];
	/* NVM configuration hash with length indicated by hash_type. */
	uint8_t	hash[64];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_mfg_get_nvm_measurement_output_t, *phwrm_mfg_get_nvm_measurement_output_t;

/*************************
 * hwrm_mfg_psoc_qstatus *
 *************************/


/* hwrm_mfg_psoc_qstatus_input (size:192b/24B) */

typedef struct hwrm_mfg_psoc_qstatus_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*  */
	uint32_t	reserved1;
	/*  */
	uint32_t	reserved2;
} hwrm_mfg_psoc_qstatus_input_t, *phwrm_mfg_psoc_qstatus_input_t;

/* hwrm_mfg_psoc_qstatus_output (size:768b/96B) */

typedef struct hwrm_mfg_psoc_qstatus_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* PBL version info. Start at 0, roll if change in structure */
	uint8_t	pbl_info_version;
	/* PBL info length. Counts all bytes. */
	uint8_t	pbl_info_length;
	/*
	 * Hardware generation major version. Rolled on incompatible hardware
	 * changes.
	 */
	uint8_t	hw_generation_major;
	/* Hardware generation minor version. Tracks minor changes. */
	uint8_t	hw_generation_minor;
	/* Reserved. */
	uint8_t	feature_support;
	/* Firmware version major. */
	uint8_t	fw_version_major;
	/* Firmware version minor. */
	uint8_t	fw_version_minor;
	/* Indicate which of the two firmware images is active. */
	uint8_t	active_image;
	/* Identifies PSoC specific part. */
	uint32_t	silicon_id;
	/* Length of part number string in bytes, including NULL terminator. */
	uint8_t	part_number_string_length;
	uint8_t	unused_1[3];
	/* Part number string in ASCII. */
	uint8_t	part_number_string[64];
	uint8_t	unused_2[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_mfg_psoc_qstatus_output_t, *phwrm_mfg_psoc_qstatus_output_t;

/***************************
 * hwrm_mfg_selftest_qlist *
 ***************************/


/* hwrm_mfg_selftest_qlist_input (size:128b/16B) */

typedef struct hwrm_mfg_selftest_qlist_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_mfg_selftest_qlist_input_t, *phwrm_mfg_selftest_qlist_input_t;

/* hwrm_mfg_selftest_qlist_output (size:192b/24B) */

typedef struct hwrm_mfg_selftest_qlist_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the number of tests available to be
	 * requested by manufacturing tool.
	 */
	uint8_t	num_tests;
	/* This field indicates which self-test is available to be run. */
	uint8_t	available_tests;
	/*
	 * Can run the peripheral tests. Individual peripherals are
	 * specified in peripheral_tests field.
	 */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_PERIPHERAL_TEST	UINT32_C(0x1)
	/*
	 * This field represents the maximum timeout for all the
	 * tests to complete in milliseconds.
	 */
	uint16_t	test_timeout;
	/*
	 * This field is a 32 bits bitmap, each bit specifies a peripheral
	 * test.
	 */
	uint32_t	peripheral_tests;
	/* Can run memory test on Co-CPU peripheral */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_PERIPHERAL_TESTS_CO_CPU_MEMORY	UINT32_C(0x1)
	/* Can run test on dpll eeprom peripheral */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_PERIPHERAL_TESTS_DPLL_EEPROM	UINT32_C(0x2)
	/* Can run test on dpll mmcx connector peripheral */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_PERIPHERAL_TESTS_DPLL_MMCX	UINT32_C(0x4)
	/* Can run test on gnss peripheral */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_PERIPHERAL_TESTS_GNSS		UINT32_C(0x8)
	/* Can run pcie test on Co-CPU peripheral */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_PERIPHERAL_TESTS_CO_CPU_PCIE	UINT32_C(0x10)
	/* Can run test on internal fabric peripheral */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_PERIPHERAL_TESTS_INTERNAL_FABRIC	UINT32_C(0x20)
	/* Can run test on oven controlled crystal oscillator peripheral */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_PERIPHERAL_TESTS_OCXO		UINT32_C(0x40)
	/* Can run test on telecom pll peripheral */
	#define HWRM_MFG_SELFTEST_QLIST_OUTPUT_PERIPHERAL_TESTS_TELECOM_PLL	UINT32_C(0x80)
	uint8_t	unused_2[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_selftest_qlist_output_t, *phwrm_mfg_selftest_qlist_output_t;

/**************************
 * hwrm_mfg_selftest_exec *
 **************************/


/* hwrm_mfg_selftest_exec_input (size:192b/24B) */

typedef struct hwrm_mfg_selftest_exec_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This field indicates which self-test is being requested to run. */
	uint8_t	flags;
	/*
	 * Run the Peripheral tests specified in peripheral_tests
	 * field.
	 */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_FLAGS_PERIPHERAL_TEST	UINT32_C(0x1)
	uint8_t	unused_0[3];
	/*
	 * This field is a 32 bits bitmap to specify which peripheral tests to
	 * run, each bit specifies a peripheral test.
	 */
	uint32_t	peripheral_tests;
	/* Run memory test on Co-CPU peripheral */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_PERIPHERAL_TESTS_CO_CPU_MEMORY	UINT32_C(0x1)
	/* Run test on dpll eeprom peripheral */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_PERIPHERAL_TESTS_DPLL_EEPROM	UINT32_C(0x2)
	/* Run test on dpll mmcx connector peripheral */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_PERIPHERAL_TESTS_DPLL_MMCX	UINT32_C(0x4)
	/* Run test on gnss peripheral */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_PERIPHERAL_TESTS_GNSS		UINT32_C(0x8)
	/* Run pcie test on Co-CPU peripheral */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_PERIPHERAL_TESTS_CO_CPU_PCIE	UINT32_C(0x10)
	/* Run test on internal fabric peripheral */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_PERIPHERAL_TESTS_INTERNAL_FABRIC	UINT32_C(0x20)
	/* Run test on oven controlled crystal oscillator peripheral */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_PERIPHERAL_TESTS_OCXO		UINT32_C(0x40)
	/* Run test on telecom pll peripheral */
	#define HWRM_MFG_SELFTEST_EXEC_INPUT_PERIPHERAL_TESTS_TELECOM_PLL	UINT32_C(0x80)
} hwrm_mfg_selftest_exec_input_t, *phwrm_mfg_selftest_exec_input_t;

/* hwrm_mfg_selftest_exec_output (size:192b/24B) */

typedef struct hwrm_mfg_selftest_exec_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The following tests were requested to be run. */
	uint8_t	requested_tests;
	/* A request was made to run the peripheral tests. */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_PERIPHERAL_TEST	UINT32_C(0x1)
	/*
	 * If a test was requested to be run as seen in the requested_tests
	 * field, this bit indicates whether the test was successful(1) or
	 * failed(0).
	 */
	uint8_t	test_success;
	/*
	 * If requested, a value of 1 indicates the peripheral tests
	 * completed successfully.
	 */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_PERIPHERAL_TEST	UINT32_C(0x1)
	uint8_t	unused_0[2];
	/*
	 * This field is a 32 bits bitmap for firmware to indicate which
	 * peripheral tests are specified by the host, each bit specifies
	 * a peripheral test.
	 */
	uint32_t	peripheral_requested_tests;
	/* Co-CPU peripheral test requested */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_REQUESTED_TESTS_CO_CPU_MEMORY	UINT32_C(0x1)
	/* dpll eeprom peripheral test requested */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_REQUESTED_TESTS_DPLL_EEPROM	UINT32_C(0x2)
	/* dpll mmcx connector peripheral test requested */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_REQUESTED_TESTS_DPLL_MMCX	UINT32_C(0x4)
	/* gnss peripheral test requested */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_REQUESTED_TESTS_GNSS		UINT32_C(0x8)
	/* pcie test on Co-CPU peripheral test requested */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_REQUESTED_TESTS_CO_CPU_PCIE	UINT32_C(0x10)
	/* internal fabric peripheral test requested */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_REQUESTED_TESTS_INTERNAL_FABRIC	UINT32_C(0x20)
	/* oven controlled crystal oscillator peripheral test requested */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_REQUESTED_TESTS_OCXO		UINT32_C(0x40)
	/* telecom pll peripheral test requested */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_REQUESTED_TESTS_TELECOM_PLL	UINT32_C(0x80)
	/*
	 * This field is a 32 bits bitmap for firmware to indicate which
	 * peripheral tests are successfully executed, each bit specifies
	 * a peripheral test.
	 */
	uint32_t	peripheral_tests_success;
	/* Co-CPU peripheral test is successfully executed */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_TESTS_SUCCESS_CO_CPU_MEMORY	UINT32_C(0x1)
	/* dpll eeprom peripheral test is successfully executed */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_TESTS_SUCCESS_DPLL_EEPROM	UINT32_C(0x2)
	/* dpll mmcx connector peripheral test is successfully executed */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_TESTS_SUCCESS_DPLL_MMCX	UINT32_C(0x4)
	/* gnss peripheral test is successfully executed */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_TESTS_SUCCESS_GNSS		UINT32_C(0x8)
	/* pcie test on Co-CPU peripheral test is successfully executed */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_TESTS_SUCCESS_CO_CPU_PCIE	UINT32_C(0x10)
	/* internal fabric peripheral test is successfully executed */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_TESTS_SUCCESS_INTERNAL_FABRIC	UINT32_C(0x20)
	/*
	 * oven controlled crystal oscillator peripheral test is successfully
	 * executed
	 */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_TESTS_SUCCESS_OCXO		UINT32_C(0x40)
	/* telecom pll peripheral test is successfully executed */
	#define HWRM_MFG_SELFTEST_EXEC_OUTPUT_PERIPHERAL_TESTS_SUCCESS_TELECOM_PLL	UINT32_C(0x80)
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_mfg_selftest_exec_output_t, *phwrm_mfg_selftest_exec_output_t;

/****************
 * hwrm_oem_cmd *
 ****************/


/* hwrm_oem_cmd_input (size:1024b/128B) */

typedef struct hwrm_oem_cmd_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The organization owning the message format. Set this field
	 * to 0x14e4 when used for Broadcom internal use when
	 * the naming authority is set to PCI_SIG.
	 */
	uint32_t	oem_id;
	/* The naming authority used for setting the oem_id. */
	uint8_t	naming_authority;
	/* Invalid naming authority */
	#define HWRM_OEM_CMD_INPUT_NAMING_AUTHORITY_INVALID UINT32_C(0x0)
	/* PCI_SIG naming authority numbering is used */
	#define HWRM_OEM_CMD_INPUT_NAMING_AUTHORITY_PCI_SIG UINT32_C(0x1)
	#define HWRM_OEM_CMD_INPUT_NAMING_AUTHORITY_LAST   HWRM_OEM_CMD_INPUT_NAMING_AUTHORITY_PCI_SIG
	/* The message family within the organization. */
	uint8_t	message_family;
	/* Invalid message family */
	#define HWRM_OEM_CMD_INPUT_MESSAGE_FAMILY_INVALID UINT32_C(0x0)
	/* This message is targeted for Truflow */
	#define HWRM_OEM_CMD_INPUT_MESSAGE_FAMILY_TRUFLOW UINT32_C(0x1)
	/* This message is targeted for RoCE */
	#define HWRM_OEM_CMD_INPUT_MESSAGE_FAMILY_ROCE	UINT32_C(0x2)
	#define HWRM_OEM_CMD_INPUT_MESSAGE_FAMILY_LAST   HWRM_OEM_CMD_INPUT_MESSAGE_FAMILY_ROCE
	uint16_t	unused;
	/* This field contains the vendor specific command data. */
	uint32_t	oem_data[26];
} hwrm_oem_cmd_input_t, *phwrm_oem_cmd_input_t;

/* hwrm_oem_cmd_output (size:768b/96B) */

typedef struct hwrm_oem_cmd_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The organization owning the message format. */
	uint32_t	oem_id;
	/* The naming authority used for setting the oem_id. */
	uint8_t	naming_authority;
	/* The message family within the organization. */
	uint8_t	message_family;
	uint16_t	unused;
	/* This field contains the vendor specific response data. */
	uint32_t	oem_data[18];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_oem_cmd_output_t, *phwrm_oem_cmd_output_t;

/***********
 * hwrm_sv *
 ***********/


/* hwrm_sv_input (size:1152b/144B) */

typedef struct hwrm_sv_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	opaque[32];
} hwrm_sv_input_t, *phwrm_sv_input_t;

/* hwrm_sv_output (size:1088b/136B) */

typedef struct hwrm_sv_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	opaque[32];
} hwrm_sv_output_t, *phwrm_sv_output_t;

/*******************
 * hwrm_udcc_qcaps *
 *******************/


/* hwrm_udcc_qcaps_input (size:128b/16B) */

typedef struct hwrm_udcc_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_udcc_qcaps_input_t, *phwrm_udcc_qcaps_input_t;

/* hwrm_udcc_qcaps_output (size:192b/24B) */

typedef struct hwrm_udcc_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents guaranteed minimum number of UDCC sessions
	 * available to the function.
	 */
	uint16_t	min_sessions;
	/*
	 * This field represents unguaranteed maximum number of UDCC sessions
	 * available to the function.
	 */
	uint16_t	max_sessions;
	/*
	 * This value indicates the type of session being modified by the
	 * UDCC.
	 */
	uint8_t	session_type;
	/* sessions are allocated on a per destination basis. */
	#define HWRM_UDCC_QCAPS_OUTPUT_SESSION_TYPE_PER_DESTINATION UINT32_C(0x0)
	/* sessions are allocated on a per QP basis. */
	#define HWRM_UDCC_QCAPS_OUTPUT_SESSION_TYPE_PER_QP	UINT32_C(0x1)
	#define HWRM_UDCC_QCAPS_OUTPUT_SESSION_TYPE_LAST	HWRM_UDCC_QCAPS_OUTPUT_SESSION_TYPE_PER_QP
	uint8_t	unused_0[3];
	/*
	 * This field represents the maximum number of bytes of UDCC program
	 * configuration data that one hwrm_udcc_comp_cfg request or
	 * hwrm_udcc_comp_qcfg response can transfer.
	 * The value is determined by the UDCC firmware.
	 */
	uint16_t	max_comp_cfg_xfer;
	/*
	 * This field represents the maximum number of bytes of UDCC program
	 * status or statistics data that one hwrm_udcc_comp_query response
	 * can transfer. The value is determined by the UDCC firmware.
	 */
	uint16_t	max_comp_data_xfer;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_qcaps_output_t, *phwrm_udcc_qcaps_output_t;

/*****************
 * hwrm_udcc_cfg *
 *****************/


/* hwrm_udcc_cfg_input (size:192b/24B) */

typedef struct hwrm_udcc_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the udcc_mode field to be
	 * configured.
	 */
	#define HWRM_UDCC_CFG_INPUT_ENABLES_UDCC_MODE	UINT32_C(0x1)
	/* UDCC mode for this function. */
	uint8_t	udcc_mode;
	/* UDCC is not enabled. */
	#define HWRM_UDCC_CFG_INPUT_UDCC_MODE_DISABLED UINT32_C(0x0)
	/* UDCC is enabled. */
	#define HWRM_UDCC_CFG_INPUT_UDCC_MODE_ENABLED  UINT32_C(0x1)
	#define HWRM_UDCC_CFG_INPUT_UDCC_MODE_LAST	HWRM_UDCC_CFG_INPUT_UDCC_MODE_ENABLED
	uint8_t	unused_1[3];
} hwrm_udcc_cfg_input_t, *phwrm_udcc_cfg_input_t;

/* hwrm_udcc_cfg_output (size:128b/16B) */

typedef struct hwrm_udcc_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_cfg_output_t, *phwrm_udcc_cfg_output_t;

/******************
 * hwrm_udcc_qcfg *
 ******************/


/* hwrm_udcc_qcfg_input (size:128b/16B) */

typedef struct hwrm_udcc_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_udcc_qcfg_input_t, *phwrm_udcc_qcfg_input_t;

/* hwrm_udcc_qcfg_output (size:128b/16B) */

typedef struct hwrm_udcc_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* UDCC mode for this function. */
	uint8_t	udcc_mode;
	uint8_t	unused_1[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_qcfg_output_t, *phwrm_udcc_qcfg_output_t;

/*************************
 * hwrm_udcc_session_cfg *
 *************************/


/* hwrm_udcc_session_cfg_input (size:384b/48B) */

typedef struct hwrm_udcc_session_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/* This bit must be '1' for the session_state to be configured. */
	#define HWRM_UDCC_SESSION_CFG_INPUT_ENABLES_SESSION_STATE	UINT32_C(0x1)
	/* This bit must be '1' for the dest_mac to be configured. */
	#define HWRM_UDCC_SESSION_CFG_INPUT_ENABLES_DEST_MAC		UINT32_C(0x2)
	/* This bit must be '1' for the src_mac to be configured. */
	#define HWRM_UDCC_SESSION_CFG_INPUT_ENABLES_SRC_MAC		UINT32_C(0x4)
	/* This bit must be '1' for the tx_stats_record to be configured. */
	#define HWRM_UDCC_SESSION_CFG_INPUT_ENABLES_TX_STATS_RECORD	UINT32_C(0x8)
	/* This bit must be '1' for the rx_stats_record to be configured. */
	#define HWRM_UDCC_SESSION_CFG_INPUT_ENABLES_RX_STATS_RECORD	UINT32_C(0x10)
	/* State to configure for the session. */
	uint8_t	session_state;
	/*
	 * This bit is set if the session is to be enabled and have firmware
	 * querying it for events. The bit is cleared if the session is to
	 * be disabled in firmware.
	 */
	#define HWRM_UDCC_SESSION_CFG_INPUT_SESSION_STATE_ENABLED		UINT32_C(0x1)
	/* UDCC flow is not created in driver. */
	#define HWRM_UDCC_SESSION_CFG_INPUT_SESSION_STATE_FLOW_NOT_CREATED	UINT32_C(0x2)
	/* UDCC flow is now deleted in driver. */
	#define HWRM_UDCC_SESSION_CFG_INPUT_SESSION_STATE_FLOW_HAS_BEEN_DELETED	UINT32_C(0x4)
	uint8_t	unused_1;
	/* A handle for the session to be configured, if previously allocated. */
	uint16_t	session_id;
	/* destination mac address used for the session. */
	uint8_t	dest_mac[6];
	uint16_t	unused_2;
	/* source mac address used for the session. */
	uint8_t	src_mac[6];
	uint16_t	unused_3;
	/*
	 * address for the tx flow statistics record to be sampled by the
	 * UDCC firmware. Session must be disabled to take effect.
	 */
	uint32_t	tx_stats_record;
	/*
	 * address for the rx flow statistics record to be sampled by the
	 * UDCC firmware. Session must be disabled to take effect.
	 */
	uint32_t	rx_stats_record;
} hwrm_udcc_session_cfg_input_t, *phwrm_udcc_session_cfg_input_t;

/* hwrm_udcc_session_cfg_output (size:128b/16B) */

typedef struct hwrm_udcc_session_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_session_cfg_output_t, *phwrm_udcc_session_cfg_output_t;

/**************************
 * hwrm_udcc_session_qcfg *
 **************************/


/* hwrm_udcc_session_qcfg_input (size:192b/24B) */

typedef struct hwrm_udcc_session_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* A handle for the session to be queried, if previously allocated. */
	uint16_t	session_id;
	uint8_t	unused_0[6];
} hwrm_udcc_session_qcfg_input_t, *phwrm_udcc_session_qcfg_input_t;

/* hwrm_udcc_session_qcfg_output (size:512b/64B) */

typedef struct hwrm_udcc_session_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* session_state specifying configuration of the session. */
	uint8_t	session_state;
	/*
	 * This bit is set if the session is enabled and firmware is
	 * querying it for events. The bit is cleared if no querying
	 * should occur for this session.
	 */
	#define HWRM_UDCC_SESSION_QCFG_OUTPUT_SESSION_STATE_ENABLED		UINT32_C(0x1)
	/* UDCC flow is not created in driver. */
	#define HWRM_UDCC_SESSION_QCFG_OUTPUT_SESSION_STATE_FLOW_NOT_CREATED	UINT32_C(0x2)
	/* UDCC flow is now deleted in driver. */
	#define HWRM_UDCC_SESSION_QCFG_OUTPUT_SESSION_STATE_FLOW_HAS_BEEN_DELETED	UINT32_C(0x4)
	uint8_t	unused_0;
	/* destination mac address used for the session. */
	uint8_t	dest_mac[6];
	/*
	 * a 4 byte or 16 byte IP address, depending on whether the ip_type
	 * specifies IPv4 or IPv6. For IPv4 addresses, the first 4 bytes of the
	 * 16 byte field are used; the remaining 12 bytes are not used.
	 */
	uint32_t	dest_ip[4];
	uint8_t	unused_1[2];
	/* source mac address used for the session. */
	uint8_t	src_mac[6];
	/* source QP number used for the session. */
	uint32_t	src_qp_num;
	/* destination QP number used for the session. */
	uint32_t	dest_qp_num;
	/*
	 * address for the tx flow statistics record to be sampled by the
	 * UDCC firmware.
	 */
	uint32_t	tx_stats_record;
	/*
	 * address for the rx flow statistics record to be sampled by the
	 * UDCC firmware.
	 */
	uint32_t	rx_stats_record;
	uint8_t	unused_2[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_session_qcfg_output_t, *phwrm_udcc_session_qcfg_output_t;

/***************************
 * hwrm_udcc_session_query *
 ***************************/


/* hwrm_udcc_session_query_input (size:192b/24B) */

typedef struct hwrm_udcc_session_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* A handle for the session to be queried, if previously allocated. */
	uint16_t	session_id;
	uint8_t	unused_0[6];
} hwrm_udcc_session_query_input_t, *phwrm_udcc_session_query_input_t;

/* hwrm_udcc_session_query_output (size:640b/80B) */

typedef struct hwrm_udcc_session_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* field for the minimum RTT value (in ns) for the session. */
	uint32_t	min_rtt_ns;
	/* field for the maximum RTT value (in ns) for the session. */
	uint32_t	max_rtt_ns;
	/*
	 * field for the current configured rate (in Mbps) for the
	 * session.
	 */
	uint32_t	cur_rate_mbps;
	/*
	 * count for the number of events sent from FW to the UDCC
	 * program.
	 */
	uint32_t	tx_event_count;
	/*
	 * count for the number of CNP events sent from FW to the UDCC
	 * program.
	 */
	uint32_t	cnp_rx_event_count;
	/*
	 * count for the number of RTT request events received by the FW from
	 * the UDCC program.
	 */
	uint32_t	rtt_req_count;
	/*
	 * count for the number of RTT response events sent by the FW to the
	 * UDCC program.
	 */
	uint32_t	rtt_resp_count;
	/* count for the number of bytes transmitted for the session. */
	uint32_t	tx_bytes_count;
	/* count for the number of packets transmitted for the session. */
	uint32_t	tx_packets_count;
	/* count of initiator probes transmitted for the session. */
	uint32_t	init_probes_sent;
	/* count of terminator probes received for the session. */
	uint32_t	term_probes_recv;
	/* count of CNP packets received for the session. */
	uint32_t	cnp_packets_recv;
	/* count of retransmission timeout events received for the session. */
	uint32_t	rto_event_recv;
	/* count of sequence error NAK events received for the session. */
	uint32_t	seq_err_nak_recv;
	/* the current number of qps associated with the session. */
	uint32_t	qp_count;
	/* count for the number of Tx events detected for the session. */
	uint32_t	tx_event_detect_count;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_session_query_output_t, *phwrm_udcc_session_query_output_t;

/**********************
 * hwrm_udcc_comp_cfg *
 **********************/


/* hwrm_udcc_comp_cfg_input (size:576b/72B) */

typedef struct hwrm_udcc_comp_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This field holds the configuration arguments, which can be used
	 * to specify the context of the configuration data, e.g. type,
	 * session ID, etc. It is possible not all arg_buf are utilized.
	 * The format and meaning of the arguments are internal to
	 * the UDCC program.
	 */
	uint8_t	arg_buf[40];
	/*
	 * This field specifies the number of bytes in arg_buf that are
	 * configuration arguments. It can be zero if there are no arguments.
	 */
	uint32_t	arg_len;
	/*
	 * This field specifies the length of the configuration data
	 * stored in the host memory. The host driver shall guarantee
	 * this number is not greater than the maximum configuration
	 * transfer size that is specified by the max_comp_cfg_xfer
	 * field of hwrm_udcc_qcaps_output.
	 */
	uint32_t	cfg_len;
	/*
	 * This field specifies the address of the host memory where
	 * the configuration data is stored. The format and meaning of
	 * the configuration data are internal to the UDCC program.
	 */
	uint64_t	cfg_host_addr;
} hwrm_udcc_comp_cfg_input_t, *phwrm_udcc_comp_cfg_input_t;

/* hwrm_udcc_comp_cfg_output (size:128b/16B) */

typedef struct hwrm_udcc_comp_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_comp_cfg_output_t, *phwrm_udcc_comp_cfg_output_t;

/***********************
 * hwrm_udcc_comp_qcfg *
 ***********************/


/* hwrm_udcc_comp_qcfg_input (size:576b/72B) */

typedef struct hwrm_udcc_comp_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This field holds the query arguments, which can be used to
	 * specify the context of the query, e.g. type, session ID, etc.
	 * It is possible not all arg_buf are utilized.
	 * The format and meaning of the arguments are internal to
	 * the UDCC program.
	 */
	uint8_t	arg_buf[40];
	/*
	 * This field specifies the number of bytes in arg_buf that are
	 * query arguments. It can be zero if there are no arguments.
	 */
	uint32_t	arg_len;
	/*
	 * This field specifies the size of the buffer in the host memory
	 * for receiving the configuration data. The host driver shall
	 * guarantee the size of the buffer is not smaller than
	 * the maximum configuration transfer size that is specified by
	 * the max_comp_cfg_xfer field of hwrm_udcc_qcaps_output.
	 */
	uint32_t	cfg_host_buf_size;
	/*
	 * This field specifies the address of the host memory where
	 * the queried configuration to be stored.
	 */
	uint64_t	cfg_host_addr;
} hwrm_udcc_comp_qcfg_input_t, *phwrm_udcc_comp_qcfg_input_t;

/* hwrm_udcc_comp_qcfg_output (size:128b/16B) */

typedef struct hwrm_udcc_comp_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field specifies the length of configuration data transferred
	 * into the host memory. The amount of data transferred is up to
	 * the maximum configuration transfer size that is specified by
	 * the max_comp_cfg_xfer field of hwrm_udcc_qcaps_output.
	 */
	uint32_t	cfg_len;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_comp_qcfg_output_t, *phwrm_udcc_comp_qcfg_output_t;

/************************
 * hwrm_udcc_comp_query *
 ************************/


/* hwrm_udcc_comp_query_input (size:576b/72B) */

typedef struct hwrm_udcc_comp_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This field holds the query arguments, which can be used to
	 * specify the context of the query, e.g. type, session ID, etc.
	 * It is possible not all arg_buf are utilized.
	 * The format and meaning of the arguments are internal to
	 * the UDCC program.
	 */
	uint8_t	arg_buf[40];
	/*
	 * This field specifies the number of bytes in arg_buf that are
	 * query arguments. It can be zero if there are no arguments.
	 */
	uint32_t	arg_len;
	/*
	 * This field specifies the size of the buffer in the host memory
	 * for receiving the status or statistics data. The host driver
	 * shall guarantee the size of the buffer is not smaller than
	 * the maximum data transfer size that is specified by
	 * the max_comp_data_xfer field of hwrm_udcc_qcaps_output.
	 */
	uint32_t	data_host_buf_size;
	/*
	 * This field specifies the address of the host memory where
	 * the queried data to be stored.
	 */
	uint64_t	data_host_addr;
} hwrm_udcc_comp_query_input_t, *phwrm_udcc_comp_query_input_t;

/* hwrm_udcc_comp_query_output (size:128b/16B) */

typedef struct hwrm_udcc_comp_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field specifies the length of status or statistics data
	 * transferred into the host memory. The amount of data transferred
	 * is up to the maximum data transfer size that is specified by
	 * the max_comp_data_xfer field of hwrm_udcc_qcaps_output.
	 */
	uint32_t	data_len;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_udcc_comp_query_output_t, *phwrm_udcc_comp_query_output_t;

#endif /* _HSI_STRUCT_DEF_H_ */
