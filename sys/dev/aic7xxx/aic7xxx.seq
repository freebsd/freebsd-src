/*+M***********************************************************************
 *Adaptec 274x/284x/294x device driver for Linux and FreeBSD.
 *
 *Copyright (c) 1994 John Aycock
 *  The University of Calgary Department of Computer Science.
 *  All rights reserved.
 *
 *FreeBSD, Twin, Wide, 2 command per target support, tagged queuing,
 *SCB paging and other optimizations:
 *Copyright (c) 1994, 1995, 1996 Justin Gibbs. All rights reserved.
 *
 *Redistribution and use in source and binary forms, with or without
 *modification, are permitted provided that the following conditions
 *are met:
 *1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions, and the following disclaimer.
 *2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *3. All advertising materials mentioning features or use of this software
 *   must display the following acknowledgement:
 *     This product includes software developed by the University of Calgary
 *     Department of Computer Science and its contributors.
 *4. Neither the name of the University nor the names of its contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 *ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *SUCH DAMAGE.
 *
 *-M************************************************************************/

VERSION AIC7XXX_SEQ_VER "$Id: aic7xxx.seq,v 1.45 1996/10/28 06:01:07 gibbs Exp $"

#if defined(__NetBSD__)
#include "../../../../dev/ic/aic7xxxreg.h"
#include "../../../../scsi/scsi_message.h"
#elif defined(__FreeBSD__)
#include "../../dev/aic7xxx/aic7xxx_reg.h"
#include "../../scsi/scsi_message.h"
#endif

/*
 * We can't just use ACCUM in the sequencer code because it
 * must be treated specially by the assembler, and it currently
 * looks for the symbol 'A'.  This is the only register defined in
 * the assembler's symbol space.
 */
A = ACCUM

/*
 * A few words on the waiting SCB list:
 * After starting the selection hardware, we check for reconnecting targets
 * as well as for our selection to complete just in case the reselection wins
 * bus arbitration.  The problem with this is that we must keep track of the
 * SCB that we've already pulled from the QINFIFO and started the selection
 * on just in case the reselection wins so that we can retry the selection at
 * a later time.  This problem cannot be resolved by holding a single entry
 * in scratch ram since a reconnecting target can request sense and this will
 * create yet another SCB waiting for selection.  The solution used here is to 
 * use byte 27 of the SCB as a psuedo-next pointer and to thread a list
 * of SCBs that are awaiting selection.  Since 0-0xfe are valid SCB indexes, 
 * SCB_LIST_NULL is 0xff which is out of range.  An entry is also added to
 * this list everytime a request sense occurs or after completing a non-tagged
 * command for which a second SCB has been queued.  The sequencer will
 * automatically consume the entries.
 */

/*
 * We assume that the kernel driver may reset us at any time, even in the
 * middle of a DMA, so clear DFCNTRL too.
 */
reset:
	clr	DFCNTRL
	clr	SCSISIGO		/* De-assert BSY */
/*
 * We jump to start after every bus free.
 */
start:
	and	FLAGS,0x07		/* clear target specific flags */
	mvi	SCSISEQ,ENRSELI		/* Always allow reselection */
	clr	SCSIRATE		/*
					 * We don't know the target we will
					 * connect to, so default to narrow
					 * transfers to avoid parity problems.
					 */
poll_for_work:
	/*
	 * Are we a twin channel device?
	 * For fairness, we check the other bus first,
	 * since we just finished a transaction on the
	 * current channel.
	 */
	test	FLAGS,TWIN_BUS	jz start2
	xor	SBLKCTL,SELBUSB			/* Toggle to the other bus */
	test	SSTAT0,SELDI	jnz reselect
	xor	SBLKCTL,SELBUSB			/* Toggle to the original bus */
start2:
	test	SSTAT0,SELDI	jnz reselect
	cmp	WAITING_SCBH,SCB_LIST_NULL je test_queue
start_waiting:
	/*
	 * Pull the first entry off of the waiting SCB list
	 * We don't have to "test_busy" because only transactions that
	 * have passed that test can be in the WAITING_SCB list.
	 */
	mov	SCBPTR,WAITING_SCBH
	jmp	start_scb2
test_queue:
	/* Has the driver posted any work for us? */
	mov	A, QCNTMASK
	test	QINCNT,A	jz poll_for_work

/*
 * We have at least one queued SCB now and we don't have any 
 * SCBs in the list of SCBs awaiting selection.  If we have
 * any SCBs availible for use, pull the tag from the QINFIFO
 * and get to work on it.
 */
	test	FLAGS, PAGESCBS	jz	dequeue_scb
	call	get_free_or_disc_scb
	cmp	SINDEX, SCB_LIST_NULL	je poll_for_work
dequeue_scb:
	mov	CUR_SCBID,QINFIFO
	test	FLAGS, PAGESCBS jnz dma_queued_scb
	/* In the non-paging case, the SCBID == hardware SCB index */
	mov	SCBPTR, CUR_SCBID
dma_queued_scb:
/*
 * DMA the SCB from host ram into the current SCB location.
 */
	mvi	DMAPARAMS, 0xd	/* HDMAEN|DIRECTION|FIFORESET */
	mov	CUR_SCBID	call dma_scb

/*
 * See if there is not already an active SCB for this target.  This code
 * locks out on a per target basis instead of target/lun.  Although this
 * is not ideal for devices that have multiple luns active at the same
 * time, it is faster than looping through all SCB's looking for active
 * commands.  We also don't have enough spare SCB space for to store the
 * SCBID of the currently busy transaction for each target/lun making it
 * impossible to link up the SCBs.
 */
test_busy:
	test	SCB_CONTROL, TAG_ENB	jnz start_scb
	mov	SAVED_SCBPTR, SCBPTR
	mov	SCB_TCL		call	index_untagged_scb
	mov	ARG_1, SINDIR			/*
						 * ARG_1 should
						 * now have the SCB ID of
						 * any active, non-tagged,
						 * command for this target.
						 */
	cmp	ARG_1, SCB_LIST_NULL je make_busy
	test	FLAGS, PAGESCBS jz simple_busy_link
	/*
	 * Put this SCB back onto the free list.  It
	 * may be necessary to satisfy the search for
	 * the active SCB.
	 */
	mov	SCBPTR, SAVED_SCBPTR
	call	add_scb_to_free_list
	/* Find the active SCB */
	mov	ALLZEROS	call findSCB
	/*
	 * If we couldn't find it, tell the kernel.  This should
	 * only happen if the parent SCB was aborted and this
	 * one was already here at the time of the abort.
	 */
	cmp	SINDEX, SCB_LIST_NULL	jne paged_busy_link
	mvi	INTSTAT, NO_MATCH_BUSY
paged_busy_link:
	/* Link us in */
	mov	SCB_LINKED_NEXT, CUR_SCBID 
	/* Put it back on the disconnected list */
	call	add_scb_to_disc_list
	jmp	poll_for_work
simple_busy_link:
	mov	SCBPTR, ARG_1
	mov	SCB_LINKED_NEXT, CUR_SCBID 
	jmp	poll_for_work
make_busy:
	mov	DINDIR, CUR_SCBID
	mov	SCBPTR, SAVED_SCBPTR

start_scb:
	/*
	 * Place us on the waiting list in case our selection
	 * doesn't win during bus arbitration.
	 */
	mov	SCB_NEXT,WAITING_SCBH
	mov	WAITING_SCBH, SCBPTR
start_scb2:
	and	SINDEX,0xf7,SBLKCTL	/* Clear the channel select bit */
	and	A,0x08,SCB_TCL		/* Get new channel bit */
	or	SINDEX,A
	mov	SBLKCTL,SINDEX		/* select channel */
	mov	SCB_TCL	call initialize_scsiid

/*
 * Enable selection phase as an initiator, and do automatic ATN
 * after the selection.  We do this now so that we can overlap the
 * rest of our work to set up this target with the arbitration and
 * selection bus phases.
 */
start_selection:
	mvi	SCSISEQ,0x58		/* ENSELO|ENAUTOATNO|ENRSELI */

/*
 * As soon as we get a successful selection, the target should go
 * into the message out phase since we have ATN asserted.  Prepare
 * the message to send.
 *
 * Messages are stored in scratch RAM starting with a length byte
 * followed by the message itself.
 */

mk_identify:
	and	MSG0,0x7,SCB_TCL	/* lun */
	and	A,DISCENB,SCB_CONTROL	/* mask off disconnect privledge */
	or	MSG0,A			/* or in disconnect privledge */
	or	MSG0,MSG_IDENTIFYFLAG
	mvi	MSG_LEN, 1

/*
 * Send a tag message if TAG_ENB is set in the SCB control block.
 * Use SCB_TAG (the position in the kernel's SCB array) as the tag value.
 */
mk_tag:
	test	SCB_CONTROL,TAG_ENB jz  mk_message
	and	MSG1,0x23,SCB_CONTROL
	mov	MSG2,SCB_TAG
	add	MSG_LEN,2	/* update message length */

/*
 * Interrupt the driver, and allow it to tweak the message buffer
 * if it asks.
 */
mk_message:
	test	SCB_CONTROL,MK_MESSAGE  jz wait_for_selection

	mvi     INTSTAT,AWAITING_MSG

wait_for_selection:
	test	SSTAT0,SELDO	jnz select 
	test	SSTAT0,SELDI	jz wait_for_selection

/*
 * Reselection has been initiated by a target. Make a note that we've been
 * reselected, but haven't seen an IDENTIFY message from the target yet.
 */
reselect:
	clr	MSG_LEN		/* Don't have anything in the mesg buffer */
	mov	SELID		call initialize_scsiid
	or	FLAGS,RESELECTED
	jmp	select2

/*
 * After the selection, remove this SCB from the "waiting SCB"
 * list.  This is achieved by simply moving our "next" pointer into
 * WAITING_SCBH.  Our next pointer will be set to null the next time this
 * SCB is used, so don't bother with it now.
 */
select:
	mov	WAITING_SCBH,SCB_NEXT
select2:
/*
 * Initialize SCSIRATE with the appropriate value for this target.
 * The SCSIRATE settings for each target are stored in an array
 * based at TARG_SCRATCH.
 */
ndx_dtr:
	shr	A,SCSIID,4
	test	SBLKCTL,SELBUSB	jz ndx_dtr_2
	or	SAVED_TCL, SELBUSB /* Add the channel bit while we're here */
	or	A,0x08		/* Channel B entries add 8 */
ndx_dtr_2:
	add	SINDEX,TARG_SCRATCH,A
	mov	SCSIRATE,SINDIR

/*
 * Initialize Ultra mode setting and clear the SCSI channel.
 */
ultra:
	and	DINDEX,0xdf,SXFRCTL0            /* default to Ultra disabled */
	/*
	 * Set CLRCHN here before the target has entered a data transfer mode -
	 * with synchronous SCSI, if you do it later, you blow away some
	 * data in the SCSI FIFO that the target has already sent to you.
	 */
	or	DINDEX, CLRCHN
	mvi	SINDEX, ULTRA_ENB_B
	test	SCSIID, 0x80     jnz ultra_2     /* Target ID > 7 */
	test	SBLKCTL, SELBUSB jnz ultra_2     /* Second channel device */
	dec	SINDEX
ultra_2:
	mov     FUNCTION1,SCSIID 
	mov     A,FUNCTION1
	test	SINDIR, A	jz set_sxfrctl0
	or	DINDEX, ULTRAEN
 
set_sxfrctl0:
	mov	SXFRCTL0,DINDEX

	mvi	SCSISEQ,ENAUTOATNP		/*
						 * ATN on parity errors
						 * for "in" phases
						 */
	mvi	CLRSINT1,CLRBUSFREE
	mvi	CLRSINT0,0x60			/* CLRSELDI|CLRSELDO */
/*
 * Main loop for information transfer phases.  If BSY is false, then
 * we have a bus free condition, expected or not.  Otherwise, wait
 * for the target to assert REQ before checking MSG, C/D and I/O
 * for the bus phase.
 *
 */
ITloop:
	test	SSTAT1,BUSFREE	jnz p_busfree
	test	SSTAT1,REQINIT	jz ITloop

	and	A,PHASE_MASK,SCSISIGI
	mov	LASTPHASE,A
	mov	SCSISIGO,A

	cmp	ALLZEROS,A	je p_dataout
	cmp	A,P_DATAIN	je p_datain
	cmp	A,P_COMMAND	je p_command
	cmp	A,P_MESGOUT	je p_mesgout
	cmp	A,P_STATUS	je p_status
	cmp	A,P_MESGIN	je p_mesgin

	mvi	INTSTAT,BAD_PHASE	/* unknown phase - signal driver */
	jmp	ITloop			/* Try reading the bus again. */

p_dataout:
	mvi	DMAPARAMS,0x7d			/*
						 * WIDEODD|SCSIEN|SDMAEN|HDMAEN|
						 * DIRECTION|FIFORESET
						 */
	jmp	data_phase_init

/*
 * If we re-enter the data phase after going through another phase, the
 * STCNT may have been cleared, so restore it from the residual field.
 */
data_phase_reinit:
	mvi	DINDEX, STCNT0
	mvi	SCB_RESID_DCNT0	call bcopy_3
	jmp	data_phase_loop

p_datain:
	mvi	DMAPARAMS,0x79		/*
					 * WIDEODD|SCSIEN|SDMAEN|HDMAEN|
					 * !DIRECTION|FIFORESET
					 */
data_phase_init:
	call	assert			/*
					 * Ensure entering a data
					 * phase is okay - seen identify, etc.
					 */

	test	FLAGS, DPHASE	jnz data_phase_reinit

	/*
	 * Initialize the DMA address and counter from the SCB.
	 * Also set SG_COUNT and SG_NEXT in memory since we cannot
	 * modify the values in the SCB itself until we see a
	 * save data pointers message.
	 */
	mvi	DINDEX, HADDR0
	mvi	SCB_DATAPTR	call bcopy_7

	call	set_stcnt_from_hcnt

	mov	SG_COUNT,SCB_SGCOUNT

	mvi	DINDEX, SG_NEXT
	mvi	SCB_SGPTR	call bcopy_4

	/* We have seen a data phase */
	or	FLAGS, DPHASE

data_phase_loop:
/* Guard against overruns */
	test	SG_COUNT, 0xff jnz data_phase_inbounds
/*
 * Turn on 'Bit Bucket' mode, set the transfer count to
 * 16meg and let the target run until it changes phase.
 * When the transfer completes, notify the host that we
 * had an overrun.
 */
	or	SXFRCTL1,BITBUCKET
	mvi	STCNT0,0xff
	mvi	STCNT1,0xff
	mvi	STCNT2,0xff

data_phase_inbounds:
/* If we are the last SG block, ensure wideodd is off. */
	cmp	SG_COUNT,0x01 jne data_phase_wideodd
	and	DMAPARAMS, 0xbf		/* Turn off WIDEODD */
data_phase_wideodd:
	mov	DMAPARAMS  call dma

/* Go tell the host about any overruns */
	test	SXFRCTL1,BITBUCKET jnz data_phase_overrun

/* Exit if we had an underrun */
	test	SSTAT0,SDONE	jz data_phase_finish /* underrun STCNT != 0 */

/*
 * Advance the scatter-gather pointers if needed 
 */
sg_advance:
	dec	SG_COUNT	/* one less segment to go */

	test	SG_COUNT, 0xff	jz data_phase_finish /* Are we done? */

	clr	A			/* add sizeof(struct scatter) */
	add	SG_NEXT0,SG_SIZEOF,SG_NEXT0
	adc	SG_NEXT1,A,SG_NEXT1

/*
 * Load a struct scatter and set up the data address and length.
 * If the working value of the SG count is nonzero, then
 * we need to load a new set of values.
 *
 * This, like all DMA's, assumes little-endian host data storage.
 */
sg_load:
	clr	HCNT2
	clr	HCNT1
	mvi	HCNT0,SG_SIZEOF

	mvi	DINDEX, HADDR0
	mvi	SG_NEXT0	call bcopy_4

	or	DFCNTRL,0xd			/* HDMAEN|DIRECTION|FIFORESET */

	call	dma_finish

/*
 * Copy data from FIFO into SCB data pointer and data count.  This assumes
 * that the SG segments are of the form:
 *
 * struct ahc_dma_seg {
 *	u_int32_t	addr;		four bytes, little-endian order
 *	u_int32_t	len;		four bytes, little endian order
 * };
 */
	mvi	HADDR0	call dfdat_in_7

/* Load STCNT as well.  It is a mirror of HCNT */
	call	set_stcnt_from_hcnt
	test	SSTAT1,PHASEMIS  jz data_phase_loop

data_phase_finish:
/*
 * After a DMA finishes, save the SG and STCNT residuals back into the SCB
 * We use STCNT instead of HCNT, since it's a reflection of how many bytes 
 * were transferred on the SCSI (as opposed to the host) bus.
 */
	mov	SCB_RESID_DCNT0,STCNT0
	mov	SCB_RESID_DCNT1,STCNT1
	mov	SCB_RESID_DCNT2,STCNT2
	mov	SCB_RESID_SGCNT, SG_COUNT
	jmp	ITloop

data_phase_overrun:
/*
 * Turn off BITBUCKET mode and notify the host
 */
	and	SXFRCTL1,0x7f		/* ~BITBUCKET */
	mvi	INTSTAT,DATA_OVERRUN
	jmp	ITloop

/*
 * Command phase.  Set up the DMA registers and let 'er rip.
 */
p_command:
	call	assert

/*
 * Load HADDR and HCNT.
 */
	mvi	DINDEX, HADDR0
	mvi	SCB_CMDPTR	call bcopy_5
	clr	HCNT1
	clr	HCNT2

	call	set_stcnt_from_hcnt

	mvi	0x3d		call dma	# SCSIEN|SDMAEN|HDMAEN|
						#   DIRECTION|FIFORESET
	jmp	ITloop

/*
 * Status phase.  Wait for the data byte to appear, then read it
 * and store it into the SCB.
 */
p_status:
	mvi	SCB_TARGET_STATUS	call inb_first
	jmp	mesgin_done

/*
 * Message out phase.  If there is not an active message, but the target
 * took us into this phase anyway, build a no-op message and send it.
 */
p_mesgout:
	test	MSG_LEN, 0xff	jnz  p_mesgout_start
	mvi	MSG_NOOP	call mk_mesg	/* build NOP message */
p_mesgout_start:
/*
 * Set up automatic PIO transfer from MSG0.  Bit 3 in
 * SXFRCTL0 (SPIOEN) is already on.
 */
	mvi	SINDEX,MSG0
	mov	DINDEX,MSG_LEN

/*
 * When target asks for a byte, drop ATN if it's the last one in
 * the message.  Otherwise, keep going until the message is exhausted.
 *
 * Keep an eye out for a phase change, in case the target issues
 * a MESSAGE REJECT.
 */
p_mesgout_loop:
	test	SSTAT1,PHASEMIS	jnz p_mesgout_phasemis
	test	SSTAT0,SPIORDY	jz p_mesgout_loop
	test	SSTAT1,PHASEMIS	jnz p_mesgout_phasemis
	cmp	DINDEX,1	jne p_mesgout_outb	/* last byte? */
	mvi	CLRSINT1,CLRATNO			/* drop ATN */
p_mesgout_outb:
	dec	DINDEX
	or	CLRSINT0, CLRSPIORDY
	mov	SCSIDATL,SINDIR
	
p_mesgout4:
	test	DINDEX,0xff	jnz p_mesgout_loop

/*
 * If the next bus phase after ATN drops is a message out, it means
 * that the target is requesting that the last message(s) be resent.
 */
p_mesgout_snoop:
	test	SSTAT1,BUSFREE	jnz p_mesgout_done
	test	SSTAT1,REQINIT	jz p_mesgout_snoop

	test	SSTAT1,PHASEMIS	jnz p_mesgout_done

	or	SCSISIGO,ATNO			/* turn on ATNO */

	jmp	ITloop

p_mesgout_phasemis:
	mvi	CLRSINT1,CLRATNO	/* Be sure to turn ATNO off */
p_mesgout_done:
	clr	MSG_LEN			/* no active msg */
	jmp	ITloop

/*
 * Message in phase.  Bytes are read using Automatic PIO mode.
 */
p_mesgin:
	mvi	A		call inb_first	/* read the 1st message byte */
	mov	REJBYTE,A			/* save it for the driver */

	test	A,MSG_IDENTIFYFLAG	jnz mesgin_identify
	cmp	A,MSG_DISCONNECT	je mesgin_disconnect
	cmp	A,MSG_SAVEDATAPOINTER	je mesgin_sdptrs
	cmp	ALLZEROS,A		je mesgin_complete
	cmp	A,MSG_RESTOREPOINTERS	je mesgin_rdptrs
	cmp	A,MSG_EXTENDED		je mesgin_extended
	cmp	A,MSG_MESSAGE_REJECT	je mesgin_reject

rej_mesgin:
/*
 * We have no idea what this message in is, so we issue a message reject
 * and hope for the best.  In any case, rejection should be a rare
 * occurrence - signal the driver when it happens.
 */
	or	SCSISIGO,ATNO			/* turn on ATNO */
	mvi	INTSTAT,SEND_REJECT		/* let driver know */

	mvi	MSG_MESSAGE_REJECT	call mk_mesg

mesgin_done:
	call	inb_last			/*ack & turn auto PIO back on*/
	jmp	ITloop


mesgin_complete:
/*
 * We got a "command complete" message, so put the SCB_TAG into the QOUTFIFO,
 * and trigger a completion interrupt.  Before doing so, check to see if there
 * is a residual or the status byte is something other than NO_ERROR (0).  In
 * either of these conditions, we upload the SCB back to the host so it can
 * process this information.  In the case of a non zero status byte, we 
 * additionally interrupt the kernel driver synchronously, allowing it to
 * decide if sense should be retrieved.  If the kernel driver wishes to request
 * sense, it will fill the kernel SCB with a request sense command and set
 * RETURN_1 to SEND_SENSE.  If RETURN_1 is set to SEND_SENSE we redownload
 * the SCB, and process it as the next command by adding it to the waiting list.
 * If the kernel driver does not wish to request sense, it need only clear
 * RETURN_1, and the command is allowed to complete normally.  We don't bother
 * to post to the QOUTFIFO in the error cases since it would require extra
 * work in the kernel driver to ensure that the entry was removed before the
 * command complete code tried processing it.
 */

/*
 * First check for residuals
 */
	test	SCB_RESID_SGCNT,0xff	jnz upload_scb
	test	SCB_TARGET_STATUS,0xff	jz status_ok	/* Good Status? */
upload_scb:
	mvi	DMAPARAMS, 0x9	/* HDMAEN | FIFORESET*/
	mov	SCB_TAG		call dma_scb
check_status:
	test	SCB_TARGET_STATUS,0xff	jz status_ok	/* Just a residual? */
	mvi	INTSTAT,BAD_STATUS			/* let driver know */
	cmp	RETURN_1, SEND_SENSE	jne status_ok
	/* This SCB becomes the next to execute as it will retrieve sense */
	mov	SCB_LINKED_NEXT, SCB_TAG
	jmp	dma_next_scb

status_ok:
/* First, mark this target as free. */
	test	SCB_CONTROL,TAG_ENB jnz test_immediate	/*
							 * Tagged commands
							 * don't busy the
							 * target.
							 */
	mov	SAVED_SCBPTR, SCBPTR
	mov	SAVED_LINKPTR, SCB_LINKED_NEXT
	mov	SCB_TCL		call	index_untagged_scb
	mov	DINDIR, SAVED_LINKPTR
	mov	SCBPTR, SAVED_SCBPTR

test_immediate:
	test    SCB_CMDLEN,0xff jnz complete  /* Immediate message complete */
/*
 * Pause the sequencer until the driver gets around to handling the command
 * complete.  This is so that any action that might require carefull timing
 * with the completion of this command can occur.
 */
	mvi	INTSTAT,IMMEDDONE
	jmp	dma_next_scb
complete:
	/* Post the SCB and issue an interrupt */
	mov	QOUTFIFO,SCB_TAG
	mvi	INTSTAT,CMDCMPLT

dma_next_scb:
	cmp	SCB_LINKED_NEXT, SCB_LIST_NULL	je mesgin_done
	test	FLAGS, PAGESCBS jnz dma_next_scb2
	/* Only DMA on top of ourselves if we are the SCB to download */
	mov	A, SCB_LINKED_NEXT
	cmp	SCB_TAG, A	je dma_next_scb2
	mov	SCBPTR, A
	jmp	add_to_waiting_list
dma_next_scb2:
	mvi	DMAPARAMS, 0xd	/* HDMAEN|DIRECTION|FIFORESET */
	mov	SCB_LINKED_NEXT		call dma_scb
add_to_waiting_list:
	mov	SCB_NEXT,WAITING_SCBH
	mov	WAITING_SCBH, SCBPTR
	or	FLAGS, SCB_LISTED
	jmp	mesgin_done

/*
 * Is it an extended message?  Copy the message to our message buffer and
 * notify the host.  The host will tell us whether to reject this message,
 * respond to it with the message that the host placed in our message buffer,
 * or simply to do nothing.
 */
mesgin_extended:
	mvi	MSGIN_EXT_LEN	 call inb_next
	mov	A, MSGIN_EXT_LEN
mesgin_extended_loop:
	mov	DINDEX	call	inb_next
	dec	A
	cmp	DINDEX, MSGIN_EXT_LASTBYTE jne mesgin_extended_loop_test
	dec	DINDEX		/* dump by repeatedly filling the last byte */
mesgin_extended_loop_test:
	test	A, 0xFF		jnz mesgin_extended_loop
mesgin_extended_intr:
	mvi	INTSTAT,EXTENDED_MSG		/* let driver know */
	cmp	RETURN_1,SEND_REJ je rej_mesgin
	cmp	RETURN_1,SEND_MSG jne mesgin_done
/* The kernel has setup a message to be sent */
	or	SCSISIGO,ATNO			/* turn on ATNO */
	jmp	mesgin_done

/*
 * Is it a disconnect message?  Set a flag in the SCB to remind us
 * and await the bus going free.
 */
mesgin_disconnect:
	or	SCB_CONTROL,DISCONNECTED
	test	FLAGS, PAGESCBS jz mesgin_done
	call	add_scb_to_disc_list
	or	FLAGS, SCB_LISTED
	jmp	mesgin_done

/*
 * Save data pointers message:
 * Copying RAM values back to SCB, for Save Data Pointers message, but
 * only if we've actually been into a data phase to change them.  This
 * protects against bogus data in scratch ram and the residual counts
 * since they are only initialized when we go into data_in or data_out.
 */
mesgin_sdptrs:
	test	FLAGS, DPHASE	jz mesgin_done
	mov	SCB_SGCOUNT,SG_COUNT

	/* The SCB SGPTR becomes the next one we'll download */
	mvi	DINDEX, SCB_SGPTR
	mvi	SG_NEXT0	call bcopy_4
	
	/* The SCB DATAPTR0 becomes the current SHADDR */
	mvi	DINDEX, SCB_DATAPTR0
	mvi	SHADDR0		call bcopy_4

/*
 * Use the residual number since STCNT is corrupted by any message transfer.
 */
	mvi	SCB_RESID_DCNT0	call	bcopy_3

	jmp	mesgin_done

/*
 * Restore pointers message?  Data pointers are recopied from the
 * SCB anytime we enter a data phase for the first time, so all
 * we need to do is clear the DPHASE flag and let the data phase
 * code do the rest.
 */
mesgin_rdptrs:
	and	FLAGS,0xef			/*
						 * !DPHASE we'll reload them
						 * the next time through
						 */
	jmp	mesgin_done

/*
 * Identify message?  For a reconnecting target, this tells us the lun
 * that the reconnection is for - find the correct SCB and switch to it,
 * clearing the "disconnected" bit so we don't "find" it by accident later.
 */
mesgin_identify:
	test	A,0x78	jnz rej_mesgin	/*!DiscPriv|!LUNTAR|!Reserved*/
	and	A,0x07			/* lun in lower three bits */
	or      SAVED_TCL,A		/* SAVED_TCL should be complete now */
	call	inb_last		/* ACK */

/*
 * Here we "snoop" the bus looking for a SIMPLE QUEUE TAG message.
 * If we get one, we use the tag returned to switch to find the proper
 * SCB.  With SCB paging, this requires using findSCB for both tagged
 * and non-tagged transactions since the SCB may exist in any slot.
 * If we're not using SCB paging, we can use the tag as the direct
 * index to the SCB.
 */
	mvi	ARG_1,SCB_LIST_NULL	/* Default to no-tag */
snoop_tag_loop:
	test	SSTAT1,BUSFREE		jnz use_findSCB
	test	SSTAT1,REQINIT		jz snoop_tag_loop
	test	SSTAT1,PHASEMIS		jnz use_findSCB
	mvi	A			call inb_first
	cmp	A,MSG_SIMPLE_Q_TAG	jne use_findSCB
get_tag:
	or	FLAGS, TAGGED_SCB
	mvi	ARG_1	call inb_next	/* tag value */
/*
 * See if the tag is in range.  The tag is < SCBCOUNT if we add
 * the complement of SCBCOUNT to the incomming tag and there is
 * no carry.
 */
	mov	A,COMP_SCBCOUNT	
	add	SINDEX,A,ARG_1
	jc	send_abort_msg

/*
 * Ensure that the SCB the tag points to is for an SCB transaction
 * to the reconnecting target.
 */
	test	FLAGS, PAGESCBS	jz index_by_tag
use_findSCB:
	mov	ALLZEROS	call findSCB	  /* Have to search */
	cmp	SINDEX, SCB_LIST_NULL, je not_found
setup_SCB:
	and	SCB_CONTROL,0xfb	  /* clear disconnect bit in SCB */
	or	FLAGS,IDENTIFY_SEEN	  /* make note of IDENTIFY */
	test	SCB_CONTROL,TAG_ENB	jnz  mesgin_done /* Ack Tag */
	jmp	ITloop
index_by_tag:
	mov	SCBPTR,ARG_1
	mov	A, SAVED_TCL
	cmp	SCB_TCL,A		jne send_abort_msg
	test	SCB_CONTROL,TAG_ENB	jz  send_abort_msg
	jmp	setup_SCB

not_found:
	mvi	INTSTAT, NO_MATCH
send_abort_msg:
	or	SCSISIGO,ATNO			/* turn on ATNO */
	test	FLAGS, TAGGED_SCB jnz abort_tag_msg
	mvi	MSG_ABORT	call mk_mesg
	jmp	mesgin_done
abort_tag_msg:
	mvi	MSG_ABORT_TAG	call mk_mesg	/* ABORT TAG message */
	jmp	mesgin_done

/*
 * Message reject?  Let the kernel driver handle this.  If we have an 
 * outstanding WDTR or SDTR negotiation, assume that it's a response from 
 * the target selecting 8bit or asynchronous transfer, otherwise just ignore 
 * it since we have no clue what it pertains to.
 */
mesgin_reject:
	mvi	INTSTAT, REJECT_MSG
	jmp	mesgin_done

/*
 * [ ADD MORE MESSAGE HANDLING HERE ]
 */

/*
 * Bus free phase.  It might be useful to interrupt the device
 * driver if we aren't expecting this.  For now, make sure that
 * ATN isn't being asserted and look for a new command.
 */
p_busfree:
	mvi	CLRSINT1,CLRATNO
	clr	LASTPHASE

/*
 * if this is an immediate command, perform a psuedo command complete to
 * notify the driver.
 */
	test	SCB_CMDLEN,0xff	jz status_ok
	test	FLAGS, SCB_LISTED	jnz start
	/*
	 * This SCB didn't disconnect or have a command complete,
	 * so put it on the free queue.  It was probably the
	 * result of an abort of some sort.  This prevents us
	 * from "leaking" SCBs.
	 */
	call	add_scb_to_free_list
	jmp	start

/*
 * Locking the driver out, build a one-byte message passed in SINDEX
 * if there is no active message already.  SINDEX is returned intact.
 */
mk_mesg:
	mvi	SEQCTL,0x50			/* PAUSEDIS|FASTMODE */
	test	MSG_LEN,0xff	jz mk_mesg1	/* Should always succeed */
	
	/*
	 * Hmmm.  For some reason the mesg buffer is in use.
	 * Tell the driver.  It should look at SINDEX to find
	 * out what we wanted to use the buffer for and resolve
	 * the conflict.
	 */
	mvi	SEQCTL,0x10			/* !PAUSEDIS|FASTMODE */
	mvi	INTSTAT,MSG_BUFFER_BUSY

mk_mesg1:
	mvi	MSG_LEN,1		/* length = 1 */
	mov	MSG0,SINDEX		/* 1-byte message */
	mvi	SEQCTL,0x10	ret	/* !PAUSEDIS|FASTMODE */

/*
 * Functions to read data in Automatic PIO mode.
 *
 * According to Adaptec's documentation, an ACK is not sent on input from
 * the target until SCSIDATL is read from.  So we wait until SCSIDATL is
 * latched (the usual way), then read the data byte directly off the bus
 * using SCSIBUSL.  When we have pulled the ATN line, or we just want to
 * acknowledge the byte, then we do a dummy read from SCISDATL.  The SCSI
 * spec guarantees that the target will hold the data byte on the bus until
 * we send our ACK.
 *
 * The assumption here is that these are called in a particular sequence,
 * and that REQ is already set when inb_first is called.  inb_{first,next}
 * use the same calling convention as inb.
 */

inb_next:
	or	CLRSINT0, CLRSPIORDY
	mov	NONE,SCSIDATL			/*dummy read from latch to ACK*/
inb_next_wait:
	test	SSTAT1,PHASEMIS	jnz mesgin_phasemis
	test	SSTAT0,SPIORDY	jz inb_next_wait /* wait for next byte */
inb_first:
	mov	DINDEX,SINDEX
	test	SSTAT1,PHASEMIS	jnz mesgin_phasemis
	mov	DINDIR,SCSIBUSL	ret		/*read byte directly from bus*/
inb_last:
	mov	NONE,SCSIDATL ret		/*dummy read from latch to ACK*/

mesgin_phasemis:
/*
 * We expected to receive another byte, but the target changed phase
 */
	mvi	INTSTAT, MSGIN_PHASEMIS
	jmp	ITloop

/*
 * DMA data transfer.  HADDR and HCNT must be loaded first, and
 * SINDEX should contain the value to load DFCNTRL with - 0x3d for
 * host->scsi, or 0x39 for scsi->host.  The SCSI channel is cleared
 * during initialization.
 */
dma:
	mov	DFCNTRL,SINDEX
dma1:
	test	SSTAT0,DMADONE	jnz dma3
	test	SSTAT1,PHASEMIS	jz dma1		/* ie. underrun */

/*
 * We will be "done" DMAing when the transfer count goes to zero, or
 * the target changes the phase (in light of this, it makes sense that
 * the DMA circuitry doesn't ACK when PHASEMIS is active).  If we are
 * doing a SCSI->Host transfer, the data FIFO should be flushed auto-
 * magically on STCNT=0 or a phase change, so just wait for FIFO empty
 * status.
 */
dma3:
	test	SINDEX,DIRECTION	jnz dma5
dma4:
	test	DFSTATUS,FIFOEMP	jz dma4

/*
 * Now shut the DMA enables off and make sure that the DMA enables are 
 * actually off first lest we get an ILLSADDR.
 */
dma5:
	/* disable DMA, but maintain WIDEODD */
	and	DFCNTRL,WIDEODD
dma6:
	test	DFCNTRL,0x38	jnz dma6  /* SCSIENACK|SDMAENACK|HDMAENACK */
return:
	ret

/*
 * Common SCSI initialization for selection and reselection.  Expects
 * the target SCSI ID to be in the upper four bits of SINDEX, and A's
 * contents are stomped on return.
 */
initialize_scsiid:
	and	SINDEX,0xf0		/* Get target ID */
	mov	SAVED_TCL, SINDEX	/* Update the target portion of this */
	and	A,0x0f,SCSIID
	or	SINDEX,A
	mov	SCSIID,SINDEX ret

/*
 * Assert that if we've been reselected, then we've seen an IDENTIFY
 * message.
 */
assert:
	test	FLAGS,RESELECTED	jz return	/* reselected? */
	test	FLAGS,IDENTIFY_SEEN	jnz return	/* seen IDENTIFY? */

	mvi	INTSTAT,NO_IDENT 	ret	/* no - tell the kernel */

/*
 * Locate a disconnected SCB either by SAVED_TCL (ARG_1 is SCB_LIST_NULL)
 * or by the SCBIDn ARG_1.  The search begins at the SCB index passed in
 * via SINDEX.  If the SCB cannot be found, SINDEX will be SCB_LIST_NULL,
 * otherwise, SCBPTR is set to the proper SCB.
 */
findSCB:
	mov	SCBPTR,SINDEX			/* switch to next SCB */
	test	SCB_CONTROL,DISCONNECTED jz findSCB1 /*should be disconnected*/
	cmp	ARG_1, SCB_LIST_NULL	jne findBySCBID
	mov	A, SAVED_TCL
	cmp	SCB_TCL,A	je foundSCB /* target ID/channel/lun match? */
findSCB1:
	inc	SINDEX
	mov	A,SCBCOUNT
	cmp	SINDEX,A	jne findSCB
/*
 * We didn't find it.  If we're paging, pull an SCB and DMA down the
 * one we want.  If we aren't paging or the SCB we dma down has the
 * abort flag set, return not found.
 */
	test	FLAGS, PAGESCBS	jz find_error
	call	get_free_or_disc_scb
	cmp	ARG_1, SCB_LIST_NULL jne find_dma_scb
	mov	SAVED_TCL	call	index_untagged_scb
	mov	ARG_1, SINDIR	/* SCBID of SCB to fetch */
find_dma_scb:
	mvi	DMAPARAMS, 0xd	/* HDMAEN|DIRECTION|FIFORESET */
	mov	ARG_1	call dma_scb
	test	SCB_CONTROL, ABORT_SCB jz return
find_error:
	mvi	SINDEX, SCB_LIST_NULL ret
findBySCBID:
	mov	A, ARG_1			/* Tag passed in ARG_1 */
	cmp	SCB_TAG,A	jne findSCB1	/* Found it? */
foundSCB:
	test	SCB_CONTROL, ABORT_SCB jnz find_error
	test	FLAGS,PAGESCBS	jz return
rem_scb_from_disc_list:
/* Remove this SCB from the disconnection list */
	cmp	SCB_NEXT,SCB_LIST_NULL je unlink_prev
	mov	SAVED_LINKPTR, SCB_PREV
	mov	SCBPTR, SCB_NEXT
	mov	SCB_PREV, SAVED_LINKPTR
	mov	SCBPTR, SINDEX
unlink_prev:
	cmp	SCB_PREV,SCB_LIST_NULL	je rHead/* At the head of the list */
	mov	SAVED_LINKPTR, SCB_NEXT
	mov	SCBPTR, SCB_PREV
	mov	SCB_NEXT, SAVED_LINKPTR
	mov	SCBPTR, SINDEX ret
rHead:
	mov	DISCONNECTED_SCBH,SCB_NEXT ret

set_stcnt_from_hcnt:
	mov	STCNT0, HCNT0
	mov	STCNT1, HCNT1
	mov	STCNT2, HCNT2 ret

bcopy_7:
	mov	DINDIR, SINDIR
	mov	DINDIR, SINDIR
bcopy_5:
	mov	DINDIR, SINDIR
bcopy_4:
	mov	DINDIR, SINDIR
bcopy_3:
	mov	DINDIR, SINDIR
	mov	DINDIR, SINDIR
	mov	DINDIR, SINDIR ret

dma_scb:
	/*
	 * SCB index is in SINDEX.  Determine the physical address in
	 * the host where this SCB is located and load HADDR with it.
	 */
	shr	DINDEX, SINDEX, 3
	shl	A, SINDEX, 5
	add	HADDR0, A, HSCB_ADDR0
	mov	A, DINDEX
	adc	HADDR1, A, HSCB_ADDR1
	clr	A
	adc	HADDR2, A, HSCB_ADDR2
	adc	HADDR3, A, HSCB_ADDR3
	/* Setup Count */
	mvi	HCNT0, 28
	clr	HCNT1
	clr	HCNT2
	mov	DFCNTRL, DMAPARAMS
	test	DMAPARAMS, DIRECTION	jnz dma_scb_fromhost
	/* Fill it with the SCB data */
	call	copy_scb_tofifo
	mvi	DFCNTRL, 0xa		/* HDMAEN | FIFOFLUSH */
dma_scb_fromhost:
	call	dma_finish
	/* If we were putting the SCB, we are done */
	test	DMAPARAMS, DIRECTION	jz	return
	mvi	SCBARRAY  call dfdat_in_7
	call	dfdat_in_7_continued
	call	dfdat_in_7_continued
	jmp	dfdat_in_7_continued
dfdat_in_7:
	mov     DINDEX,SINDEX
dfdat_in_7_continued:
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT ret

copy_scb_tofifo:
	mvi	SCBARRAY  call dfdat_out_7
	call	dfdat_out_7
	call	dfdat_out_7
dfdat_out_7:
	mov	DFDAT,SINDIR
	mov	DFDAT,SINDIR
	mov	DFDAT,SINDIR
	mov	DFDAT,SINDIR
	mov	DFDAT,SINDIR
	mov	DFDAT,SINDIR
	mov	DFDAT,SINDIR ret

/*
 * Wait for DMA from host memory to data FIFO to complete, then disable
 * DMA and wait for it to acknowledge that it's off.
 */
dma_finish:
	test	DFSTATUS,HDONE	jz dma_finish
	/* Turn off DMA preserving WIDEODD */
	and	DFCNTRL,WIDEODD
dma_finish2:
	test	DFCNTRL,HDMAENACK jnz dma_finish2
	ret

index_untagged_scb:
	mov	DINDEX, SINDEX
	shr	DINDEX, 4
	and	DINDEX, 0x03			/* Bottom two bits of tid */
	add	DINDEX, SCB_ACTIVE0
	shr	A, SINDEX, 6			/* Target ID divided by 4 */
	test	SCB_TCL, SELBUSB jz index_untagged_scb2
	or	A, 2				/* Add 2 positions */
index_untagged_scb2:
	mov	SCBPTR, A			/*
						 * Select the SCB with this 
						 * target's information.
						 */
	mov	SINDEX, DINDEX	ret


get_free_or_disc_scb:
	mov	SINDEX, ALLZEROS
	cmp	FREE_SCBH, SCB_LIST_NULL jne get_free_scb
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL je return_error
	mov	SCBPTR, DISCONNECTED_SCBH
/*
 * If we are starting a new transaction, we have to ensure that
 * there is at least one SCB left in case a reselection wins out.
 */
	test	FLAGS, RESELECTED	jnz dequeue_disc_scb
	cmp	SCB_NEXT, SCB_LIST_NULL je return_error
dequeue_disc_scb:
/*
 * If we have a residual, then we are in the middle of some I/O
 * and we have to send this SCB back up to the kernel so that the
 * saved data pointers and residual information isn't lost.
 */
	test	SCB_RESID_SGCNT,0xff	jz unlink_disc_scb
	mvi	DMAPARAMS, 0x9	/* HDMAEN | FIFORESET*/
	mov	SCB_TAG		call dma_scb
unlink_disc_scb:
	call	rem_scb_from_disc_list
	ret
get_free_scb:
/*
 * If we are starting a new transaction, we have to ensure that
 * there is at least one SCB left in case a reselection wins out.
 */
	test	FLAGS, RESELECTED	jnz dequeue_free_scb
	cmp	SCB_NEXT, SCB_LIST_NULL jne dequeue_free_scb
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL je return_error
dequeue_free_scb:
	mov	SCBPTR, FREE_SCBH
	mov	FREE_SCBH, SCB_NEXT ret
return_error:
	mvi	SINDEX, SCB_LIST_NULL	ret

add_scb_to_free_list:
	mov	SCB_NEXT, FREE_SCBH
	mov	FREE_SCBH, SCBPTR ret

add_scb_to_disc_list:
/*
 * Link this SCB into the DISCONNECTED list.  This list holds the
 * candidates for paging out an SCB if one is needed for a new command.
 * Modifying the disconnected list is a critical(pause dissabled) section.
 */
	mvi	SCB_PREV, SCB_LIST_NULL
	mov	SCB_NEXT, DISCONNECTED_SCBH
	mov	DISCONNECTED_SCBH, SCBPTR
	cmp	SCB_NEXT,SCB_LIST_NULL je return
	mov	SCBPTR,SCB_NEXT
	mov	SCB_PREV,DISCONNECTED_SCBH
	mov	SCBPTR,DISCONNECTED_SCBH ret

