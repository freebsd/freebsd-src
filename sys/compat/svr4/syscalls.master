 $FreeBSD$
;	from: @(#)syscalls.master	8.1 (Berkeley) 7/19/93
;
; System call name/number master file (or rather, slave, from SVR4).
; Processed to create svr4_sysent.c, svr4_syscalls.c and svr4_syscall.h.

; Columns: number type nargs name alt{name,tag,rtyp}/comments
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, COMPAT
;	name	psuedo-prototype of syscall routine
;		If one of the following alts is different, then all appear:
;	altname	name of system call if different
;	alttag	name of args struct tag if different from [o]`name'"_args"
;	altrtyp	return type if not int (bogus - syscalls always return int)
;		for UNIMPL/OBSOL, name continues with comments

; types:
;	STD	always included
;	COMPAT	included on COMPAT #ifdef
;	LIBCOMPAT included on COMPAT #ifdef, and placed in syscall.h
;	OBSOL	obsolete, not included in system, only specifies name
;	UNIMPL	not implemented, placeholder only

; #ifdef's, etc. may be included, and are copied to the output files.

#include <sys/types.h>
#include <sys/sysent.h>
#include <sys/sysproto.h>
#include <netinet/in.h>

#include <compat/svr4/svr4.h>
#include <compat/svr4/svr4_types.h>
#include <compat/svr4/svr4_signal.h>
#include <compat/svr4/svr4_proto.h>

0	UNIMPL	unused
1	NOPROTO	{ void sys_exit(int rval); } exit sys_exit_args void
2	MNOPROTO { int fork(void); }
3	MNOPROTO { int read(int fd, char *buf, u_int nbyte); }
4	MNOPROTO { int write(int fd, char *buf, u_int nbyte); }
5	STD	{ int svr4_sys_open(char *path, int flags, int mode); }
6	MNOPROTO { int close(int fd); }
7	STD	{ int svr4_sys_wait(int *status); }
8	STD	{ int svr4_sys_creat(char *path, int mode); }
9	NOPROTO	{ int link(char *path, char *link); }
10	NOPROTO	{ int unlink(char *path); }
11	STD	{ int svr4_sys_execv(char *path, char **argp); }
12	NOPROTO	{ int chdir(char *path); }
13	STD	{ int svr4_sys_time(time_t *t); }
14	STD	{ int svr4_sys_mknod(char* path, int mode, int dev); }
15	NOPROTO	{ int chmod(char *path, int mode); }
16	NOPROTO	{ int chown(char *path, uid_t uid, gid_t gid); }
17	STD	{ int svr4_sys_break(caddr_t nsize); }
18	STD	{ int svr4_sys_stat(char* path, struct svr4_stat* ub); }
19	NOPROTO	{ int lseek(int filedes, off_t *offset, int whence); }
20	MNOPROTO { pid_t getpid(void); }
21	UNIMPL	old_mount
22	UNIMPL	sysv_umount
23	MNOPROTO { int setuid(uid_t uid); }
24	MNOPROTO { uid_t getuid(void); }
25	UNIMPL	stime
26	UNIMPL	ptrace
27	STD	{ int svr4_sys_alarm(unsigned sec); }
28	STD	{ int svr4_sys_fstat(int fd, struct svr4_stat *sb); }
29	MSTD	{ int svr4_sys_pause(void); }
30	STD	{ int svr4_sys_utime(char *path, struct svr4_utimbuf *ubuf); }
31	UNIMPL	stty
32	UNIMPL	gtty
33	STD	{ int svr4_sys_access(char *path, int flags); }
34	MSTD	{ int svr4_sys_nice(int prio); }
35	UNIMPL	statfs
36	NOPROTO	{ int sync(void); }
37	MSTD	{ int svr4_sys_kill(int pid, int signum); }
38	UNIMPL	fstatfs
39	MSTD	{ int svr4_sys_pgrpsys(int cmd, int pid, int pgid); }
40	UNIMPL	xenix
41	MNOPROTO { int dup(u_int fd); }
42	MNOPROTO { int pipe(void); }
43	STD	{ int svr4_sys_times(struct tms *tp); }
44	UNIMPL	profil
45	UNIMPL	plock
46	MNOPROTO { int setgid(gid_t gid); }
47	MNOPROTO { gid_t getgid(void); }
48	MSTD	{ int svr4_sys_signal(int signum, svr4_sig_t handler); }
#if defined(NOTYET)
49	STD	{ int svr4_sys_msgsys(int what, int a2, int a3, int a4, \
		    int a5); }
#else
49	UNIMPL	msgsys
#endif
50	STD	{ int svr4_sys_sysarch(int op, void *a1); }
51	UNIMPL	acct
52	UNIMPL	shmsys
53	UNIMPL	semsys
54	STD	{ int svr4_sys_ioctl(int fd, u_long com, caddr_t data); }
55	UNIMPL	uadmin
56	UNIMPL	exch
57	STD	{ int svr4_sys_utssys(void *a1, void *a2, int sel, void *a3); }
58	NOPROTO	{ int fsync(int fd); }
59	STD	{ int svr4_sys_execve(char *path, char **argp, char **envp); }
60	MNOPROTO { int umask(int newmask); }
61	NOPROTO	{ int chroot(char *path); }
62	MSTD	{ int svr4_sys_fcntl(int fd, int cmd, char *arg); }
63	MSTD	{ int svr4_sys_ulimit(int cmd, long newlimit); }
64	UNIMPL	reserved
65	UNIMPL	reserved
66	UNIMPL	reserved
67	UNIMPL	reserved
68	UNIMPL	reserved
69	UNIMPL	reserved
70	UNIMPL	advfs
71	UNIMPL	unadvfs
72	UNIMPL	rmount
73	UNIMPL	rumount
74	UNIMPL	rfstart
75	UNIMPL	sigret
76	UNIMPL	rdebug
77	UNIMPL	rfstop
78	UNIMPL	rfsys
79	NOPROTO	{ int rmdir(char *path); }
80	NOPROTO	{ int mkdir(char *path, int mode); }
81	STD	{ int svr4_sys_getdents(int fd, char *buf, int nbytes); }
82	UNIMPL	libattach
83	UNIMPL	libdetach
84	UNIMPL	sysfs
85	STD	{ int svr4_sys_getmsg(int fd, struct svr4_strbuf *ctl, \
		    struct svr4_strbuf *dat, int *flags); }
86	STD	{ int svr4_sys_putmsg(int fd, struct svr4_strbuf *ctl, \
		    struct svr4_strbuf *dat, int flags); }
87	STD	{ int svr4_sys_poll(struct pollfd *fds, unsigned int nfds, \
		    int timeout); }
88	STD	{ int svr4_sys_lstat(char *path, struct svr4_stat *ub); }
89	NOPROTO	{ int symlink(char *path, char *link); }
90	NOPROTO	{ int readlink(char *path, char *buf, int count); }
91	MNOPROTO { int getgroups(u_int gidsetsize, gid_t *gidset); }
92	MNOPROTO { int setgroups(u_int gidsetsize, gid_t *gidset); }
93	NOPROTO	{ int fchmod(int fd, int mode); }
94	NOPROTO	{ int fchown(int fd, int uid, int gid); }
95	MSTD	{ int svr4_sys_sigprocmask(int how, svr4_sigset_t *set, \
		    svr4_sigset_t *oset); }
96	MSTD	{ int svr4_sys_sigsuspend(svr4_sigset_t *ss); }
97	MSTD	{ int svr4_sys_sigaltstack(struct svr4_sigaltstack *nss, \
		    struct svr4_sigaltstack *oss); }
98	MSTD	{ int svr4_sys_sigaction(int signum, \
		    struct svr4_sigaction *nsa, struct svr4_sigaction *osa); }
99	MSTD	{ int svr4_sys_sigpending(int what, svr4_sigset_t *mask); }
100	STD	{ int svr4_sys_context(int func, struct svr4_ucontext *uc); }
101	UNIMPL	evsys
102	UNIMPL	evtrapret
103	STD	{ int svr4_sys_statvfs(char *path, struct svr4_statvfs *fs); }
104	STD	{ int svr4_sys_fstatvfs(int fd, struct svr4_statvfs *fs); }
105	UNIMPL	whoknows
106	UNIMPL	nfssvc
107	STD	{ int svr4_sys_waitsys(int grp, int id, \
		    union svr4_siginfo *info, int options); }
108	UNIMPL	sigsendsys
109	STD	{ int svr4_sys_hrtsys(int cmd, int fun, int sub, void *rv1, \
		    void *rv2); }
110	UNIMPL	acancel
111	UNIMPL	async
112	UNIMPL	priocntlsys
113	STD	{ int svr4_sys_pathconf(char *path, int name); }
114	UNIMPL	mincore
115	STD	{ caddr_t svr4_sys_mmap( caddr_t addr, svr4_size_t len, \
				int prot, int flags, int fd, svr4_off_t pos); }
116	MNOPROTO { int mprotect(void *addr, int len, int prot); }
117	MNOPROTO { int munmap(void *addr, int len); }
118	STD	{ int svr4_sys_fpathconf(int fd, int name); }
119	MNOPROTO { int vfork(void); }
120	NOPROTO	{ int fchdir(int fd); }
121	NOPROTO	{ int readv(int fd, struct iovec *iovp, u_int iovcnt); }
122	NOPROTO	{ int writev(int fd, struct iovec *iovp, u_int iovcnt); }
123	STD	{ int svr4_sys_xstat(int two, char *path, \
		    struct svr4_xstat *ub); }
124	STD	{ int svr4_sys_lxstat(int two, char *path, \
		    struct svr4_xstat *ub); }
125	STD	{ int svr4_sys_fxstat(int two, int fd, struct svr4_xstat *sb); }
126	STD	{ int svr4_sys_xmknod(int two, char *path, svr4_mode_t mode, \
		    svr4_dev_t dev); }
127	UNIMPL	clocal
128	MSTD	{ int svr4_sys_setrlimit(int which, \
		    const struct svr4_rlimit *rlp); }
129	MSTD	{ int svr4_sys_getrlimit(int which, \
		    struct svr4_rlimit *rlp); }
130	NOPROTO	{ int lchown(char *path, uid_t uid, gid_t gid); }
131	STD	{ int svr4_sys_memcntl(void * addr, svr4_size_t len, int cmd, \
		    void * arg, int attr, int mask); }
132	UNIMPL	getpmsg
133	UNIMPL	putpmsg
134	NOPROTO	{ int rename(char *from, char *to); }
135	STD	{ int svr4_sys_uname(struct svr4_utsname* name, int dummy); }
136	MNOPROTO { int setegid(gid_t egid); }
137	STD	{ int svr4_sys_sysconfig(int name); }
138	MNOPROTO { int adjtime(struct timeval *delta, \
		    struct timeval *olddelta); }
139	STD	{ long svr4_sys_systeminfo(int what, char *buf, long len); }
140	UNIMPL	notused
141	MNOPROTO { int seteuid(uid_t euid); }
142	UNIMPL	vtrace
; fork1
143	MUNIMPL { int fork(void); } 
144	UNIMPL	sigtimedwait
145	UNIMPL	lwp_info
146	UNIMPL	yield
147	UNIMPL	lwp_sema_wait
148	UNIMPL	lwp_sema_post
149	UNIMPL	lwp_sema_trywait
150	UNIMPL	notused
151	UNIMPL	notused
152	UNIMPL	modctl
153	STD	{ int svr4_sys_fchroot(int fd); }
154	STD	{ int svr4_sys_utimes(char *path, struct timeval *tptr); }
155	STD	{ int svr4_sys_vhangup(void); }
156	STD	{ int svr4_sys_gettimeofday(struct timeval *tp); }
157	MNOPROTO { int getitimer(u_int which, struct itimerval *itv); }
158	MNOPROTO { int setitimer(u_int which, struct itimerval *itv, \
		    struct itimerval *oitv); }
159	UNIMPL	lwp_create
160	UNIMPL	lwp_exit
161	UNIMPL	lwp_suspend
162	UNIMPL	lwp_continue
163	UNIMPL	lwp_kill
164	UNIMPL	lwp_self
165	UNIMPL	lwp_getprivate
166	UNIMPL	lwp_setprivate
167	UNIMPL	lwp_wait
168	UNIMPL	lwp_mutex_unlock
169	UNIMPL	lwp_mutex_lock
170	UNIMPL	lwp_cond_wait
171	UNIMPL	lwp_cond_signal
172	UNIMPL	lwp_cond_broadcast
173	UNIMPL	{ ssize_t svr4_sys_pread(int fd, void *buf, size_t nbyte, \
		    svr4_off_t off); }
174	UNIMPL	{ ssize_t svr4_sys_pwrite(int fd, const void *buf, \
		    size_t nbyte, svr4_off_t off); }
175	STD	{ svr4_off64_t svr4_sys_llseek(int fd, long offset1, \
		    long offset2, int whence); }
176	UNIMPL	inst_sync
177	UNIMPL	whoknows
178	UNIMPL	kaio
179	UNIMPL	whoknows
180	UNIMPL	whoknows
181	UNIMPL	whoknows
182	UNIMPL	whoknows
183	UNIMPL	whoknows
184	UNIMPL	tsolsys
185	STD	{ int svr4_sys_acl(char *path, int cmd, int num, \
		    struct svr4_aclent *buf); }
186	STD	{ int svr4_sys_auditsys(int code, int a1, int a2, int a3, \
		    int a4, int a5); }
187	UNIMPL	processor_bind
188	UNIMPL	processor_info
189	UNIMPL	p_online
190	UNIMPL	sigqueue
191	UNIMPL	clock_gettime
192	UNIMPL	clock_settime
193	UNIMPL	clock_getres
194	UNIMPL	timer_create
195	UNIMPL	timer_delete
196	UNIMPL	timer_settime
197	UNIMPL	timer_gettime
198	UNIMPL	timer_overrun
199	MNOPROTO { int nanosleep(const struct timespec *rqtp, \
		    struct timespec *rmtp); }
200	STD	{ int svr4_sys_facl(int fd, int cmd, int num, \
		    struct svr4_aclent *buf); }
201	UNIMPL	door
202	MNOPROTO { int setreuid(int ruid, int euid); }
203	MNOPROTO { int setregid(int rgid, int egid); }
204	UNIMPL	install_utrap
205	UNIMPL	signotify
206	UNIMPL	schedctl
207	UNIMPL	pset
208	UNIMPL	whoknows
209	STD	{ int svr4_sys_resolvepath(const char *path, char *buf, \
		    size_t bufsiz); }
210	UNIMPL	signotifywait
211	UNIMPL	lwp_sigredirect
212	UNIMPL	lwp_alarm
213	STD	{ int svr4_sys_getdents64(int fd, struct svr4_dirent64 *dp, \
		    int nbytes); }
;213	UNIMPL	getdents64
214	STD	{ caddr_t svr4_sys_mmap64(void *addr, svr4_size_t len, \
		    int prot, int flags, int fd, svr4_off64_t pos); }
215	STD	{ int svr4_sys_stat64(char *path, struct svr4_stat64 *sb); }
216	STD	{ int svr4_sys_lstat64(char *path, struct svr4_stat64 *sb); }
217	STD	{ int svr4_sys_fstat64(int fd, struct svr4_stat64 *sb); }
218	STD	{ int svr4_sys_statvfs64(char *path, \
		    struct svr4_statvfs64 *fs); }
219	STD	{ int svr4_sys_fstatvfs64(int fd, struct svr4_statvfs64 *fs); }
220	MSTD	{ int svr4_sys_setrlimit64(int which, \
		    const struct svr4_rlimit64 *rlp); }
221	MSTD	{ int svr4_sys_getrlimit64(int which, \
		    struct svr4_rlimit64 *rlp); }
222	UNIMPL	pread64
223	UNIMPL	pwrite64
224	STD	{ int svr4_sys_creat64(char *path, int mode); }
225	STD	{ int svr4_sys_open64(char *path, int flags, int mode); }
226	UNIMPL	rpcsys
227	UNIMPL	whoknows
228	UNIMPL	whoknows
229	UNIMPL	whoknows
230	STD	{ int svr4_sys_socket(int domain, int type, int protocol); }
231	NOPROTO	{ int socketpair(int domain, int type, int protocol, \
		    int *rsv); }
232	NOPROTO	{ int bind(int s, const struct sockaddr *name, int namelen); }
233	NOPROTO	{ int listen(int s, int backlog); }
234	NOPROTO	{ int accept(int s, struct sockaddr *name, int *anamelen); }
235	NOPROTO	{ int connect(int s, const struct sockaddr *name, \
		    int namelen); }
236	NOPROTO	{ int shutdown(int s, int how); }
237	STD	{ int svr4_sys_recv(int s, caddr_t buf, int len, int flags); }
238	NOPROTO	{ ssize_t recvfrom(int s, void *buf, size_t len, int flags, \
		    struct sockaddr *from, int *fromlenaddr); }
239	NOPROTO	{ ssize_t recvmsg(int s, struct msghdr *msg, int flags); }
240	STD	{ int svr4_sys_send(int s, caddr_t buf, int len, int flags); }
241	NOPROTO	{ ssize_t sendmsg(int s, const struct msghdr *msg, int flags); }
242	STD	{ ssize_t svr4_sys_sendto(int s, void *buf, size_t len, \
		    int flags, struct sockaddr *to, int tolen); }
243	NOPROTO	{ int getpeername(int fdes, struct sockaddr *asa, int *alen); }
244	NOPROTO	{ int getsockname(int fdes, struct sockaddr *asa, int *alen); }
245	NOPROTO	{ int getsockopt(int s, int level, int name, void *val, \
		    int *avalsize); }
246	NOPROTO	{ int setsockopt(int s, int level, int name, const void *val, \
		    int valsize); }
247	UNIMPL	sockconfig
248	UNIMPL	{ int ntp_gettime(struct ntptimeval *ntvp); }
249	MUNIMPL	{ int ntp_adjtime(struct timex *tp); }
