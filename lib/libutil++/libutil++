/*-
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) 2025 Chelsio Communications, Inc.
 * Written by: John Baldwin <jhb@FreeBSD.org>
 */

#ifndef __LIBUTILPP__
#define	__LIBUTILPP__

#include <sys/cdefs.h>
#include <sys/nv.h>
#include <libutil.h>
#include <netdb.h>
#include <stdarg.h>
#include <unistd.h>

#include <memory>

namespace freebsd {
	/*
	 * FILE_up is a std::unique_ptr<> for FILE objects which uses
	 * fclose() to destroy the wrapped pointer.
	 */
	struct fclose_deleter {
		void operator() (FILE *fp) const
		{
			fclose(fp);
		}
	};

	typedef std::unique_ptr<FILE, fclose_deleter> FILE_up;

	/*
	 * addrinfo_up is a std::unique_ptr<> which uses
	 * freeaddrinfo() to destroy the wrapped pointer.  It is
	 * intended to wrap arrays allocated by getaddrinfo().
	 */
	struct freeaddrinfo_deleter {
		void operator() (struct addrinfo *ai) const
		{
			freeaddrinfo(ai);
		}
	};

	typedef std::unique_ptr<addrinfo, freeaddrinfo_deleter> addrinfo_up;

	/*
	 * This class is intended to function similar to unique_ptr<>,
	 * but it contains a file descriptor rather than a pointer to
	 * an object.  On destruction the descriptor is closed via
	 * close(2).
	 *
	 * Similar to unique_ptr<>, release() returns ownership of the
	 * file descriptor to the caller.  reset() closes the current
	 * file descriptor and takes ownership of a new one.  A move
	 * constructor permits ownership to be transferred via
	 * std::move().  An integer file descriptor can be assigned
	 * directly which is equivalent to calling reset().
	 *
	 * An explicit bool conversion operator permits testing this
	 * class in logical expressions.  It returns true if it
	 * contains a valid descriptor.
	 *
	 * An implicit int conversion operator returns the underlying
	 * file descriptor allowing objects of this type to be passed
	 * directly to APIs such as connect(), listen(), etc.
	 */
	class fd_up {
	public:
		fd_up() : _fd(-1) {}
		fd_up(int fd) : _fd(fd) {}
		fd_up(fd_up &&other) : _fd(other.release()) {}
		fd_up(fd_up const &) = delete;

		~fd_up() { reset(); }

		int
		get() const
		{
			return (_fd);
		}

		int
		release()
		{
			int fd = _fd;

			_fd = -1;
			return (fd);
		}

		void
		reset(int newfd = -1)
		{
			if (_fd >= 0)
				close(_fd);
			_fd = newfd;
		}

		fd_up &operator=(fd_up &&other) noexcept
		{
			if (this == &other)
				return *this;

			reset(other.release());
			return *this;
		}

		fd_up &operator=(fd_up const &) = delete;

		fd_up &operator=(int fd)
		{
			reset(fd);
			return *this;
		}

		explicit operator bool() const { return _fd >= 0; }
		operator int() const { return _fd; }
	private:
		int	_fd;
	};

	/*
	 * malloc_up<T> is a std::unique_ptr<> which uses free() to
	 * destroy the wrapped pointer.  This can be used to wrap
	 * pointers allocated implicitly by malloc() such as those
	 * returned by strdup().
	 */
	template <class T>
	struct free_deleter {
		void operator() (T *p) const
		{
			free(p);
		}
	};

	template <class T>
	using malloc_up = std::unique_ptr<T, free_deleter<T>>;

	/*
	 * nvlist_up is a std::unique_ptr<> for nvlist_t objects which
	 * uses nvlist_destroy() to destroy the wrapped pointer.
	 */
	struct nvlist_deleter {
		void operator() (nvlist_t *nvl) const
		{
			nvlist_destroy(nvl);
		}
	};

	typedef std::unique_ptr<nvlist_t, nvlist_deleter> nvlist_up;

	/*
	 * A wrapper class for the pidfile_* API.  The destructor
	 * calls pidfile_remove() when an object is destroyed.  This
	 * class is similar to std::unique_ptr<> in that it retains
	 * exclusive ownership of the pidfh object.
	 *
	 * In addition to release() and reset methods(), write(),
	 * close(), and fileno() methods are provided as wrappers for
	 * pidfile_*.
	 */
	class pidfile {
	public:
		pidfile() : _pfh(nullptr) {}
		pidfile(struct pidfh *pfh) : _pfh(pfh) {}
		pidfile(pidfile &&other) : _pfh(other.release()) {}
		pidfile(pidfile const &) = delete;

		~pidfile() { reset(); }

		struct pidfh *
		release()
		{
			struct pidfh *pfh = _pfh;

			_pfh = nullptr;
			return (pfh);
		}

		void
		reset(struct pidfh *pfh = nullptr)
		{
			if (_pfh != nullptr)
				pidfile_remove(_pfh);
			_pfh = pfh;
		}

		int
		write()
		{
			return (pidfile_write(_pfh));
		}

		int
		close()
		{
			int rv = pidfile_close(_pfh);
			if (rv == 0)
				_pfh = nullptr;
			return (rv);
		}

		int
		fileno()
		{
			return (pidfile_fileno(_pfh));
		}

		pidfile &operator=(pidfile &&other) noexcept
		{
			if (this == &other)
				return *this;
			reset(other.release());
			return *this;
		}

		pidfile &operator=(pidfile const &) = delete;

		pidfile &operator=(struct pidfh *pfh)
		{
			reset(pfh);
			return *this;
		}

		explicit operator bool() const { return _pfh != nullptr; }
	private:
		struct pidfh *_pfh = nullptr;
	};

	/*
	 * Returns a std::string containing the same output as
	 * sprintf().  Throws std::bad_alloc if an error occurs.
	 */
	std::string stringf(const char *fmt, ...) __printflike(1, 2);
	std::string stringf(const char *fmt, va_list ap);
}

#endif /* !__LIBUTILPP__ */
