/*
 * It'd be nice to automatically generate the syscall symbols, but we
 * don't know to what version they will eventually belong to, so for now
 * it has to be manual.
 */
FBSD_1.0 {
	__acl_aclcheck_fd;
	__acl_aclcheck_file;
	__acl_aclcheck_link;
	__acl_delete_fd;
	__acl_delete_file;
	__acl_delete_link;
	__acl_get_fd;
	__acl_get_file;
	__acl_get_link;
	__acl_set_fd;
	__acl_set_file;
	__acl_set_link;
	__getcwd;
	__mac_execve;
	__mac_get_fd;
	__mac_get_file;
	__mac_get_link;
	__mac_get_pid;
	__mac_get_proc;
	__mac_set_fd;
	__mac_set_file;
	__mac_set_link;
	__mac_set_proc;
	__setugid;
	__syscall;
	__sysctl;
	_exit;
	_umtx_op;
	abort2;
	accept;
	access;
	acct;
	adjtime;
	aio_cancel;
	aio_error;
	aio_fsync;
	aio_read;
	aio_return;
	aio_suspend;
	aio_waitcomplete;
	aio_write;
	audit;
	auditctl;
	auditon;
	bind;
	chdir;
	chflags;
	chmod;
	chown;
	chroot;
	clock_getres;
	clock_gettime;
	clock_settime;
	close;
	connect;
	dup;
	dup2;
	eaccess;
	execve;
	extattr_delete_fd;
	extattr_delete_file;
	extattr_delete_link;
	extattr_get_fd;
	extattr_get_file;
	extattr_get_link;
	extattr_list_fd;
	extattr_list_file;
	extattr_list_link;
	extattr_set_fd;
	extattr_set_file;
	extattr_set_link;
	extattrctl;
	fchdir;
	fchflags;
	fchmod;
	fchown;
	fcntl;
	fhopen;
	flock;
	fork;
	fpathconf;
	fsync;
	futimes;
	getaudit;
	getaudit_addr;
	getauid;
	getcontext;
	getdtablesize;
	getegid;
	geteuid;
	getfh;
	getgid;
	getgroups;
	getitimer;
	getpagesize;
	getpeername;
	getpgid;
	getpgrp;
	getpid;
	getppid;
	getpriority;
	getresgid;
	getresuid;
	getrlimit;
	getrusage;
	getsid;
	getsockname;
	getsockopt;
	gettimeofday;
	getuid;
	ioctl;
	issetugid;
	jail;
	jail_attach;
	kenv;
	kill;
	kldfind;
	kldfirstmod;
	kldload;
	kldnext;
	kldstat;
	kldsym;
	kldunload;
	kldunloadf;
	kqueue;
	kmq_notify;		/* Do we want these to be public interfaces? */
	kmq_open;		/* librt uses them to provide mq_xxx. */
	kmq_setattr;
	kmq_timedreceive;
	kmq_timedsend;
	kmq_unlink;
	ksem_close;
	ksem_destroy;
	ksem_getvalue;
	ksem_init;
	ksem_open;
	ksem_post;
	ksem_timedwait;
	ksem_trywait;
	ksem_unlink;
	ksem_wait;
	ktrace;
	lchflags;
	lchmod;
	lchown;
	lgetfh;
	link;
	lio_listio;
	listen;
	lutimes;
	mac_syscall;
	madvise;
	mincore;
	minherit;
	mkdir;
	mkfifo;
	mlock;
	mlockall;
	modfind;
	modfnext;
	modnext;
	modstat;
	mount;
	mprotect;
	msgget;
	msgrcv;
	msgsnd;
	msgsys;
	msync;
	munlock;
	munlockall;
	munmap;
	nanosleep;
	nfssvc;
	nmount;
	ntp_adjtime;
	ntp_gettime;
	open;
	pathconf;
	pipe;
	poll;
	posix_openpt;
	preadv;
	profil;
	pselect;
	ptrace;
	pwritev;
	quotactl;
	read;
	readlink;
	readv;
	reboot;
	recvfrom;
	recvmsg;
	rename;
	revoke;
	rfork;
	rmdir;
	rtprio;
	rtprio_thread;
	sched_get_priority_max;
	sched_get_priority_min;
	sched_getparam;
	sched_getscheduler;
	sched_rr_get_interval;
	sched_setparam;
	sched_setscheduler;
	sched_yield;
	select;
	semget;
	semop;
	semsys;
	sendfile;
	sendmsg;
	sendto;
	setaudit;
	setaudit_addr;
	setauid;
	setegid;
	seteuid;
	setgid;
	setgroups;
	setitimer;
	setlogin;
	setpgid;
	setpriority;
	setregid;
	setresgid;
	setresuid;
	setreuid;
	setrlimit;
	setsid;
	setsockopt;
	settimeofday;
	setuid;
	shm_open;
	shm_unlink;
	shmat;
	shmdt;
	shmget;
	shmsys;
	shutdown;
	sigaction;
	sigaltstack;
	sigpending;
	sigprocmask;
	sigqueue;
	sigreturn;
	sigsuspend;
	sigtimedwait;
	sigwait;
	sigwaitinfo;
	socket;
	socketpair;
	swapon;
	symlink;
	sync;
	sysarch;
	syscall;
	thr_create;
	thr_exit;
	thr_kill;
	thr_kill2;
	thr_new;
	thr_self;
	thr_set_name;
	thr_suspend;
	thr_wake;
	ktimer_create;		/* Do we want these to be public interfaces? */
	ktimer_delete;		/* librt uses them to provide timer_xxx. */
	ktimer_getoverrun;
	ktimer_gettime;
	ktimer_settime;
	umask;
	undelete;
	unlink;
	unmount;
	utimes;
	utrace;
	uuidgen;
	vadvise;
	vfork;
	wait4;
	write;
	writev;

	__error;
	ftruncate;
	lseek;
	mmap;
	pread;
	pwrite;
	truncate;
};

FBSD_1.1 {
	__semctl;
	closefrom;
	cpuset;
	cpuset_getid;
	cpuset_setid;
	cpuset_getaffinity;
	cpuset_setaffinity;
	faccessat;
	fchmodat;
	fchownat;
	fexecve;
	futimesat;
	jail_get;
	jail_set;
	jail_remove;
	linkat;
	lpathconf;
	mkdirat;
	mkfifoat;
	msgctl;
	readlinkat;
	renameat;
	setfib;
	shmctl;
	symlinkat;
	unlinkat;
};

FBSD_1.2 {
	cap_enter;
	cap_getmode;
	getloginclass;
	getpagesizes;
	pdfork;
	pdgetpid;
	pdkill;
	posix_fallocate;
	rctl_get_racct;
	rctl_get_rules;
	rctl_get_limits;
	rctl_add_rule;
	rctl_remove_rule;
	setloginclass;
};

FBSD_1.3 {
	accept4;
	aio_mlock;
	bindat;
	cap_fcntls_get;
	cap_fcntls_limit;
	cap_ioctls_get;
	cap_ioctls_limit;
	__cap_rights_get;
	cap_rights_limit;
	cap_sandboxed;
	chflagsat;
	clock_getcpuclockid2;
	connectat;
	ffclock_getcounter;
	ffclock_getestimate;
	ffclock_setestimate;
	pipe2;
	posix_fadvise;
	procctl;
	wait6;
};

FBSD_1.4 {
	futimens;
	ppoll;
	utimensat;
	numa_setaffinity;
	numa_getaffinity;
	sendmmsg;
	recvmmsg;
};

FBSD_1.5 {
	clock_nanosleep;
	elf_aux_info;
	fdatasync;
	fhstat;
	fhstatfs;
	fstat;
	fstatat;
	fstatfs;
	getdents;
	getdirentries;
	getfsstat;
	getrandom;
	kevent;
	lstat;
	mknod;
	mknodat;
	stat;
	statfs;
	cpuset_getdomain;
	cpuset_setdomain;
};

FBSD_1.6 {
	__sysctlbyname;
	aio_readv;
	aio_writev;
	close_range;
	copy_file_range;
	fhlink;
	fhlinkat;
	fhreadlink;
	getfhat;
	funlinkat;
	shm_create_largepage;
	shm_rename;
};

FBSD_1.7 {
	_Fork;
	fspacectl;
	kqueuex;
	membarrier;
	swapoff;
	timerfd_create;
	timerfd_gettime;
	timerfd_settime;
};

FBSD_1.8 {
	 kcmp;
};

FBSDprivate_1.0 {
	/* Add entries in sort(1) order */
	__libc_sigwait;
	__libsys_interposing_slot;
	__set_error_selector;
	__sigwait;
	gssd_syscall;
	nlm_syscall;
	rpctls_syscall;
};
