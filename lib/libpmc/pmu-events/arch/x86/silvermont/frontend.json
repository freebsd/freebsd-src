[
    {
        "BriefDescription": "Counts the number of baclears",
        "Counter": "0,1",
        "EventCode": "0xE6",
        "EventName": "BACLEARS.ALL",
        "PublicDescription": "The BACLEARS event counts the number of times the front end is resteered, mainly when the Branch Prediction Unit cannot provide a correct prediction and this is corrected by the Branch Address Calculator at the front end.  The BACLEARS.ANY event counts the number of baclears for any type of branch.",
        "SampleAfterValue": "200003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts the number of JCC baclears",
        "Counter": "0,1",
        "EventCode": "0xE6",
        "EventName": "BACLEARS.COND",
        "PublicDescription": "The BACLEARS event counts the number of times the front end is resteered, mainly when the Branch Prediction Unit cannot provide a correct prediction and this is corrected by the Branch Address Calculator at the front end.  The BACLEARS.COND event counts the number of JCC (Jump on Condtional Code) baclears.",
        "SampleAfterValue": "200003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Counts the number of RETURN baclears",
        "Counter": "0,1",
        "EventCode": "0xE6",
        "EventName": "BACLEARS.RETURN",
        "PublicDescription": "The BACLEARS event counts the number of times the front end is resteered, mainly when the Branch Prediction Unit cannot provide a correct prediction and this is corrected by the Branch Address Calculator at the front end.  The BACLEARS.RETURN event counts the number of RETURN baclears.",
        "SampleAfterValue": "200003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Counts the number of times a decode restriction reduced the decode throughput due to wrong instruction length prediction",
        "Counter": "0,1",
        "EventCode": "0xE9",
        "EventName": "DECODE_RESTRICTION.PREDECODE_WRONG",
        "PublicDescription": "Counts the number of times a decode restriction reduced the decode throughput due to wrong instruction length prediction.",
        "SampleAfterValue": "200003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Instruction fetches",
        "Counter": "0,1",
        "EventCode": "0x80",
        "EventName": "ICACHE.ACCESSES",
        "PublicDescription": "This event counts all instruction fetches, not including most uncacheable\r\nfetches.",
        "SampleAfterValue": "200003",
        "UMask": "0x3"
    },
    {
        "BriefDescription": "Instruction fetches from Icache",
        "Counter": "0,1",
        "EventCode": "0x80",
        "EventName": "ICACHE.HIT",
        "PublicDescription": "This event counts all instruction fetches from the instruction cache.",
        "SampleAfterValue": "200003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Icache miss",
        "Counter": "0,1",
        "EventCode": "0x80",
        "EventName": "ICACHE.MISSES",
        "PublicDescription": "This event counts all instruction fetches that miss the Instruction cache or produce memory requests. This includes uncacheable fetches. An instruction fetch miss is counted only once and not once for every cycle it is outstanding.",
        "SampleAfterValue": "200003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Counts the number of times entered into a ucode flow in the FEC.  Includes inserted flows due to front-end detected faults or assists.  Speculative count.",
        "Counter": "0,1",
        "EventCode": "0xE7",
        "EventName": "MS_DECODED.MS_ENTRY",
        "PublicDescription": "Counts the number of times the MSROM starts a flow of UOPS. It does not count every time a UOP is read from the microcode ROM.  The most common case that this counts is when a micro-coded instruction is encountered by the front end of the machine.  Other cases include when an instruction encounters a fault, trap, or microcode assist of any sort.  The event will count MSROM startups for UOPS that are speculative, and subsequently cleared by branch mispredict or machine clear.  Background: UOPS are produced by two mechanisms.  Either they are generated by hardware that decodes instructions into UOPS, or they are delivered by a ROM (called the MSROM) that holds UOPS associated with a specific instruction.  MSROM UOPS might also be delivered in response to some condition such as a fault or other exceptional condition.  This event is an excellent mechanism for detecting instructions that require the use of MSROM instructions.",
        "SampleAfterValue": "200003",
        "UMask": "0x1"
    }
]