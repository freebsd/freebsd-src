.\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.Dd March 24, 2024
.Dt PRINTF 3
.Os
.Sh NAME
.Nm printf ,
.Nm fprintf ,
.Nm sprintf ,
.Nm snprintf ,
.Nm asprintf ,
.Nm dprintf ,
.Nm vprintf ,
.Nm vfprintf ,
.Nm vsprintf ,
.Nm vsnprintf ,
.Nm vasprintf ,
.Nm vdprintf
.Nd formatted output conversion
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In stdio.h
.Ft int
.Fn printf "const char * restrict format" ...
.Ft int
.Fn fprintf "FILE * restrict stream" "const char * restrict format" ...
.Ft int
.Fn sprintf "char * restrict str" "const char * restrict format" ...
.Ft int
.Fn snprintf "char * restrict str" "size_t size" "const char * restrict format" ...
.Ft int
.Fn asprintf "char **ret" "const char *format" ...
.Ft int
.Fn dprintf "int fd" "const char * restrict format" ...
.In stdarg.h
.Ft int
.Fn vprintf "const char * restrict format" "va_list ap"
.Ft int
.Fn vfprintf "FILE * restrict stream" "const char * restrict format" "va_list ap"
.Ft int
.Fn vsprintf "char * restrict str" "const char * restrict format" "va_list ap"
.Ft int
.Fn vsnprintf "char * restrict str" "size_t size" "const char * restrict format" "va_list ap"
.Ft int
.Fn vasprintf "char **ret" "const char *format" "va_list ap"
.Ft int
.Fn vdprintf "int fd" "const char * restrict format" "va_list ap"
.Sh DESCRIPTION
The
.Fn printf
family of functions produces output according to a
.Fa format
as described below.
This format may contain
.Dq conversion specifiers ;
the results of such conversions, if any, depend on the arguments
following the
.Fa format
string.
.Pp
The
.Fn printf
and
.Fn vprintf
functions write output to the standard output stream,
.Em stdout ;
.Fn fprintf
and
.Fn vfprintf
write output to the given output
.Fa stream ;
.Fn dprintf
and
.Fn vdprintf
write output to the given file descriptor;
.Fn sprintf ,
.Fn snprintf ,
.Fn vsprintf ,
and
.Fn vsnprintf
write to the character string
.Fa str ;
.Fn asprintf
and
.Fn vasprintf
dynamically allocate a new string with
.Xr malloc 3
that is stored in
.Fa ret .
.Pp
These functions write the output under the control of a
.Fa format
string that specifies how subsequent arguments
(or arguments accessed via the variable-length argument facilities of
.Xr stdarg 3 )
are converted for output.
.Pp
.Fn asprintf
and
.Fn vasprintf
functions
set
.Fa *ret
to be a pointer to a buffer sufficiently large to hold the formatted string.
This pointer should be passed to
.Xr free 3
to release the allocated storage when it is no longer needed.
If sufficient space cannot be allocated,
.Fn asprintf
and
.Fn vasprintf
will return \-1 and set
.Fa ret
to be a
.Dv NULL
pointer.
.Pp
.Fn snprintf
and
.Fn vsnprintf
functions
will write at most
.Fa size Ns \-1
of the characters to
.Fa str
of the characters printed into the output string
(the
.Fa size Ns 'th
character then gets the terminating
.Ql \e0 ) ;
if the return value is greater than or equal to the
.Fa size
argument, the string was too short
and some of the print characters are discarded.
The output is null-terminated, unless
.Fa size
is 0.
.Pp
.Fn sprintf
and
.Fn vsprintf
functions
effectively assume a
.Fa size
of
.Dv INT_MAX + 1 ;
results in an infinite
.Fa size ;
their use is not recommended.
.Pp
The format string is composed of zero or more directives:
ordinary
.\" multibyte
characters (not
.Cm % ) ,
which are copied unchanged to the output stream;
and conversion specifications, each of which results
in fetching zero or more subsequent arguments.
Each conversion specification is introduced by
the
.Cm %
character.
The arguments must correspond properly (after type promotion)
with the conversion specifier.
After the
.Cm % ,
the following appear in sequence:
.Pp
The overall syntax of a conversion specification is:
.Bd -filled -offset indent
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Ar flags
.Op Ar width
.Op . Ar precision
.Op Ar size
.Ar conversion
.Sm on
.Ed
.Pp
Not all combinations of these parts are meaningful;
see the description of the individual
.Ar conversion
specifiers for details.
.Pp
The parts of a conversion specification are as follows:
.Bl -tag -wdith Ds
.It Cm %
A literal percent character begins a conversion specification.
.It Ar argno Ns Cm $
An optional field, consisting of a decimal digit string followed by a
.Cm $ ,
specifying the next argument to access.
If this field is not provided, the argument following the last
argument accessed will be used.
Arguments are numbered starting at
.Cm 1 .
If unaccessed arguments in the format string are interspersed with ones that
are accessed the results will be indeterminate.
.It Ar flags
Zero or more of the following flags:
.Bl -tag -width 11n
.It Cm # Pq hash
Use an
.Dq alternate form
for the output.
For
.Cm c , d , i , n , p , s ,
and
.Cm u
conversions, this option has no effect.
For
.Cm b
and
.Cm B
conversions, a non-zero result has the string
.Ql 0b
(or
.Ql 0B
for
.Cm B
conversions) prepended to it.
For
.Cm o
conversions, the
.Ar precision
of the number is increased to force the first
character of the output string to a zero.
For
.Cm x
and
.Cm X
conversions, a non-zero result has the string
.Ql 0x
(or
.Ql 0X
for
.Cm X
conversions) prepended to it.
For
.Cm a , A , e , E , f , F , g ,
and
.Cm G
conversions, the result will always contain a decimal point, even if no
digits follow it (normally, a decimal point appears in the results of
those conversions only if a digit follows).
For
.Cm g
and
.Cm G
conversions, trailing zeros are not removed from the result as they
would otherwise be.
.It Cm 0 (zero)
Zero padding.
For all conversions except
.Cm n ,
the converted value is padded on the left with zeros rather than blanks.
If a
.Ar precision
is given with a numeric
.Ar conversion
.Cm ( b , B , d , i , o , u , i , x ,
and
.Cm X ) ,
the
.Cm 0
flag is ignored.
.It Cm \- Pq minus
A negative field width flag;
the converted value is to be left adjusted on the field boundary.
Except for
.Cm n
.Ar conversion ,
the converted value is padded on the right with blanks,
rather than on the left with blanks or zeros.
A
.Cm \-
overrides a
.Cm 0
if both are given.
.It So "\ " Sc (space)
For signed conversions, print a space character before a positive number
associated with these
.Ar conversion
options
.Cm ( a , A , d , e , E , f , F , g , G ,
or
.Cm i ) .
.It Cm + Pq plus
A sign must always be placed before a
number produced by a signed
.Ar conversion .
.Cm +
overrides a space if both are specified.
.It So "'" Sc (apostrophe)
Decimal conversions
.Cm ( d , u ,
or
.Cm i )
or the integral portion of a floating point conversion
.Cm ( f
or
.Cm F )
should be grouped and separated by thousands using
the non-monetary separator returned by
.Xr localeconv 3 .
.El
.Itg
.It Ar width
An optional decimal digit string specifying a minimum field width.
If the converted value has fewer characters than the field width, it will
be padded with spaces on the left (or right, if the left-adjustment
flag has been given) to fill out
the field width.
.It Pf . Ar precision
An optional precision, in the form of a period
.Cm \&.
followed by an
optional digit string.
If the digit string is omitted, the precision is taken as zero.
This gives the minimum number of digits to appear for
.Cm b , B , d , i , o , u , x ,
and
.Cm X
conversions, the number of digits to appear after the decimal-point for
.Cm a , A , e , E , f ,
and
.Cm F
conversions, the maximum number of significant digits for
.Cm g
and
.Cm G
conversions, or the maximum number of characters to be printed from a
string for
.Cm s
conversions.
.It Ar size
An optional length modifier, that specifies the size of the argument.
The following length modifiers are valid for the
.Cm b , B , d , i , n , o , u , x ,
or
.Cm X
conversion:
.Bl -column ".Cm q Em (deprecated)" ".Vt signed char" ".Vt unsigned long long" ".Vt long long *"
.It Sy Modifier Ta Cm d , i Ta Cm b , B , o , u , x , X Ta Cm n
.It Cm hh Ta Vt "signed char" Ta Vt "unsigned char" Ta Vt "signed char *"
.It Cm h Ta Vt short Ta Vt "unsigned short" Ta Vt "short *"
.It Cm l No (ell) Ta Vt long Ta Vt "unsigned long" Ta Vt "long *"
.It Cm ll No (ell ell) Ta Vt "long long" Ta Vt "unsigned long long" Ta Vt "long long *"
.It Cm j Ta Vt intmax_t Ta Vt uintmax_t Ta Vt "intmax_t *"
.It Cm t Ta Vt ptrdiff_t Ta (see note) Ta Vt "ptrdiff_t *"
.It Cm w Ns Ar N Ta Vt intN_t Ta Vt uintN_t Ta Vt "intN_t *"
.It Cm wf Ns Ar N Ta Vt int_fastN_t Ta Vt uint_fastN_t Ta Vt "int_fastN_t *"
.It Cm z Ta (see note) Ta Vt size_t Ta (see note)
.It Cm q Em (deprecated) Ta Vt quad_t Ta Vt u_quad_t Ta Vt "quad_t *"
.El
.Pp
Note:
the
.Cm t
modifier, when applied to a
.Cm b , B , o , u , x ,
or
.Cm X
conversion, indicates that the argument is of an unsigned type
equivalent in size to a
.Vt ptrdiff_t .
The
.Cm z
modifier, when applied to a
.Cm d
or
.Cm i
conversion, indicates that the argument is of a signed type equivalent in
size to a
.Vt size_t .
Similarly, when applied to an
.Cm n
conversion, it indicates that the argument is a pointer to a signed type
equivalent in size to a
.Vt size_t .
.Pp
The following length modifier is valid for the
.Cm a , A , e , E , f , F , g ,
or
.Cm G
conversion:
.Bl -column ".Sy Modifier" ".Cm a , A , e , E , f , F , g , G"
.It Sy Modifier Ta Cm a , A , e , E , f , F , g , G
.It Cm l No (ell) Ta Vt double
(ignored, same behavior as without it)
.It Cm L Ta Vt "long double"
.El
.Pp
The following length modifier is valid for the
.Cm c
or
.Cm s
conversion:
.Bl -column ".Sy Modifier" ".Vt wint_t" ".Vt wchar_t *"
.It Sy Modifier Ta Cm c Ta Cm s
.It Cm l No (ell) Ta Vt wint_t Ta Vt "wchar_t *"
.El
.It
A character that specifies the type of conversion to be applied.
.El
.Pp
A field
.Ar width
or
.Ar precision ,
or both, may be indicated as
.Cm * Ns Op Ar argno Ns Cm $ ,
i.e. as an aterisk optionally followed
by an unsigned decimal digit string and a dollar sign.
In this case, an
.Vt int
argument supplies the field
.Ar width
org
.Ar precision .
A negative field
.Ar widthg
is treated as a left adjustment flag followed by a
positive field
.Ar width ;
a negativeg
.Ar precision
is treated as though it were
missing.
If a single format directive mixes positional
.Ar argno Ns Cm $
and modifiers, the result is undefined.
.Pp
The conversion specifiers are:
.Pp
.Bl -tag -width ".Cm %"
.It Cm %
No argument is converted.
The completeg
.Ar conversion
specification
is
.Ql %% .
.El
.Bl -tag -width ".Cm A"
.It Cm A
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm #
.Op CM \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar hexadecimals
.Op Cm L | l
.Cm A
.Sm On
.Pp
.Cm A
conversion uses the prefix
.Dq Li 0X ,
the letters
.Dq Li ABCDEF
to represent theg
.Ar hexadecimal
characters, and the letter
.Ql P
to separate the mantissa and exponent.
.Pp
The
.Vt double
argument is rounded and converted tog
.Ar hexadecimal
notation in the style
.Sm off
.Oo \- Oc Li 0x Ar h Li \&. Ar hhhp Oo \(+- Oc Ar d ,
.Sm on
where the number of digits after the hexadecimal-point character
is equal to theg
.Ar precision
specification.
If theg
.Ar precision
is missing, it is taken as enough to represent
the floating-point number exactly, and no rounding occurs.
If theg
.Ar precision
is zero, no hexadecimal-point character appears.
The
.Cm p
is a literal character
.Ql p ,
and the exponent consists of a positive or negative sign
followed by a decimal number representing an exponent of 2.
.Pp
Note that there may be multiple valid ways to represent floating-point
numbers in this hexadecimal format.
For example,
.Li 0x1.92p+1 , 0x3.24p+0 , 0x6.48p-1 ,
and
.Li 0xc.9p-2
are all equivalent.
.Fx 8.0
and later always prints finite non-zero numbers using
.Ql 1
as the digit before the hexadecimal point.
Zeroes are always represented with a mantissa of 0 (preceded by a
.Ql -
if appropriate) and an exponent of
.Li +0 .
.Pp
.It Cm a
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm #
.Op CM \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar hexadecimals
.Op Cm L | l
.Cm a
.Sm On
.Pp
.Cm a
conversion uses the prefix
.Dq Li 0x ,
the letters
.Dq Li abcdef
to represent theg
.Ar hexadecimal
charcters, and the letter 'p' to separate the mantissa and exponent.
.Pp
The
.Vt double
argument is rounded and converted tog
.Ar hexadecimal
notation in the style
.Sm off
.Oo \- Oc Li 0x Ar h Li \&. Ar hhhp Oo \(+- Oc Ar d ,
.Sm on
where the number of digits after the hexadecimal-point character
is equal to theg
.Ar precision
specification.
If theg
.Ar precision
is missing, it is taken as enough to represent
the floating-point number exactly, and no rounding occurs.
If theg
.Ar precision
is zero, no hexadecimal-point character appears.
The
.Cm p
is a literal character
.Ql p ,
and the exponent consists of a positive or negative sign
followed by a decimal number representing an exponent of 2.
.Pp
Note that there may be multiple valid ways to represent floating-point
numbers in this hexadecimal format.
For example,
.Li 0x1.92p+1 , 0x3.24p+0 , 0x6.48p-1 ,
and
.Li 0xc.9p-2
are all equivalent.
.Fx 8.0
and later always prints finite non-zero numbers using
.Ql 1
as the digit before the hexadecimal point.
Zeroes are always represented with a mantissa of 0 (preceded by a
.Ql -
if appropriate) and an exponent of
.Li +0 .
.Pp
.It Cm b
The
.Vt unsigned int
(or appropriate variant) argument is converted to unsigned binary.
This is used for
.Cm x
conversions.
.Pp
.It Cm B
The
.Vt unsigned int
(or apporiate variant) argument is converted to unsigned binary.
This is used for
.Cm X
conversions.
.It Cm C
Treated as
.Cm c
with the
.Cm l
(ell) modifier.
.It Cm c
The
.Vt int
argument is converted to an
.Vt "unsigned char" ,
and the resulting character is written.
.Pp
If the
.Cm l
(ell) modifier is used, the
.Vt wint_t
argument shall be converted to a
.Vt wchar_t ,
and the (potentially multi-byte) sequence representing the
single wide character is written, including any shift sequences.
If a shift sequence is used, the shift state is also restored
to the original state after the character.
.It Cm D
A deprecated alias for
.Cm %ld .
.It Cm d
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar mindigits
.Op Ar size
.Cm d
.Sm on
.Pp
The
.Vt int
argument is converted to signed decimal notation.
If specified, at least
.Ar mindigits
are printed, padding with leading zeros if needed.
.It Cm E
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm #
.Op Cm \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar decimals
.Op Cm L | l
.Cm E
.Sm on
.Pp
The
.Vt double
argument is rounded and converted in the style
.Sm off
.Oo \- Oc Ar d Li \&. Ar ddd Li E \(+- Ar dd
.Sm on
where there is one digit before the
decimal-point character
and the number of digits after it is equal to theg
.Ar precision ;
if theg
.Ar precision
is missing,
it is taken as 6; if theg
.Ar precision
is
zero, no decimal-point character appears.
An
.Cm E
conversion uses the letter
.Ql E
to introduce the exponent.
The exponent always contains at least two digits; if the value is zero,
the exponent is 00.
.Pp
If the argument is infinity, it is converted tog
.Li INFg
org
.Li -INF .
If the argument is not-a-number (NaN), it is converted tog
.Li NANg
or
.Li -NAN .
.It Cm e
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm #
.Op Cm \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar decimals
.Op Cm L | l
.Cm e
.Sm on
.Pp
The
.Vt double
argument is rounded and converted in the style
.Sm off
.Oo \- Oc Ar d Li \&. Ar ddd Li e \(+- Ar dd
.Sm on
where there is one digit before the
decimal-point character
and the number of digits after it is equal to theg
.Ar precision ;
if theg
.Ar precision
is missing,
it is taken as 6; if theg
.Ar precision
is
zero, no decimal-point character appears.
An
.Cm e
conversion uses the letter
.Ql e
to introduce the exponent.
The exponent always contains at least two digits; if the value is zero,
the exponent is 00.
.Pp
If the argument is infinity, it is converted to
.Li INF
or
.Li -INF .
If the argument is not-a-number (NaN), it is converted to
.Li NAN
or
.Li -NAN .
.It Cm F
.Sm off
.Cm %
.Op ar argno Cm $
.Op Cm #
.Op Cm \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar decimals
.Op Cm L | l
.Cm F
.Sm on
.Pp
The
.Vt double
argument is rounded and converted to decimal notation [\-]ddd.dddddd with
.Ar decimals ,
or six digits by default, after the decimal point.
If
.Ar decimals
is zero and the
.Sq Cm #
flag is not given, the decimal point is omitted.
If a decimal point appears, at least one digit appears before it.
If the argument is infinity, it is converted to
.Ql INF or
.Ql -INF .
If the argument is not-anumber (NaN), it is converted to
.Ql NAN or
.Ql -NAN .
.It Cm f
.Sm off
.Cm %
.Op ar argno Cm $
.Op Cm #
.Op Cm \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar decimals
.Op Cm L | l
.Cm f
.Sm on
.Pp
The
.Vt double
argument is rounded and converted to decimal notation [\-]ddd.dddddd with
.Ar decimals ,
or six digits by default, after the decimal point.
If
.Ar decimals
is zero and the
.Sq Cm #
flag is not given, the decimal point is omitted.
If a decimal point appears, at least one digit appears before it.
If the argument is infinity, it is converted to
.Ql inf or
.Ql -inf .
If the argument is not-anumber (NaN), it is converted to
.Ql nan or
.Ql -nan .
.It Cm i
An alias for
.Cm d ,
supporting the same modifiers.
The
.Vt int
argument is converted to a signed decimal notation.
.It Cm G
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm #
.Op Cm \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar significant
.Op Cm L | l
.Cm G
.Sm on
.Pp
The
.Vt double
argument is converted in style
.Cm F
or
.Cm E
.Pq general gloating point notation
with
.Ar significant
digits, or six significant digits by default.
If
.Ar significant
is zero, one is used instead.
Style
.Cm e
is used if the exponent from its conversion is less than \-4
or greater than or equal to
.Ar significant .
Unless the
.Sq Cm #
flag is given, trailing zeros are removed from the fractional
part of the result, and the decimal point only appears if it is
followed by a least one digit.
.It Cm g
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm #
.Op Cm \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar significant
.Op Cm L | l
.Cm g
.Sm on
.Pp
The
.Vt double
argument is converted in style
.Cm f
or
.Cm e
.Pq general gloating point notation
with
.Ar significant
digits, or six significant digits by default.
If
.Ar significant
is zero, one is used instead.
Style
.Cm e
is used if the exponent from its conversion is less than \-4
or greater than or equal to
.Ar significant .
Unless the
.Sq Cm #
flag is given, trailing zeros are removed from the fractional
part of the result, and the decimal point only appears if it is
followed by a least one digit.
.Pp
.It Cm m
Print the string representation of the error code stored in the
.Dv errno
variable at the beginning of the call, as returned by
.Xr strerror 3 .
No argument is taken.
.It Cm n
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Ar size 
.Cm n
.Sm on
.Pp
The number of characters written so far is stored into the
integer indicated by the
.Vt "int *"
(or variant) pointer argument.
No argument is converted.
.It Cm O
A deprecated alias for
.Ar lo .
.It Cm o
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm #
.Op Cm \~ | +
.Op Cm \- | 0
.Op Ar width
.Op . Ar significant
.Op Cm L | l
.Cm o
.Sm on
.Pp
Similar to
.Ar u
except that the
.Ar unsigned int
argument is converted to unsigned octal notation.
If the 
.Ql # 
flag is given,
.Ar minidigits
is increased such that the first digit printed is a zero, except
if a zero value is printed with an explicit
.Ar minidigts
of zero.
.Pp
.It Cm p
The
.Vt "void *"
pointer argument is printed in
.Ar hexadecimal
(as if by
.Ql %#x
or
.Ql %#lx ) .
.Pp
.Pp
.It Cm S
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm \-
.Op Ar width
.Op . Ar maxbytes
.Cm ls
.Sm on
.Pp
Treated as
.Cm s
with the
.Cm l
(ell) modifier.
.Pp
If the
.Cm l
(ell) modifier is used, the
.Vt "wchar_t *"
argument is expected to be a pointer to an array of wide characters
(pointer to a wide string).
For each wide character in the string, the (potentially multi-byte)
sequence representing the
wide character is written, including any shift sequences.
If any shift sequence is used, the shift state is also restored
to the original state after the string.
Wide characters from the array are written up to (but not including)
a terminating wide
.Dv NUL
character;
if a precision is specified, no more than the number of bytes specified are
written (including shift sequences).
Partial characters are never written.
If a precision is given, no null character
need be present; if the precision is not specified, or is greater than
the number of bytes required to render the multibyte representation of
the string, the array must contain a terminating wide
.Dv NUL
character.
.It Cm s
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm \-
.Op Ar width
.Op . Ar maxbytes
.Cm s
.Sm on
.Pp
The
.Vt "char *"
argument is expected to be a pointer to an array of character type (pointer
to a string).
Characters from the array are written up to (but not including)
a terminating
.Dv NUL
character;
if a precision is specified, no more than the number specified are
written.
If a precision is given, no null character
need be present; if theg
.Ar precision
is not specified, or is greater than
the size of the array, the array must contain a terminating
.Dv NUL
character.
.It Cm U
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm \~ | 0
.Op .Ar mindigits
.Op .Ar size
.Cm U
.Sm on
.Pp
A deprecated alias forg
.Cm lu .
.It Cm u
.Sm off
.Cm %
.Op Ar argno Cm $
.Op Cm \~ | 0
.Op .Ar mindigits
.Op .Ar size
.Cm u
.Sm on
.Pp
The
.Vt unsigned int
argument is converted to unsigned decimal notation.
If specified, at least
.Ar mindigits
are printed, padding with leading zeros if needed.
The following are similar to
.Cm u
except that they take an argument of a different size:
.Bl -column %hhu
.It Cm hhu Ta Vt unsigned char
.It Cm hu  Ta Vt unsigned short
.It Cm u   Ta Vt unsigned int
.It Cm lu  Ta Vt unsigned long Pq percent ell u
.It Cm llu Ta Vt unsigned long long Pq percent ell ell u
.It Cm ju  Ta Vt uintmax_t
.It Cm tu  Ta unsigned type of same size as Vt ptrdiff_t
.It Cm zu  Ta Vt size_t
.It Cm qu  Ta Vt u_quad_t Pq deprecated
.El
.Pp
.It Cm X
.Sm off
.Cm %
.Op ar argno Cm $
.Op Cm #
.Op Cm \- | 0
.Op Ar width
.Op . Ar mindigits
.Op Ar size
.Cm X
.Sm on
.Pp
Identical to
.Vt x
except that upper case is used, i.e. '0X' for the
optional prefix and
.Ql 0123456789ABCDEF
for the digits.
.Pp
.It Cm x
.Sm off
.Cm %
.Op ar argno Cm $
.Op Cm #
.Op Cm \- | 0
.Op Ar width
.Op . Ar mindigits
.Op Ar size
.Cm x
.Sm on
.Pp
Similar to
.Vt u
except that theg
.Vt unsigned int
argument is converted to unsigned hexadecimal notation using the digits
.Ql 0123456789abcdef .
If the
.Sq CM #
flag is given, the string
.Ql 0x
is prepended unless the value is zero.
The decimal point
character is defined in the program's locale (category
.Dv LC_NUMERIC ) .
.Pp
In no case does a non-existent or small field width cause truncation of
a numeric field; if the result of ag
.Ar conversion
is wider than the field
width, the
field is expanded to contain the
.Ar conversion
result.
.Sh RETURN VALUES
These functions return the number of characters printed
(not including the trailing
.Ql \e0
used to end output to strings),
except for
.Fn snprintf
and
.Fn vsnprintf ,
which return the number of characters that would have been printed if the
.Fa size
were unlimited
(again, not including the final
.Ql \e0 ) .
These functions return a negative value if an error occurs.
.Sh EXAMPLES
To print a date and time in the form
.Dq Li "Sunday, July 3, 10:02" ,
where
.Fa weekday
and
.Fa month
are pointers to strings:
.Bd -literal -offset indent
#include <stdio.h>
fprintf(stdout, "%s, %s %d, %.2d:%.2d\en",
	weekday, month, day, hour, min);
.Ed
.Pp
To print \*(Pi
to five decimal places:
.Bd -literal -offset indent
#include <math.h>
#include <stdio.h>
fprintf(stdout, "pi = %.5f\en", 4 * atan(1.0));
.Ed
.Pp
To allocate a 128 byte string and print into it:
.Bd -literal -offset indent
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
char *newfmt(const char *fmt, ...)
{
	char *p;
	va_list ap;
	if ((p = malloc(128)) == NULL)
		return (NULL);
	va_start(ap, fmt);
	(void) vsnprintf(p, 128, fmt, ap);
	va_end(ap);
	return (p);
}
.Ed
.Sh COMPATIBILITY
The conversion formats
.Cm D , O ,
and
.Cm U
are not standard and
are provided only for backward compatibility.
The conversion format
.Cm \&%m
is also not standard and provides the popular extension from the
.Tn GNU C
library.
.Pp
The effect of padding the
.Cm p
format with zeros (either by the
.Cm 0
flag or by specifying a precision), and the benign effect (i.e., none)
of the
.Cm #
flag on
.Cm %n
and
.Cm p
conversions, as well as other
nonsensical combinations such as
.Cm Ld ,
are not standard; such combinations
should be avoided.
.Sh ERRORS
In addition to the errors documented for the
.Xr write 2
system call, the
.Fn printf
family of functions may fail if:
.Bl -tag -width Er
.It Bq Er EILSEQ
An invalid wide character code was encountered.
.It Bq Er ENOMEM
Insufficient storage space is available.
.It Bq Er EOVERFLOW
The
.Fa size
argument exceeds
.Dv INT_MAX + 1 ,
or the return value would be too large to be represented by an
.Vt int .
.El
.Sh SEE ALSO
.Xr printf 1 ,
.Xr errno 2 ,
.Xr fmtcheck 3 ,
.Xr scanf 3 ,
.Xr setlocale 3 ,
.Xr strerror 3 ,
.Xr wprintf 3
.Sh STANDARDS
Subject to the caveats noted in the
.Sx BUGS
section below, the
.Fn fprintf ,
.Fn printf ,
.Fn sprintf ,
.Fn vprintf ,
.Fn vfprintf ,
and
.Fn vsprintf
functions
conform to
.St -ansiC
and
.St -isoC-99 .
With the same reservation, the
.Fn snprintf
and
.Fn vsnprintf
functions conform to
.St -isoC-99 ,
while
.Fn dprintf
and
.Fn vdprintf
conform to
.St -p1003.1-2008 .
.Sh HISTORY
The functions
.Fn asprintf
and
.Fn vasprintf
first appeared in the
.Tn GNU C
library.
These were implemented by
.An Peter Wemm Aq Mt peter@FreeBSD.org
in
.Fx 2.2 ,
but were later replaced with a different implementation
from
.Ox 2.3
by
.An Todd C. Miller Aq Mt Todd.Miller@courtesan.com .
The
.Fn dprintf
and
.Fn vdprintf
functions were added in
.Fx 8.0 .
The
.Cm \&%m
format extension first appeared in the
.Tn GNU C
library, and was implemented in
.Fx 12.0 .
.Sh BUGS
The
.Nm
family of functions do not correctly handle multibyte characters in the
.Fa format
argument.
.Sh SECURITY CONSIDERATIONS
The
.Fn sprintf
and
.Fn vsprintf
functions are easily misused in a manner which enables malicious users
to arbitrarily change a running program's functionality through
a buffer overflow attack.
Because
.Fn sprintf
and
.Fn vsprintf
assume an infinitely long string,
callers must be careful not to overflow the actual space;
this is often hard to assure.
For safety, programmers should use the
.Fn snprintf
interface instead.
For example:
.Bd -literal
void
foo(const char *arbitrary_string, const char *and_another)
{
	char onstack[8];

#ifdef BAD
	/*
	 * This first sprintf is bad behavior.  Do not use sprintf!
	 */
	sprintf(onstack, "%s, %s", arbitrary_string, and_another);
#else
	/*
	 * The following two lines demonstrate better use of
	 * snprintf().
	 */
	snprintf(onstack, sizeof(onstack), "%s, %s", arbitrary_string,
	    and_another);
#endif
}
.Ed
.Pp
The
.Fn printf
and
.Fn sprintf
family of functions are also easily misused in a manner
allowing malicious users to arbitrarily change a running program's
functionality by either causing the program
to print potentially sensitive data
.Dq "left on the stack" ,
or causing it to generate a memory fault or bus error
by dereferencing an invalid pointer.
.Pp
.Cm %n
can be used to write arbitrary data to potentially carefully-selected
addresses.
Programmers are therefore strongly advised to never pass untrusted strings
as the
.Fa format
argument, as an attacker can put format specifiers in the string
to mangle your stack,
leading to a possible security hole.
This holds true even if the string was built using a function like
.Fn snprintf ,
as the resulting string may still contain user-supplied conversion specifiers
for later interpolation by
.Fn printf .
.Pp
Always use the proper secure idiom:
.Pp
.Dl "snprintf(buffer, sizeof(buffer), \*q%s\*q, string);"
