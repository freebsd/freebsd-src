PARSE reference clock driver:

This directory contains the files making up the parser for
the parse refclock driver. For reasonably sane clocks this refclock
drivers allows a refclock implementation by just providing a
conversion routine and the appropriate NTP parameters. Refclock
support can run as low a 3k code with the parse refclock driver.

The modules in here are designed to live in two worlds. In userlevel
as part of the xntp daemon and in kernel land as part of a STREAMS module
or, if someone gets to it, as part of a line discipline. Currently only
SunOS4.x/SunOS5.x STREAMS are supported (volunteers for other vendors like HP?).
This structure means, that refclock_parse can work with or without kernel
support. Kernelsupport increases accuracy tremendingly. The current restriction
of the parse driver is that it only supports SYSV type ttys and that kernel
support is only available for Suns right now.

Three kernel modules are part of this directory. These work only on
SunOS (SunOS4 and SunOS5).

	SunOS4 (aka Solaris 1.x):
		parsestreams.loadable_module.o	- standard parse module for SunOS 4

		Both modules can be loaded via modload <modulename>.

	SunOS5 (aka Solaris 2.x):
		parse		- auto loadable streams module

		To install just drop "parse" into /kernel/strmod and
		start the daemon (SunOS5 will do the rest).

The structure of the parse reference clock driver is as follows:

	ntpd	- contains NTP implementation and calls a reference clock
		  127.127.8.x which is implemented by
	 	  refclock_parse.c
		  - which contains several refclock decriptions. These are
		    selected by the x part of the refclock address.
		    The lower two bits specify the device to use. Thus the
		    value (x % 4) determines the device to open
		    (/dev/refclock-0 - /dev/refclock-3).

		    The kind of clock is selected by the mode parameter. This parameter
		    selects the clock type which deterimines how I/O is done,
		    the tty parameters and the NTP parameters.

		    refclock_parse operates on an abstract reference clock
		    that delivers time stamps and stati. Offsets and sychron-
		    isation information is derived from this data and passed
		    on to refclock_receive of xntp which uses that data for
		    syncronisation.

		    The abstract reference clock is generated by the parse*
		    routines. They parse the incoming data stream from the
		    clock and convert it to the appropriate time stamps.
		    The data is also mapped int the abstract clock states
		    	POWERUP - clock has no valid phase and time code
				  information

			NOSYNC	- Time code is not confirmed, phase is probably
				  ok.
			SYNC	- Time code and phase are correct.

		    A clock is trusted for a certain time (type parameter) when
		    it leaves the SYNC state. This is derived from the
		    observation that quite a few clocks can still generate good
		    time code information when losing contact to their
		    synchronisation source. When the clock does not reagain
		    synchronisation in that trust period it will be deemed
		    unsynchronised until it regains synchronisation. The same
		    will happen if xntp sees the clock unsynchronised at
		    startup.

		    The upper bit of x specifies that all samples delivered
		    from the clock should be used to discipline the NTP
		    loopfilter. For clock with accurate once a second time
		    information this means big improvements for time keeping.
		    A prerequisite for passing on the time stamps to
		    the loopfilter is, that the clock is in synchronised state.

	   parse.c  These are the general routines to parse the incoming data
		    stream. Usually these routines should not require
		    modification.

	   clk_*.c  These files hole the conversion code for the time stamps
		    and the description how the time code can be parsed and
		    where the time stamps are to be taken.
		    If you want to add a new clock type this is the file
		    you need to write in addition to mention it in
		    parse_conf.c and setting up the NTP and TTY parameters
		    in refclock_parse.c.

Further information can be found in parse/README.parse and the various source
files.

Frank Kardel
