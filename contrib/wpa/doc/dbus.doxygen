/**
\page dbus wpa_supplicant D-Bus API

This section documents the wpa_supplicant D-Bus API. Every D-Bus
interface implemented by wpa_supplicant is described here including
their methods, signals, and properties with arguments, returned
values, and possible errors.

Interfaces:
- \ref dbus_main
- \ref dbus_interface
- \ref dbus_wps
- \ref dbus_p2pdevice
- \ref dbus_bss
- \ref dbus_network
- \ref dbus_peer
- \ref dbus_group
- \ref dbus_persistent_group
- \ref dbus_mesh


\section dbus_main fi.w1.wpa_supplicant1

Interface implemented by the main wpa_supplicant D-Bus object
registered in the bus with fi.w1.wpa_supplicant1 name.

\subsection dbus_main_methods Methods

<ul>
      <li>
	<h3>CreateInterface ( a{sv} : args ) --> o : interface</h3>
	<p>Registers a wireless interface in wpa_supplicant.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : args</dt>
	  <dd>
	    A dictionary with arguments used to add the interface to wpa_supplicant. The dictionary may contain the following entries:
	    <table>
	      <tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th>
	      <tr><td>Ifname</td><td>s</td><td>Name of the network interface to control, e.g., wlan0</td><td>Yes</td>
	      <tr><td>BridgeIfname</td><td>s</td><td>Name of the bridge interface to control, e.g., br0</td><td>No</td>
	      <tr><td>Driver</td><td>s</td><td>Driver name which the interface uses, e.g., nl80211</td><td>No</td>
	      <tr><td>ConfigFile</td><td>s</td><td>Configuration file path</td><td>No</td>
	    </table>
	  </dd>
	</dl>
	<h4>Returns</h4>
	<dl>
	  <dt>o : interface</dt>
	  <dd>A D-Bus path to object representing created interface</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InterfaceExists</dt>
	  <dd>wpa_supplicant already controls this interface.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Creating interface failed for an unknown reason.</dd>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>Invalid entries were found in the passed argument.</dd>
	</dl>
      </li>

      <li>
	<h3>RemoveInterface ( o : interface ) --> nothing</h3>
	<p>Deregisters a wireless interface from wpa_supplicant.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : interface</dt>
	  <dd>A D-Bus path to an object representing an interface to remove returned by CreateInterface</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InterfaceUnknown</dt>
	  <dd>Object pointed by the path doesn't exist or doesn't represent an interface.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Removing interface failed for an unknown reason.</dd>
	</dl>
      </li>

      <li>
	<h3>GetInterface ( s : ifname ) --> o : interface</h3>
	<p>Returns a D-Bus path to an object related to an interface which wpa_supplicant already controls.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : ifname</dt>
	  <dd>Name of the network interface, e.g., wlan0</dd>
	</dl>
	<h4>Returns</h4>
	<dl>
	  <dt>o : interface</dt>
	  <dd>A D-Bus path to an object representing an interface</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InterfaceUnknown</dt>
	  <dd>An interface with the passed name in not controlled by wpa_supplicant.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Getting an interface object path failed for an unknown reason.</dd>
	</dl>
      </li>

      <li>
	<h3>ExpectDisconnect ( ) --> nothing</h3>
	<p>Notify wpa_supplicant of an externally triggered disconnection, e.g., due to system suspend.</p>
      </li>
    </ul>

\subsection dbus_main_properties Properties

<ul>
      <li>
	<h3>DebugLevel - s - (read/write)</h3>
	<p>Global wpa_supplicant debugging level. Possible values are
	"msgdump" (verbose debugging), "debug" (debugging),
	"info" (informative), "warning" (warnings), and "error" (errors).</p>
      </li>

      <li>
	<h3>DebugTimestamp - b - (read/write)</h3>
	<p>Global wpa_supplicant debugging parameter. Determines if timestamps are shown in debug logs.</p>
      </li>

      <li>
	<h3>DebugShowKeys - b - (read/write)</h3>
	<p>Global wpa_supplicant debugging parameter. Determines if secrets are shown in debug logs.</p>
      </li>

      <li>
	<h3>Interfaces - ao - (read)</h3>
	<p>An array with paths to D-Bus objects representing controlled interfaces each.</p>
      </li>

      <li>
	<h3>EapMethods - as - (read)</h3>
	<p>An array with supported EAP methods names.</p>
      </li>

      <li>
	<h3>Capabilities - as - (read)</h3>
	<p>An array with supported capabilities (e.g., "ap", "ibss-rsn", "p2p", "interworking").</p>
      </li>

      <li>
	<h3>WFDIEs - ay - (read/write)</h3>
	<p>Wi-Fi Display subelements.</p>
      </li>
    </ul>

\subsection dbus_main_signals Signals

<ul>
      <li>
	<h3>InterfaceAdded ( o : interface, a{sv} : properties )</h3>
	<p>A new interface was added to wpa_supplicant.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : interface</dt>
	  <dd>A D-Bus path to an object representing the added interface</dd>
	</dl>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary containing properties of added interface.</dd>
	</dl>
      </li>

      <li>
	<h3>InterfaceRemoved ( o : interface )</h3>
	<p>An interface was removed from wpa_supplicant.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : interface</dt>
	  <dd>A D-Bus path to an object representing the removed interface</dd>
	</dl>
      </li>

      <li>
	<h3>PropertiesChanged ( a{sv} : properties )</h3>
	<p>Some properties have changed.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary with pairs of properties names which have changed and theirs new values. Possible dictionary keys are: "DebugParams"</dd>
	</dl>
      </li>
    </ul>


\section dbus_interface fi.w1.wpa_supplicant1.Interface

Interface implemented by objects related to network interface added to
wpa_supplicant, i.e., returned by
fi.w1.wpa_supplicant1.CreateInterface.

\subsection dbus_interface_methods Methods

<ul>
      <li>
	<h3>Scan ( a{sv} : args ) --> nothing</h3>
	<p>Triggers a scan.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : args</dt>
	  <dd>
	    A dictionary with arguments describing scan type:
	    <table>
	      <tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th>
	      <tr><td>Type</td><td>s</td><td>Type of the scan. Possible values: "active", "passive"</td><td>Yes</td>
	      <tr><td>SSIDs</td><td>aay</td><td>Array of SSIDs to scan for (applies only if scan type is active)</td><td>No</td>
	      <tr><td>IEs</td><td>aay</td><td>Information elements to used in active scan (applies only if scan type is active)</td><td>No</td>
	      <tr><td>Channels</td><td>a(uu)</td><td>Array of frequencies to scan in form of (center, width) in MHz.</td><td>No</td>
	      <tr><td>AllowRoam</td><td>b</td><td>TRUE (or absent) to allow a roaming decision based on the results of this scan, FALSE to prevent a roaming decision.</td><td>No</td>
	    </table>
	  </dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>Invalid entries were found in the passed argument.</dd>
	</dl>
      </li>

      <li>
	<h3>Disconnect ( ) --> nothing</h3>
	<p>Disassociates the interface from current network.</p>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.NotConnected</dt>
	  <dd>Interface is not connected to any network.</dd>
	</dl>
      </li>

      <li>
	<h3>AddNetwork ( a{sv} : args ) --> o : network</h3>
	<p>Adds a new network to the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : args</dt>
	  <dd>A dictionary with network configuration. Dictionary entries are equivalent to entries in the "network" block in wpa_supplicant configuration file. Entry values should be appropriate type to the entry, e.g., an entry with key "frequency" should have value type int.</dd>
	</dl>
	<h4>Returns</h4>
	<dl>
	  <dt>o : network</dt>
	  <dd>A D-Bus path to an object representing a configured network</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>Invalid entries were found in the passed argument.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Adding network failed for an unknown reason.</dd>
	</dl>
      </li>

      <li>
	<h3>RemoveNetwork ( o : network ) --> nothing</h3>
	<p>Removes a configured network from the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : network</dt>
	  <dd>A D-Bus path to an object representing a configured network returned by fi.w1.wpa_supplicant1.Interface.AddNetwork</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.NetworkUnknown</dt>
	  <dd>A passed path doesn't point to any network object.</dd>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>A passed path doesn't point to any network object.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Removing network failed for an unknown reason.</dd>
	</dl>
      </li>

      <li>
	<h3>RemoveAllNetworks ( ) --> nothing</h3>
	<p>Remove all configured networks from the interface.</p>
      </li>

      <li>
	<h3>SelectNetwork ( o : network ) --> nothing</h3>
	<p>Attempt association with a configured network.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : network</dt>
	  <dd>A D-Bus path to an object representing a configured network returned by fi.w1.wpa_supplicant1.Interface.AddNetwork</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.NetworkUnknown</dt>
	  <dd>A passed path doesn't point to any network object.</dd>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>A passed path doesn't point to any network object.</dd>
	</dl>
      </li>

      <li>
	<h3>Reassociate ( ) --> nothing</h3>
	<p>Attempt reassociation.</p>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InterfaceDisabled</dt>
	  <dd>The interface is disabled.</dd>
	</dl>
      </li>

      <li>
	<h3>Reattach ( ) --> nothing</h3>
	<p>Attempt reassociation back to the current BSS.</p>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.NotConnected</dt>
	  <dd>Interface is not connected to any network.</dd>
	</dl>
      </li>

      <li>
	<h3>Reconnect ( ) --> nothing</h3>
	<p>Attempt reconnection and connect if in disconnected state.</p>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InterfaceDisabled</dt>
	  <dd>The interface is disabled.</dd>
	</dl>
      </li>

      <li>
	<h3>Roam ( s : addr ) --> nothing</h3>
	<p>Initiate a roam to another BSS within the current ESS.</p>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>Missing address argument.</dd>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>Invalid hardware address format.</dd>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>Target BSS not found.</dd>
	  <dt>fi.w1.wpa_supplicant1.NotConnected</dt>
	  <dd>Interface is not connected to any network.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Scan processing was not included in the build.</dd>
	</dl>
      </li>

      <li>
	<h3>AddBlob ( s : name, ay : data ) --> nothing</h3>
	<p>Adds a blob to the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : name</dt>
	  <dd>A name of a blob</dd>
	  <dt>ay : data</dt>
	  <dd>A blob data</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.BlobExists</dt>
	  <dd>A blob with the specified name already exists.</dd>
	</dl>
      </li>

      <li>
	<h3>RemoveBlob ( s : name ) --> nothing</h3>
	<p>Removes the blob from the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : name</dt>
	  <dd>A name of the blob to remove</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.BlobUnknown</dt>
	  <dd>A blob with the specified name doesn't exist.</dd>
	</dl>
      </li>

      <li>
	<h3>GetBlob ( s : name ) --> ay : data</h3>
	<p>Returns the blob data of a previously added blob.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : name</dt>
	  <dd>A name of the blob</dd>
	</dl>
	<h4>Returns</h4>
	<dl>
	  <dt>ay : data</dt>
	  <dd>A blob data</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.BlobUnknown</dt>
	  <dd>A blob with the specified name doesn't exist.</dd>
	</dl>
      </li>
      <li>
	<h3>AutoScan ( s : arg ) --> nothing</h3>
	<p>Set autoscan parameters for the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : arg</dt>
	  <dd>Autoscan parameter line or empty to unset autoscan.</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.NoMemory</dt>
	  <dd>Needed memory was not possible to get allocated.</dd>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>Invalid entries were found in the passed argument.</dd>
	</dl>
      </li>
      <li>
	<h3>TDLSDiscover ( s : peer_address ) --> nothing</h3>
	<p>Initiate a TDLS discovery for a peer.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : peer_address</dt>
	  <dd>MAC address for the peer to perform TDLS discovery.</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>The "peer_address" argument is not a properly formatted MAC.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Initiating the TDLS operation failed for an unknown reason.</dd>
	</dl>
      </li>
      <li>
	<h3>TDLSSetup ( s : peer_address ) --> nothing</h3>
	<p>Setup a TDLS session for a peer.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : peer_address</dt>
	  <dd>MAC address for the peer to perform TDLS setup.</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>The "peer_address" argument is not a properly formatted MAC.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Initiating the TDLS operation failed for an unknown reason.</dd>
	</dl>
      </li>
      <li>
	<h3>TDLSStatus ( s : peer_address ) --> s</h3>
	<p>Return TDLS status with respect to a peer.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : peer_address</dt>
	  <dd>MAC address for the peer for which status is requested.</dd>
	</dl>
	<h4>Returns</h4>
	<dl>
	  <dt>s : status</dt>
	  <dd>Current status of the TDLS link with the selected peer.</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>The "peer_address" argument is not a properly formatted MAC.</dd>
	</dl>
      </li>
      <li>
	<h3>TDLSTeardown ( s : peer_address ) --> nothing</h3>
	<p>Tear down a TDLS session with a peer.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : peer_address</dt>
	  <dd>MAC address for the peer to tear down TDLS connectivity with.</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>The "peer_address" argument is not a properly formatted MAC.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Initiating the TDLS operation failed for an unknown reason.</dd>
	</dl>
      </li>
      <li>
	<h3>TDLSChannelSwitch ( a{sv} : args ) --> nothing</h3>
	<p>Configure TDLS channel switching behavior with a peer.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : args</dt>
	  <dd>A dictionary with arguments identifying the peer and channel switching behavior.</dd>
	</dl>
      </li>
      <li>
	<h3>TDLSCancelChannelSwitch ( s : peer_address ) --> nothing</h3>
	<p>Disable channel switching for a TDLS session with a peer.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : peer_address</dt>
	  <dd>MAC address for the peer.</dd>
	</dl>
      </li>
      <li>
	<h3>VendorElemAdd ( i: frame_id, ay: ielems ) --> nothing</h3>
	<p>Add Vendor Elements to corresponding frame ID.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>i : frame_id</dt>
	  <dd>Frame ID for which Vendor specific IE is to be added.</dd>
	  <dt>ay : ielems</dt>
	  <dd>Information Element(s).</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>The "ielems" argument is not a properly formatted or size mismatch.</dd>
	  <dt>fi.w1.wpa_supplicant1.NoMemory</dt>
	  <dd>Needed memory was not possible to get allocated.</dd>
	</dl>
      </li>
      <li>
	<h3>VendorElemGet ( i: frame_id ) --> ay: ielems</h3>
	<p>Get Vendor Elements of corresponding frame ID.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>i : frame_id</dt>
	  <dd>Frame ID for which Vendor specific IE is being queried.</dd>
	  <dt>ay : ielems</dt>
	  <dd>Information Element(s).</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>The "frame_id" argument is not valid.</dd>
	</dl>
      </li>
      <li>
	<h3>VendorElemRem ( i: frame_id, ay: ielems ) --> nothing</h3>
	<p>Remove Vendor Elements of corresponding frame ID.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>i : frame_id</dt>
	  <dd>Frame ID for which Vendor specific IE is to be removed.</dd>
	  <dt>ay : ielems</dt>
	  <dd>Information Element(s) OR * to remove all.</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>The "ielems" argument is not a properly formatted or size mismatch.</dd>
	  <dt>fi.w1.wpa_supplicant1.NoMemory</dt>
	  <dd>Needed memory was not possible to get allocated.</dd>
	</dl>
      </li>
      <li>
	<h3>SaveConfig ( ) --> nothing</h3>
	<p>Save configuration to the configuration file.</p>
      </li>
      <li>
	<h3>AbortScan ( ) --> nothing</h3>
	<p>Abort ongoing scan operation.</p>
      </li>
      <li>
	<h3>EAPLogoff ( ) --> nothing</h3>
	<p>IEEE 802.1X EAPOL state machine logoff.</p>
      </li>
      <li>
	<h3>EAPLogon ( ) --> nothing</h3>
	<p>IEEE 802.1X EAPOL state machine logon.</p>
      </li>

      <li>
	<h3>NetworkReply ( o : network, s : field, s : value ) --> nothing</h3>
	<p>Provide parameter requested by NetworkRequest().</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : network</dt>
	  <dd>A D-Bus path to an object representing the network (copied from NetworkRequest()).</dd>
	  <dt>s : field</dt>
	  <dd>Requested information (copied from NetworkRequest()).</dd>
	  <dt>s : value</dt>
	  <dd>The requested information (e.g., password for EAP authentication).</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.NetworkUnknown</dt>
	  <dd>A passed path doesn't point to any network object.</dd>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>A passed path doesn't point to any network object.</dd>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>IEEE 802.1X support was not included in the build.</dd>
	</dl>
      </li>

      <li>
	<h3>SetPKCS11EngineAndModulePath ( s : pkcs11_engine_path, s : pkcs11_module_path ) --> nothing</h3>
	<p>Set PKCS #11 engine and module path.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : pkcs11_engine_path</dt>
	  <dd>PKCS #11 engine path.</dd>
	  <dt>s : pkcs11_module_path</dt>
	  <dd>PKCS #11 module path.</dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>org.freedesktop.DBus.Error.Failed.InvalidArgs</dt>
	  <dd>Invalid PKCS #11 engine or module path.</dd>
	  <dt>org.freedesktop.DBus.Error.Failed</dt>
	  <dd>Reinit of the EAPOL state machine with the new PKCS #11 engine and module path failed.</dd>
	</dl>
      </li>
      <li>
	<h3>SignalPoll ( ) --> a{sv} : properties</h3>
	<p>Fetch signal properties for the current connection.</p>
	<h4>Returns</h4>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>
	    <table>
	      <tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th>
	      <tr><td>linkspeed</td><td>i</td><td>Link speed (Mbps)</td><td>No</td>
	      <tr><td>noise</td><td>i</td><td>Noise (dBm)</td><td>No</td>
	      <tr><td>width</td><td>s</td><td>Channel width</td><td>No</td>
	      <tr><td>frequency</td><td>u</td><td>Frequency (MHz)</td><td>No</td>
	      <tr><td>rssi</td><td>i</td><td>RSSI (dBm)</td><td>No</td>
	      <tr><td>avg-rssi</td><td>i</td><td>Average RSSI (dBm)</td><td>No</td>
	      <tr><td>center-frq1</td><td>i</td><td>VHT segment 1 frequency (MHz)</td><td>No</td>
	      <tr><td>center-frq2</td><td>i</td><td>VHT segment 2 frequency (MHz)</td><td>No</td>
	    </table>
	  </dd>
	</dl>
      </li>
      <li>
	<h3>FlushBSS ( u : age ) --> nothing</h3>
	<p>Flush BSS entries from the cache.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>u : age</dt>
	  <dd>Maximum age in seconds for BSS entries to keep in cache (0 = remove all entries).</dd>
	</dl>
      </li>

      <li>
	<h3>SubscribeProbeReq ( ) --> nothing</h3>
	<p>Subscribe to receive Probe Request events. This is needed in addition to registering a signal handler for the ProbeRequest signal to avoid flooding D-Bus with all Probe Request indications when no application is interested in them.</p>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.SubscriptionInUse</dt>
	  <dd>Another application is already subscribed.</dd>
	  <dt>fi.w1.wpa_supplicant1.NoMemory</dt>
	  <dd>Needed memory was not possible to get allocated.</dd>
	</dl>
      </li>

      <li>
	<h3>UnsubscribeProbeReq ( ) --> nothing</h3>
	<p>Unsubscribe from receiving Probe Request events.</p>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.NoSubscription</dt>
	  <dd>No subscription in place.</dd>
	  <dt>fi.w1.wpa_supplicant1.SubscriptionNotYou</dt>
	  <dd>Subscription in place, but for another process.</dd>
	</dl>
      </li>
    </ul>

\subsection dbus_interface_properties Properties

<ul>
      <li>
	<h3>Capabilities - a{sv} - (read)</h3>
	<p>Capabilities of the interface. Dictionary contains following entries:</p>
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th>
	  <tr><td>Pairwise</td><td>as</td><td>Possible array elements: "ccmp-256", "gcmp-256", "ccmp", "gcmp", "tkip", "none"</td>
	  <tr><td>Group</td><td>as</td><td>Possible array elements: "ccmp-256", "gcmp-256", "ccmp", "gcmp", "tkip", "wep104", "wep40"</td>
	  <tr><td>GroupMgmt</td><td>as</td><td>Possible array elements: "aes-128-cmac", "bip-gmac-128", "bip-gmac-256", "bip-cmac-256"</td>
	  <tr><td>KeyMgmt</td><td>as</td><td>Possible array elements: "wpa-psk", "wpa-ft-psk", "wpa-psk-sha256", "wpa-eap", "wpa-ft-eap", "wpa-eap-sha256", "sae", "owe", "ieee8021x", "wpa-none", "wps", "none"</td>
	  <tr><td>Protocol</td><td>as</td><td>Possible array elements: "rsn", "wpa"</td>
	  <tr><td>AuthAlg</td><td>as</td><td>Possible array elements: "open", "shared", "leap"</td>
	  <tr><td>Scan</td><td>as</td><td>Possible array elements: "active", "passive", "ssid"</td>
	  <tr><td>Modes</td><td>as</td><td>Possible array elements: "infrastructure", "ad-hoc", "ap"</td>
	</table>
      </li>

      <li>
	<h3>State - s - (read)</h3>
	<p>A state of the interface. Possible values are: return "disconnected", "inactive", "scanning", "authenticating", "associating", "associated", "4way_handshake", "group_handshake", "completed","unknown".</p>
      </li>

      <li>
	<h3>Scanning - b - (read)</h3>
	<p>Determines if the interface is already scanning or not</p>
      </li>

      <li>
	<h3>ApScan - u - (read/write)</h3>
	<p>Identical to ap_scan entry in wpa_supplicant configuration file. Possible values are 0, 1 or 2.</p>
      </li>

      <li>
	<h3>BSSExpireAge - u - (read/write)</h3>
	<p>Identical to bss_expiration_age entry in wpa_supplicant configuration file.</p>
      </li>

      <li>
	<h3>BSSExpireCount - u - (read/write)</h3>
	<p>Identical to bss_expiration_scan_count entry in wpa_supplicant configuration file.</p>
      </li>

      <li>
	<h3>Country - s - (read/write)</h3>
	<p>Identical to country entry in wpa_supplicant configuration file.</p>
      </li>

      <li>
	<h3>Ifname - s - (read)</h3>
	<p>Name of network interface controlled by the interface, e.g., wlan0.</p>
      </li>

      <li>
	<h3>BridgeIfname - s - (read)</h3>
	<p>Name of bridge network interface controlled by the interface, e.g., br0.</p>
      </li>

      <li>
	<h3>Driver - s - (read)</h3>
	<p>Name of driver used by the interface, e.g., nl80211.</p>
      </li>

      <li>
	<h3>ConfigFile - s - (read)</h3>
	<p>Configuration file path. Returns an empty string if no configuration file is in use.</p>
      </li>

      <li>
	<h3>CurrentBSS - o - (read)</h3>
	<p>Path to D-Bus object representing BSS which wpa_supplicant is associated with, or "/" if is not associated at all.</p>
      </li>

      <li>
	<h3>CurrentNetwork - o - (read)</h3>
	<p>Path to D-Bus object representing configured network which wpa_supplicant uses at the moment, or "/" if doesn't use any.</p>
      </li>

      <li>
	<h3>CurrentAuthMode - s - (read)</h3>
	<p>Current authentication type.</p>
      </li>

      <li>
	<h3>Blobs - as - (read)</h3>
	<p>List of blobs names added to the Interface.</p>
      </li>

      <li>
	<h3>BSSs - ao - (read)</h3>
	<p>List of D-Bus objects paths representing BSSs known to the interface, i.e., scan results.</p>
      </li>

      <li>
	<h3>Stations - ao - (read)</h3>
	<p>List of D-Bus objects paths representing connected stations in AP mode.</p>
      </li>

      <li>
	<h3>Networks - ao - (read)</h3>
	<p>List of D-Bus objects paths representing configured networks.</p>
      </li>

      <li>
	<h3>FastReauth - b - (read/write)</h3>
	<p>Identical to fast_reauth entry in wpa_supplicant configuration file.</p>
      </li>

      <li>
	<h3>ScanInterval - i - (read/write)</h3>
	<p>Time (in seconds) between scans for a suitable AP. Must be >= 0.</p>
      </li>

      <li>
	<h3>PKCS11EnginePath - s - (read)</h3>
	<p>PKCS #11 engine path.</p>
      </li>

      <li>
	<h3>PKCS11ModulePath - s - (read)</h3>
	<p>PKCS #11 module path.</p>
      </li>

      <li>
	<h3>DisconnectReason - i - (read)</h3>
	<p>The most recent IEEE 802.11 reason code for disconnect. Negative value indicates locally generated disconnection.</p>
      </li>

      <li>
	<h3>AuthStatusCode - i - (read)</h3>
	<p>The most recent IEEE 802.11 status code for authentication.</p>
      </li>

      <li>
	<h3>AssocStatusCode - i - (read)</h3>
	<p>The most recent IEEE 802.11 status code for association rejection.</p>
      </li>

      <li>
	<h3>RoamTime - u - (read)</h3>
	<p>The most recent roam time in milliseconds.</p>
      </li>

      <li>
	<h3>RoamComplete - b - (read)</h3>
	<p>The most recent roam success or failure.</p>
      </li>

      <li>
	<h3>SessionLength - u - (read)</h3>
	<p>The most recent BSS session length in milliseconds.</p>
      </li>

      <li>
	<h3>BSSTMStatus - u - (read)</h3>
	<p>The most recent BSS Transition Management status code.</p>
      </li>

      <li>
	<h3>EapolVersion - s - (read/write)</h3>
	<p>IEEE 802.1X/EAPOL version number</p>
      </li>

      <li>
	<h3>Bgscan - s - (read/write)</h3>
	<p>Background scan and roaming parameters or an empty string if none</p>
      </li>

      <li>
	<h3>DisableScanOffload - s - (read/write)</h3>
	<p>Disable automatic offloading of scan requests</p>
      </li>

      <li>
	<h3>OpenscEnginePath - s - (read/write)</h3>
	<p>Path to the OpenSSL engine for opensc</p>
      </li>

      <li>
	<h3>OpensslCiphers - s - (read/write)</h3>
	<p>OpenSSL cipher string</p>
      </li>

      <li>
	<h3>PcscReader - s - (read/write)</h3>
	<p>PC/SC reader name prefix</p>
      </li>

      <li>
	<h3>PcscPin - s - (read/write)</h3>
	<p>PIN for USIM, GSM SIM, and smartcards</p>
      </li>

      <li>
	<h3>ExternalSim - s - (read/write)</h3>
	<p>Use external processing for SIM/USIM operations</p>
      </li>

      <li>
	<h3>DriverParam - s - (read/write)</h3>
	<p>Driver interface parameters</p>
      </li>

      <li>
	<h3>Dot11RSNAConfigPMKLifetime - s - (read/write)</h3>
	<p>Maximum lifetime of a PMK</p>
      </li>

      <li>
	<h3>Dot11RSNAConfigPMKReauthThreshold - s - (read/write)</h3>
	<p>PMK re-authentication threshold</p>
      </li>

      <li>
	<h3>Dot11RSNAConfigSATimeout - s - (read/write)</h3>
	<p>Security association timeout</p>
      </li>

      <li>
	<h3>BssMaxCount - s - (read/write)</h3>
	<p>Maximum number of BSS entries to keep in memory</p>
      </li>

      <li>
	<h3>FilterSsids - s - (read/write)</h3>
	<p>SSID-based scan result filtering</p>
      </li>

      <li>
	<h3>FilterRssi - s - (read/write)</h3>
	<p>RSSI-based scan result filtering</p>
      </li>

      <li>
	<h3>MaxNumSta - s - (read/write)</h3>
	<p>Maximum number of STAs in an AP/P2P GO</p>
      </li>

      <li>
	<h3>DisassocLowAck - s - (read/write)</h3>
	<p>Disassocicate stations with massive packet loss</p>
      </li>

      <li>
	<h3>Interworking - s - (read/write)</h3>
	<p>Whether Interworking (IEEE 802.11u) is enabled</p>
      </li>

      <li>
	<h3>Hessid - s - (read/write)</h3>
	<p>Homogeneous ESS identifier</p>
      </li>

      <li>
	<h3>AccessNetworkType - s - (read/write)</h3>
	<p>Access Network Type</p>
      </li>

      <li>
	<h3>PbcInM1 - s - (read/write)</h3>
	<p>AP mode WPS probing workaround for PBC with Windows 7</p>
      </li>

      <li>
	<h3>Autoscan - s - (read/write)</h3>
	<p>Automatic scan parameters or an empty string if none</p>
      </li>

      <li>
	<h3>WpsNfcDevPwId - s - (read/write)</h3>
	<p>NFC Device Password ID for password token</p>
      </li>

      <li>
	<h3>WpsNfcDhPubkey - s - (read/write)</h3>
	<p>NFC DH Public Key for password token</p>
      </li>

      <li>
	<h3>WpsNfcDhPrivkey - s - (read/write)</h3>
	<p>NFC DH Private Key for password token</p>
      </li>

      <li>
	<h3>WpsNfcDevPw - s - (read/write)</h3>
	<p>NFC Device Password for password token</p>
      </li>

      <li>
	<h3>ExtPasswordBackend - s - (read/write)</h3>
	<p>External password backend or an empty string if none</p>
      </li>

      <li>
	<h3>P2pGoMaxInactivity - s - (read/write)</h3>
	<p>Timeout in seconds to detect STA inactivity</p>
      </li>

      <li>
	<h3>AutoInterworking - s - (read/write)</h3>
	<p>Whether to use network selection automatically</p>
      </li>

      <li>
	<h3>Okc - s - (read/write)</h3>
	<p>Whether to enable opportunistic key caching by default</p>
      </li>

      <li>
	<h3>Pmf - s - (read/write)</h3>
	<p>Whether to enable/require PMF by default</p>
      </li>

      <li>
	<h3>SaeGroups - s - (read/write)</h3>
	<p>Preference list of enabled groups for SAE</p>
      </li>

      <li>
	<h3>DtimPeriod - s - (read/write)</h3>
	<p>Default DTIM period in Beacon intervals</p>
      </li>

      <li>
	<h3>BeaconInt - s - (read/write)</h3>
	<p>Default Beacon interval in TU</p>
      </li>

      <li>
	<h3>IgnoreOldScanRes - s - (read/write)</h3>
	<p>Ignore scan results older than request</p>
      </li>

      <li>
	<h3>FreqList - s - (read/write)</h3>
	<p>Array of allowed scan frequencies or an empty string for all</p>
      </li>

      <li>
	<h3>ScanCurFreq - s - (read/write)</h3>
	<p>Whether to scan only the current channel</p>
      </li>

      <li>
	<h3>SchedScanInterval - s - (read/write)</h3>
	<p>schedule scan interval</p>
      </li>

      <li>
	<h3>TdlsExternalControl - s - (read/write)</h3>
	<p>External control for TDLS setup requests</p>
      </li>

      <li>
	<h3>OsuDir - s - (read/write)</h3>
	<p>OSU provider information directory</p>
      </li>

      <li>
	<h3>WowlanTriggers - s - (read/write)</h3>
	<p>Wake-on-WLAN triggers</p>
      </li>

      <li>
	<h3>P2pSearchDelay - s - (read/write)</h3>
	<p>Extra delay between concurrent search iterations</p>
      </li>

      <li>
	<h3>MacAddr - s - (read/write)</h3>
	<p>MAC address policy default</p>
      </li>

      <li>
	<h3>RandAddrLifetime - s - (read/write)</h3>
	<p>Lifetime of random MAC address in seconds</p>
      </li>

      <li>
	<h3>PreassocMacAddr - s - (read/write)</h3>
	<p>Pre-association MAC address policy</p>
      </li>

      <li>
	<h3>KeyMgmtOffload - s - (read/write)</h3>
	<p>Use key management offload</p>
      </li>

      <li>
	<h3>PassiveScan - s - (read/write)</h3>
	<p>Whether to force passive scan for network connection</p>
      </li>

      <li>
	<h3>ReassocSameBssOptim - s - (read/write)</h3>
	<p>Whether to optimize reassoc-to-same-BSS</p>
      </li>

      <li>
	<h3>WpsPriority - s - (read/write)</h3>
	<p>Priority for the networks added through WPS</p>
      </li>

      <li>
	<h3>MACAddressRandomizationMask - a{say} - (read/write)</h3>
	<p>Masks to show which bits not to randomize with MAC address randomization. Possible keys are "scan", "sched_scan", and "pno". Values must be an array of 6 bytes.</p>
	<p>When this property is set, the new dictionary replaces the old value, rather than merging them together. Leaving a key out of the dictionary will turn off MAC address randomization for that scan type.</p>
      </li>
    </ul>

\subsection dbus_interface_signals Signals

<ul>
      <li>
	<h3>ScanDone ( b : success )</h3>
	<p>Scanning finished. </p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : success</dt>
	  <dd>Determines if scanning was successful. If so, results are available.</dd>
	</dl>
      </li>

      <li>
	<h3>BSSAdded ( o : BSS, a{sv} : properties )</h3>
	<p>Interface became aware of a new BSS.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : BSS</dt>
	  <dd>A D-Bus path to an object representing the new BSS.</dd>
	</dl>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary containing properties of added BSS.</dd>
	</dl>
      </li>

      <li>
	<h3>BSSRemoved ( o : BSS )</h3>
	<p>BSS disappeared.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : BSS</dt>
	  <dd>A D-Bus path to an object representing the BSS.</dd>
	</dl>
      </li>

      <li>
	<h3>BlobAdded ( s : blobName )</h3>
	<p>A new blob has been added to the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : blobName</dt>
	  <dd>A name of the added blob.</dd>
	</dl>
      </li>

      <li>
	<h3>BlobRemoved ( s : blobName )</h3>
	<p>A blob has been removed from the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : blobName</dt>
	  <dd>A name of the removed blob.</dd>
	</dl>
      </li>

      <li>
	<h3>NetworkAdded ( o : network, a{sv} : properties )</h3>
	<p>A new network has been added to the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : network</dt>
	  <dd>A D-Bus path to an object representing the added network.</dd>
	</dl>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary containing properties of added network.</dd>
	</dl>
      </li>

      <li>
	<h3>NetworkRemoved ( o : network )</h3>
	<p>The network has been removed from the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : network</dt>
	  <dd>A D-Bus path to an object representing the removed network.</dd>
	</dl>
      </li>

      <li>
	<h3>NetworkSelected ( o : network )</h3>
	<p>The network has been selected.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : network</dt>
	  <dd>A D-Bus path to an object representing the selected network.</dd>
	</dl>
      </li>

      <li>
	<h3>StaAuthorized ( s : mac )</h3>
	<p>A new station has been authorized to the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : mac</dt>
	  <dd>A mac address which has been authorized.</dd>
	</dl>
      </li>

      <li>
	<h3>StaDeauthorized ( s : mac )</h3>
	<p>A station has been deauthorized to the interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : mac</dt>
	  <dd>A mac address which has been deauthorized.</dd>
	</dl>
      </li>

      <li>
	<h3>StationAdded ( o : Station, a{sv} : properties )</h3>
	<p>A new station has been added to the interface.</p>
	<p>This signal complements StaAuthorized, passing the Station object and its properties.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : Station</dt>
	  <dd>A D-Bus path to an object representing the new Station.</dd>
	</dl>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary containing properties of added Station.</dd>
	</dl>
      </li>

      <li>
	<h3>StationRemoved ( o : Station )</h3>
	<p>The station has been removed from the interface.</p>
	<p>This signal complements StaDeauthorized, passing the Station object.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : Station</dt>
	  <dd>A D-Bus path to an object representing the Station.</dd>
	</dl>
      </li>

      <li>
	<h3>PropertiesChanged ( a{sv} : properties )</h3>
	<p>Some properties have changed.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary with pairs of properties names which have changed and theirs new values. Possible dictionary keys are: "ApScan", "Scanning", "State", "CurrentBSS", "CurrentNetwork"</dd>
	</dl>
      </li>

      <li>
	<h3>Certification ( a{sv} : parameters )</h3>
	<p>Information about server TLS certificates.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : parameters</dt>
	  <dd>A dictionary with pairs of field names and their values. Possible dictionary keys are: "depth", "subject", "altsubject", "cert_hash", "cert".</dd>
	</dl>
      </li>

      <li>
	<h3>EAP ( s : status, s : parameter )</h3>
	<p>Information about EAP peer status.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : status</dt>
	  <dd>Operation, e.g., "started", "accept proposed method", "remote certificate verification", "eap parameter needed", "completion".</dd>
	  <dt>s : parameter</dt>
	  <dd>Information about the operation, e.g., EAP method name, "success".</dd>
	</dl>
      </li>

      <li>
	<h3>NetworkRequest ( o : network, s : field, s : txt )</h3>
	<p>Request for network parameter. NetworkResponse() is used to provide the requested parameter.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>o : network</dt>
	  <dd>D-Bus path to an object representing the network.</dd>
	  <dt>s : field</dt>
	  <dd>Requested information, e.g., "PASSWORD".</dd>
	  <dt>txt : field</dt>
	  <dd>Human readable information about the requested information.</dd>
	</dl>
      </li>

      <li>
	<h3>ProbeRequest ( a{sv} : args )</h3>
	<p>Information about a received Probe Request frame. This signal is delivered only to a single application that has subscribed to received the events with SubscribeProbeReq().</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : args</dt>
	  <dd>A dictionary with pairs of field names and their values. Possible dictionary keys are: "addr", "dst", "bssid", "ies", "signal".</dd>
	</dl>
      </li>
    </ul>


\section dbus_wps fi.w1.wpa_supplicant1.Interface.WPS

Interface for performing WPS (Wi-Fi Simple Config) operations.

\subsection dbus_wps_methods Methods

<ul>
      <li>
	<h3>Start ( a{sv} : args ) --> a{sv} : output</h3>
	<p>Starts WPS configuration. Note: When used with P2P groups, this needs to be issued on the GO group interface.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : args</dt>
	  <dd>
	    A dictionary with arguments used to start WPS configuration. The dictionary may contain the following entries:
	    <table>
	      <tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th>
	      <tr><td>Role</td><td>s</td><td>The device's role. Possible values are "enrollee" and "registrar".</td><td>Yes</td>
	      <tr><td>Type</td><td>s</td><td>WPS authentication type. Applies only for enrollee role. Possible values are "pin" and "pbc".</td><td>Yes, for enrollee role; otherwise no</td>
	      <tr><td>Pin</td><td>s</td><td>WPS Pin.</td><td>Yes, for registrar role; otherwise optional</td>
	      <tr><td>Bssid</td><td>ay</td><td>Note: This is used to specify the peer MAC address when authorizing WPS connection in AP or P2P GO role.</td><td>No</td>
	      <tr><td>P2PDeviceAddress</td><td>ay</td><td>P2P Device Address of a peer to authorize for PBC connection. Used only in P2P GO role.</td><td>No</td>
	    </table>
	  </dd>
	</dl>
	<h4>Returns</h4>
	<dl>
	  <dt>a{sv} : output</dt>
	  <dd>
	    <table>
	      <tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th>
	      <tr><td>Pin</td><td>s</td><td>Newly generated PIN, if not specified for enrollee role and pin authentication type.</td><td>No</td>
	    </table>
	  </dd>
	</dl>
	<h4>Possible errors</h4>
	<dl>
	  <dt>fi.w1.wpa_supplicant1.UnknownError</dt>
	  <dd>Starting WPS configuration failed for an unknown reason.</dd>
	  <dt>fi.w1.wpa_supplicant1.InvalidArgs</dt>
	  <dd>Invalid entries were found in the passed argument.</dd>
	</dl>
      </li>
      <li>
	<h3>Cancel ( nothing ) --> nothing</h3>
	<p>Cancel ongoing WPS operation.</p>
      </li>
    </ul>

\subsection dbus_wps_properties Properties

<ul>
      <li>
	<h3>ProcessCredentials - b - (read/write)</h3>
	<p>Determines if the interface will process the credentials (credentials_processed configuration file parameter).</p>
      </li>
      <li>
	<h3>ConfigMethods - s - (read/write)</h3>
	<p>The currently advertised WPS configuration methods. Available methods: usba ethernet label display ext_nfc_token int_nfc_token nfc_interface push_button keypad virtual_display physical_display virtual_push_button physical_push_button.</p>
      </li>
      <li>
	<h3>DeviceName - s - (read/write)</h3>
	<p>User-friendly description of device; up to 32 octets encoded in UTF-8.</p>
      </li>
      <li>
	<h3>Manufacturer - s - (read/write)</h3>
	<p>The manufacturer of the device (up to 64 ASCII characters).</p>
      </li>
      <li>
	<h3>ModelName - s - (read/write)</h3>
	<p>Model of the device (up to 32 ASCII characters).</p>
      </li>
      <li>
	<h3>ModelNumber - s - (read/write)</h3>
	<p>Additional device description (up to 32 ASCII characters).</p>
      </li>
      <li>
	<h3>SerialNumber - s - (read/write)</h3>
	<p>Serial number of the device (up to 32 characters).</p>
      </li>
      <li>
	<h3>DeviceType - ay - (read/write)</h3>
	<p>Device Type (8 octet value with 2 octet category, 4 octet OUI, 2 octet subcategory.</p>
      </li>
    </ul>

\subsection dbus_wps_signals Signals

<ul>
      <li>
	<h3>Event ( s : name, a{sv} : args )</h3>
	<p>WPS event occurred.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>s : event</dt>
	  <dd>Event type. Possible values are: "success, "fail", "m2d", and
	  "pbc-overlap".</dd>
	  <dt>a{sv} : args</dt>
	  <dd>
	    Event arguments. Empty for success and pbc-overlap events, error information ( "msg" : i, "config_error" : i, "error_indication" : i ) for fail event and following entries for m2d event:
	    <table>
	      <tr><th>config_methods</th><th>Value type</th>
	      <tr><td>manufacturer</td><td>q</td>
	      <tr><td>model_name</td><td>ay</td>
	      <tr><td>model_number</td><td>ay</td>
	      <tr><td>serial_number</td><td>ay</td>
	      <tr><td>dev_name</td><td>ay</td>
	      <tr><td>primary_dev_type</td><td>ay</td>
	      <tr><td>config_error</td><td>q</td>
	      <tr><td>dev_password_id</td><td>q</td>
	    </table>
	  </dd>
	</dl>
      </li>

      <li>
	<h3>Credentials ( a{sv} : credentials )</h3>
	<p>WPS credentials. Dictionary contains:</p>
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th>
	  <tr><td>BSSID</td><td>ay</td><td></td>
	  <tr><td>SSID</td><td>s</td><td></td>
	  <tr><td>AuthType</td><td>as</td><td>Possible array elements: "open", "shared", "wpa-psk", "wpa-eap", "wpa2-eap", "wpa2-psk"</td>
	  <tr><td>EncrType</td><td>as</td><td>Possible array elements: "none", "wep", "tkip", "aes"</td>
	  <tr><td>Key</td><td>ay</td><td>Key data</td>
	  <tr><td>KeyIndex</td><td>u</td><td>Key index</td>
	</table>
      </li>

      <li>
	<h3>PropertiesChanged ( a{sv} : properties )</h3>
	<p>Some properties have changed.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary with pairs of properties names which have changed and theirs new values. Possible dictionary keys are: "ProcessCredentials"</dd>
	</dl>
      </li>
    </ul>


\section dbus_p2pdevice fi.w1.wpa_supplicant1.Interface.P2PDevice

Interface for performing P2P (Wi-Fi Peer-to-Peer) P2P Device operations.

\subsection dbus_p2pdevice_methods Methods

<ul>
  <li>
    <h3>Find ( a{sv} : args ) --> nothing</h3>
    <p>Start P2P find operation (i.e., alternating P2P Search and Listen states to discover peers and be discoverable).</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for the P2P find operation:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>Timeout</td><td>i</td><td>Timeout for operating in seconds</td><td>no</td></tr>
	<tr><td>RequestedDeviceTypes</td><td>aay</td><td>WPS Device Types to search for</td><td>no</td></tr>
	<tr><td>DiscoveryType</td><td>s</td><td>"start_with_full" (default, if not specified), "social", "progressive"</td><td>no</td></tr>
	<tr><td>freq</td><td>i</td><td>Initial scan channel (frequency in MHz) for the start_with_full case to limit the initial scan to the specified channel</td><td>no</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>StopFind ( nothing ) --> nothing</h3>
    <p>Stop P2P find operation.</p>
  </li>

  <li>
    <h3>Listen ( i : timeout ) --> nothing</h3>
    <p>Start P2P listen operation (i.e., be discoverable).</p>
    <h4>Arguments</h4>
    <dl>
      <dt>i : timeout</dt>
      <dd>Timeout in seconds for stopping the listen operation.</dd>
    </dl>
  </li>

  <li>
    <h3>ExtendedListen ( a{sv} : args ) --> nothing</h3>
    <p>Configure Extended Listen Timing. If the parameters are omitted, this feature is disabled. If the parameters are included, Listen State will be entered every interval msec for at least period msec. Both values have acceptable range of 1-65535 (with interval obviously having to be larger than or equal to duration). If the P2P module is not idle at the time the Extended Listen Timing timeout occurs, the Listen State operation will be skipped.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for extended listen. Leave out all items to disable extended listen.
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>period</td><td>i</td><td>Extended listen period in milliseconds; 1-65535.</td><td>no</td></tr>
	<tr><td>interval</td><td>i</td><td>Extended listen interval in milliseconds; 1-65535.</td><td>no</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>PresenceRequest ( a{sv} : args ) --> nothing</h3>
    <p>Request a specific GO presence in a P2P group where the local device is a P2P Client. Send a P2P Presence Request to the GO (this is only available when acting as a P2P client). If no duration/interval pairs are given, the request indicates that this client has no special needs for GO presence. The first parameter pair gives the preferred duration and interval values in microseconds. If the second pair is included, that indicates which value would be acceptable.
    \note This needs to be issued on a P2P group interface if separate group interfaces are used.
    \bug It would be cleaner to not require .P2PDevice methods to be issued on a group interface. In other words, args['group_object'] could be used to specify the group or this method could be moved to be a .Group PresenceRequest() method.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for the presence request.
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>duration1</td><td>i</td><td>Duration in microseconds.</td><td>no</td></tr>
	<tr><td>interval1</td><td>i</td><td>Interval in microseconds.</td><td>no</td></tr>
	<tr><td>duration2</td><td>i</td><td>Duration in microseconds.</td><td>no</td></tr>
	<tr><td>interval2</td><td>i</td><td>Interval in microseconds.</td><td>no</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>ProvisionDiscoveryRequest ( o : peer, s : config_method ) --> nothing</h3>
  </li>

  <li>
    <h3>Connect ( a{sv} : args ) --> s : generated_pin</h3>
    <p>Request a P2P group to be started through GO Negotiation or by joining an already operating group.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for the requested connection:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>peer</td><td>o</td><td></td><td>yes</td></tr>
	<tr><td>persistent</td><td>b</td><td>Whether to form a persistent group.</td><td>no</td></tr>
	<tr><td>join</td><td>b</td><td>Whether to join an already operating group instead of forming a new group.</td><td>no</td></tr>
	<tr><td>authorize_only</td><td>b</td><td>Whether to authorize a peer to initiate GO Negotiation instead of initiating immediately.</td><td>no</td></tr>
	<tr><td>frequency</td><td>i</td><td>Operating frequency in MHz</td><td>no</td></tr>
	<tr><td>go_intent</td><td>i</td><td>GO intent 0-15</td><td>no</td></tr>
	<tr><td>wps_method</td><td>s</td><td>"pbc", "display", "keypad", "pin" (alias for "display")</td><td>yes</td></tr>
	<tr><td>pin</td><td>s</td><td></td><td>no</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>GroupAdd ( a{sv} : args ) --> nothing</h3>
    <p>Request a P2P group to be started without GO Negotiation.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for the requested group:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>persistent</td><td>b</td><td>Whether to form a persistent group.</td><td>no</td></tr>
	<tr><td>persistent_group_object</td><td>o</td><td></td><td>no</td></tr>
	<tr><td>frequency</td><td>i</td><td>Operating frequency in MHz</td><td>no</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>Cancel ( nothing ) --> nothing</h3>
    <p>Stop ongoing P2P group formation operation.</p>
  </li>

  <li>
    <h3>Invite ( a{sv} : args ) --> nothing</h3>
    <p>Invite a peer to join an already operating group or to re-invoke a persistent group.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for the invitation:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>peer</td><td>o</td><td></td><td>yes</td></tr>
	<tr><td>persistent_group_object</td><td>o</td><td></td><td>no</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>Disconnect ( nothing ) --> nothing</h3>
    <p>Terminate a P2P group.
    \note This needs to be issued on a P2P group interface if separate group interfaces are used.
    \bug It would be cleaner to not require .P2PDevice methods to be issued on a group interface. In other words, this would either need to be Disconnect(group_object) or moved to be a .Group Disconnect() method.</p>
  </li>

  <li>
    <h3>RejectPeer ( o : peer ) --> nothing</h3>
    <p>Reject connection attempt from a peer (specified with a device address). This is a mechanism to reject a pending GO Negotiation with a peer and request to automatically block any further connection or discovery of the peer.</p>
  </li>

  <li>
    <h3>RemoveClient ( a{sv} : args ) --> nothing</h3>
    <p>Remove the client from all groups (operating and persistent) from the local GO.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for removing a client:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>peer</td><td>o</td><td>Object path for peer's P2P Device Address</td><td>yes</td></tr>
	<tr><td>iface</td><td>s</td><td>Interface address[MAC Address format] of the peer to be disconnected. Required if object path is not provided.</td><td>no</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>Flush ( nothing ) --> nothing</h3>
    <p>Flush P2P peer table and state.</p>
  </li>

  <li>
    <h3>AddService ( a{sv} : args ) --> nothing</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for the service:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>service_type</td><td>s</td><td>"upnp", "bonjour"</td><td>yes</td></tr>
	<tr><td>version</td><td>u</td><td>Required for UPnP services.</td><td>no</td></tr>
	<tr><td>service</td><td>s</td><td></td><td></td></tr>
	<tr><td>query</td><td>ay</td><td></td><td></td></tr>
	<tr><td>response</td><td>ay</td><td></td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>DeleteService ( a{sv} : args ) --> nothing</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with parameters for the service:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>service_type</td><td>s</td><td>"upnp", "bonjour"</td><td>yes</td></tr>
	<tr><td>version</td><td>u</td><td>Required for UPnP services.</td><td>no</td></tr>
	<tr><td>service</td><td>s</td><td></td><td></td></tr>
	<tr><td>query</td><td>ay</td><td></td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>FlushService ( nothing ) --> nothing</h3>
  </li>

  <li>
    <h3>ServiceDiscoveryRequest ( a{sv} : args ) --> t : ref</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with following parameters:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>peer_object</td><td>o</td><td></td><td>no</td></tr>
	<tr><td>service_type</td><td>s</td><td>"upnp"</td><td>no</td></tr>
	<tr><td>version</td><td>u</td><td>Required for UPnP services.</td><td>no</td></tr>
	<tr><td>service</td><td>s</td><td></td><td></td></tr>
	<tr><td>tlv</td><td>ay</td><td></td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>ServiceDiscoveryResponse ( a{sv} : args ) --> nothing : ref</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with following parameters:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>peer_object</td><td>o</td><td></td><td>yes</td></tr>
	<tr><td>frequency</td><td>i</td><td></td><td>yes</td></tr>
	<tr><td>dialog_token</td><td>i</td><td></td><td>yes</td></tr>
	<tr><td>tlvs</td><td>ay</td><td></td><td>yes</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>ServiceDiscoveryCancelRequest ( t : args ) --> nothing : ref</h3>
  </li>

  <li>
    <h3>ServiceUpdate ( nothing ) --> nothing</h3>
  </li>

  <li>
    <h3>ServiceDiscoveryExternal ( i : arg ) --> nothing</h3>
  </li>

  <li>
    <h3>AddPersistentGroup ( a{sv} : args ) --> o : path</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>
	A dictionary with following parameters:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th><th>Required</th></tr>
	<tr><td>bssid</td><td>s</td><td>P2P Device Address of the GO in the persistent group.</td><td>yes</td></tr>
	<tr><td>ssid</td><td>s</td><td>SSID of the group</td><td>yes</td></tr>
	<tr><td>psk</td><td>s</td><td>Passphrase (on the GO and optionally on P2P Client) or PSK (on P2P Client if passphrase ise not known)</td><td>yes</td></tr>
	<tr><td>mode</td><td>s</td><td>"3" on GO or "0" on P2P Client</td><td>yes</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>RemovePersistentGroup ( o : path ) --> nothing</h3>
  </li>

  <li>
    <h3>RemoveAllPersistentGroups ( nothing ) --> nothing</h3>
  </li>
</ul>

\subsection dbus_p2pdevice_properties Properties

<ul>
  <li>
    <h3>P2PDeviceConfig - a{sv} - (read/write)</h3>
    <p>Dictionary with following entries. On write, only the included values are changed.</p>
    <table>
    <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
    <tr><td>DeviceName</td><td>s</td><td></td></tr>
    <tr><td>PrimaryDeviceType</td><td>ay</td><td></td></tr>
    <tr><td>SecondaryDeviceTypes</td><td>aay</td><td></td></tr>
    <tr><td>VendorExtension</td><td>aay</td><td></td></tr>
    <tr><td>GOIntent</td><td>u</td><td></td></tr>
    <tr><td>PersistentReconnect</td><td>b</td><td></td></tr>
    <tr><td>ListenRegClass</td><td>u</td><td></td></tr>
    <tr><td>ListenChannel</td><td>u</td><td></td></tr>
    <tr><td>OperRegClass</td><td>u</td><td></td></tr>
    <tr><td>OperChannel</td><td>u</td><td></td></tr>
    <tr><td>SsidPostfix</td><td>s</td><td></td></tr>
    <tr><td>IntraBss</td><td>b</td><td></td></tr>
    <tr><td>GroupIdle</td><td>u</td><td></td></tr>
    <tr><td>disassoc_low_ack</td><td>u</td><td></td></tr>
    <tr><td>NoGroupIface</td><td>b</td><td></td></tr>
    <tr><td>p2p_search_delay</td><td>u</td><td></td></tr>
    </table>
  </li>

  <li>
    <h3>Peers - ao - (read)</h3>
  </li>

  <li>
    <h3>Role - s - (read)</h3>
    <p>\bug What is this trying to indicate? It does not make much sense to have a P2PDevice property role since there can be multiple concurrent groups and the P2P Device role is always active anyway.</p>
  </li>

  <li>
    <h3>Group - o - (read)</h3>
    <p>\bug What is this trying to indicate? It does not make much sense to have a P2PDevice property Group since there can be multiple concurrent groups.</p>
  </li>

  <li>
    <h3>PeerGO - o - (read)</h3>
    <p>\bug What is this trying to indicate? It does not make much sense to have a P2PDevice property PeerGO since there can be multiple concurrent groups.</p>
  </li>

  <li>
    <h3>PersistentGroups - ao - (read)</h3>
  </li>
</ul>

\subsection dbus_p2pdevice_signals Signals

<ul>
  <li>
    <h3>DeviceFound ( o : path )</h3>
  </li>

  <li>
    <h3>DeviceFoundProperties ( o : path, a{sv} : properties )</h3>
    <p>A new peer device has been found.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>o : path</dt>
      <dd>A D-Bus path to an object representing the found peer device.</dd>
    </dl>
    <dl>
      <dt>a{sv} : properties</dt>
      <dd>A dictionary containing properties of the found peer device.</dd>
    </dl>
  </li>

  <li>
    <h3>DeviceLost ( o : path )</h3>
  </li>

  <li>
    <h3>FindStopped ( )</h3>
  </li>

  <li>
    <h3>ProvisionDiscoveryRequestDisplayPin ( o : peer_object, s : pin )</h3>
  </li>

  <li>
    <h3>ProvisionDiscoveryResponseDisplayPin ( o : peer_object, s : pin )</h3>
  </li>

  <li>
    <h3>ProvisionDiscoveryRequestEnterPin ( o : peer_object )</h3>
  </li>

  <li>
    <h3>ProvisionDiscoveryResponseEnterPin ( o : peer_object )</h3>
  </li>

  <li>
    <h3>ProvisionDiscoveryPBCRequest ( o : peer_object )</h3>
  </li>

  <li>
    <h3>ProvisionDiscoveryPBCResponse ( o : peer_object )</h3>
  </li>

  <li>
    <h3>ProvisionDiscoveryFailure ( o : peer_object, i : status )</h3>
  </li>

  <li>
    <h3>GroupStarted ( a{sv} : properties )</h3>
    <p>A new P2P group was started or joined.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : properties</dt>
      <dd>A dictionary with following information on the added group:
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
	  <tr><td>interface_object</td><td>o</td><td>D-Bus path of the interface on which this group is operating on. See \ref dbus_interface.</td></tr>
	  <tr><td>role</td><td>s</td><td>The role of the local device in the group: "GO" or "client".</td></tr>
	  <tr><td>group_object</td><td>o</td><td>D-Bus path of the group. See \ref dbus_group.</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>GONegotiationSuccess ( a{sv} : properties )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : properties</dt>
      <dd>A dictionary with following information:
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
	  <tr><td>peer_object</td><td>o</td><td>D-Bus path of the peer. See \ref dbus_peer.</td></tr>
	  <tr><td>status</td><td>i</td><td></td></tr>
	  <tr><td>passphrase</td><td>s</td><td>Passphrase for the group. Included only if this device becomes the GO of the group.</td></tr>
	  <tr><td>role_go</td><td>s</td><td>The role of the local device in the group: "GO" or "client".</td></tr>
	  <tr><td>ssid</td><td>ay</td><td></td></tr>
	  <tr><td>peer_device_addr</td><td>ay</td><td></td></tr>
	  <tr><td>peer_interface_addr</td><td>ay</td><td></td></tr>
	  <tr><td>wps_method</td><td>s</td><td></td></tr>
	  <tr><td>frequency_list</td><td>ai</td><td></td></tr>
	  <tr><td>persistent_group</td><td>i</td><td></td></tr>
	  <tr><td>peer_config_timeout</td><td>u</td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>GONegotiationFailure ( a{sv} : properties )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : properties</dt>
      <dd>A dictionary with following information:
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
	  <tr><td>peer_object</td><td>o</td><td>D-Bus path of the peer. See \ref dbus_peer.</td></tr>
	  <tr><td>status</td><td>i</td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>GONegotiationRequest ( o : path, q : dev_passwd_id, y : device_go_intent )</h3>
  </li>

  <li>
    <h3>InvitationResult ( a{sv} : invite_result )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : invite_result</dt>
      <dd>A dictionary with following information:
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
	  <tr><td>status</td><td>i</td><td></td></tr>
	  <tr><td>BSSID</td><td>ay</td><td>Optionally present</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>GroupFinished ( a{sv} : properties )</h3>
    <p>A P2P group was removed.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : properties</dt>
      <dd>A dictionary with following information of the removed group:
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
	  <tr><td>interface_object</td><td>o</td><td>D-Bus path of the interface on which this group is operating on. See \ref dbus_interface.</td></tr>
	  <tr><td>role</td><td>s</td><td>The role of the local device in the group: "GO" or "client".</td></tr>
	  <tr><td>group_object</td><td>o</td><td>D-Bus path of the group. See \ref dbus_group.</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>ServiceDiscoveryRequest ( a{sv} : sd_request )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : sd_request</dt>
      <dd>A dictionary with following information:
	<table>
	  <tr><td>peer_object</td><td>o</td><td></td></tr>
	  <tr><td>frequency</td><td>i</td><td></td></tr>
	  <tr><td>dialog_token</td><td>i</td><td></td></tr>
	  <tr><td>update_indicator</td><td>q</td><td></td></tr>
	  <tr><td>tlvs</td><td>ay</td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>ServiceDiscoveryResponse ( a{sv} : sd_response )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : sd_response</dt>
      <dd>A dictionary with following information:
	<table>
	  <tr><td>peer_object</td><td>o</td><td></td></tr>
	  <tr><td>update_indicator</td><td>q</td><td></td></tr>
	  <tr><td>tlvs</td><td>ay</td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>PersistentGroupAdded ( o : path, a{sv} : properties )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>o : path</dt>
      <dd>D-Bus object path for the persistent group. See \ref dbus_persistent_group.</dd>
      <dt>a{sv} : properties</dt>
      <dd>A dictionary with following information:
	<table>
	<tr><th>Key</th><th>Value type</th><th>Description</th></tr>
	<tr><td>bssid</td><td>s</td><td>P2P Device Address of the GO in the persistent group.</td></tr>
	<tr><td>ssid</td><td>s</td><td>SSID of the group</td></tr>
	<tr><td>psk</td><td>s</td><td>Passphrase (on the GO and optionally on P2P Client) or PSK (on P2P Client if passphrase ise not known)</td></tr>
	<tr><td>disabled</td><td>s</td><td>Set to "2" to indicate special network block use as a P2P persistent group information</td></tr>
	<tr><td>mode</td><td>s</td><td>"3" on GO or "0" on P2P Client</td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>PersistentGroupRemoved ( o : path )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>o : path</dt>
      <dd>D-Bus object path for the persistent group. See \ref dbus_persistent_group.</dd>
    </dl>
  </li>

  <li>
    <h3>WpsFailed ( s : name, a{sv} : args )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>s : name</dt>
      <dd>"fail"</dd>
      <dt>a{sv} : args</dt>
      <dd>A dictionary with following information:
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
	  <tr><td>msg</td><td>i</td><td></td></tr>
	  <tr><td>config_error</td><td>n</td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>InvitationReceived ( a{sv} : properties )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : properties</dt>
      <dd>A dictionary with following information:
	<table>
	  <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
	  <tr><td>sa</td><td>ay</td><td>Optionally present</td></tr>
	  <tr><td>go_dev_addr</td><td>ay</td><td>Optionally present</td></tr>
	  <tr><td>bssid</td><td>ay</td><td>Optionally present</td></tr>
	  <tr><td>persistent_id</td><td>i</td><td>Optionally present</td></tr>
	  <tr><td>op_freq</td><td>i</td><td></td></tr>
	</table>
      </dd>
    </dl>
  </li>

  <li>
    <h3>GroupFormationFailure ( s : reason )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>s : reason</dt>
      <dd>Reason for failure or empty string if not known.</dd>
    </dl>
  </li>
</ul>

\section dbus_bss fi.w1.wpa_supplicant1.BSS

Interface implemented by objects representing a scanned BSSs, i.e.,
scan results.

\subsection dbus_bss_properties Properties

<ul>
      <li>
	<h3>BSSID - ay - (read)</h3>
	<p>BSSID of the BSS.</p>
      </li>
      <li>
	<h3>SSID - ay - (read)</h3>
	<p>SSID of the BSS.</p>
      </li>
      <li>
	<h3>WPA - a{sv} - (read)</h3>
	<p>WPA information of the BSS. Empty dictionary indicates no WPA support. Dictionary entries are:</p>
	<table>
	  <tr><td>KeyMgmt</td><td>as</td><td>Key management suite. Possible array elements: "wpa-psk", "wpa-eap", "wpa-none"</td>
	  <tr><td>Pairwise</td><td>as</td><td>Pairwise cipher suites. Possible array elements: "ccmp", "tkip"</td>
	  <tr><td>Group</td><td>s</td><td>Group cipher suite. Possible values are: "ccmp", "tkip", "wep104", "wep40"</td>
	</table>
      </li>
      <li>
	<h3>RSN - a{sv} - (read)</h3>
	<p>RSN information of the BSS. Empty dictionary indicates no RSN support. Dictionary entries are:</p>
	<table>
	  <tr><td>KeyMgmt</td><td>as</td><td>Key management suite. Possible array elements: "wpa-psk", "wpa-ft-psk", "wpa-psk-sha256", "wpa-eap", "wpa-ft-eap", "wpa-eap-sha256", "wpa-eap-suite-b", "wpa-eap-suite-b-192", "wpa-fils-sha256", "wpa-fils-sha384", "wpa-ft-fils-sha256", "wpa-ft-fils-sha384", "sae", "ft-sae", "wpa-none"</td>
	  <tr><td>Pairwise</td><td>as</td><td>Pairwise cipher suites. Possible array elements: "ccmp", "tkip"</td>
	  <tr><td>Group</td><td>s</td><td>Group cipher suite. Possible values are: "ccmp", "tkip", "wep104", "wep40"</td>
	  <tr><td>MgmtGroup</td><td>s</td><td>Management frames cipher suite. Possible values are: "aes128cmac"</td>
	</table>
      </li>
      <li>
	<h3>WPS - a{sv} - (read)</h3>
	<p>WPS information of the BSS. Empty dictionary indicates no WPS support. Dictionary entries are:</p>
	<table>
	  <tr><td>Type</td><td>s</td><td>"pbc", "pin", ""</td>
	</table>
      </li>
      <li>
	<h3>IEs - ay - (read)</h3>
	<p>All IEs of the BSS as a chain of TLVs</p>
      </li>
      <li>
	<h3>Privacy - b - (read)</h3>
	<p>Indicates if BSS supports privacy.</p>
      </li>
      <li>
	<h3>Mode - s - (read)</h3>
	<p>Describes mode of the BSS. Possible values are: "ad-hoc" and "infrastructure".</p>
      </li>
      <li>
	<h3>Frequency - q - (read)</h3>
	<p>Frequency of the BSS in MHz.</p>
      </li>
      <li>
	<h3>Rates - au - (read)</h3>
	<p>Descending ordered array of rates supported by the BSS in bits per second.</p>
      </li>
      <li>
	<h3>Signal - n - (read)</h3>
	<p>Signal strength of the BSS.</p>
      </li>
      <li>
	<h3>Age - u - (read)</h3>
	<p>Number of seconds since the BSS was last seen.</p>
      </li>
    </ul>

\subsection dbus_bss_signals Signals

<ul>
      <li>
	<h3>PropertiesChanged ( a{sv} : properties )</h3>
	<p>Some properties have changed.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary with pairs of properties names which have changed and theirs new values.</dd>
	</dl>
      </li>
    </ul>


\section dbus_network fi.w1.wpa_supplicant1.Network

Interface implemented by objects representing configured networks,
i.e., returned by fi.w1.wpa_supplicant1.Interface.AddNetwork.

\subsection dbus_network_properties Properties

<ul>
      <li>
	<h3>Enabled - b - (read/write)</h3>
	<p>Determines if the configured network is enabled or not.</p>
      </li>

      <li>
	<h3>Properties - a{sv} - (read/write)</h3>
	<p>Properties of the configured network. Dictionary contains entries from "network" block of wpa_supplicant configuration file. All values are string type, e.g., frequency is "2437", not 2437. When setting the properties, use the same format as for the AddNetwork() function.</p>
      </li>
    </ul>

\subsection dbus_network_signals Signals

<ul>
      <li>
	<h3>PropertiesChanged ( a{sv} : properties )</h3>
	<p>Some properties have changed.</p>
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary with pairs of properties names which have changed and theirs new values. Possible dictionary keys are: "Enabled"</dd>
	</dl>
      </li>
    </ul>

\section dbus_peer fi.w1.wpa_supplicant1.Peer

Interface implemented by objects representing P2P peer devices.

\subsection dbus_peer_properties Properties

<ul>
  <li>
    <h3>DeviceName - s - (read)</h3>
  </li>

  <li>
    <h3>Manufacturer - s - (read)</h3>
  </li>

  <li>
    <h3>ModelName - s - (read)</h3>
  </li>

  <li>
    <h3>ModelNumber - s - (read)</h3>
  </li>

  <li>
    <h3>SerialNumber - s - (read)</h3>
  </li>

  <li>
    <h3>PrimaryDeviceType - ay - (read)</h3>
  </li>

  <li>
    <h3>config_method - q - (read)</h3>
  </li>

  <li>
    <h3>level - i - (read)</h3>
  </li>

  <li>
    <h3>devicecapability - y - (read)</h3>
  </li>

  <li>
    <h3>groupcapability - y - (read)</h3>
    <p>Group Capability field from the last frame from which this peer information was updated.
    \note This field is only for debugging purposes and must not be used to determine whether the peer happens to be operating a group as a GO at the moment.
    </p>
  </li>

  <li>
    <h3>SecondaryDeviceTypes - aay - (read)</h3>
  </li>

  <li>
    <h3>VendorExtension - aay - (read)</h3>
  </li>

  <li>
    <h3>IEs - ay - (read)</h3>
    <p>This is a confusingly named property that includes Wi-Fi Display subelements from the peer.
    \bug This should really be renamed since "IEs" means something completely different..
    </p>
  </li>

  <li>
    <h3>DeviceAddress - ay - (read)</h3>
    <p>The P2P Device Address of the peer.</p>
  </li>

  <li>
    <h3>Groups - ao - (read)</h3>
    <p>The current groups in which this peer is connected.</p>
  </li>
</ul>

\subsection dbus_peer_signals Signals

<ul>
  <li>
    <h3>PropertiesChanged ( a{sv} : properties )</h3>
    <p>Some properties have changed.
    \deprecated Use org.freedesktop.DBus.Properties.PropertiesChanged instead.</p>
    \todo Explain how ProertiesChanged signals are supposed to be of any real use with Peer objects (i.e., one signal for multiple peers).
	<h4>Arguments</h4>
	<dl>
	  <dt>a{sv} : properties</dt>
	  <dd>A dictionary with pairs of properties names which have changed and their new values.</dd>
	</dl>
      </li>
    </ul>

\section dbus_group fi.w1.wpa_supplicant1.Group

Interface implemented by objects representing active P2P groups.

\subsection dbus_group_properties Properties

<ul>
  <li>
    <h3>Members - ao - (read)</h3>
    <p>Array of D-Bus object paths for the peer devices that are currently connected to the group. This is valid only on the GO device. An empty array is returned in P2P Client role.
  </li>

  <li>
    <h3>Group - o - (read)</h3>
    <p>\todo Why is this here? This D-Bus object path is to this specific group and one needs to know it to fetching this information in the first place..
    </p>
  </li>

  <li>
    <h3>Role - s - (read)</h3>
    <p>The role of this device in the group: "GO", "client".</p>
  </li>

  <li>
    <h3>SSID - ay - (read)</h3>
    <p>P2P Group SSID.</p>
  </li>

  <li>
    <h3>BSSID - ay - (read)</h3>
    <p>P2P Group BSSID (the P2P Interface Address of the GO).</p>
  </li>

  <li>
    <h3>Frequency - q - (read)</h3>
    <p>The frequency (in MHz) of the group operating channel.</p>
  </li>

  <li>
    <h3>Passphrase - s - (read)</h3>
    <p>Passphrase used in the group. This is always available on the GO. For P2P Client role, this may be available depending on whether the peer GO provided the passphrase during the WPS provisioning step. If not available, an empty string is returned.</p>
  </li>

  <li>
    <h3>PSK - ay - (read)</h3>
    <p>PSK used in the group.</p>
  </li>

  <li>
    <h3>WPSVendorExtensions - aay - (read/write)</h3>
    <p>WPS vendor extension attributes used on the GO. This is valid only the in the GO role. An empty array is returned in P2P Client role. At maximum, 10 separate vendor extension byte arrays can be configured. The GO device will include the configured attributes in WPS exchanges.</p>
  </li>
</ul>

\subsection dbus_group_signals Signals

<ul>
  <li>
    <h3>PeerJoined ( o : peer )</h3>
    <p>A peer device has joined the group. This is indicated only on the GO device.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>o : peer</dt>
      <dd>A D-Bus path to the object representing the peer. See \ref dbus_peer.</dd>
    </dl>
  </li>

  <li>
    <h3>PeerDisconnected ( o : peer )</h3>
    <p>A peer device has left the group. This is indicated only on the GO device.</p>
    <h4>Arguments</h4>
    <dl>
      <dt>o : peer</dt>
      <dd>A D-Bus path to the object representing the peer. See \ref dbus_peer.</dd>
    </dl>
  </li>
</ul>

\section dbus_persistent_group fi.w1.wpa_supplicant1.PersistentGroup

Interface implemented by objects representing persistent P2P groups.

\subsection dbus_persistent_group_properties Properties

<ul>
  <li>
    <h3>Properties - a{sv} - (read/write)</h3>
    <p>Properties of the persistent group. These are same properties as in the \ref dbus_network. When writing this, only the entries to be modified are included, i.e., any item that is not included will be left at its existing value. The following entries are used for persistent groups:</p>
    <table>
      <tr><th>Key</th><th>Value type</th><th>Description</th></tr>
      <tr><td>bssid</td><td>s</td><td>P2P Device Address of the GO in the persistent group.</td></tr>
      <tr><td>ssid</td><td>s</td><td>SSID of the group</td></tr>
      <tr><td>psk</td><td>s</td><td>Passphrase (on the GO and optionally on P2P Client) or PSK (on P2P Client if passphrase ise not known)</td></tr>
      <tr><td>disabled</td><td>s</td><td>Set to "2" to indicate special network block use as a P2P persistent group information</td></tr>
      <tr><td>mode</td><td>s</td><td>"3" on GO or "0" on P2P Client</td></tr>
    </table>
  </li>
</ul>

\section dbus_mesh fi.w1.wpa_supplicant1.Interface.Mesh

Interface for performing mesh operations.

\subsection dbus_mesh_properties Properties

<ul>
  <li>
    <h3>MeshPeers - aay - (read)</h3>
  </li>

  <li>
    <h3>MeshGroup - ay - (read)</h3>
  </li>
</ul>

\subsection dbus_mesh_signals Signals

<ul>
  <li>
    <h3>MeshGroupStarted ( a{sv} : args )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>A dictionary containing information of the started mesh group.</dd>
    </dl>
  </li>
  <li>
    <h3>MeshGroupRemoved ( a{sv} : args )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>A dictionary containing information of the removed mesh group.</dd>
    </dl>
  </li>
  <li>
    <h3>MeshPeerConnected ( a{sv} : args )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>A dictionary containing information of the connected mesh peer.</dd>
    </dl>
  </li>
  <li>
    <h3>MeshPeerDisconnected ( a{sv} : args )</h3>
    <p></p>
    <h4>Arguments</h4>
    <dl>
      <dt>a{sv} : args</dt>
      <dd>A dictionary containing information of the disconnected mesh peer.</dd>
    </dl>
  </li>
</ul>

*/
