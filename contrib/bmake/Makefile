#	$Id: Makefile,v 1.133 2025/03/08 20:12:56 sjg Exp $

PROG = bmake

SRCS = \
	arch.c \
	buf.c \
	compat.c \
	cond.c \
	dir.c \
	for.c \
	hash.c \
	job.c \
	lst.c \
	main.c \
	make.c \
	make_malloc.c \
	meta.c \
	metachar.c \
	parse.c \
	str.c \
	suff.c \
	targ.c \
	trace.c \
	util.c \
	var.c

.MAIN: all

MAN = ${PROG}.1
SRCS.${MAN} = ${srcdir}/make.1

.-include "VERSION"
.-include "Makefile.inc"

# this file gets generated by configure
.-include "Makefile.config"

.if !empty(LIBOBJS)
SRCS += ${LIBOBJS:T:.o=.c}
.endif

# just in case
prefix ?= /usr
srcdir ?= ${.PARSEDIR}
srcdir := ${srcdir}

DEFAULT_SYS_PATH ?= ${prefix}/share/mk

CPPFLAGS += -DUSE_META
CFLAGS += ${CPPFLAGS}
CFLAGS += -D_PATH_DEFSYSPATH=\"${DEFAULT_SYS_PATH}\"
CFLAGS += -I. -I${srcdir} ${XDEFS} -DMAKE_NATIVE
CFLAGS += ${COPTS.${.ALLSRC:M*.c:T:u}}
COPTS.main.c += "-DMAKE_VERSION=\"${_MAKE_VERSION}\""

.for x in FORCE_MAKE_OS FORCE_MACHINE FORCE_MACHINE_ARCH
.ifdef $x
COPTS.main.c += "-D$x=\"${$x}\""
.endif
.endfor

# meta mode can be useful even without filemon
# should be set by now
USE_FILEMON ?= no
.if ${USE_FILEMON:tl} != "no"
.PATH:	${srcdir}/filemon
SRCS += filemon_${USE_FILEMON}.c
COPTS.meta.c += -DUSE_FILEMON -DUSE_FILEMON_${USE_FILEMON:tu}
COPTS.job.c += ${COPTS.meta.c}

.if ${USE_FILEMON} == "dev"
FILEMON_H ?= /usr/include/dev/filemon/filemon.h
.if exists(${FILEMON_H}) && ${FILEMON_H:T} == "filemon.h"
COPTS.filemon_dev.c += -DHAVE_FILEMON_H -I${FILEMON_H:H}
.endif
.elif ${USE_FILEMON} == "ktrace"
COPTS.filemon_ktrace.c += -Wno-error=unused-parameter
.endif

.endif				# USE_FILEMON

.PATH:	${srcdir}

# start-delete1 for bsd.after-import.mk
# we skip a lot of this when building as part of FreeBSD etc.

# list of OS's which are derrived from BSD4.4
BSD44_LIST = NetBSD FreeBSD OpenBSD DragonFly MirBSD Bitrig
# we are...
OS := ${.MAKE.OS:U${uname -s:L:sh}}
# are we 4.4BSD ?
isBSD44 := ${BSD44_LIST:M${OS}}

.if ${isBSD44} == "" && ${OS:NCygwin:NDarwin:NLinux} != ""
MANTARGET ?= cat
.if ${MACHINE} == "sun386"
# even I don't have one of these anymore :-)
CFLAGS += -DPORTAR
.elif ${OS} != "SunOS"
# assume the worst
SRCS += sigcompat.c
CFLAGS += -DSIGNAL_FLAGS=SA_RESTART
.endif
.else
MANTARGET ?= man
.endif

# turn this on by default - ignored if we are root
WITH_INSTALL_AS_USER =

# suppress with -DWITHOUT_*
OPTIONS_DEFAULT_YES += \
	AUTOCONF_MK \
	INSTALL_MK \
	PROG_LINK \
	TESTS \

OPTIONS_DEFAULT_NO += \
	GEN_MAN \
	PROG_VERSION \

.if ${PROG} != "make" || ${srcdir} != ${.CURDIR} || !exists(${srcdir}/${MAN})
WITH_GEN_MAN = 1
.endif

# process options now
.include <own.mk>

.if ${MK_PROG_VERSION} == "yes"
PROG_NAME = ${PROG}-${_MAKE_VERSION}
.if ${MK_PROG_LINK} == "yes"
SYMLINKS += ${PROG_NAME} ${BINDIR}/${PROG}
.endif
.endif

EXTRACT_MAN = no
# end-delete1

.if make(obj) || make(clean)
SUBDIR.${MK_TESTS} += unit-tests
.endif

MAN1 = ${MAN}

.if ${MK_GEN_MAN:Uno} == "yes"

# we use this to generate ${MAN}
.include <${srcdir}/mk/genfiles.mk>

.if ${PROG} != "make"
CLEANFILES += my.history
SED_CMDS.${MAN} += \
	-e '/^.Dt/s/MAKE/${PROG:tu}/' \
	-e '/^.Nm/s/make/${PROG}/' \

.endif

.if ${CLEANFILES:U:Mmy.history} != ""
${MAN}: my.history
my.history:
	@(echo ".Nm"; \
	echo "is derived from NetBSD"; \
	echo ".Xr make 1 ."; \
	echo "It uses autoconf to facilitate portability to other platforms."; \
	echo ".Pp") > $@

SED_CMDS.${MAN} += \
	-e '/^.Sh HISTORY/rmy.history' \
	-e '/^.Sh HISTORY/,/BUGS/s,^.Nm,make,' \

.endif

.if ${.MAKE.OS:N*BSD} != ""
# assume .Nx is not supported
SED_CMDS.${MAN} += -e 's/^\.Nx/NetBSD/'
.endif

# watch out for a late change of PROG
.if !empty(SRCS.${MAN})
.NOPATH: ${MAN}
${MAN}:	${SRCS.${MAN}} _GENFILES_USE

all man beforeinstall: ${MAN}
_mfromdir = .
.endif
.endif				# MK_GEN_MAN

MANTARGET ?= cat
MANDEST ?= ${MANDIR}/${MANTARGET}1

.if ${MANTARGET} == "cat"
_mfromdir = ${srcdir}
.endif

.include <prog.mk>

CPPFLAGS += -DMAKE_NATIVE -DHAVE_CONFIG_H
COPTS.var.c += -Wno-cast-qual
COPTS.job.c += -Wno-format-nonliteral
COPTS.parse.c += -Wno-format-nonliteral
COPTS.var.c += -Wno-format-nonliteral

# Force these
SHAREDIR = ${SHAREDIR.bmake:U${prefix}/share}
BINDIR = ${BINDIR.bmake:U${prefix}/bin}
MANDIR = ${MANDIR.bmake:U${SHAREDIR}/man}

${OBJS}: config.h

# start-delete2 for bsd.after-import.mk

# make sure that MAKE_VERSION gets updated.
main.o: ${srcdir}/VERSION

.if ${MK_AUTOCONF_MK} == "yes"
CONFIGURE_DEPS += ${.CURDIR}/VERSION
# we do not need or want the generated makefile
CONFIGURE_ARGS += --without-makefile
AUTOCONF_GENERATED_MAKEFILE = Makefile.config
.include <autoconf.mk>
.endif
SHARE_MK ?= ${SHAREDIR}/mk
MKSRC = ${srcdir}/mk
INSTALL ?= ${srcdir}/install-sh

.if ${MK_INSTALL_MK} == "yes"
install: install-mk
.endif

beforeinstall:
	test -d ${DESTDIR}${BINDIR} || ${INSTALL} -m ${DIRMODE} -d ${DESTDIR}${BINDIR}
	test -d ${DESTDIR}${MANDEST} || ${INSTALL} -m ${DIRMODE} -d ${DESTDIR}${MANDEST}

install-mk:
.if exists(${MKSRC}/install-mk)
	test -d ${DESTDIR}${SHARE_MK} || ${INSTALL} -m ${DIRMODE} -d ${DESTDIR}${SHARE_MK}
	sh ${MKSRC}/install-mk -v -m ${NONBINMODE} ${DESTDIR}${SHARE_MK}
.else
	@echo need to unpack mk.tar.gz under ${srcdir} or set MKSRC; false
.endif
# end-delete2

# A simple unit-test driver to help catch regressions
TEST_MAKE ?= ${.OBJDIR}/${PROG:T}
accept test: .NOMETA
	cd ${.CURDIR}/unit-tests && \
	MAKEFLAGS= ${TEST_MAKE} -r -m / ${.TARGET} ${TESTS:DTESTS=${TESTS:Q}}


.if make(test) && ${MK_AUTO_OBJ} == "yes"
# The test target above visits unit-tests with -r -m /
# which prevents MK_AUTO_OBJ doing its job
# so do it here
.if defined(MAKEOBJDIRPREFIX) || ${MAKEOBJDIR:U:M*/*} != ""
_utobj = ${.OBJDIR}/unit-tests
.else
_utobj = ${.CURDIR}/unit-tests/${MAKEOBJDIR:Uobj}
.endif
utobj: .NOMETA
	@test -d ${_utobj} && exit 0; \
	echo "[Creating ${_utobj}...]"; \
	umask ${OBJDIR_UMASK:U002}; \
	mkdir -p ${_utobj}
test: utobj
.endif
