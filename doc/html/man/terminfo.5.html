<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!-- 
  * t
  * DO NOT EDIT THIS FILE BY HAND!
  * It is generated from terminfo.head, Caps, and terminfo.tail.
  * Note: this must be run through tbl before nroff.
  * The magic cookie on the first line triggers this under some man programs.
  ****************************************************************************
  * Copyright (c) 1998-2009,2010 Free Software Foundation, Inc.              *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
  * copy of this software and associated documentation files (the            *
  * "Software"), to deal in the Software without restriction, including      *
  * without limitation the rights to use, copy, modify, merge, publish,      *
  * distribute, distribute with modifications, sublicense, and/or sell       *
  * copies of the Software, and to permit persons to whom the Software is    *
  * furnished to do so, subject to the following conditions:                 *
  *                                                                          *
  * The above copyright notice and this permission notice shall be included  *
  * in all copies or substantial portions of the Software.                   *
  *                                                                          *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
  *                                                                          *
  * Except as contained in this notice, the name(s) of the above copyright   *
  * holders shall not be used in advertising or otherwise to promote the     *
  * sale, use or other dealings in this Software without prior written       *
  * authorization.                                                           *
  ****************************************************************************
  * @Id: terminfo.head,v 1.18 2010/07/31 16:08:48 tom Exp @
  * Head of terminfo man page ends here
  * @Id: terminfo.tail,v 1.53 2010/12/04 18:38:55 tom Exp @
  * Beginning of terminfo.tail file
  * This file is part of ncurses.
  * See "terminfo.head" for copyright.
  *.in -2
  *.in +2
  *.in -2
  *.in +2
  *.TH
-->
<HTML>
<HEAD>
<TITLE>terminfo 5   File Formats</TITLE>
<link rev=made href="mailto:bug-ncurses@gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</HEAD>
<BODY>
<H1>terminfo 5   File Formats</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
<STRONG><A HREF="terminfo.5.html">terminfo(5)</A></STRONG>                   File Formats                  <STRONG><A HREF="terminfo.5.html">terminfo(5)</A></STRONG>




</PRE>
<H2>NAME</H2><PRE>
       terminfo - terminal capability data base


</PRE>
<H2>SYNOPSIS</H2><PRE>
       /usr/share/terminfo/*/*


</PRE>
<H2>DESCRIPTION</H2><PRE>
       <EM>Terminfo</EM>  is  a  data  base  describing terminals, used by
       screen-oriented programs  such  as  <STRONG><A HREF="nvi.1.html">nvi(1)</A></STRONG>,  <STRONG><A HREF="rogue.1.html">rogue(1)</A></STRONG>  and
       libraries  such  as <STRONG><A HREF="ncurses.3x.html">curses(3x)</A></STRONG>.  <EM>Terminfo</EM> describes termi-
       nals by giving a set of capabilities which they  have,  by
       specifying how to perform screen operations, and by speci-
       fying padding requirements and  initialization  sequences.
       This describes <STRONG>ncurses</STRONG> version 5.9 (patch 20110404).

       Entries in <EM>terminfo</EM> consist of a sequence of `,' separated
       fields (embedded commas may be escaped with a backslash or
       notated  as \054).  White space after the `,' separator is
       ignored.  The first entry  for  each  terminal  gives  the
       names  which  are known for the terminal, separated by `|'
       characters.  The first  name  given  is  the  most  common
       abbreviation  for the terminal, the last name given should
       be a long name fully identifying  the  terminal,  and  all
       others  are  understood as synonyms for the terminal name.
       All names but the last should be in lower case and contain
       no  blanks;  the last name may well contain upper case and
       blanks for readability.

       Lines beginning with a `#' in the first column are treated
       as  comments.  While comment lines are legal at any point,
       the output of <STRONG>captoinfo</STRONG> and <STRONG>infotocap</STRONG>  (aliases  for  <STRONG>tic</STRONG>)
       will move comments so they occur only between entries.

       Newlines  and  leading  tabs  may  be  used for formatting
       entries for readability.  These are  removed  from  parsed
       entries.   The  <STRONG>infocmp</STRONG> <STRONG>-f</STRONG> option relies on this to format
       if-then-else expressions: the result can be read by <STRONG>tic</STRONG>.

       Terminal names (except for the last, verbose entry) should
       be chosen using the following conventions.  The particular
       piece of hardware making up the  terminal  should  have  a
       root  name, thus ``hp2621''.  This name should not contain
       hyphens.  Modes that the hardware can be in, or user pref-
       erences,  should  be indicated by appending a hyphen and a
       mode suffix.  Thus, a vt100 in 132 column  mode  would  be
       vt100-w.  The following suffixes should be used where pos-
       sible:


      <STRONG>Suffix</STRONG>                  <STRONG>Meaning</STRONG>                   <STRONG>Example</STRONG>
      -<EM>nn</EM>      Number of lines on the screen            aaa-60
      -<EM>n</EM>p      Number of pages of memory                c100-4p
      -am      With automargins (usually the default)   vt100-am
      -m       Mono mode; suppress color                ansi-m
      -mc      Magic cookie; spaces when highlighting   wy30-mc
      -na      No arrow keys (leave them in local)      c100-na
      -nam     Without automatic margins                vt100-nam
      -nl      No status line                           att4415-nl
      -ns      No status line                           hp2626-ns
      -rv      Reverse video                            c100-rv
      -s       Enable status line                       vt100-s

      -vb      Use visible bell instead of beep         wy370-vb
      -w       Wide mode (&gt; 80 columns, usually 132)    vt100-w

       For more on terminal naming conventions, see  the  <STRONG>term(7)</STRONG>
       manual page.

   <STRONG>Capabilities</STRONG>
       The  following  is  a  complete  table of the capabilities
       included in a terminfo description block and available  to
       terminfo-using code.  In each line of the table,

       The  <STRONG>variable</STRONG>  is the name by which the programmer (at the
       terminfo level) accesses the capability.

       The <STRONG>capname</STRONG> is the short name used  in  the  text  of  the
       database,  and  is used by a person updating the database.
       Whenever possible, capnames are chosen to be the  same  as
       or similar to the ANSI X3.64-1979 standard (now superseded
       by ECMA-48, which uses identical or very  similar  names).
       Semantics are also intended to match those of the specifi-
       cation.

       The termcap code is the old <STRONG>termcap</STRONG> capability name  (some
       capabilities are new, and have names which termcap did not
       originate).

       Capability names have no hard length limit, but an  infor-
       mal  limit  of  5 characters has been adopted to keep them
       short and to allow the tabs in the  source  file  <STRONG>Caps</STRONG>  to
       line up nicely.

       Finally,  the  description  field  attempts  to convey the
       semantics of the capability.  You may find some  codes  in
       the description field:

       (P)    indicates that padding may be specified

       #[1-9] in  the description field indicates that the string
              is passed through tparm with parms as given (#<EM>i</EM>).

       (P*)   indicates that padding may vary  in  proportion  to
              the number of lines affected

       (#<EM>i</EM>)   indicates the <EM>i</EM>th parameter.


       These are the boolean capabilities:


               <STRONG>Variable</STRONG>          <STRONG>Cap-</STRONG>  <STRONG>TCap</STRONG>      <STRONG>Description</STRONG>
               <STRONG>Booleans</STRONG>          <STRONG>name</STRONG>  <STRONG>Code</STRONG>
       auto_left_margin          bw    bw    cub1 wraps from col-
                                             umn 0 to last column
       auto_right_margin         am    am    terminal has auto-
                                             matic margins
       back_color_erase          bce   ut    screen erased with
                                             background color
       can_change                ccc   cc    terminal can re-
                                             define existing col-
                                             ors
       ceol_standout_glitch      xhp   xs    standout not erased
                                             by overwriting (hp)
       col_addr_glitch           xhpa  YA    only positive motion
                                             for hpa/mhpa caps


       cpi_changes_res           cpix  YF    changing character
                                             pitch changes reso-
                                             lution
       cr_cancels_micro_mode     crxm  YB    using cr turns off
                                             micro mode
       dest_tabs_magic_smso      xt    xt    tabs destructive,
                                             magic so char
                                             (t1061)
       eat_newline_glitch        xenl  xn    newline ignored
                                             after 80 cols (con-
                                             cept)
       erase_overstrike          eo    eo    can erase over-
                                             strikes with a blank
       generic_type              gn    gn    generic line type
       hard_copy                 hc    hc    hardcopy terminal
       hard_cursor               chts  HC    cursor is hard to
                                             see
       has_meta_key              km    km    Has a meta key
                                             (i.e., sets 8th-bit)
       has_print_wheel           daisy YC    printer needs opera-
                                             tor to change char-
                                             acter set
       has_status_line           hs    hs    has extra status
                                             line
       hue_lightness_saturation  hls   hl    terminal uses only
                                             HLS color notation
                                             (Tektronix)
       insert_null_glitch        in    in    insert mode distin-
                                             guishes nulls
       lpi_changes_res           lpix  YG    changing line pitch
                                             changes resolution
       memory_above              da    da    display may be
                                             retained above the
                                             screen
       memory_below              db    db    display may be
                                             retained below the
                                             screen
       move_insert_mode          mir   mi    safe to move while
                                             in insert mode
       move_standout_mode        msgr  ms    safe to move while
                                             in standout mode
       needs_xon_xoff            nxon  nx    padding will not
                                             work, xon/xoff
                                             required
       no_esc_ctlc               xsb   xb    beehive (f1=escape,
                                             f2=ctrl C)
       no_pad_char               npc   NP    pad character does
                                             not exist
       non_dest_scroll_region    ndscr ND    scrolling region is
                                             non-destructive
       non_rev_rmcup             nrrmc NR    smcup does not
                                             reverse rmcup
       over_strike               os    os    terminal can over-
                                             strike
       prtr_silent               mc5i  5i    printer will not
                                             echo on screen
       row_addr_glitch           xvpa  YD    only positive motion
                                             for vpa/mvpa caps
       semi_auto_right_margin    sam   YE    printing in last
                                             column causes cr
       status_line_esc_ok        eslok es    escape can be used
                                             on the status line
       tilde_glitch              hz    hz    cannot print ~'s
                                             (hazeltine)


       transparent_underline     ul    ul    underline character
                                             overstrikes
       xon_xoff                  xon   xo    terminal uses
                                             xon/xoff handshaking

       These are the numeric capabilities:


            <STRONG>Variable</STRONG>         <STRONG>Cap-</STRONG>     <STRONG>TCap</STRONG>       <STRONG>Description</STRONG>
             <STRONG>Numeric</STRONG>         <STRONG>name</STRONG>     <STRONG>Code</STRONG>
       columns               cols     co     number of columns in
                                             a line
       init_tabs             it       it     tabs initially every
                                             # spaces
       label_height          lh       lh     rows in each label
       label_width           lw       lw     columns in each
                                             label
       lines                 lines    li     number of lines on
                                             screen or page
       lines_of_memory       lm       lm     lines of memory if &gt;
                                             line. 0 means varies
       magic_cookie_glitch   xmc      sg     number of blank
                                             characters left by
                                             smso or rmso
       max_attributes        ma       ma     maximum combined
                                             attributes terminal
                                             can handle
       max_colors            colors   Co     maximum number of
                                             colors on screen
       max_pairs             pairs    pa     maximum number of
                                             color-pairs on the
                                             screen
       maximum_windows       wnum     MW     maximum number of
                                             defineable windows
       no_color_video        ncv      NC     video attributes
                                             that cannot be used
                                             with colors
       num_labels            nlab     Nl     number of labels on
                                             screen
       padding_baud_rate     pb       pb     lowest baud rate
                                             where padding needed
       virtual_terminal      vt       vt     virtual terminal
                                             number (CB/unix)
       width_status_line     wsl      ws     number of columns in
                                             status line

       The following numeric  capabilities  are  present  in  the
       SVr4.0  term  structure, but are not yet documented in the
       man page.  They came in with SVr4's printer support.


             <STRONG>Variable</STRONG>         <STRONG>Cap-</STRONG>    <STRONG>TCap</STRONG>       <STRONG>Description</STRONG>
             <STRONG>Numeric</STRONG>          <STRONG>name</STRONG>    <STRONG>Code</STRONG>
       bit_image_entwining    bitwin  Yo     number of passes for
                                             each bit-image row
       bit_image_type         bitype  Yp     type of bit-image
                                             device
       buffer_capacity        bufsz   Ya     numbers of bytes
                                             buffered before
                                             printing
       buttons                btns    BT     number of buttons on
                                             mouse
       dot_horz_spacing       spinh   Yc     spacing of dots hor-
                                             izontally in dots
                                             per inch

       dot_vert_spacing       spinv   Yb     spacing of pins ver-
                                             tically in pins per
                                             inch
       max_micro_address      maddr   Yd     maximum value in
                                             micro_..._address
       max_micro_jump         mjump   Ye     maximum value in
                                             parm_..._micro
       micro_col_size         mcs     Yf     character step size
                                             when in micro mode
       micro_line_size        mls     Yg     line step size when
                                             in micro mode
       number_of_pins         npins   Yh     numbers of pins in
                                             print-head
       output_res_char        orc     Yi     horizontal resolu-
                                             tion in units per
                                             line
       output_res_horz_inch   orhi    Yk     horizontal resolu-
                                             tion in units per
                                             inch
       output_res_line        orl     Yj     vertical resolution
                                             in units per line
       output_res_vert_inch   orvi    Yl     vertical resolution
                                             in units per inch
       print_rate             cps     Ym     print rate in char-
                                             acters per second
       wide_char_size         widcs   Yn     character step size
                                             when in double wide
                                             mode

       These are the string capabilities:


               <STRONG>Variable</STRONG>          <STRONG>Cap-</STRONG>   <STRONG>TCap</STRONG>     <STRONG>Description</STRONG>
                <STRONG>String</STRONG>           <STRONG>name</STRONG>   <STRONG>Code</STRONG>
       acs_chars                 acsc   ac   graphics charset
                                             pairs, based on
                                             vt100
       back_tab                  cbt    bt   back tab (P)
       bell                      bel    bl   audible signal
                                             (bell) (P)
       carriage_return           cr     cr   carriage return (P*)
                                             (P*)
       change_char_pitch         cpi    ZA   Change number of
                                             characters per inch
                                             to #1
       change_line_pitch         lpi    ZB   Change number of
                                             lines per inch to #1
       change_res_horz           chr    ZC   Change horizontal
                                             resolution to #1
       change_res_vert           cvr    ZD   Change vertical res-
                                             olution to #1
       change_scroll_region      csr    cs   change region to
                                             line #1 to line #2
                                             (P)
       char_padding              rmp    rP   like ip but when in
                                             insert mode
       clear_all_tabs            tbc    ct   clear all tab stops
                                             (P)
       clear_margins             mgc    MC   clear right and left
                                             soft margins
       clear_screen              clear  cl   clear screen and
                                             home cursor (P*)
       clr_bol                   el1    cb   Clear to beginning
                                             of line


       clr_eol                   el     ce   clear to end of line
                                             (P)
       clr_eos                   ed     cd   clear to end of
                                             screen (P*)
       column_address            hpa    ch   horizontal position
                                             #1, absolute (P)
       command_character         cmdch  CC   terminal settable
                                             cmd character in
                                             prototype !?
       create_window             cwin   CW   define a window #1
                                             from #2,#3 to #4,#5
       cursor_address            cup    cm   move to row #1
                                             columns #2
       cursor_down               cud1   do   down one line
       cursor_home               home   ho   home cursor (if no
                                             cup)
       cursor_invisible          civis  vi   make cursor invisi-
                                             ble
       cursor_left               cub1   le   move left one space
       cursor_mem_address        mrcup  CM   memory relative cur-
                                             sor addressing, move
                                             to row #1 columns #2
       cursor_normal             cnorm  ve   make cursor appear
                                             normal (undo
                                             civis/cvvis)
       cursor_right              cuf1   nd   non-destructive
                                             space (move right
                                             one space)
       cursor_to_ll              ll     ll   last line, first
                                             column (if no cup)
       cursor_up                 cuu1   up   up one line
       cursor_visible            cvvis  vs   make cursor very
                                             visible
       define_char               defc   ZE   Define a character
                                             #1, #2 dots wide,
                                             descender #3
       delete_character          dch1   dc   delete character
                                             (P*)
       delete_line               dl1    dl   delete line (P*)
       dial_phone                dial   DI   dial number #1
       dis_status_line           dsl    ds   disable status line
       display_clock             dclk   DK   display clock
       down_half_line            hd     hd   half a line down
       ena_acs                   enacs  eA   enable alternate
                                             char set
       enter_alt_charset_mode    smacs  as   start alternate
                                             character set (P)
       enter_am_mode             smam   SA   turn on automatic
                                             margins
       enter_blink_mode          blink  mb   turn on blinking
       enter_bold_mode           bold   md   turn on bold (extra
                                             bright) mode
       enter_ca_mode             smcup  ti   string to start pro-
                                             grams using cup
       enter_delete_mode         smdc   dm   enter delete mode
       enter_dim_mode            dim    mh   turn on half-bright
                                             mode
       enter_doublewide_mode     swidm  ZF   Enter double-wide
                                             mode
       enter_draft_quality       sdrfq  ZG   Enter draft-quality
                                             mode
       enter_insert_mode         smir   im   enter insert mode
       enter_italics_mode        sitm   ZH   Enter italic mode
       enter_leftward_mode       slm    ZI   Start leftward car-
                                             riage motion

       enter_micro_mode          smicm  ZJ   Start micro-motion
                                             mode
       enter_near_letter_quality snlq   ZK   Enter NLQ mode
       enter_normal_quality      snrmq  ZL   Enter normal-quality
                                             mode
       enter_protected_mode      prot   mp   turn on protected
                                             mode
       enter_reverse_mode        rev    mr   turn on reverse
                                             video mode
       enter_secure_mode         invis  mk   turn on blank mode
                                             (characters invisi-
                                             ble)
       enter_shadow_mode         sshm   ZM   Enter shadow-print
                                             mode
       enter_standout_mode       smso   so   begin standout mode
       enter_subscript_mode      ssubm  ZN   Enter subscript mode
       enter_superscript_mode    ssupm  ZO   Enter superscript
                                             mode
       enter_underline_mode      smul   us   begin underline mode
       enter_upward_mode         sum    ZP   Start upward car-
                                             riage motion
       enter_xon_mode            smxon  SX   turn on xon/xoff
                                             handshaking
       erase_chars               ech    ec   erase #1 characters
                                             (P)
       exit_alt_charset_mode     rmacs  ae   end alternate char-
                                             acter set (P)
       exit_am_mode              rmam   RA   turn off automatic
                                             margins
       exit_attribute_mode       sgr0   me   turn off all
                                             attributes
       exit_ca_mode              rmcup  te   strings to end pro-
                                             grams using cup
       exit_delete_mode          rmdc   ed   end delete mode
       exit_doublewide_mode      rwidm  ZQ   End double-wide mode
       exit_insert_mode          rmir   ei   exit insert mode
       exit_italics_mode         ritm   ZR   End italic mode
       exit_leftward_mode        rlm    ZS   End left-motion mode
       exit_micro_mode           rmicm  ZT   End micro-motion
                                             mode
       exit_shadow_mode          rshm   ZU   End shadow-print
                                             mode
       exit_standout_mode        rmso   se   exit standout mode
       exit_subscript_mode       rsubm  ZV   End subscript mode
       exit_superscript_mode     rsupm  ZW   End superscript mode
       exit_underline_mode       rmul   ue   exit underline mode
       exit_upward_mode          rum    ZX   End reverse charac-
                                             ter motion
       exit_xon_mode             rmxon  RX   turn off xon/xoff
                                             handshaking
       fixed_pause               pause  PA   pause for 2-3 sec-
                                             onds
       flash_hook                hook   fh   flash switch hook
       flash_screen              flash  vb   visible bell (may
                                             not move cursor)
       form_feed                 ff     ff   hardcopy terminal
                                             page eject (P*)
       from_status_line          fsl    fs   return from status
                                             line
       goto_window               wingo  WG   go to window #1
       hangup                    hup    HU   hang-up phone
       init_1string              is1    i1   initialization
                                             string
       init_2string              is2    is   initialization
                                             string

       init_3string              is3    i3   initialization
                                             string
       init_file                 if     if   name of initializa-
                                             tion file
       init_prog                 iprog  iP   path name of program
                                             for initialization
       initialize_color          initc  Ic   initialize color #1
                                             to (#2,#3,#4)
       initialize_pair           initp  Ip   Initialize color
                                             pair #1 to
                                             fg=(#2,#3,#4),
                                             bg=(#5,#6,#7)
       insert_character          ich1   ic   insert character (P)
       insert_line               il1    al   insert line (P*)
       insert_padding            ip     ip   insert padding after
                                             inserted character
       key_a1                    ka1    K1   upper left of keypad
       key_a3                    ka3    K3   upper right of key-
                                             pad
       key_b2                    kb2    K2   center of keypad
       key_backspace             kbs    kb   backspace key
       key_beg                   kbeg   @1   begin key
       key_btab                  kcbt   kB   back-tab key
       key_c1                    kc1    K4   lower left of keypad
       key_c3                    kc3    K5   lower right of key-
                                             pad
       key_cancel                kcan   @2   cancel key
       key_catab                 ktbc   ka   clear-all-tabs key
       key_clear                 kclr   kC   clear-screen or
                                             erase key
       key_close                 kclo   @3   close key
       key_command               kcmd   @4   command key
       key_copy                  kcpy   @5   copy key
       key_create                kcrt   @6   create key
       key_ctab                  kctab  kt   clear-tab key
       key_dc                    kdch1  kD   delete-character key
       key_dl                    kdl1   kL   delete-line key
       key_down                  kcud1  kd   down-arrow key
       key_eic                   krmir  kM   sent by rmir or smir
                                             in insert mode
       key_end                   kend   @7   end key
       key_enter                 kent   @8   enter/send key
       key_eol                   kel    kE   clear-to-end-of-line
                                             key
       key_eos                   ked    kS   clear-to-end-of-
                                             screen key
       key_exit                  kext   @9   exit key
       key_f0                    kf0    k0   F0 function key
       key_f1                    kf1    k1   F1 function key
       key_f10                   kf10   k;   F10 function key
       key_f11                   kf11   F1   F11 function key
       key_f12                   kf12   F2   F12 function key
       key_f13                   kf13   F3   F13 function key
       key_f14                   kf14   F4   F14 function key
       key_f15                   kf15   F5   F15 function key
       key_f16                   kf16   F6   F16 function key
       key_f17                   kf17   F7   F17 function key
       key_f18                   kf18   F8   F18 function key
       key_f19                   kf19   F9   F19 function key
       key_f2                    kf2    k2   F2 function key
       key_f20                   kf20   FA   F20 function key
       key_f21                   kf21   FB   F21 function key
       key_f22                   kf22   FC   F22 function key
       key_f23                   kf23   FD   F23 function key
       key_f24                   kf24   FE   F24 function key

       key_f25                   kf25   FF   F25 function key
       key_f26                   kf26   FG   F26 function key
       key_f27                   kf27   FH   F27 function key
       key_f28                   kf28   FI   F28 function key
       key_f29                   kf29   FJ   F29 function key
       key_f3                    kf3    k3   F3 function key
       key_f30                   kf30   FK   F30 function key
       key_f31                   kf31   FL   F31 function key
       key_f32                   kf32   FM   F32 function key
       key_f33                   kf33   FN   F33 function key
       key_f34                   kf34   FO   F34 function key
       key_f35                   kf35   FP   F35 function key
       key_f36                   kf36   FQ   F36 function key
       key_f37                   kf37   FR   F37 function key
       key_f38                   kf38   FS   F38 function key
       key_f39                   kf39   FT   F39 function key
       key_f4                    kf4    k4   F4 function key
       key_f40                   kf40   FU   F40 function key
       key_f41                   kf41   FV   F41 function key
       key_f42                   kf42   FW   F42 function key
       key_f43                   kf43   FX   F43 function key
       key_f44                   kf44   FY   F44 function key
       key_f45                   kf45   FZ   F45 function key
       key_f46                   kf46   Fa   F46 function key
       key_f47                   kf47   Fb   F47 function key
       key_f48                   kf48   Fc   F48 function key
       key_f49                   kf49   Fd   F49 function key
       key_f5                    kf5    k5   F5 function key
       key_f50                   kf50   Fe   F50 function key
       key_f51                   kf51   Ff   F51 function key
       key_f52                   kf52   Fg   F52 function key
       key_f53                   kf53   Fh   F53 function key
       key_f54                   kf54   Fi   F54 function key
       key_f55                   kf55   Fj   F55 function key
       key_f56                   kf56   Fk   F56 function key
       key_f57                   kf57   Fl   F57 function key
       key_f58                   kf58   Fm   F58 function key
       key_f59                   kf59   Fn   F59 function key
       key_f6                    kf6    k6   F6 function key
       key_f60                   kf60   Fo   F60 function key
       key_f61                   kf61   Fp   F61 function key
       key_f62                   kf62   Fq   F62 function key
       key_f63                   kf63   Fr   F63 function key
       key_f7                    kf7    k7   F7 function key
       key_f8                    kf8    k8   F8 function key
       key_f9                    kf9    k9   F9 function key
       key_find                  kfnd   @0   find key
       key_help                  khlp   %1   help key
       key_home                  khome  kh   home key
       key_ic                    kich1  kI   insert-character key
       key_il                    kil1   kA   insert-line key
       key_left                  kcub1  kl   left-arrow key
       key_ll                    kll    kH   lower-left key (home
                                             down)
       key_mark                  kmrk   %2   mark key
       key_message               kmsg   %3   message key
       key_move                  kmov   %4   move key
       key_next                  knxt   %5   next key
       key_npage                 knp    kN   next-page key
       key_open                  kopn   %6   open key
       key_options               kopt   %7   options key
       key_ppage                 kpp    kP   previous-page key
       key_previous              kprv   %8   previous key
       key_print                 kprt   %9   print key
       key_redo                  krdo   %0   redo key

       key_reference             kref   &amp;1   reference key
       key_refresh               krfr   &amp;2   refresh key
       key_replace               krpl   &amp;3   replace key
       key_restart               krst   &amp;4   restart key
       key_resume                kres   &amp;5   resume key
       key_right                 kcuf1  kr   right-arrow key
       key_save                  ksav   &amp;6   save key
       key_sbeg                  kBEG   &amp;9   shifted begin key
       key_scancel               kCAN   &amp;0   shifted cancel key
       key_scommand              kCMD   *1   shifted command key
       key_scopy                 kCPY   *2   shifted copy key
       key_screate               kCRT   *3   shifted create key
       key_sdc                   kDC    *4   shifted delete-char-
                                             acter key
       key_sdl                   kDL    *5   shifted delete-line
                                             key
       key_select                kslt   *6   select key
       key_send                  kEND   *7   shifted end key
       key_seol                  kEOL   *8   shifted clear-to-
                                             end-of-line key
       key_sexit                 kEXT   *9   shifted exit key
       key_sf                    kind   kF   scroll-forward key
       key_sfind                 kFND   *0   shifted find key
       key_shelp                 kHLP   #1   shifted help key
       key_shome                 kHOM   #2   shifted home key
       key_sic                   kIC    #3   shifted insert-char-
                                             acter key
       key_sleft                 kLFT   #4   shifted left-arrow
                                             key
       key_smessage              kMSG   %a   shifted message key
       key_smove                 kMOV   %b   shifted move key
       key_snext                 kNXT   %c   shifted next key
       key_soptions              kOPT   %d   shifted options key
       key_sprevious             kPRV   %e   shifted previous key
       key_sprint                kPRT   %f   shifted print key
       key_sr                    kri    kR   scroll-backward key
       key_sredo                 kRDO   %g   shifted redo key
       key_sreplace              kRPL   %h   shifted replace key
       key_sright                kRIT   %i   shifted right-arrow
                                             key
       key_srsume                kRES   %j   shifted resume key
       key_ssave                 kSAV   !1   shifted save key
       key_ssuspend              kSPD   !2   shifted suspend key
       key_stab                  khts   kT   set-tab key
       key_sundo                 kUND   !3   shifted undo key
       key_suspend               kspd   &amp;7   suspend key
       key_undo                  kund   &amp;8   undo key
       key_up                    kcuu1  ku   up-arrow key
       keypad_local              rmkx   ke   leave 'key-
                                             board_transmit' mode
       keypad_xmit               smkx   ks   enter 'key-
                                             board_transmit' mode
       lab_f0                    lf0    l0   label on function
                                             key f0 if not f0
       lab_f1                    lf1    l1   label on function
                                             key f1 if not f1
       lab_f10                   lf10   la   label on function
                                             key f10 if not f10
       lab_f2                    lf2    l2   label on function
                                             key f2 if not f2
       lab_f3                    lf3    l3   label on function
                                             key f3 if not f3
       lab_f4                    lf4    l4   label on function
                                             key f4 if not f4


       lab_f5                    lf5    l5   label on function
                                             key f5 if not f5
       lab_f6                    lf6    l6   label on function
                                             key f6 if not f6
       lab_f7                    lf7    l7   label on function
                                             key f7 if not f7
       lab_f8                    lf8    l8   label on function
                                             key f8 if not f8
       lab_f9                    lf9    l9   label on function
                                             key f9 if not f9
       label_format              fln    Lf   label format
       label_off                 rmln   LF   turn off soft labels
       label_on                  smln   LO   turn on soft labels
       meta_off                  rmm    mo   turn off meta mode
       meta_on                   smm    mm   turn on meta mode
                                             (8th-bit on)
       micro_column_address      mhpa   ZY   Like column_address
                                             in micro mode
       micro_down                mcud1  ZZ   Like cursor_down in
                                             micro mode
       micro_left                mcub1  Za   Like cursor_left in
                                             micro mode
       micro_right               mcuf1  Zb   Like cursor_right in
                                             micro mode
       micro_row_address         mvpa   Zc   Like row_address #1
                                             in micro mode
       micro_up                  mcuu1  Zd   Like cursor_up in
                                             micro mode
       newline                   nel    nw   newline (behave like
                                             cr followed by lf)
       order_of_pins             porder Ze   Match software bits
                                             to print-head pins
       orig_colors               oc     oc   Set all color pairs
                                             to the original ones
       orig_pair                 op     op   Set default pair to
                                             its original value
       pad_char                  pad    pc   padding char
                                             (instead of null)
       parm_dch                  dch    DC   delete #1 characters
                                             (P*)
       parm_delete_line          dl     DL   delete #1 lines (P*)
       parm_down_cursor          cud    DO   down #1 lines (P*)
       parm_down_micro           mcud   Zf   Like parm_down_cur-
                                             sor in micro mode
       parm_ich                  ich    IC   insert #1 characters
                                             (P*)
       parm_index                indn   SF   scroll forward #1
                                             lines (P)
       parm_insert_line          il     AL   insert #1 lines (P*)
       parm_left_cursor          cub    LE   move #1 characters
                                             to the left (P)
       parm_left_micro           mcub   Zg   Like parm_left_cur-
                                             sor in micro mode
       parm_right_cursor         cuf    RI   move #1 characters
                                             to the right (P*)
       parm_right_micro          mcuf   Zh   Like parm_right_cur-
                                             sor in micro mode
       parm_rindex               rin    SR   scroll back #1 lines
                                             (P)
       parm_up_cursor            cuu    UP   up #1 lines (P*)
       parm_up_micro             mcuu   Zi   Like parm_up_cursor
                                             in micro mode
       pkey_key                  pfkey  pk   program function key
                                             #1 to type string #2


       pkey_local                pfloc  pl   program function key
                                             #1 to execute string
                                             #2
       pkey_xmit                 pfx    px   program function key
                                             #1 to transmit
                                             string #2
       plab_norm                 pln    pn   program label #1 to
                                             show string #2
       print_screen              mc0    ps   print contents of
                                             screen
       prtr_non                  mc5p   pO   turn on printer for
                                             #1 bytes
       prtr_off                  mc4    pf   turn off printer
       prtr_on                   mc5    po   turn on printer
       pulse                     pulse  PU   select pulse dialing
       quick_dial                qdial  QD   dial number #1 with-
                                             out checking
       remove_clock              rmclk  RC   remove clock
       repeat_char               rep    rp   repeat char #1 #2
                                             times (P*)
       req_for_input             rfi    RF   send next input char
                                             (for ptys)
       reset_1string             rs1    r1   reset string
       reset_2string             rs2    r2   reset string
       reset_3string             rs3    r3   reset string
       reset_file                rf     rf   name of reset file
       restore_cursor            rc     rc   restore cursor to
                                             position of last
                                             save_cursor
       row_address               vpa    cv   vertical position #1
                                             absolute (P)
       save_cursor               sc     sc   save current cursor
                                             position (P)
       scroll_forward            ind    sf   scroll text up (P)
       scroll_reverse            ri     sr   scroll text down (P)
       select_char_set           scs    Zj   Select character
                                             set, #1
       set_attributes            sgr    sa   define video
                                             attributes #1-#9
                                             (PG9)
       set_background            setb   Sb   Set background color
                                             #1
       set_bottom_margin         smgb   Zk   Set bottom margin at
                                             current line
       set_bottom_margin_parm    smgbp  Zl   Set bottom margin at
                                             line #1 or (if smgtp
                                             is not given) #2
                                             lines from bottom
       set_clock                 sclk   SC   set clock, #1 hrs #2
                                             mins #3 secs
       set_color_pair            scp    sp   Set current color
                                             pair to #1
       set_foreground            setf   Sf   Set foreground color
                                             #1
       set_left_margin           smgl   ML   set left soft margin
                                             at current column.
                                             See smgl. (ML is not
                                             in BSD termcap).
       set_left_margin_parm      smglp  Zm   Set left (right)
                                             margin at column #1
       set_right_margin          smgr   MR   set right soft mar-
                                             gin at current col-
                                             umn
       set_right_margin_parm     smgrp  Zn   Set right margin at
                                             column #1

       set_tab                   hts    st   set a tab in every
                                             row, current columns
       set_top_margin            smgt   Zo   Set top margin at
                                             current line
       set_top_margin_parm       smgtp  Zp   Set top (bottom)
                                             margin at row #1
       set_window                wind   wi   current window is
                                             lines #1-#2 cols
                                             #3-#4
       start_bit_image           sbim   Zq   Start printing bit
                                             image graphics
       start_char_set_def        scsd   Zr   Start character set
                                             definition #1, with
                                             #2 characters in the
                                             set
       stop_bit_image            rbim   Zs   Stop printing bit
                                             image graphics
       stop_char_set_def         rcsd   Zt   End definition of
                                             character set #1
       subscript_characters      subcs  Zu   List of subscript-
                                             able characters
       superscript_characters    supcs  Zv   List of superscript-
                                             able characters
       tab                       ht     ta   tab to next 8-space
                                             hardware tab stop
       these_cause_cr            docr   Zw   Printing any of
                                             these characters
                                             causes CR
       to_status_line            tsl    ts   move to status line,
                                             column #1
       tone                      tone   TO   select touch tone
                                             dialing
       underline_char            uc     uc   underline char and
                                             move past it
       up_half_line              hu     hu   half a line up
       user0                     u0     u0   User string #0
       user1                     u1     u1   User string #1
       user2                     u2     u2   User string #2
       user3                     u3     u3   User string #3
       user4                     u4     u4   User string #4
       user5                     u5     u5   User string #5
       user6                     u6     u6   User string #6
       user7                     u7     u7   User string #7
       user8                     u8     u8   User string #8
       user9                     u9     u9   User string #9
       wait_tone                 wait   WA   wait for dial-tone
       xoff_character            xoffc  XF   XOFF character
       xon_character             xonc   XN   XON character
       zero_motion               zerom  Zx   No motion for subse-
                                             quent character

       The  following  string  capabilities  are  present  in the
       SVr4.0 term structure, but were originally not  documented
       in the man page.


               <STRONG>Variable</STRONG>          <STRONG>Cap-</STRONG>     <STRONG>TCap</STRONG>    <STRONG>Description</STRONG>
                <STRONG>String</STRONG>           <STRONG>name</STRONG>     <STRONG>Code</STRONG>
       alt_scancode_esc          scesa    S8   Alternate escape
                                               for scancode emu-
                                               lation
       bit_image_carriage_return bicr     Yv   Move to beginning
                                               of same row
       bit_image_newline         binel    Zz   Move to next row
                                               of the bit image

       bit_image_repeat          birep    Xy   Repeat bit image
                                               cell #1 #2 times
       char_set_names            csnm     Zy   Produce #1'th item
                                               from list of char-
                                               acter set names
       code_set_init             csin     ci   Init sequence for
                                               multiple codesets
       color_names               colornm  Yw   Give name for
                                               color #1
       define_bit_image_region   defbi    Yx   Define rectan-
                                               gualar bit image
                                               region
       device_type               devt     dv   Indicate lan-
                                               guage/codeset sup-
                                               port
       display_pc_char           dispc    S1   Display PC charac-
                                               ter #1
       end_bit_image_region      endbi    Yy   End a bit-image
                                               region
       enter_pc_charset_mode     smpch    S2   Enter PC character
                                               display mode
       enter_scancode_mode       smsc     S4   Enter PC scancode
                                               mode
       exit_pc_charset_mode      rmpch    S3   Exit PC character
                                               display mode
       exit_scancode_mode        rmsc     S5   Exit PC scancode
                                               mode
       get_mouse                 getm     Gm   Curses should get
                                               button events,
                                               parameter #1 not
                                               documented.
       key_mouse                 kmous    Km   Mouse event has
                                               occurred
       mouse_info                minfo    Mi   Mouse status
                                               information
       pc_term_options           pctrm    S6   PC terminal
                                               options
       pkey_plab                 pfxl     xl   Program function
                                               key #1 to type
                                               string #2 and show
                                               string #3
       req_mouse_pos             reqmp    RQ   Request mouse
                                               position
       scancode_escape           scesc    S7   Escape for scan-
                                               code emulation
       set0_des_seq              s0ds     s0   Shift to codeset 0
                                               (EUC set 0, ASCII)
       set1_des_seq              s1ds     s1   Shift to codeset 1
       set2_des_seq              s2ds     s2   Shift to codeset 2
       set3_des_seq              s3ds     s3   Shift to codeset 3
       set_a_background          setab    AB   Set background
                                               color to #1, using
                                               ANSI escape
       set_a_foreground          setaf    AF   Set foreground
                                               color to #1, using
                                               ANSI escape
       set_color_band            setcolor Yz   Change to ribbon
                                               color #1
       set_lr_margin             smglr    ML   Set both left and
                                               right margins to
                                               #1, #2.  (ML is
                                               not in BSD term-
                                               cap).
       set_page_length           slines   YZ   Set page length to
                                               #1 lines

       set_tb_margin             smgtb    MT   Sets both top and
                                               bottom margins to
                                               #1, #2

        The XSI Curses  standard  added  these.   They  are  some
        post-4.1  versions  of System V curses, e.g., Solaris 2.5
        and IRIX 6.x.  The <STRONG>ncurses</STRONG> termcap  names  for  them  are
        invented; according to the XSI Curses standard, they have
        no termcap names.  If your compiled terminfo entries  use
        these,  they  may  not be binary-compatible with System V
        terminfo entries after SVr4.1; beware!


                <STRONG>Variable</STRONG>         <STRONG>Cap-</STRONG>   <STRONG>TCap</STRONG>     <STRONG>Description</STRONG>
                 <STRONG>String</STRONG>          <STRONG>name</STRONG>   <STRONG>Code</STRONG>
        enter_horizontal_hl_mode ehhlm  Xh   Enter horizontal
                                             highlight mode
        enter_left_hl_mode       elhlm  Xl   Enter left highlight
                                             mode
        enter_low_hl_mode        elohlm Xo   Enter low highlight
                                             mode
        enter_right_hl_mode      erhlm  Xr   Enter right high-
                                             light mode
        enter_top_hl_mode        ethlm  Xt   Enter top highlight
                                             mode
        enter_vertical_hl_mode   evhlm  Xv   Enter vertical high-
                                             light mode
        set_a_attributes         sgr1   sA   Define second set of
                                             video attributes
                                             #1-#6
        set_pglen_inch           slengthsL   YI Set page length
                                             to #1 hundredth of
                                             an inch

   <STRONG>A</STRONG> <STRONG>Sample</STRONG> <STRONG>Entry</STRONG>
       The following entry, describing an ANSI-standard terminal,
       is  representative  of  what a <STRONG>terminfo</STRONG> entry for a modern
       terminal typically looks like.

     ansi|ansi/pc-term compatible with color,
             mc5i,
             colors#8, ncv#3, pairs#64,
             cub=\E[%p1%dD, cud=\E[%p1%dB, cuf=\E[%p1%dC,
             cuu=\E[%p1%dA, dch=\E[%p1%dP, dl=\E[%p1%dM,
             ech=\E[%p1%dX, el1=\E[1K, hpa=\E[%p1%dG, ht=\E[I,
             ich=\E[%p1%d@, il=\E[%p1%dL, indn=\E[%p1%dS, .indn=\E[%p1%dT,
             kbs=^H, kcbt=\E[Z, kcub1=\E[D, kcud1=\E[B,
             kcuf1=\E[C, kcuu1=\E[A, kf1=\E[M, kf10=\E[V,
             kf11=\E[W, kf12=\E[X, kf2=\E[N, kf3=\E[O, kf4=\E[P,
             kf5=\E[Q, kf6=\E[R, kf7=\E[S, kf8=\E[T, kf9=\E[U,
             kich1=\E[L, mc4=\E[4i, mc5=\E[5i, nel=\r\E[S,
             op=\E[37;40m, rep=%p1%c\E[%p2%{1}%-%db,
             rin=\E[%p1%dT, s0ds=\E(B, s1ds=\E)B, s2ds=\E*B,
             s3ds=\E+B, setab=\E[4%p1%dm, setaf=\E[3%p1%dm,
             setb=\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
             setf=\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
             sgr=\E[0;10%?%p1%t;7%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p6%t;1%;%?%p7%t;8%;%?%p8%t;11%;%?%p9%t;12%;m,
             sgr0=\E[0;10m, tbc=\E[2g, u6=\E[%d;%dR, u7=\E[6n,
             u8=\E[?%[;0123456789]c, u9=\E[c, vpa=\E[%p1%dd,

       Entries may continue onto multiple lines by placing  white
       space  at  the  beginning  of  each line except the first.
       Comments may be included on lines  beginning  with  ``#''.
       Capabilities in <EM>terminfo</EM> are of three types: Boolean capa-
       bilities which indicate that the terminal has some partic-
       ular  feature, numeric capabilities giving the size of the
       terminal or the size  of  particular  delays,  and  string
       capabilities,  which  give a sequence which can be used to
       perform particular terminal operations.


   <STRONG>Types</STRONG> <STRONG>of</STRONG> <STRONG>Capabilities</STRONG>
       All capabilities have names.  For instance, the fact  that
       ANSI-standard  terminals  have <EM>automatic</EM> <EM>margins</EM> (i.e., an
       automatic return and line-feed when the end of a  line  is
       reached)  is  indicated  by  the capability <STRONG>am</STRONG>.  Hence the
       description of ansi includes <STRONG>am</STRONG>.  Numeric capabilities are
       followed  by  the character `#' and then a positive value.
       Thus <STRONG>cols</STRONG>, which indicates the number of columns the  ter-
       minal  has,  gives  the  value  `80' for ansi.  Values for
       numeric capabilities may be specified in decimal, octal or
       hexadecimal,  using the C programming language conventions
       (e.g., 255, 0377 and 0xff or 0xFF).

       Finally, string valued capabilities, such as <STRONG>el</STRONG> (clear  to
       end of line sequence) are given by the two-character code,
       an `=', and then a string ending  at  the  next  following
       `,'.

       A  number  of  escape sequences are provided in the string
       valued capabilities for easy encoding of characters there.
       Both  <STRONG>\E</STRONG>  and  <STRONG>\e</STRONG> map to an ESCAPE character, <STRONG>^x</STRONG> maps to a
       control-x for any appropriate x, and the sequences  <STRONG>\n</STRONG>  <STRONG>\l</STRONG>
       <STRONG>\r</STRONG>  <STRONG>\t</STRONG>  <STRONG>\b</STRONG>  <STRONG>\f</STRONG>  <STRONG>\s</STRONG> give a newline, line-feed, return, tab,
       backspace, form-feed, and space.  Other escapes include <STRONG>\^</STRONG>
       for  <STRONG>^</STRONG>, <STRONG>\\</STRONG> for <STRONG>\</STRONG>, <STRONG>\</STRONG>, for comma, <STRONG>\:</STRONG> for <STRONG>:</STRONG>, and <STRONG>\0</STRONG> for null.
       (<STRONG>\0</STRONG> will produce \200, which does not terminate  a  string
       but behaves as a null character on most terminals, provid-
       ing CS7 is specified.  See <STRONG><A HREF="stty.1.html">stty(1)</A></STRONG>.)  Finally,  characters
       may be given as three octal digits after a <STRONG>\</STRONG>.

       A  delay  in  milliseconds may appear anywhere in a string
       capability, enclosed in $&lt;..&gt; brackets, as in  <STRONG>el</STRONG>=\EK$&lt;5&gt;,
       and  padding  characters  are supplied by <EM>tputs</EM> to provide
       this delay.  The delay must be a number with at  most  one
       decimal place of precision; it may be followed by suffixes
       `*' or '/' or both.  A  `*'  indicates  that  the  padding
       required  is  proportional to the number of lines affected
       by the  operation,  and  the  amount  given  is  the  per-
       affected-unit  padding  required.   (In the case of insert
       character,  the  factor  is  still  the  number  of  <EM>lines</EM>
       affected.)   Normally,  padding  is advisory if the device
       has the <STRONG>xon</STRONG> capability; it is used  for  cost  computation
       but  does not trigger delays.  A `/' suffix indicates that
       the padding is mandatory and forces a delay of  the  given
       number  of  milliseconds  even on devices for which <STRONG>xon</STRONG> is
       present to indicate flow control.

       Sometimes individual capabilities must be  commented  out.
       To  do this, put a period before the capability name.  For
       example, see the second <STRONG>ind</STRONG> in the example above.


   <STRONG>Fetching</STRONG> <STRONG>Compiled</STRONG> <STRONG>Descriptions</STRONG>
       If the environment variable TERMINFO is set, it is  inter-
       preted  as the pathname of a directory containing the com-
       piled description you are working on.  Only that directory
       is searched.

       If  TERMINFO  is  not set, the <STRONG>ncurses</STRONG> version of the ter-
       minfo reader code  will  instead  look  in  the  directory
       <STRONG>$HOME/.terminfo</STRONG>  for  a compiled description.  If it fails
       to find one  there,  and  the  environment  variable  TER-
       MINFO_DIRS  is set, it will interpret the contents of that
       variable as a list of colon- separated directories  to  be
       searched  (an  empty  entry is interpreted as a command to
       search <EM>/usr/share/terminfo</EM>).  If no description  is  found
       in  any of the TERMINFO_DIRS directories, the fetch fails.

       If neither TERMINFO nor TERMINFO_DIRS  is  set,  the  last
       place   tried  will  be  the  system  terminfo  directory,
       <EM>/usr/share/terminfo</EM>.

       (Neither the  <STRONG>$HOME/.terminfo</STRONG>  lookups  nor  TERMINFO_DIRS
       extensions   are  supported  under  stock  System  V  ter-
       minfo/curses.)


   <STRONG>Preparing</STRONG> <STRONG>Descriptions</STRONG>
       We now outline how to prepare descriptions  of  terminals.
       The  most  effective way to prepare a terminal description
       is by imitating the description of a similar  terminal  in
       <EM>terminfo</EM>  and  to  build up a description gradually, using
       partial descriptions with <EM>vi</EM> or some other screen-oriented
       program  to  check that they are correct.  Be aware that a
       very unusual terminal may expose deficiencies in the abil-
       ity  of  the  <EM>terminfo</EM>  file to describe it or bugs in the
       screen-handling code of the test program.

       To get the padding for insert line right (if the  terminal
       manufacturer did not document it) a severe test is to edit
       a large file at 9600 baud, delete 16 or so lines from  the
       middle  of  the screen, then hit the `u' key several times
       quickly.  If the terminal messes up, more padding is  usu-
       ally  needed.  A similar test can be used for insert char-
       acter.


   <STRONG>Basic</STRONG> <STRONG>Capabilities</STRONG>
       The number of columns on each line  for  the  terminal  is
       given  by the <STRONG>cols</STRONG> numeric capability.  If the terminal is
       a CRT, then the number of lines on the screen is given  by
       the <STRONG>lines</STRONG> capability.  If the terminal wraps around to the
       beginning of the next line when it reaches the right  mar-
       gin, then it should have the <STRONG>am</STRONG> capability.  If the termi-
       nal can clear its screen, leaving the cursor in  the  home
       position,  then this is given by the <STRONG>clear</STRONG> string capabil-
       ity.  If the terminal overstrikes (rather than clearing  a
       position  when  a character is struck over) then it should
       have the <STRONG>os</STRONG> capability.  If the  terminal  is  a  printing
       terminal,  with no soft copy unit, give it both <STRONG>hc</STRONG> and <STRONG>os</STRONG>.
       (<STRONG>os</STRONG> applies to storage scope terminals, such as  TEKTRONIX
       4010  series, as well as hard copy and APL terminals.)  If
       there is a code to move the cursor to the left edge of the
       current row, give this as <STRONG>cr</STRONG>.  (Normally this will be car-
       riage return, control M.)  If there is a code  to  produce
       an audible signal (bell, beep, etc) give this as <STRONG>bel</STRONG>.

       If  there is a code to move the cursor one position to the
       left (such as backspace) that capability should  be  given
       as  <STRONG>cub1</STRONG>.   Similarly, codes to move to the right, up, and
       down should be given as <STRONG>cuf1</STRONG>, <STRONG>cuu1</STRONG>, and <STRONG>cud1</STRONG>.  These local
       cursor  motions  should not alter the text they pass over,
       for example, you would not normally use  `<STRONG>cuf1</STRONG>= '  because
       the space would erase the character moved over.

       A  very  important  point  here  is  that the local cursor
       motions encoded in <EM>terminfo</EM> are undefined at the left  and
       top  edges  of  a  CRT  terminal.   Programs  should never
       attempt to backspace around the left edge,  unless  <STRONG>bw</STRONG>  is
       given, and never attempt to go up locally off the top.  In
       order to scroll text up, a program will go to  the  bottom
       left corner of the screen and send the <STRONG>ind</STRONG> (index) string.

       To scroll text down, a program goes to the top left corner
       of  the  screen  and  sends the <STRONG>ri</STRONG> (reverse index) string.
       The strings <STRONG>ind</STRONG> and <STRONG>ri</STRONG> are undefined  when  not  on  their
       respective corners of the screen.

       Parameterized versions of the scrolling sequences are <STRONG>indn</STRONG>
       and <STRONG>rin</STRONG> which have the same semantics as <STRONG>ind</STRONG> and <STRONG>ri</STRONG> except
       that  they take one parameter, and scroll that many lines.
       They are also undefined except at the appropriate edge  of
       the screen.

       The  <STRONG>am</STRONG>  capability tells whether the cursor sticks at the
       right edge of the screen when text  is  output,  but  this
       does not necessarily apply to a <STRONG>cuf1</STRONG> from the last column.
       The only local motion which is defined from the left  edge
       is  if  <STRONG>bw</STRONG>  is  given, then a <STRONG>cub1</STRONG> from the left edge will
       move to the right edge of the previous row.  If <STRONG>bw</STRONG> is  not
       given,  the effect is undefined.  This is useful for draw-
       ing a box around the edge of the screen, for example.   If
       the  terminal has switch selectable automatic margins, the
       <EM>terminfo</EM> file usually assumes that this is on;  i.e.,  <STRONG>am</STRONG>.
       If  the  terminal  has  a command which moves to the first
       column of the next line, that command can be given as  <STRONG>nel</STRONG>
       (newline).   It  does not matter if the command clears the
       remainder of the current line, so if the terminal  has  no
       <STRONG>cr</STRONG>  and <STRONG>lf</STRONG> it may still be possible to craft a working <STRONG>nel</STRONG>
       out of one or both of them.

       These  capabilities  suffice  to  describe  hard-copy  and
       "glass-tty"  terminals.   Thus  the  model  33 teletype is
       described as

       33|tty33|tty|model 33 teletype,
            bel=^G, cols#72, cr=^M, cud1=^J, hc, ind=^J, os,

       while the Lear Siegler ADM-3 is described as

       adm3|3|lsi adm3,
            am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,
            ind=^J, lines#24,


   <STRONG>Parameterized</STRONG> <STRONG>Strings</STRONG>
       Cursor addressing and other strings  requiring  parameters
       in  the  terminal  are described by a parameterized string
       capability, with <STRONG><A HREF="printf.3.html">printf(3)</A></STRONG> like escapes  <STRONG>%x</STRONG>  in  it.   For
       example,  to  address  the  cursor,  the <STRONG>cup</STRONG> capability is
       given, using two parameters: the row and column to address
       to.  (Rows and columns are numbered from zero and refer to
       the physical screen visible to the user, not to any unseen
       memory.)   If  the  terminal  has  memory  relative cursor
       addressing, that can be indicated by <STRONG>mrcup</STRONG>.

       The parameter mechanism uses a stack and special  <STRONG>%</STRONG>  codes
       to  manipulate  it.  Typically a sequence will push one of
       the parameters onto the stack and then print  it  in  some
       format.   Print  (e.g.,  "%d")  is  a special case.  Other
       operations, including "%t"  pop  their  operand  from  the
       stack.  It is noted that more complex operations are often
       necessary, e.g., in the <STRONG>sgr</STRONG> string.

       The <STRONG>%</STRONG> encodings have the following meanings:


       %%   outputs `%'

       %<EM>[[</EM>:<EM>]flags][width[.precision]][</EM>doxXs<EM>]</EM>
            as in <STRONG>printf</STRONG>, flags are [-+#] and space.  Use  a  `:'
            to  allow the next character to be a `-' flag, avoid-
            ing interpreting "%-" as an operator.

       %c   print pop() like %c in <STRONG>printf</STRONG>

       %s   print pop() like %s in <STRONG>printf</STRONG>

       %p[1-9]
            push <EM>i</EM>'th parameter

       %P[a-z]
            set dynamic variable [a-z] to pop()

       %g[a-z]
            get dynamic variable [a-z] and push it

       %P[A-Z]
            set static variable [a-z] to pop()

       %g[A-Z]
            get static variable [a-z] and push it

            The terms  "static"  and  "dynamic"  are  misleading.
            Historically,  these are simply two different sets of
            variables, whose values are not reset  between  calls
            to  <STRONG>tparm</STRONG>.   However,  that fact is not documented in
            other implementations.  Relying on it will  adversely
            impact portability to other implementations.

       %'<EM>c</EM>' char constant <EM>c</EM>

       %{<EM>nn</EM>}
            integer constant <EM>nn</EM>

       %l   push strlen(pop)

       %+ %- %* %/ %m
            arithmetic (%m is mod): push(pop() op pop())

       %&amp; %| %^
            bit operations (AND, OR and exclusive-OR): push(pop()
            op pop())

       %= %&gt; %&lt;
            logical operations: push(pop() op pop())

       %A, %O
            logical AND and OR operations (for conditionals)

       %! %~
            unary  operations  (logical  and   bit   complement):
            push(op pop())

       %i   add 1 to first two parameters (for ANSI terminals)

       %? <EM>expr</EM> %t <EM>thenpart</EM> %e <EM>elsepart</EM> %;
            This  forms  an  if-then-else.   The  %e  <EM>elsepart</EM> is
            optional.  Usually the %? <EM>expr</EM> part  pushes  a  value
            onto  the stack, and %t pops it from the stack, test-
            ing if it is nonzero (true).  If it is zero  (false),
            control passes to the %e (else) part.

            It is possible to form else-if's a la Algol 68:
            %? c1 %t b1 %e c2 %t b2 %e c3 %t b3 %e c4 %t b4 %e %;

            where ci are conditions, bi are bodies.

            Use the <STRONG>-f</STRONG> option of <STRONG>tic</STRONG> or <STRONG>infocmp</STRONG> to see the struc-
            ture  of if-then-else's.  Some strings, e.g., <STRONG>sgr</STRONG> can
            be very complicated when written on one line.  The <STRONG>-f</STRONG>
            option  splits  the  string into lines with the parts
            indented.

       Binary operations are in postfix form with the operands in
       the  usual  order.   That  is,  to  get  x-5 one would use
       "%gx%{5}%-".  %P and %g variables  are  persistent  across
       escape-string evaluations.

       Consider the HP2645, which, to get to row 3 and column 12,
       needs to be sent \E&amp;a12c03Y  padded  for  6  milliseconds.
       Note  that  the  order of the rows and columns is inverted
       here, and that the row and column are printed as two  dig-
       its.  Thus its <STRONG>cup</STRONG> capability is "cup=6\E&amp;%p2%2dc%p1%2dY".

       The Microterm ACT-IV needs the current row and column sent
       preceded  by  a <STRONG>^T</STRONG>, with the row and column simply encoded
       in binary, "cup=^T%p1%c%p2%c".  Terminals which  use  "%c"
       need  to  be  able  to backspace the cursor (<STRONG>cub1</STRONG>), and to
       move the cursor up one line on the screen (<STRONG>cuu1</STRONG>).  This is
       necessary  because it is not always safe to transmit <STRONG>\n</STRONG> <STRONG>^D</STRONG>
       and <STRONG>\r</STRONG>, as the system may change or  discard  them.   (The
       library  routines  dealing  with terminfo set tty modes so
       that tabs are never expanded, so \t is safe to send.  This
       turns out to be essential for the Ann Arbor 4080.)

       A final example is the LSI ADM-3a, which uses row and col-
       umn  offset  by  a  blank  character,  thus  "cup=\E=%p1%'
       '%+%c%p2%'  '%+%c".   After sending `\E=', this pushes the
       first parameter, pushes the ASCII value for a space  (32),
       adds  them  (pushing  the sum on the stack in place of the
       two previous values) and outputs that value as  a  charac-
       ter.   Then  the  same  is  done for the second parameter.
       More complex arithmetic is possible using the stack.


   <STRONG>Cursor</STRONG> <STRONG>Motions</STRONG>
       If the terminal has a fast way to home the cursor (to very
       upper  left  corner  of  screen) then this can be given as
       <STRONG>home</STRONG>; similarly a fast way of getting to the  lower  left-
       hand  corner can be given as <STRONG>ll</STRONG>; this may involve going up
       with <STRONG>cuu1</STRONG> from the home position,  but  a  program  should
       never  do this itself (unless <STRONG>ll</STRONG> does) because it can make
       no assumption about the effect of moving up from the  home
       position.   Note  that  the  home  position is the same as
       addressing to (0,0): to the top left corner of the screen,
       not  of  memory.   (Thus, the \EH sequence on HP terminals
       cannot be used for <STRONG>home</STRONG>.)

       If the terminal has row or column absolute cursor address-
       ing,  these  can be given as single parameter capabilities
       <STRONG>hpa</STRONG> (horizontal position absolute) and <STRONG>vpa</STRONG> (vertical posi-
       tion absolute).  Sometimes these are shorter than the more
       general two parameter sequence (as with  the  hp2645)  and
       can   be   used  in  preference  to  <STRONG>cup</STRONG>.   If  there  are
       parameterized local motions (e.g., move <EM>n</EM>  spaces  to  the
       right) these can be given as <STRONG>cud</STRONG>, <STRONG>cub</STRONG>, <STRONG>cuf</STRONG>, and <STRONG>cuu</STRONG> with a
       single parameter  indicating  how  many  spaces  to  move.
       These  are  primarily useful if the terminal does not have
       <STRONG>cup</STRONG>, such as the TEKTRONIX 4025.

       If the terminal needs to be in a special mode when running
       a program that uses these capabilities, the codes to enter
       and exit this mode can be given as <STRONG>smcup</STRONG> and <STRONG>rmcup</STRONG>.   This
       arises,  for example, from terminals like the Concept with
       more than one page of memory.  If the  terminal  has  only
       memory  relative cursor addressing and not screen relative
       cursor addressing, a one screen-sized window must be fixed
       into  the terminal for cursor addressing to work properly.
       This is also used for the TEKTRONIX 4025, where <STRONG>smcup</STRONG> sets
       the  command character to be the one used by terminfo.  If
       the <STRONG>smcup</STRONG> sequence will not restore the  screen  after  an
       <STRONG>rmcup</STRONG> sequence is output (to the state prior to outputting
       <STRONG>rmcup</STRONG>), specify <STRONG>nrrmc</STRONG>.


   <STRONG>Area</STRONG> <STRONG>Clears</STRONG>
       If the terminal can clear from the current position to the
       end  of  the  line,  leaving  the cursor where it is, this
       should be given as <STRONG>el</STRONG>.  If the terminal can clear from the
       beginning  of  the line to the current position inclusive,
       leaving the cursor where it is, this should  be  given  as
       <STRONG>el1</STRONG>.   If the terminal can clear from the current position
       to the end of the display, then this should  be  given  as
       <STRONG>ed</STRONG>.   <STRONG>Ed</STRONG>  is only defined from the first column of a line.
       (Thus, it can be simulated by a request to delete a  large
       number of lines, if a true <STRONG>ed</STRONG> is not available.)


   <STRONG>Insert/delete</STRONG> <STRONG>line</STRONG> <STRONG>and</STRONG> <STRONG>vertical</STRONG> <STRONG>motions</STRONG>
       If  the terminal can open a new blank line before the line
       where the cursor is, this should be given as <STRONG>il1</STRONG>; this  is
       done  only  from the first position of a line.  The cursor
       must then appear on the newly blank line.  If the terminal
       can  delete  the  line  which  the cursor is on, then this
       should be given as <STRONG>dl1</STRONG>; this is done only from  the  first
       position  on  the line to be deleted.  Versions of <STRONG>il1</STRONG> and
       <STRONG>dl1</STRONG> which take a single parameter  and  insert  or  delete
       that many lines can be given as <STRONG>il</STRONG> and <STRONG>dl</STRONG>.

       If  the terminal has a settable scrolling region (like the
       vt100) the command to set this can be described  with  the
       <STRONG>csr</STRONG>  capability,  which  takes two parameters: the top and
       bottom lines of the scrolling region.  The cursor position
       is, alas, undefined after using this command.

       It  is possible to get the effect of insert or delete line
       using <STRONG>csr</STRONG> on a properly chosen region; the <STRONG>sc</STRONG> and <STRONG>rc</STRONG> (save
       and  restore  cursor)  commands may be useful for ensuring
       that your synthesized insert/delete string does  not  move
       the  cursor.  (Note that the <STRONG><A HREF="ncurses.3x.html">ncurses(3x)</A></STRONG> library does this
       synthesis  automatically,  so   you   need   not   compose
       insert/delete strings for an entry with <STRONG>csr</STRONG>).

       Yet another way to construct insert and delete might be to
       use a combination of index with  the  memory-lock  feature
       found  on some terminals (like the HP-700/90 series, which
       however also has insert/delete).

       Inserting lines at the top or bottom  of  the  screen  can
       also  be  done using <STRONG>ri</STRONG> or <STRONG>ind</STRONG> on many terminals without a
       true insert/delete line, and is often faster even on  ter-
       minals with those features.

       The  boolean  <STRONG>non_dest_scroll_region</STRONG> should be set if each
       scrolling window is effectively a view port on  a  screen-
       sized  canvas.   To  test  for  this  capability, create a
       scrolling region in the middle of the screen, write  some-
       thing  to  the  bottom line, move the cursor to the top of
       the region, and do <STRONG>ri</STRONG> followed by <STRONG>dl1</STRONG> or <STRONG>ind</STRONG>.  If the data
       scrolled  off  the  bottom  of  the  region  by the <STRONG>ri</STRONG> re-
       appears, then scrolling is non-destructive.  System V  and
       XSI  Curses  expect that <STRONG>ind</STRONG>, <STRONG>ri</STRONG>, <STRONG>indn</STRONG>, and <STRONG>rin</STRONG> will simu-
       late destructive scrolling; their  documentation  cautions
       you  not  to  define <STRONG>csr</STRONG> unless this is true.  This <STRONG>curses</STRONG>
       implementation is more liberal and will do explicit erases
       after scrolling if <STRONG>ndstr</STRONG> is defined.

       If the terminal has the ability to define a window as part
       of memory, which all commands affect, it should  be  given
       as the parameterized string <STRONG>wind</STRONG>.  The four parameters are
       the starting and ending lines in memory and  the  starting
       and ending columns in memory, in that order.

       If  the terminal can retain display memory above, then the
       <STRONG>da</STRONG> capability should be given; if display  memory  can  be
       retained  below,  then <STRONG>db</STRONG> should be given.  These indicate
       that deleting a line  or  scrolling  may  bring  non-blank
       lines  up  from  below  or that scrolling back with <STRONG>ri</STRONG> may
       bring down non-blank lines.


   <STRONG>Insert/Delete</STRONG> <STRONG>Character</STRONG>
       There are two basic kinds of  intelligent  terminals  with
       respect  to insert/delete character which can be described
       using <EM>terminfo.</EM>  The most common  insert/delete  character
       operations  affect only the characters on the current line
       and shift characters off the  end  of  the  line  rigidly.
       Other  terminals,  such  as the Concept 100 and the Perkin
       Elmer Owl, make a distinction between  typed  and  untyped
       blanks  on  the  screen, shifting upon an insert or delete
       only to an untyped blank on the  screen  which  is  either
       eliminated,  or  expanded  to two untyped blanks.  You can
       determine the kind of terminal you have  by  clearing  the
       screen  and  then typing text separated by cursor motions.
       Type "abc    def" using local cursor motions (not  spaces)
       between the "abc" and the "def".  Then position the cursor
       before the "abc" and put the terminal in insert mode.   If
       typing  characters  causes  the  rest of the line to shift
       rigidly and characters to fall off the end, then your ter-
       minal  does  not  distinguish  between  blanks and untyped
       positions.  If the "abc" shifts over to  the  "def"  which
       then  move together around the end of the current line and
       onto the next as you insert, you have the second  type  of
       terminal,  and should give the capability <STRONG>in</STRONG>, which stands
       for "insert null".  While these are two logically separate
       attributes  (one  line  versus multi-line insert mode, and
       special treatment of untyped spaces) we have seen no  ter-
       minals whose insert mode cannot be described with the sin-
       gle attribute.

       Terminfo can describe both terminals which have an  insert
       mode, and terminals which send a simple sequence to open a
       blank position on the current  line.   Give  as  <STRONG>smir</STRONG>  the
       sequence  to  get  into  insert  mode.   Give  as <STRONG>rmir</STRONG> the
       sequence to leave insert  mode.   Now  give  as  <STRONG>ich1</STRONG>  any
       sequence  needed  to  be  sent  just  before  sending  the
       character to be inserted.   Most  terminals  with  a  true
       insert  mode  will  not  give <STRONG>ich1</STRONG>; terminals which send a
       sequence to open a screen position should give it here.

       If your terminal has both, insert mode is usually  prefer-
       able  to  <STRONG>ich1</STRONG>.   Technically,  you  should  not give both
       unless the terminal actually requires both to be  used  in
       combination.   Accordingly,  some  non-curses applications
       get confused if both are present; the symptom  is  doubled
       characters in an update using insert.  This requirement is
       now rare; most <STRONG>ich</STRONG> sequences do not require previous smir,
       and most smir insert modes do not require <STRONG>ich1</STRONG> before each
       character.  Therefore, the  new  <STRONG>curses</STRONG>  actually  assumes
       this  is the case and uses either <STRONG>rmir</STRONG>/<STRONG>smir</STRONG> or <STRONG>ich</STRONG>/<STRONG>ich1</STRONG> as
       appropriate (but not both).  If you have to write an entry
       to  be  used under new curses for a terminal old enough to
       need both, include the <STRONG>rmir</STRONG>/<STRONG>smir</STRONG> sequences in <STRONG>ich1</STRONG>.

       If post insert padding is needed, give this as a number of
       milliseconds  in <STRONG>ip</STRONG> (a string option).  Any other sequence
       which may need to be sent after  an  insert  of  a  single
       character may also be given in <STRONG>ip</STRONG>.  If your terminal needs
       both to be placed into an `insert mode' and a special code
       to  precede  each  inserted character, then both <STRONG>smir</STRONG>/<STRONG>rmir</STRONG>
       and <STRONG>ich1</STRONG> can be given, and both will  be  used.   The  <STRONG>ich</STRONG>
       capability, with one parameter, <EM>n</EM>, will repeat the effects
       of <STRONG>ich1</STRONG> <EM>n</EM> times.

       If padding is necessary between characters typed while not
       in  insert  mode,  give  this  as a number of milliseconds
       padding in <STRONG>rmp</STRONG>.

       It is occasionally  necessary  to  move  around  while  in
       insert  mode  to delete characters on the same line (e.g.,
       if there is a tab after the insertion position).  If  your
       terminal  allows  motion while in insert mode you can give
       the capability <STRONG>mir</STRONG> to speed up  inserting  in  this  case.
       Omitting  <STRONG>mir</STRONG>  will  affect  only  speed.   Some terminals
       (notably Datamedia's) must not have <STRONG>mir</STRONG> because of the way
       their insert mode works.

       Finally,  you  can specify <STRONG>dch1</STRONG> to delete a single charac-
       ter, <STRONG>dch</STRONG> with one parameter, <EM>n</EM>, to  delete  <EM>n</EM>  <EM>characters,</EM>
       and  delete mode by giving <STRONG>smdc</STRONG> and <STRONG>rmdc</STRONG> to enter and exit
       delete mode (any mode the terminal needs to be  placed  in
       for <STRONG>dch1</STRONG> to work).

       A  command to erase <EM>n</EM> characters (equivalent to outputting
       <EM>n</EM> blanks without moving the cursor) can be  given  as  <STRONG>ech</STRONG>
       with one parameter.


   <STRONG>Highlighting,</STRONG> <STRONG>Underlining,</STRONG> <STRONG>and</STRONG> <STRONG>Visible</STRONG> <STRONG>Bells</STRONG>
       If  your  terminal  has  one  or  more  kinds  of  display
       attributes, these can be represented in a number  of  dif-
       ferent ways.  You should choose one display form as <EM>stand-</EM>
       <EM>out</EM> <EM>mode</EM>, representing a good, high contrast, easy-on-the-
       eyes,  format  for  highlighting  error messages and other
       attention getters.  (If you have a choice,  reverse  video
       plus  half-bright  is  good, or reverse video alone.)  The
       sequences to enter and exit standout  mode  are  given  as
       <STRONG>smso</STRONG>  and  <STRONG>rmso</STRONG>, respectively.  If the code to change into
       or out of standout mode  leaves  one  or  even  two  blank
       spaces  on the screen, as the TVI 912 and Teleray 1061 do,
       then <STRONG>xmc</STRONG> should be given to tell how many spaces are left.

       Codes  to  begin  underlining  and  end underlining can be
       given as <STRONG>smul</STRONG> and <STRONG>rmul</STRONG> respectively.  If the terminal  has
       a  code  to  underline  the current character and move the
       cursor one space to the right, such as the Microterm Mime,
       this can be given as <STRONG>uc</STRONG>.

       Other  capabilities  to  enter  various highlighting modes
       include <STRONG>blink</STRONG> (blinking) <STRONG>bold</STRONG> (bold or extra  bright)  <STRONG>dim</STRONG>
       (dim  or  half-bright)  <STRONG>invis</STRONG> (blanking or invisible text)
       <STRONG>prot</STRONG> (protected) <STRONG>rev</STRONG> (reverse video) <STRONG>sgr0</STRONG>  (turn  off  <EM>all</EM>
       attribute  modes)  <STRONG>smacs</STRONG>  (enter  alternate  character set
       mode) and  <STRONG>rmacs</STRONG>  (exit  alternate  character  set  mode).
       Turning  on  any of these modes singly may or may not turn
       off other modes.

       If there is a sequence to set  arbitrary  combinations  of
       modes,  this should be given as <STRONG>sgr</STRONG> (set attributes), tak-
       ing 9 parameters.  Each parameter is either 0 or  nonzero,
       as the corresponding attribute is on or off.  The 9 param-
       eters are, in order: standout, underline, reverse,  blink,
       dim,  bold,  blank, protect, alternate character set.  Not
       all modes need be supported by <STRONG>sgr</STRONG>, only those  for  which
       corresponding separate attribute commands exist.

       For example, the DEC vt220 supports most of the modes:


            <STRONG>tparm</STRONG> <STRONG>parameter</STRONG>   <STRONG>attribute</STRONG>    <STRONG>escape</STRONG> <STRONG>sequence</STRONG>

            none              none         \E[0m
            p1                standout     \E[0;1;7m
            p2                underline    \E[0;4m
            p3                reverse      \E[0;7m
            p4                blink        \E[0;5m
            p5                dim          not available
            p6                bold         \E[0;1m
            p7                invis        \E[0;8m
            p8                protect      not used
            p9                altcharset   ^O (off) ^N (on)

       We  begin each escape sequence by turning off any existing
       modes, since there is no quick way  to  determine  whether
       they are active.  Standout is set up to be the combination
       of reverse and bold.  The vt220  terminal  has  a  protect
       mode,  though  it  is  not commonly used in sgr because it
       protects characters on the screen  from  the  host's  era-
       sures.   The  altcharset mode also is different in that it
       is either ^O or ^N, depending on whether it is off or  on.
       If  all  modes  are  turned  on, the resulting sequence is
       \E[0;1;4;5;7;8m^N.

       Some sequences are common to different modes.   For  exam-
       ple,  ;7  is output when either p1 or p3 is true, that is,
       if either standout or reverse modes are turned on.

       Writing out the above sequences, along with  their  depen-
       dencies yields


          <STRONG>sequence</STRONG>   <STRONG>when</STRONG> <STRONG>to</STRONG> <STRONG>output</STRONG>      <STRONG>terminfo</STRONG> <STRONG>translation</STRONG>

          \E[0       always              \E[0
          ;1         if p1 or p6         %?%p1%p6%|%t;1%;
          ;4         if p2               %?%p2%|%t;4%;
          ;5         if p4               %?%p4%|%t;5%;

          ;7         if p1 or p3         %?%p1%p3%|%t;7%;
          ;8         if p7               %?%p7%|%t;8%;
          m          always              m
          ^N or ^O   if p9 ^N, else ^O   %?%p9%t^N%e^O%;

       Putting this all together into the sgr sequence gives:

           sgr=\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;
               %?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\016%e\017%;,

       Remember  that  if  you specify sgr, you must also specify
       sgr0.  Also, some implementations rely on sgr being  given
       if  sgr0  is, Not all terminfo entries necessarily have an
       sgr string, however.  Many terminfo  entries  are  derived
       from  termcap  entries which have no sgr string.  The only
       drawback to adding an sgr  string  is  that  termcap  also
       assumes  that  sgr0  does not exit alternate character set
       mode.

       Terminals with the ``magic cookie'' glitch  (<STRONG>xmc</STRONG>)  deposit
       special   ``cookies''   when   they  receive  mode-setting
       sequences, which affect the display algorithm rather  than
       having  extra  bits  for  each character.  Some terminals,
       such as the HP 2621,  automatically  leave  standout  mode
       when  they  move to a new line or the cursor is addressed.
       Programs using standout mode  should  exit  standout  mode
       before  moving the cursor or sending a newline, unless the
       <STRONG>msgr</STRONG> capability, asserting that it  is  safe  to  move  in
       standout mode, is present.

       If  the terminal has a way of flashing the screen to indi-
       cate an error quietly (a bell replacement) then  this  can
       be given as <STRONG>flash</STRONG>; it must not move the cursor.

       If  the  cursor  needs to be made more visible than normal
       when it is not on the bottom line (to make, for example, a
       non-blinking  underline  into  an  easier to find block or
       blinking underline) give this sequence as <STRONG>cvvis</STRONG>.  If there
       is  a  way  to  make the cursor completely invisible, give
       that as <STRONG>civis</STRONG>.  The capability <STRONG>cnorm</STRONG> should be given which
       undoes the effects of both of these modes.

       If your terminal correctly generates underlined characters
       (with no special codes needed) even  though  it  does  not
       overstrike,  then you should give the capability <STRONG>ul</STRONG>.  If a
       character overstriking another leaves both  characters  on
       the screen, specify the capability <STRONG>os</STRONG>.  If overstrikes are
       erasable with a blank, then this should  be  indicated  by
       giving <STRONG>eo</STRONG>.


   <STRONG>Keypad</STRONG> <STRONG>and</STRONG> <STRONG>Function</STRONG> <STRONG>Keys</STRONG>
       If the terminal has a keypad that transmits codes when the
       keys are pressed, this information  can  be  given.   Note
       that it is not possible to handle terminals where the key-
       pad only works in local (this applies, for example, to the
       unshifted  HP  2621  keys).   If  the keypad can be set to
       transmit or not transmit, give these  codes  as  <STRONG>smkx</STRONG>  and
       <STRONG>rmkx</STRONG>.  Otherwise the keypad is assumed to always transmit.
       The codes sent by the left arrow, right arrow,  up  arrow,
       down  arrow,  and  home keys can be given as <STRONG>kcub1,</STRONG> <STRONG>kcuf1,</STRONG>
       <STRONG>kcuu1,</STRONG> <STRONG>kcud1,</STRONG> and <STRONG>khome</STRONG> respectively.  If there are  func-
       tion  keys  such  as f0, f1, ..., f10, the codes they send
       can be given as <STRONG>kf0,</STRONG> <STRONG>kf1,</STRONG> <STRONG>...,</STRONG> <STRONG>kf10</STRONG>.  If these  keys  have
       labels  other  than the default f0 through f10, the labels
       can  be  given  as  <STRONG>lf0,</STRONG>  <STRONG>lf1,</STRONG>  <STRONG>...,</STRONG>  <STRONG>lf10</STRONG>.    The   codes
       transmitted  by  certain  other special keys can be given:
       <STRONG>kll</STRONG> (home down), <STRONG>kbs</STRONG> (backspace), <STRONG>ktbc</STRONG> (clear  all  tabs),
       <STRONG>kctab</STRONG>  (clear  the  tab  stop in this column), <STRONG>kclr</STRONG> (clear
       screen or  erase  key),  <STRONG>kdch1</STRONG>  (delete  character),  <STRONG>kdl1</STRONG>
       (delete line), <STRONG>krmir</STRONG> (exit insert mode), <STRONG>kel</STRONG> (clear to end
       of line), <STRONG>ked</STRONG> (clear to  end  of  screen),  <STRONG>kich1</STRONG>  (insert
       character  or  enter insert mode), <STRONG>kil1</STRONG> (insert line), <STRONG>knp</STRONG>
       (next  page),  <STRONG>kpp</STRONG>  (previous  page),  <STRONG>kind</STRONG>  (scroll  for-
       ward/down), <STRONG>kri</STRONG> (scroll backward/up), <STRONG>khts</STRONG> (set a tab stop
       in this column).  In addition, if the keypad has a 3 by  3
       array  of  keys  including  the four arrow keys, the other
       five keys can be given as <STRONG>ka1</STRONG>, <STRONG>ka3</STRONG>,  <STRONG>kb2</STRONG>,  <STRONG>kc1</STRONG>,  and  <STRONG>kc3</STRONG>.
       These  keys are useful when the effects of a 3 by 3 direc-
       tional pad are needed.

       Strings to program function keys can be  given  as  <STRONG>pfkey</STRONG>,
       <STRONG>pfloc</STRONG>,  and <STRONG>pfx</STRONG>.  A string to program screen labels should
       be specified as <STRONG>pln</STRONG>.  Each  of  these  strings  takes  two
       parameters:  the function key number to program (from 0 to
       10) and the string to program it with.  Function key  num-
       bers  out  of  this  range may program undefined keys in a
       terminal dependent manner.   The  difference  between  the
       capabilities  is  that <STRONG>pfkey</STRONG> causes pressing the given key
       to be the same as the user typing the given string;  <STRONG>pfloc</STRONG>
       causes the string to be executed by the terminal in local;
       and <STRONG>pfx</STRONG> causes the string to be transmitted  to  the  com-
       puter.

       The capabilities <STRONG>nlab</STRONG>, <STRONG>lw</STRONG> and <STRONG>lh</STRONG> define the number of pro-
       grammable screen labels and their width  and  height.   If
       there  are  commands  to  turn the labels on and off, give
       them in <STRONG>smln</STRONG> and <STRONG>rmln</STRONG>.  <STRONG>smln</STRONG> is normally output after  one
       or more pln sequences to make sure that the change becomes
       visible.


   <STRONG>Tabs</STRONG> <STRONG>and</STRONG> <STRONG>Initialization</STRONG>
       If the terminal has hardware tabs, the command to  advance
       to  the  next tab stop can be given as <STRONG>ht</STRONG> (usually control
       I).  A ``back-tab'' command which moves  leftward  to  the
       preceding tab stop can be given as <STRONG>cbt</STRONG>.  By convention, if
       the teletype modes indicate that tabs are  being  expanded
       by  the  computer  rather than being sent to the terminal,
       programs should not  use  <STRONG>ht</STRONG>  or  <STRONG>cbt</STRONG>  even  if  they  are
       present,  since  the user may not have the tab stops prop-
       erly set.  If the terminal has  hardware  tabs  which  are
       initially  set every <EM>n</EM> spaces when the terminal is powered
       up, the numeric parameter <STRONG>it</STRONG> is given, showing the  number
       of  spaces  the tabs are set to.  This is normally used by
       the <EM>tset</EM> command to determine whether to set the mode  for
       hardware  tab expansion, and whether to set the tab stops.
       If the terminal has tab stops that can be  saved  in  non-
       volatile  memory, the terminfo description can assume that
       they are properly set.

       Other capabilities include <STRONG>is1</STRONG>, <STRONG>is2</STRONG>, and <STRONG>is3</STRONG>,  initializa-
       tion  strings  for the terminal, <STRONG>iprog</STRONG>, the path name of a
       program to be run to initialize the terminal, and <STRONG>if</STRONG>,  the
       name  of  a  file  containing long initialization strings.
       These strings are expected to set the terminal into  modes
       consistent  with  the  rest  of  the terminfo description.
       They are normally sent to the terminal, by the <EM>init</EM> option
       of  the  <EM>tput</EM>  program,  each time the user logs in.  They
       will be printed in the following order:

              run the program
                     <STRONG>iprog</STRONG>

              output <STRONG>is1</STRONG> <STRONG>is2</STRONG>

              set the margins using
                     <STRONG>mgc</STRONG>, <STRONG>smgl</STRONG> and <STRONG>smgr</STRONG>

              set tabs using
                     <STRONG>tbc</STRONG> and <STRONG>hts</STRONG>

              print the file
                     <STRONG>if</STRONG>

              and finally
                     output <STRONG>is3</STRONG>.

       Most initialization is done with  <STRONG>is2</STRONG>.   Special  terminal
       modes can be set up without duplicating strings by putting
       the common sequences in <STRONG>is2</STRONG> and special cases in  <STRONG>is1</STRONG>  and
       <STRONG>is3</STRONG>.

       A set of sequences that does a harder reset from a totally
       unknown state can be given as <STRONG>rs1</STRONG>, <STRONG>rs2</STRONG>, <STRONG>rf</STRONG> and <STRONG>rs3</STRONG>, analo-
       gous  to  <STRONG>is1</STRONG>  <STRONG>,</STRONG>  <STRONG>is2</STRONG>  <STRONG>,</STRONG>  <STRONG>if</STRONG>  and <STRONG>is3</STRONG> respectively.  These
       strings are output by the <EM>reset</EM>  program,  which  is  used
       when  the terminal gets into a wedged state.  Commands are
       normally placed in <STRONG>rs1</STRONG>, <STRONG>rs2</STRONG> <STRONG>rs3</STRONG> and <STRONG>rf</STRONG> only if  they  pro-
       duce  annoying effects on the screen and are not necessary
       when logging in.  For example,  the  command  to  set  the
       vt100  into  80-column mode would normally be part of <STRONG>is2</STRONG>,
       but it causes an annoying glitch of the screen and is  not
       normally  needed  since the terminal is usually already in
       80 column mode.

       The <EM>reset</EM> program writes strings including <STRONG>iprog</STRONG>, etc., in
       the  same  order  as  the  <EM>init</EM>  program, using <STRONG>rs1</STRONG>, etc.,
       instead of <STRONG>is1</STRONG>, etc.  If any of <STRONG>rs1</STRONG>, <STRONG>rs2</STRONG>, <STRONG>rs3</STRONG>, or <STRONG>rf</STRONG> reset
       capability  strings  are  missing, the <EM>reset</EM> program falls
       back  upon  the  corresponding  initialization  capability
       string.

       If there are commands to set and clear tab stops, they can
       be given as <STRONG>tbc</STRONG> (clear all tab stops) and <STRONG>hts</STRONG> (set  a  tab
       stop  in the current column of every row).  If a more com-
       plex sequence is needed  to  set  the  tabs  than  can  be
       described  by  this,  the sequence can be placed in <STRONG>is2</STRONG> or
       <STRONG>if</STRONG>.

   <STRONG>Delays</STRONG> <STRONG>and</STRONG> <STRONG>Padding</STRONG>
       Many older and slower  terminals  do  not  support  either
       XON/XOFF or DTR handshaking, including hard copy terminals
       and some very archaic CRTs (including,  for  example,  DEC
       VT100s).   These may require padding characters after cer-
       tain cursor motions and screen changes.

       If the terminal uses xon/xoff handshaking for flow control
       (that  is, it automatically emits ^S back to the host when
       its input buffers are close to full), set <STRONG>xon</STRONG>.  This capa-
       bility  suppresses  the emission of padding.  You can also
       set it for memory-mapped console devices effectively  that
       do  not  have  a  speed limit.  Padding information should
       still be included so that routines can make  better  deci-
       sions about relative costs, but actual pad characters will
       not be transmitted.

       If <STRONG>pb</STRONG> (padding baud rate) is given, padding is  suppressed
       at  baud rates below the value of <STRONG>pb</STRONG>.  If the entry has no
       padding baud rate, then whether padding is emitted or  not
       is completely controlled by <STRONG>xon</STRONG>.

       If  the terminal requires other than a null (zero) charac-
       ter as a pad, then this can be given  as  <STRONG>pad</STRONG>.   Only  the
       first character of the <STRONG>pad</STRONG> string is used.


   <STRONG>Status</STRONG> <STRONG>Lines</STRONG>
       Some  terminals  have  an extra `status line' which is not
       normally used by software (and thus  not  counted  in  the
       terminal's <STRONG>lines</STRONG> capability).

       The  simplest  case  is  a  status  line  which is cursor-
       addressable but not part of the main scrolling  region  on
       the  screen;  the  Heathkit  H19 has a status line of this
       kind, as would a 24-line VT100 with  a  23-line  scrolling
       region  set up on initialization.  This situation is indi-
       cated by the <STRONG>hs</STRONG> capability.

       Some terminals with status lines need special sequences to
       access  the  status  line.   These  may  be expressed as a
       string with single parameter <STRONG>tsl</STRONG> which takes the cursor to
       a  given zero-origin column on the status line.  The capa-
       bility <STRONG>fsl</STRONG> must return to the main-screen cursor positions
       before  the  last  <STRONG>tsl</STRONG>.   You may need to embed the string
       values of <STRONG>sc</STRONG> (save cursor) and <STRONG>rc</STRONG> (restore cursor) in  <STRONG>tsl</STRONG>
       and <STRONG>fsl</STRONG> to accomplish this.

       The  status  line is normally assumed to be the same width
       as the width of the terminal.  If this is untrue, you  can
       specify it with the numeric capability <STRONG>wsl</STRONG>.

       A  command to erase or blank the status line may be speci-
       fied as <STRONG>dsl</STRONG>.

       The  boolean  capability  <STRONG>eslok</STRONG>  specifies   that   escape
       sequences, tabs, etc., work ordinarily in the status line.

       The <STRONG>ncurses</STRONG> implementation does not yet use any  of  these
       capabilities.   They are documented here in case they ever
       become important.


   <STRONG>Line</STRONG> <STRONG>Graphics</STRONG>
       Many terminals have alternate character  sets  useful  for
       forms-drawing.   Terminfo  and <STRONG>curses</STRONG> build in support for
       the drawing characters supported by the VT100,  with  some
       characters  from  the  AT&amp;T  4410v1 added.  This alternate
       character set may be specified by the <STRONG>acsc</STRONG> capability.


       <STRONG>Glyph</STRONG>                      <STRONG>ACS</STRONG>            <STRONG>Ascii</STRONG>      <STRONG>VT100</STRONG>
       <STRONG>Name</STRONG>                       <STRONG>Name</STRONG>           <STRONG>Default</STRONG>    <STRONG>Name</STRONG>
       UK pound sign              ACS_STERLING   f          }
       arrow pointing down        ACS_DARROW     v          .
       arrow pointing left        ACS_LARROW     &lt;          ,
       arrow pointing right       ACS_RARROW     &gt;          +
       arrow pointing up          ACS_UARROW     ^          -
       board of squares           ACS_BOARD      #          h
       bullet                     ACS_BULLET     o          ~
       checker board (stipple)    ACS_CKBOARD    :          a
       degree symbol              ACS_DEGREE     \          f
       diamond                    ACS_DIAMOND    +          `
       greater-than-or-equal-to   ACS_GEQUAL     &gt;          z
       greek pi                   ACS_PI         *          {
       horizontal line            ACS_HLINE      -          q
       lantern symbol             ACS_LANTERN    #          i
       large plus or crossover    ACS_PLUS       +          n
       less-than-or-equal-to      ACS_LEQUAL     &lt;          y

       lower left corner          ACS_LLCORNER   +          m
       lower right corner         ACS_LRCORNER   +          j
       not-equal                  ACS_NEQUAL     !          |
       plus/minus                 ACS_PLMINUS    #          g
       scan line 1                ACS_S1         ~          o
       scan line 3                ACS_S3         -          p
       scan line 7                ACS_S7         -          r
       scan line 9                ACS_S9         _          s
       solid square block         ACS_BLOCK      #          0
       tee pointing down          ACS_TTEE       +          w
       tee pointing left          ACS_RTEE       +          u
       tee pointing right         ACS_LTEE       +          t
       tee pointing up            ACS_BTEE       +          v
       upper left corner          ACS_ULCORNER   +          l
       upper right corner         ACS_URCORNER   +          k
       vertical line              ACS_VLINE      |          x

       The best way to define a new device's graphics set  is  to
       add  a  column  to a copy of this table for your terminal,
       giving  the  character   which   (when   emitted   between
       <STRONG>smacs</STRONG>/<STRONG>rmacs</STRONG>  switches) will be rendered as the correspond-
       ing graphic.  Then read off the VT100/your terminal  char-
       acter  pairs  right  to left in sequence; these become the
       ACSC string.


   <STRONG>Color</STRONG> <STRONG>Handling</STRONG>
       Most color terminals are either `Tektronix-like'  or  `HP-
       like'.   Tektronix-like terminals have a predefined set of
       N colors (where N usually 8), and can  set  character-cell
       foreground and background characters independently, mixing
       them into N * N color-pairs.  On  HP-like  terminals,  the
       use must set each color pair up separately (foreground and
       background are  not  independently  settable).   Up  to  M
       color-pairs  may  be  set  up  from  2*M different colors.
       ANSI-compatible terminals are Tektronix-like.

       Some basic color capabilities are independent of the color
       method.  The numeric capabilities <STRONG>colors</STRONG> and <STRONG>pairs</STRONG> specify
       the maximum numbers of colors and color-pairs that can  be
       displayed  simultaneously.   The <STRONG>op</STRONG> (original pair) string
       resets foreground and background colors to  their  default
       values  for the terminal.  The <STRONG>oc</STRONG> string resets all colors
       or color-pairs to their default values for  the  terminal.
       Some  terminals  (including  many  PC  terminal emulators)
       erase screen  areas  with  the  current  background  color
       rather  than the power-up default background; these should
       have the boolean capability <STRONG>bce</STRONG>.

       To change the current foreground or background color on  a
       Tektronix-type  terminal,  use <STRONG>setaf</STRONG> (set ANSI foreground)
       and <STRONG>setab</STRONG> (set ANSI background) or <STRONG>setf</STRONG>  (set  foreground)
       and  <STRONG>setb</STRONG> (set background).  These take one parameter, the
       color  number.   The  SVr4  documentation  describes  only
       <STRONG>setaf</STRONG>/<STRONG>setab</STRONG>;  the  XPG4  draft  says that "If the terminal
       supports ANSI escape sequences to set background and fore-
       ground,  they  should be coded as <STRONG>setaf</STRONG> and <STRONG>setab</STRONG>, respec-
       tively.  If the terminal supports other  escape  sequences
       to  set background and foreground, they should be coded as
       <STRONG>setf</STRONG> and <STRONG>setb</STRONG>, respectively.  The <EM>vidputs()</EM>  function  and
       the  refresh  functions  use  <STRONG>setaf</STRONG>  and <STRONG>setab</STRONG> if they are
       defined."

       The <STRONG>setaf</STRONG>/<STRONG>setab</STRONG> and <STRONG>setf</STRONG>/<STRONG>setb</STRONG> capabilities take  a  single
       numeric argument each.  Argument values 0-7 of <STRONG>setaf</STRONG>/<STRONG>setab</STRONG>
       are portably defined as follows (the middle column is  the
       symbolic #define available in the header for the <STRONG>curses</STRONG> or
       <STRONG>ncurses</STRONG> libraries).  The terminal hardware is free to  map
       these  as  it  likes,  but  the RGB values indicate normal
       locations in color space.


             <STRONG>Color</STRONG>       <STRONG>#define</STRONG>       <STRONG>Value</STRONG>       <STRONG>RGB</STRONG>
             black     <STRONG>COLOR_BLACK</STRONG>       0     0, 0, 0
             red       <STRONG>COLOR_RED</STRONG>         1     max,0,0
             green     <STRONG>COLOR_GREEN</STRONG>       2     0,max,0
             yellow    <STRONG>COLOR_YELLOW</STRONG>      3     max,max,0
             blue      <STRONG>COLOR_BLUE</STRONG>        4     0,0,max
             magenta   <STRONG>COLOR_MAGENTA</STRONG>     5     max,0,max
             cyan      <STRONG>COLOR_CYAN</STRONG>        6     0,max,max
             white     <STRONG>COLOR_WHITE</STRONG>       7     max,max,max

       The argument values of <STRONG>setf</STRONG>/<STRONG>setb</STRONG>  historically  correspond
       to a different mapping, i.e.,

             <STRONG>Color</STRONG>       <STRONG>#define</STRONG>       <STRONG>Value</STRONG>       <STRONG>RGB</STRONG>
             black     <STRONG>COLOR_BLACK</STRONG>       0     0, 0, 0
             blue      <STRONG>COLOR_BLUE</STRONG>        1     0,0,max
             green     <STRONG>COLOR_GREEN</STRONG>       2     0,max,0
             cyan      <STRONG>COLOR_CYAN</STRONG>        3     0,max,max
             red       <STRONG>COLOR_RED</STRONG>         4     max,0,0
             magenta   <STRONG>COLOR_MAGENTA</STRONG>     5     max,0,max
             yellow    <STRONG>COLOR_YELLOW</STRONG>      6     max,max,0
             white     <STRONG>COLOR_WHITE</STRONG>       7     max,max,max
       It is important to not confuse the two sets of color capa-
       bilities; otherwise red/blue will be interchanged  on  the
       display.

       On  an  HP-like terminal, use <STRONG>scp</STRONG> with a color-pair number
       parameter to set which color pair is current.

       On a Tektronix-like terminal, the capability  <STRONG>ccc</STRONG>  may  be
       present  to  indicate that colors can be modified.  If so,
       the <STRONG>initc</STRONG> capability will take a color number (0 to <STRONG>colors</STRONG>
       -  1)and  three  more parameters which describe the color.
       These three parameters default to being interpreted as RGB
       (Red,  Green, Blue) values.  If the boolean capability <STRONG>hls</STRONG>
       is present, they are instead as HLS (Hue, Lightness, Satu-
       ration) indices.  The ranges are terminal-dependent.

       On  an  HP-like  terminal, <STRONG>initp</STRONG> may give a capability for
       changing a color-pair value.  It will take  seven  parame-
       ters;  a  color-pair  number (0 to <STRONG>max_pairs</STRONG> - 1), and two
       triples describing first background  and  then  foreground
       colors.   These  parameters  must be (Red, Green, Blue) or
       (Hue, Lightness, Saturation) depending on <STRONG>hls</STRONG>.

       On some color terminals, colors collide  with  highlights.
       You can register these collisions with the <STRONG>ncv</STRONG> capability.
       This is a bit-mask of attributes not to be used when  col-
       ors  are  enabled.  The correspondence with the attributes
       understood by <STRONG>curses</STRONG> is as follows:


                      <STRONG>Attribute</STRONG>      <STRONG>Bit</STRONG>   <STRONG>Decimal</STRONG>
                      A_STANDOUT     0     1
                      A_UNDERLINE    1     2
                      A_REVERSE      2     4
                      A_BLINK        3     8
                      A_DIM          4     16
                      A_BOLD         5     32
                      A_INVIS        6     64
                      A_PROTECT      7     128
                      A_ALTCHARSET   8     256

       For example,  on  many  IBM  PC  consoles,  the  underline
       attribute  collides  with the foreground color blue and is
       not available in color mode.  These  should  have  an  <STRONG>ncv</STRONG>
       capability of 2.

       SVr4  curses  does nothing with <STRONG>ncv</STRONG>, ncurses recognizes it
       and optimizes the output in favor of colors.


   <STRONG>Miscellaneous</STRONG>
       If the terminal requires other than a null (zero)  charac-
       ter  as  a  pad,  then this can be given as pad.  Only the
       first character of the pad string is used.  If the  termi-
       nal does not have a pad character, specify npc.  Note that
       ncurses implements  the  termcap-compatible  <STRONG>PC</STRONG>  variable;
       though  the  application  may  set this value to something
       other than a null, ncurses will test  <STRONG>npc</STRONG>  first  and  use
       napms if the terminal has no pad character.

       If  the terminal can move up or down half a line, this can
       be indicated with <STRONG>hu</STRONG>  (half-line  up)  and  <STRONG>hd</STRONG>  (half-line
       down).  This is primarily useful for superscripts and sub-
       scripts on hard-copy terminals.  If a  hard-copy  terminal
       can  eject  to  the next page (form feed), give this as <STRONG>ff</STRONG>
       (usually control L).

       If there is a command to repeat a given character a  given
       number  of times (to save time transmitting a large number
       of identical characters) this can be  indicated  with  the
       parameterized  string  <STRONG>rep</STRONG>.   The  first  parameter is the
       character to be repeated and the second is the  number  of
       times  to repeat it.  Thus, tparm(repeat_char, 'x', 10) is
       the same as `xxxxxxxxxx'.

       If the terminal has a settable command character, such  as
       the  TEKTRONIX  4025, this can be indicated with <STRONG>cmdch</STRONG>.  A
       prototype command character is chosen which is used in all
       capabilities.   This character is given in the <STRONG>cmdch</STRONG> capa-
       bility to identify it.  The following convention  is  sup-
       ported  on  some  UNIX  systems:  The environment is to be
       searched for a <STRONG>CC</STRONG> variable, and if found, all  occurrences
       of the prototype character are replaced with the character
       in the environment variable.

       Terminal descriptions that do  not  represent  a  specific
       kind of known terminal, such as <EM>switch</EM>, <EM>dialup</EM>, <EM>patch</EM>, and
       <EM>network</EM>, should include the  <STRONG>gn</STRONG>  (generic)  capability  so
       that  programs  can  complain that they do not know how to
       talk to the terminal.  (This capability does not apply  to
       <EM>virtual</EM>   terminal   descriptions  for  which  the  escape
       sequences are known.)

       If the terminal has a ``meta key'' which acts as  a  shift
       key,  setting  the  8th  bit of any character transmitted,
       this fact can be indicated with <STRONG>km</STRONG>.   Otherwise,  software
       will assume that the 8th bit is parity and it will usually
       be cleared.  If strings exist to turn this  ``meta  mode''
       on and off, they can be given as <STRONG>smm</STRONG> and <STRONG>rmm</STRONG>.

       If  the terminal has more lines of memory than will fit on
       the screen at once, the number of lines of memory  can  be
       indicated  with  <STRONG>lm</STRONG>.   A  value of <STRONG>lm</STRONG>#0 indicates that the
       number of lines is not fixed, but that there is still more
       memory than fits on the screen.

       If the terminal is one of those supported by the UNIX vir-
       tual terminal protocol, the terminal number can  be  given
       as <STRONG>vt</STRONG>.

       Media copy strings which control an auxiliary printer con-
       nected to the terminal can be given as <STRONG>mc0</STRONG>: print the con-
       tents  of  the screen, <STRONG>mc4</STRONG>: turn off the printer, and <STRONG>mc5</STRONG>:
       turn on the printer.  When the printer  is  on,  all  text
       sent  to  the terminal will be sent to the printer.  It is
       undefined whether the text is also displayed on the termi-
       nal screen when the printer is on.  A variation <STRONG>mc5p</STRONG> takes
       one parameter, and leaves the printer on for as many char-
       acters  as  the  value  of  the  parameter, then turns the
       printer off.  The parameter should not  exceed  255.   All
       text,  including  <STRONG>mc4</STRONG>,  is  transparently  passed  to  the
       printer while an <STRONG>mc5p</STRONG> is in effect.


   <STRONG>Glitches</STRONG> <STRONG>and</STRONG> <STRONG>Braindamage</STRONG>
       Hazeltine terminals, which do not allow `~' characters  to
       be displayed should indicate <STRONG>hz</STRONG>.

       Terminals which ignore a line-feed immediately after an <STRONG>am</STRONG>
       wrap, such as the Concept and vt100, should indicate <STRONG>xenl</STRONG>.

       If  <STRONG>el</STRONG>  is  required  to  get  rid of standout (instead of
       merely writing normal text on top of it),  <STRONG>xhp</STRONG>  should  be
       given.

       Teleray  terminals,  where  tabs turn all characters moved
       over to blanks, should  indicate  <STRONG>xt</STRONG>  (destructive  tabs).
       Note:    the    variable    indicating    this    is   now
       `dest_tabs_magic_smso'; in older  versions,  it  was  tel-
       eray_glitch.  This glitch is also taken to mean that it is
       not possible to position the cursor on top  of  a  ``magic
       cookie'', that to erase standout mode it is instead neces-
       sary to use delete and insert line.  The ncurses implemen-
       tation ignores this glitch.

       The  Beehive Superbee, which is unable to correctly trans-
       mit the escape or control C characters, has <STRONG>xsb</STRONG>,  indicat-
       ing  that the f1 key is used for escape and f2 for control
       C.  (Only certain Superbees have this  problem,  depending
       on  the  ROM.)  Note that in older terminfo versions, this
       capability  was  called  `beehive_glitch';   it   is   now
       `no_esc_ctl_c'.

       Other  specific  terminal  problems  may  be  corrected by
       adding more capabilities of the form <STRONG>x</STRONG><EM>x</EM>.


   <STRONG>Similar</STRONG> <STRONG>Terminals</STRONG>
       If there are two very similar terminals, one (the variant)
       can  be  defined  as  being just like the other (the base)
       with certain exceptions.  In the definition of  the  vari-
       ant,  the string capability <STRONG>use</STRONG> can be given with the name
       of the base terminal.  The capabilities given  before  <STRONG>use</STRONG>
       override  those  in  the base type named by <STRONG>use</STRONG>.  If there
       are multiple <STRONG>use</STRONG> capabilities, they are merged in  reverse
       order.   That is, the rightmost <STRONG>use</STRONG> reference is processed
       first, then the one to its left, and so forth.   Capabili-
       ties  given explicitly in the entry override those brought
       in by <STRONG>use</STRONG> references.

       A capability can be canceled by placing <STRONG>xx@</STRONG> to the left of
       the  use  reference that imports it, where <EM>xx</EM> is the capa-
       bility.  For example, the entry

                   2621-nl, smkx@, rmkx@, use=2621,

       defines a 2621-nl that does not  have  the  <STRONG>smkx</STRONG>  or  <STRONG>rmkx</STRONG>
       capabilities,  and hence does not turn on the function key
       labels when in visual mode.  This is useful for  different
       modes for a terminal, or for different user preferences.


   <STRONG>Pitfalls</STRONG> <STRONG>of</STRONG> <STRONG>Long</STRONG> <STRONG>Entries</STRONG>
       Long  terminfo  entries  are  unlikely to be a problem; to
       date, no entry has even  approached  terminfo's  4096-byte
       string-table maximum.  Unfortunately, the termcap transla-
       tions are much more strictly limited (to 1023 bytes), thus
       termcap  translations  of  long terminfo entries can cause
       problems.

       The man pages for 4.3BSD and older versions  of  <STRONG>tgetent()</STRONG>
       instruct  the  user to allocate a 1024-byte buffer for the
       termcap entry.  The  entry  gets  null-terminated  by  the
       termcap library, so that makes the maximum safe length for
       a termcap entry 1k-1 (1023) bytes.  Depending on what  the
       application  and  the termcap library being used does, and
       where in the termcap file the terminal type that <STRONG>tgetent()</STRONG>
       is searching for is, several bad things can happen.

       Some  termcap libraries print a warning message or exit if
       they find an entry that's longer than 1023  bytes;  others
       do  not;  others truncate the entries to 1023 bytes.  Some
       application programs allocate more than the recommended 1K
       for the termcap entry; others do not.

       Each termcap entry has two important sizes associated with
       it: before "tc" expansion, and after "tc" expansion.  "tc"
       is  the  capability that tacks on another termcap entry to
       the end of the current one, to add  on  its  capabilities.
       If  a termcap entry does not use the "tc" capability, then
       of course the two lengths are the same.

       The "before tc expansion" length  is  the  most  important
       one,  because it affects more than just users of that par-
       ticular terminal.  This is the length of the entry  as  it
       exists in /etc/termcap, minus the backslash-newline pairs,
       which <STRONG>tgetent()</STRONG> strips out while reading it.  Some termcap
       libraries  strip  off  the final newline, too (GNU termcap
       does not).  Now suppose:

       *    a termcap entry before expansion is  more  than  1023
            bytes long,

       *    and the application has only allocated a 1k buffer,

       *    and  the  termcap library (like the one in BSD/OS 1.1
            and GNU) reads the whole entry into  the  buffer,  no
            matter  what its length, to see if it is the entry it
            wants,

       *    and <STRONG>tgetent()</STRONG> is searching for a terminal  type  that
            either is the long entry, appears in the termcap file
            after the long entry, or does not appear in the  file
            at  all  (so  that  <STRONG>tgetent()</STRONG> has to search the whole
            termcap file).

       Then <STRONG>tgetent()</STRONG> will overwrite memory, perhaps  its  stack,
       and  probably core dump the program.  Programs like telnet
       are particularly vulnerable;  modern  telnets  pass  along
       values  like the terminal type automatically.  The results
       are almost as undesirable with  a  termcap  library,  like
       SunOS  4.1.3  and Ultrix 4.4, that prints warning messages
       when it reads an overly long termcap entry.  If a  termcap
       library  truncates  long  entries,  like  OSF/1 3.0, it is
       immune to dying here but will return  incorrect  data  for
       the terminal.

       The "after tc expansion" length will have a similar effect
       to the above, but only for people who actually set TERM to
       that  terminal type, since <STRONG>tgetent()</STRONG> only does "tc" expan-
       sion once it is found the terminal  type  it  was  looking
       for, not while searching.

       In summary, a termcap entry that is longer than 1023 bytes
       can cause, on various combinations  of  termcap  libraries
       and  applications,  a  core  dump,  warnings, or incorrect
       operation.  If it is too long even before "tc"  expansion,
       it will have this effect even for users of some other ter-
       minal types and users whose TERM variable does not have  a
       termcap entry.

       When in -C (translate to termcap) mode, the <STRONG>ncurses</STRONG> imple-
       mentation of <STRONG><A HREF="tic.1m.html">tic(1m)</A></STRONG> issues warning messages when the pre-
       tc  length  of  a termcap translation is too long.  The -c
       (check) option also checks resolved (after  tc  expansion)
       lengths.

   <STRONG>Binary</STRONG> <STRONG>Compatibility</STRONG>
       It  is not wise to count on portability of binary terminfo
       entries between commercial UNIX versions.  The problem  is
       that  there  are  at least two versions of terminfo (under
       HP-UX and AIX) which diverged from System V terminfo after
       SVr1,  and have added extension capabilities to the string
       table that (in the binary format) collide  with  System  V
       and XSI Curses extensions.


</PRE>
<H2>EXTENSIONS</H2><PRE>
       Some  SVr4  <STRONG>curses</STRONG>  implementations,  and  all previous to
       SVr4, do not interpret the %A and %O operators in  parame-
       ter strings.

       SVr4/XPG4  do  not  specify whether <STRONG>msgr</STRONG> licenses movement
       while in an alternate-character-set mode (such modes  may,
       among  other  things,  map CR and NL to characters that do
       not trigger local motions).   The  <STRONG>ncurses</STRONG>  implementation
       ignores  <STRONG>msgr</STRONG>  in <STRONG>ALTCHARSET</STRONG> mode.  This raises the possi-
       bility that an XPG4  implementation  making  the  opposite
       interpretation  may need terminfo entries made for <STRONG>ncurses</STRONG>
       to have <STRONG>msgr</STRONG> turned off.

       The <STRONG>ncurses</STRONG> library handles insert-character  and  insert-
       character modes in a slightly non-standard way to get bet-
       ter update efficiency.  See  the  <STRONG>Insert/Delete</STRONG>  <STRONG>Character</STRONG>
       subsection above.

       The   parameter   substitutions  for  <STRONG>set_clock</STRONG>  and  <STRONG>dis-</STRONG>
       <STRONG>play_clock</STRONG> are not documented in SVr4 or  the  XSI  Curses
       standard.  They are deduced from the documentation for the
       AT&amp;T 505 terminal.

       Be careful assigning the <STRONG>kmous</STRONG>  capability.   The  <STRONG>ncurses</STRONG>
       wants  to  interpret it as <STRONG>KEY_MOUSE</STRONG>, for use by terminals
       and emulators like xterm that  can  return  mouse-tracking
       information in the keyboard-input stream.

       Different  commercial ports of terminfo and curses support
       different subsets of the XSI Curses standard and (in  some
       cases) different extension sets.  Here is a summary, accu-
       rate as of October 1995:

       <STRONG>SVR4,</STRONG> <STRONG>Solaris,</STRONG> <STRONG>ncurses</STRONG> -- These support all SVr4 capabili-
       ties.

       <STRONG>SGI</STRONG>  --  Supports  the  SVr4  set,  adds  one undocumented
       extended string capability (<STRONG>set_pglen</STRONG>).

       <STRONG>SVr1,</STRONG> <STRONG>Ultrix</STRONG> -- These support a restricted subset of  ter-
       minfo  capabilities.   The booleans end with <STRONG>xon_xoff</STRONG>; the
       numerics with  <STRONG>width_status_line</STRONG>;  and  the  strings  with
       <STRONG>prtr_non</STRONG>.

       <STRONG>HP/UX</STRONG>  --  Supports  the  SVr1  subset,  plus the SVr[234]
       numerics <STRONG>num_labels</STRONG>, <STRONG>label_height</STRONG>, <STRONG>label_width</STRONG>, plus func-
       tion  keys  11  through  63, plus <STRONG>plab_norm</STRONG>, <STRONG>label_on</STRONG>, and
       <STRONG>label_off</STRONG>, plus some incompatible extensions in the string
       table.

       <STRONG>AIX</STRONG>  --  Supports  the  SVr1 subset, plus function keys 11
       through 63, plus a number  of  incompatible  string  table
       extensions.

       <STRONG>OSF</STRONG>  -- Supports both the SVr4 set and the AIX extensions.


</PRE>
<H2>FILES</H2><PRE>
       /usr/share/terminfo/?/*  files     containing     terminal
                                descriptions


</PRE>
<H2>SEE ALSO</H2><PRE>
       <STRONG><A HREF="tic.1m.html">tic(1m)</A></STRONG>,   <STRONG><A HREF="infocmp.1m.html">infocmp(1m)</A></STRONG>,  <STRONG><A HREF="ncurses.3x.html">curses(3x)</A></STRONG>,  <STRONG><A HREF="printf.3.html">printf(3)</A></STRONG>,  <STRONG><A HREF="term.5.html">term(5)</A></STRONG>.
       <STRONG><A HREF="term_variables.3x.html">term_variables(3x)</A></STRONG>.


</PRE>
<H2>AUTHORS</H2><PRE>
       Zeyd M. Ben-Halim, Eric  S.  Raymond,  Thomas  E.  Dickey.
       Based on pcurses by Pavel Curtis.



                                                            <STRONG><A HREF="terminfo.5.html">terminfo(5)</A></STRONG>
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
