.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PROVIDER-KEM 7ossl"
.TH PROVIDER-KEM 7ossl "2023-09-19" "3.0.11" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
provider\-kem \- The kem library <\-> provider functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& #include <openssl/core_dispatch.h>
\& #include <openssl/core_names.h>
\&
\& /*
\&  * None of these are actual functions, but are displayed like this for
\&  * the function signatures for functions that are offered as function
\&  * pointers in OSSL_DISPATCH arrays.
\&  */
\&
\& /* Context management */
\& void *OSSL_FUNC_kem_newctx(void *provctx);
\& void OSSL_FUNC_kem_freectx(void *ctx);
\& void *OSSL_FUNC_kem_dupctx(void *ctx);
\&
\& /* Encapsulation */
\& int OSSL_FUNC_kem_encapsulate_init(void *ctx, void *provkey, const char *name,
\&                                    const OSSL_PARAM params[]);
\& int OSSL_FUNC_kem_encapsulate(void *ctx, unsigned char *out, size_t *outlen,
\&                               unsigned char *secret, size_t *secretlen);
\&
\& /* Decapsulation */
\& int OSSL_FUNC_kem_decapsulate_init(void *ctx, void *provkey, const char *name);
\& int OSSL_FUNC_kem_decapsulate(void *ctx, unsigned char *out, size_t *outlen,
\&                               const unsigned char *in, size_t inlen);
\&
\& /* KEM parameters */
\& int OSSL_FUNC_kem_get_ctx_params(void *ctx, OSSL_PARAM params[]);
\& const OSSL_PARAM *OSSL_FUNC_kem_gettable_ctx_params(void *ctx, void *provctx);
\& int OSSL_FUNC_kem_set_ctx_params(void *ctx, const OSSL_PARAM params[]);
\& const OSSL_PARAM *OSSL_FUNC_kem_settable_ctx_params(void *ctx, void *provctx);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This documentation is primarily aimed at provider authors. See \fBprovider\fR\|(7)
for further information.
.PP
The asymmetric kem (\s-1OSSL_OP_KEM\s0) operation enables providers to
implement asymmetric kem algorithms and make them available to applications
via the \s-1API\s0 functions \fBEVP_PKEY_encapsulate\fR\|(3),
\&\fBEVP_PKEY_decapsulate\fR\|(3) and other related functions.
.PP
All \*(L"functions\*(R" mentioned here are passed as function pointers between
\&\fIlibcrypto\fR and the provider in \s-1\fBOSSL_DISPATCH\s0\fR\|(3) arrays via
\&\s-1\fBOSSL_ALGORITHM\s0\fR\|(3) arrays that are returned by the provider's
\&\fBprovider_query_operation()\fR function
(see \*(L"Provider Functions\*(R" in \fBprovider\-base\fR\|(7)).
.PP
All these \*(L"functions\*(R" have a corresponding function type definition
named \fBOSSL_FUNC_{name}_fn\fR, and a helper function to retrieve the
function pointer from an \s-1\fBOSSL_DISPATCH\s0\fR\|(3) element named
\&\fBOSSL_FUNC_{name}\fR.
For example, the \*(L"function\*(R" \fBOSSL_FUNC_kem_newctx()\fR has these:
.PP
.Vb 3
\& typedef void *(OSSL_FUNC_kem_newctx_fn)(void *provctx);
\& static ossl_inline OSSL_FUNC_kem_newctx_fn
\&     OSSL_FUNC_kem_newctx(const OSSL_DISPATCH *opf);
.Ve
.PP
\&\s-1\fBOSSL_DISPATCH\s0\fR\|(3) arrays are indexed by numbers that are provided as
macros in \fBopenssl\-core_dispatch.h\fR\|(7), as follows:
.PP
.Vb 3
\& OSSL_FUNC_kem_newctx               OSSL_FUNC_KEM_NEWCTX
\& OSSL_FUNC_kem_freectx              OSSL_FUNC_KEM_FREECTX
\& OSSL_FUNC_kem_dupctx               OSSL_FUNC_KEM_DUPCTX
\&
\& OSSL_FUNC_kem_encapsulate_init     OSSL_FUNC_KEM_ENCAPSULATE_INIT
\& OSSL_FUNC_kem_encapsulate          OSSL_FUNC_KEM_ENCAPSULATE
\&
\& OSSL_FUNC_kem_decapsulate_init     OSSL_FUNC_KEM_DECAPSULATE_INIT
\& OSSL_FUNC_kem_decapsulate          OSSL_FUNC_KEM_DECAPSULATE
\&
\& OSSL_FUNC_kem_get_ctx_params       OSSL_FUNC_KEM_GET_CTX_PARAMS
\& OSSL_FUNC_kem_gettable_ctx_params  OSSL_FUNC_KEM_GETTABLE_CTX_PARAMS
\& OSSL_FUNC_kem_set_ctx_params       OSSL_FUNC_KEM_SET_CTX_PARAMS
\& OSSL_FUNC_kem_settable_ctx_params  OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS
.Ve
.PP
An asymmetric kem algorithm implementation may not implement all of these
functions.
In order to be a consistent set of functions a provider must implement
OSSL_FUNC_kem_newctx and OSSL_FUNC_kem_freectx.
It must also implement both of OSSL_FUNC_kem_encapsulate_init and
OSSL_FUNC_kem_encapsulate, or both of OSSL_FUNC_kem_decapsulate_init and
OSSL_FUNC_kem_decapsulate.
OSSL_FUNC_kem_get_ctx_params is optional but if it is present then so must
OSSL_FUNC_kem_gettable_ctx_params.
Similarly, OSSL_FUNC_kem_set_ctx_params is optional but if it is present then
so must OSSL_FUNC_kem_settable_ctx_params.
.PP
An asymmetric kem algorithm must also implement some mechanism for generating,
loading or importing keys via the key management (\s-1OSSL_OP_KEYMGMT\s0) operation.
See \fBprovider\-keymgmt\fR\|(7) for further details.
.SS "Context Management Functions"
.IX Subsection "Context Management Functions"
\&\fBOSSL_FUNC_kem_newctx()\fR should create and return a pointer to a provider side
structure for holding context information during an asymmetric kem operation.
A pointer to this context will be passed back in a number of the other
asymmetric kem operation function calls.
The parameter \fIprovctx\fR is the provider context generated during provider
initialisation (see \fBprovider\fR\|(7)).
.PP
\&\fBOSSL_FUNC_kem_freectx()\fR is passed a pointer to the provider side asymmetric
kem context in the \fIctx\fR parameter.
This function should free any resources associated with that context.
.PP
\&\fBOSSL_FUNC_kem_dupctx()\fR should duplicate the provider side asymmetric kem
context in the \fIctx\fR parameter and return the duplicate copy.
.SS "Asymmetric Key Encapsulation Functions"
.IX Subsection "Asymmetric Key Encapsulation Functions"
\&\fBOSSL_FUNC_kem_encapsulate_init()\fR initialises a context for an asymmetric
encapsulation given a provider side asymmetric kem context in the \fIctx\fR
parameter, a pointer to a provider key object in the \fIprovkey\fR parameter and
the \fIname\fR of the algorithm.
The \fIparams\fR, if not \s-1NULL,\s0 should be set on the context in a manner similar to
using \fBOSSL_FUNC_kem_set_ctx_params()\fR.
The key object should have been previously generated, loaded or imported into
the provider using the key management (\s-1OSSL_OP_KEYMGMT\s0) operation (see
\&\fBprovider\-keymgmt\fR\|(7)>.
.PP
\&\fBOSSL_FUNC_kem_encapsulate()\fR performs the actual encapsulation itself.
A previously initialised asymmetric kem context is passed in the \fIctx\fR
parameter.
Unless \fIout\fR is \s-1NULL,\s0 the data to be encapsulated is internally generated,
and returned into the buffer pointed to by the \fIsecret\fR parameter and the
encapsulated data should also be written to the location pointed to by the
\&\fIout\fR parameter. The length of the encapsulated data should be written to
\&\fI*outlen\fR and the length of the generated secret should be written to
\&\fI*secretlen\fR.
.PP
If \fIout\fR is \s-1NULL\s0 then the maximum length of the encapsulated data should be
written to \fI*outlen\fR, and the maximum length of the generated secret should be
written to \fI*secretlen\fR.
.SS "Decapsulation Functions"
.IX Subsection "Decapsulation Functions"
\&\fBOSSL_FUNC_kem_decapsulate_init()\fR initialises a context for an asymmetric
decapsulation given a provider side asymmetric kem context in the \fIctx\fR
parameter, a pointer to a provider key object in the \fIprovkey\fR parameter, and
a \fIname\fR of the algorithm.
The key object should have been previously generated, loaded or imported into
the provider using the key management (\s-1OSSL_OP_KEYMGMT\s0) operation (see
\&\fBprovider\-keymgmt\fR\|(7)>.
.PP
\&\fBOSSL_FUNC_kem_decapsulate()\fR performs the actual decapsulation itself.
A previously initialised asymmetric kem context is passed in the \fIctx\fR
parameter.
The data to be decapsulated is pointed to by the \fIin\fR parameter which is \fIinlen\fR
bytes long.
Unless \fIout\fR is \s-1NULL,\s0 the decapsulated data should be written to the location
pointed to by the \fIout\fR parameter.
The length of the decapsulated data should be written to \fI*outlen\fR.
If \fIout\fR is \s-1NULL\s0 then the maximum length of the decapsulated data should be
written to \fI*outlen\fR.
.SS "Asymmetric Key Encapsulation Parameters"
.IX Subsection "Asymmetric Key Encapsulation Parameters"
See \s-1\fBOSSL_PARAM\s0\fR\|(3) for further details on the parameters structure used by
the \fBOSSL_FUNC_kem_get_ctx_params()\fR and \fBOSSL_FUNC_kem_set_ctx_params()\fR
functions.
.PP
\&\fBOSSL_FUNC_kem_get_ctx_params()\fR gets asymmetric kem parameters associated
with the given provider side asymmetric kem context \fIctx\fR and stores them in
\&\fIparams\fR.
Passing \s-1NULL\s0 for \fIparams\fR should return true.
.PP
\&\fBOSSL_FUNC_kem_set_ctx_params()\fR sets the asymmetric kem parameters associated
with the given provider side asymmetric kem context \fIctx\fR to \fIparams\fR.
Any parameter settings are additional to any that were previously set.
Passing \s-1NULL\s0 for \fIparams\fR should return true.
.PP
No parameters are currently recognised by built-in asymmetric kem algorithms.
.PP
\&\fBOSSL_FUNC_kem_gettable_ctx_params()\fR and \fBOSSL_FUNC_kem_settable_ctx_params()\fR
get a constant \s-1\fBOSSL_PARAM\s0\fR\|(3) array that describes the gettable and settable
parameters, i.e. parameters that can be used with \fBOSSL_FUNC_kem_get_ctx_params()\fR
and \fBOSSL_FUNC_kem_set_ctx_params()\fR respectively.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBOSSL_FUNC_kem_newctx()\fR and \fBOSSL_FUNC_kem_dupctx()\fR should return the newly
created provider side asymmetric kem context, or \s-1NULL\s0 on failure.
.PP
All other functions should return 1 for success or 0 on error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBprovider\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
The provider \s-1KEM\s0 interface was introduced in OpenSSL 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2020\-2021 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
