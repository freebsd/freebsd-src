.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "OSSL_CRMF_MSG_GET0_TMPL 3ossl"
.TH OSSL_CRMF_MSG_GET0_TMPL 3ossl 2025-07-01 3.5.1 OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
OSSL_CRMF_MSG_get0_tmpl,
OSSL_CRMF_CERTTEMPLATE_get0_publicKey,
OSSL_CRMF_CERTTEMPLATE_get0_subject,
OSSL_CRMF_CERTTEMPLATE_get0_issuer,
OSSL_CRMF_CERTTEMPLATE_get0_serialNumber,
OSSL_CRMF_CERTTEMPLATE_get0_extensions,
OSSL_CRMF_CERTID_get0_serialNumber,
OSSL_CRMF_CERTID_get0_issuer,
OSSL_CRMF_ENCRYPTEDKEY_get1_encCert,
OSSL_CRMF_ENCRYPTEDKEY_get1_pkey,
OSSL_CRMF_ENCRYPTEDKEY_init_envdata,
OSSL_CRMF_ENCRYPTEDVALUE_decrypt,
OSSL_CRMF_ENCRYPTEDVALUE_get1_encCert,
OSSL_CRMF_MSG_get_certReqId,
OSSL_CRMF_MSG_centralkeygen_requested
\&\- functions reading from CRMF CertReqMsg structures
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/crmf.h>
\&
\& OSSL_CRMF_CERTTEMPLATE *OSSL_CRMF_MSG_get0_tmpl(const OSSL_CRMF_MSG *crm);
\& X509_PUBKEY
\& *OSSL_CRMF_CERTTEMPLATE_get0_publicKey(const OSSL_CRMF_CERTTEMPLATE *tmpl);
\& const X509_NAME
\& *OSSL_CRMF_CERTTEMPLATE_get0_subject(const OSSL_CRMF_CERTTEMPLATE *tmpl);
\& const X509_NAME
\& *OSSL_CRMF_CERTTEMPLATE_get0_issuer(const OSSL_CRMF_CERTTEMPLATE *tmpl);
\& const ASN1_INTEGER
\& *OSSL_CRMF_CERTTEMPLATE_get0_serialNumber(const OSSL_CRMF_CERTTEMPLATE *tmpl);
\& X509_EXTENSIONS
\& *OSSL_CRMF_CERTTEMPLATE_get0_extensions(const OSSL_CRMF_CERTTEMPLATE *tmpl);
\&
\& const ASN1_INTEGER
\& *OSSL_CRMF_CERTID_get0_serialNumber(const OSSL_CRMF_CERTID *cid);
\& const X509_NAME *OSSL_CRMF_CERTID_get0_issuer(const OSSL_CRMF_CERTID *cid);
\&
\& X509 *OSSL_CRMF_ENCRYPTEDKEY_get1_encCert(const OSSL_CRMF_ENCRYPTEDKEY *ecert,
\&                                           OSSL_LIB_CTX *libctx, const char *propq,
\&                                           EVP_PKEY *pkey, unsigned int flags);
\& EVP_PKEY
\& *OSSL_CRMF_ENCRYPTEDKEY_get1_pkey(OSSL_CRMF_ENCRYPTEDKEY *encryptedKey,
\&                                   X509_STORE *ts, STACK_OF(X509) *extra,
\&                                   EVP_PKEY *pkey, X509 *cert,
\&                                   ASN1_OCTET_STRING *secret,
\&                                   OSSL_LIB_CTX *libctx, const char *propq);
\& OSSL_CRMF_ENCRYPTEDKEY
\& *OSSL_CRMF_ENCRYPTEDKEY_init_envdata(CMS_EnvelopedData *envdata);
\&
\& unsigned char
\& *OSSL_CRMF_ENCRYPTEDVALUE_decrypt(const OSSL_CRMF_ENCRYPTEDVALUE *enc,
\&                                   OSSL_LIB_CTX *libctx, const char *propq,
\&                                   EVP_PKEY *pkey, int *outlen);
\& X509
\& *OSSL_CRMF_ENCRYPTEDVALUE_get1_encCert(const OSSL_CRMF_ENCRYPTEDVALUE *ecert,
\&                                        OSSL_LIB_CTX *libctx, const char *propq,
\&                                        EVP_PKEY *pkey);
\&
\& int OSSL_CRMF_MSG_get_certReqId(const OSSL_CRMF_MSG *crm);
\& int OSSL_CRMF_MSG_centralkeygen_requested(const OSSL_CRMF_MSG *crm,
\&                                           const X509_REQ *p10cr);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\fBOSSL_CRMF_MSG_get0_tmpl()\fR retrieves the certificate template of \fIcrm\fR.
.PP
\&\fBOSSL_CRMF_CERTTEMPLATE_get0_publicKey()\fR retrieves the public key of the
given certificate template \fItmpl\fR.
.PP
\&\fBOSSL_CRMF_CERTTEMPLATE_get0_subject()\fR retrieves the subject name of the
given certificate template \fItmpl\fR.
.PP
\&\fBOSSL_CRMF_CERTTEMPLATE_get0_issuer()\fR retrieves the issuer name of the
given certificate template \fItmpl\fR.
.PP
\&\fBOSSL_CRMF_CERTTEMPLATE_get0_serialNumber()\fR retrieves the serialNumber of the
given certificate template \fItmpl\fR.
.PP
\&\fBOSSL_CRMF_CERTTEMPLATE_get0_extensions()\fR retrieves the X.509 extensions
of the given certificate template \fItmpl\fR, or NULL if not present.
.PP
OSSL_CRMF_CERTID_get0_serialNumber retrieves the serialNumber
of the given CertId \fIcid\fR.
.PP
OSSL_CRMF_CERTID_get0_issuer retrieves the issuer name
of the given CertId \fIcid\fR, which must be of ASN.1 type GEN_DIRNAME.
.PP
\&\fBOSSL_CRMF_ENCRYPTEDKEY_get1_encCert()\fR decrypts the certificate in the given
encryptedKey \fIecert\fR, using the private key \fIpkey\fR, library context
\&\fIlibctx\fR and property query string \fIpropq\fR (see \fBOSSL_LIB_CTX\fR\|(3)).
This is needed for the indirect POPO method as in RFC 4210 section 5.2.8.2.
The function returns the decrypted certificate as a copy, leaving its ownership
with the caller, who is responsible for freeing it.
.PP
\&\fBOSSL_CRMF_ENCRYPTEDKEY_get1_pkey()\fR decrypts the private key in \fIencryptedKey\fR.
If \fIencryptedKey\fR is not of type \fBOSSL_CRMF_ENCRYPTEDKEY_ENVELOPEDDATA\fR,
decryption uses the private key \fIpkey\fR.
The library context \fIlibctx\fR and property query \fIpropq\fR are taken into account as usual.
The rest of this paragraph is relevant only if CMS support not disabled for the OpenSSL build
and \fIencryptedKey\fR is of type case \fBOSSL_CRMF_ENCRYPTEDKEY_ENVELOPEDDATA\fR.
Decryption uses the \fIsecret\fR parameter if not NULL;
otherwise uses the private key <pkey> and the certificate \fIcert\fR 
related to \fIpkey\fR, where \fIcert\fR is recommended to be given if available.
On success, the function verifies the decrypted data as signed data,
using the trust store \fIts\fR and any untrusted certificates in \fIextra\fR.
Doing so, it checks for the purpose "CMP Key Generation Authority" (cmKGA).
.PP
\&\fBOSSL_CRMF_ENCRYPTEDKEY_init_envdata()\fR returns \fIOSSL_CRMF_ENCRYPTEDKEY\fR, initialized with
the enveloped data \fIenvdata\fR.
.PP
\&\fBOSSL_CRMF_ENCRYPTEDVALUE_decrypt()\fR decrypts the encrypted value in the given
encryptedValue \fIenc\fR, using the private key \fIpkey\fR, library context
\&\fIlibctx\fR and property query string \fIpropq\fR (see \fBOSSL_LIB_CTX\fR\|(3)).
.PP
\&\fBOSSL_CRMF_ENCRYPTEDVALUE_get1_encCert()\fR decrypts the certificate in the given
encryptedValue \fIecert\fR, using the private key \fIpkey\fR, library context
\&\fIlibctx\fR and property query string \fIpropq\fR (see \fBOSSL_LIB_CTX\fR\|(3)).
This is needed for the indirect POPO method as in RFC 4210 section 5.2.8.2.
The function returns the decrypted certificate as a copy, leaving its ownership
with the caller, who is responsible for freeing it.
.PP
\&\fBOSSL_CRMF_MSG_get_certReqId()\fR retrieves the certReqId of \fIcrm\fR.
.PP
\&\fBOSSL_CRMF_MSG_centralkeygen_requested()\fR returns 1 if central key generation
is requested i.e., the public key in the certificate request (\fIcrm\fR is taken if it is non-NULL,
otherwise \fIp10cr\fR) is NULL or has an empty key value (with length zero).
In case \fIcrm\fR is non-NULL, this is checked for consistency with its \fBpopo\fR field
(must be NULL if and only if central key generation is requested).
Otherwise it returns 0, and on error a negative value.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBOSSL_CRMF_MSG_get_certReqId()\fR returns the certificate request ID as a
nonnegative integer or \-1 on error.
.PP
\&\fBOSSL_CRMF_MSG_centralkeygen_requested()\fR returns 1 if central key generation
is requested, 0 if it is not requested, and a negative value on error.
.PP
All other functions return a pointer with the intended result or NULL on error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
RFC 4211
.SH HISTORY
.IX Header "HISTORY"
The OpenSSL CRMF support was added in OpenSSL 3.0.
.PP
\&\fBOSSL_CRMF_CERTTEMPLATE_get0_publicKey()\fR was added in OpenSSL 3.2.
.PP
\&\fBOSSL_CRMF_ENCRYPTEDKEY_get1_encCert()\fR, \fBOSSL_CRMF_ENCRYPTEDKEY_get1_pkey()\fR,
\&\fBOSSL_CRMF_ENCRYPTEDKEY_init_envdata()\fR, \fBOSSL_CRMF_ENCRYPTEDVALUE_decrypt()\fR
and \fBOSSL_CRMF_MSG_centralkeygen_requested()\fR were added in OpenSSL 3.5.
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2007\-2025 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
<https://www.openssl.org/source/license.html>.
