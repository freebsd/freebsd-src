.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "UI_NEW 3ossl"
.TH UI_NEW 3ossl "2023-09-19" "3.0.11" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
UI,
UI_new, UI_new_method, UI_free, UI_add_input_string, UI_dup_input_string,
UI_add_verify_string, UI_dup_verify_string, UI_add_input_boolean,
UI_dup_input_boolean, UI_add_info_string, UI_dup_info_string,
UI_add_error_string, UI_dup_error_string, UI_construct_prompt,
UI_add_user_data, UI_dup_user_data, UI_get0_user_data, UI_get0_result,
UI_get_result_length,
UI_process, UI_ctrl, UI_set_default_method, UI_get_default_method,
UI_get_method, UI_set_method, UI_OpenSSL, UI_null \- user interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ui.h>
\&
\& typedef struct ui_st UI;
\&
\& UI *UI_new(void);
\& UI *UI_new_method(const UI_METHOD *method);
\& void UI_free(UI *ui);
\&
\& int UI_add_input_string(UI *ui, const char *prompt, int flags,
\&                         char *result_buf, int minsize, int maxsize);
\& int UI_dup_input_string(UI *ui, const char *prompt, int flags,
\&                         char *result_buf, int minsize, int maxsize);
\& int UI_add_verify_string(UI *ui, const char *prompt, int flags,
\&                          char *result_buf, int minsize, int maxsize,
\&                          const char *test_buf);
\& int UI_dup_verify_string(UI *ui, const char *prompt, int flags,
\&                          char *result_buf, int minsize, int maxsize,
\&                          const char *test_buf);
\& int UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,
\&                          const char *ok_chars, const char *cancel_chars,
\&                          int flags, char *result_buf);
\& int UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,
\&                          const char *ok_chars, const char *cancel_chars,
\&                          int flags, char *result_buf);
\& int UI_add_info_string(UI *ui, const char *text);
\& int UI_dup_info_string(UI *ui, const char *text);
\& int UI_add_error_string(UI *ui, const char *text);
\& int UI_dup_error_string(UI *ui, const char *text);
\&
\& char *UI_construct_prompt(UI *ui_method,
\&                           const char *phrase_desc, const char *object_name);
\&
\& void *UI_add_user_data(UI *ui, void *user_data);
\& int UI_dup_user_data(UI *ui, void *user_data);
\& void *UI_get0_user_data(UI *ui);
\&
\& const char *UI_get0_result(UI *ui, int i);
\& int UI_get_result_length(UI *ui, int i);
\&
\& int UI_process(UI *ui);
\&
\& int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)());
\&
\& void UI_set_default_method(const UI_METHOD *meth);
\& const UI_METHOD *UI_get_default_method(void);
\& const UI_METHOD *UI_get_method(UI *ui);
\& const UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth);
\&
\& UI_METHOD *UI_OpenSSL(void);
\& const UI_METHOD *UI_null(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1UI\s0 stands for User Interface, and is general purpose set of routines to
prompt the user for text-based information.  Through user-written methods
(see \fBUI_create_method\fR\|(3)), prompting can be done in any way
imaginable, be it plain text prompting, through dialog boxes or from a
cell phone.
.PP
All the functions work through a context of the type \s-1UI.\s0  This context
contains all the information needed to prompt correctly as well as a
reference to a \s-1UI_METHOD,\s0 which is an ordered vector of functions that
carry out the actual prompting.
.PP
The first thing to do is to create a \s-1UI\s0 with \fBUI_new()\fR or \fBUI_new_method()\fR,
then add information to it with the UI_add or UI_dup functions.  Also,
user-defined random data can be passed down to the underlying method
through calls to \fBUI_add_user_data()\fR or \fBUI_dup_user_data()\fR.  The default
\&\s-1UI\s0 method doesn't care about these data, but other methods might.  Finally,
use \fBUI_process()\fR to actually perform the prompting and \fBUI_get0_result()\fR
and \fBUI_get_result_length()\fR to find the result to the prompt and its length.
.PP
A \s-1UI\s0 can contain more than one prompt, which are performed in the given
sequence.  Each prompt gets an index number which is returned by the
UI_add and UI_dup functions, and has to be used to get the corresponding
result with \fBUI_get0_result()\fR and \fBUI_get_result_length()\fR.
.PP
\&\fBUI_process()\fR can be called more than once on the same \s-1UI,\s0 thereby allowing
a \s-1UI\s0 to have a long lifetime, but can just as well have a short lifetime.
.PP
The functions are as follows:
.PP
\&\fBUI_new()\fR creates a new \s-1UI\s0 using the default \s-1UI\s0 method.  When done with
this \s-1UI,\s0 it should be freed using \fBUI_free()\fR.
.PP
\&\fBUI_new_method()\fR creates a new \s-1UI\s0 using the given \s-1UI\s0 method.  When done with
this \s-1UI,\s0 it should be freed using \fBUI_free()\fR.
.PP
\&\fBUI_OpenSSL()\fR returns the built-in \s-1UI\s0 method (note: not necessarily the
default one, since the default can be changed.  See further on).  This
method is the most machine/OS dependent part of OpenSSL and normally
generates the most problems when porting.
.PP
\&\fBUI_null()\fR returns a \s-1UI\s0 method that does nothing.  Its use is to avoid
getting internal defaults for passed \s-1UI_METHOD\s0 pointers.
.PP
\&\fBUI_free()\fR removes a \s-1UI\s0 from memory, along with all other pieces of memory
that's connected to it, like duplicated input strings, results and others.
If \fBui\fR is \s-1NULL\s0 nothing is done.
.PP
\&\fBUI_add_input_string()\fR and \fBUI_add_verify_string()\fR add a prompt to the \s-1UI,\s0
as well as flags and a result buffer and the desired minimum and maximum
sizes of the result, not counting the final \s-1NUL\s0 character.  The given
information is used to prompt for information, for example a password,
and to verify a password (i.e. having the user enter it twice and check
that the same string was entered twice).  \fBUI_add_verify_string()\fR takes
and extra argument that should be a pointer to the result buffer of the
input string that it's supposed to verify, or verification will fail.
.PP
\&\fBUI_add_input_boolean()\fR adds a prompt to the \s-1UI\s0 that's supposed to be answered
in a boolean way, with a single character for yes and a different character
for no.  A set of characters that can be used to cancel the prompt is given
as well.  The prompt itself is divided in two, one part being the
descriptive text (given through the \fIprompt\fR argument) and one describing
the possible answers (given through the \fIaction_desc\fR argument).
.PP
\&\fBUI_add_info_string()\fR and \fBUI_add_error_string()\fR add strings that are shown at
the same time as the prompt for extra information or to show an error string.
The difference between the two is only conceptual.  With the built-in method,
there's no technical difference between them.  Other methods may make a
difference between them, however.
.PP
The flags currently supported are \fB\s-1UI_INPUT_FLAG_ECHO\s0\fR, which is relevant for
\&\fBUI_add_input_string()\fR and will have the users response be echoed (when
prompting for a password, this flag should obviously not be used, and
\&\fB\s-1UI_INPUT_FLAG_DEFAULT_PWD\s0\fR, which means that a default password of some
sort will be used (completely depending on the application and the \s-1UI\s0
method).
.PP
\&\fBUI_dup_input_string()\fR, \fBUI_dup_verify_string()\fR, \fBUI_dup_input_boolean()\fR,
\&\fBUI_dup_info_string()\fR and \fBUI_dup_error_string()\fR are basically the same
as their UI_add counterparts, except that they make their own copies
of all strings.
.PP
\&\fBUI_construct_prompt()\fR is a helper function that can be used to create
a prompt from two pieces of information: a phrase description \fIphrase_desc\fR
and an object name \fIobject_name\fR, where the latter may be \s-1NULL.\s0
The default constructor (if there is none provided by the method used)
creates a string "Enter \fIphrase_desc\fR for \fIobject_name\fR:\*(L"
where the \*(R" for \fIobject_name\fR" part is left out if \fIobject_name\fR is \s-1NULL.\s0
With the description \*(L"pass phrase\*(R" and the filename \*(L"foo.key\*(R", that becomes
\&\*(L"Enter pass phrase for foo.key:\*(R".  Other methods may create whatever
string and may include encodings that will be processed by the other
method functions.
.PP
\&\fBUI_add_user_data()\fR adds a user data pointer for the method to use at any
time.  The built-in \s-1UI\s0 method doesn't care about this info.  Note that several
calls to this function doesn't add data, it replaces the previous blob
with the one given as argument.
.PP
\&\fBUI_dup_user_data()\fR duplicates the user data and works as an alternative
to \fBUI_add_user_data()\fR when the user data needs to be preserved for a longer
duration, perhaps even the lifetime of the application.  The \s-1UI\s0 object takes
ownership of this duplicate and will free it whenever it gets replaced or
the \s-1UI\s0 is destroyed.  \fBUI_dup_user_data()\fR returns 0 on success, or \-1 on memory
allocation failure or if the method doesn't have a duplicator function.
.PP
\&\fBUI_get0_user_data()\fR retrieves the data that has last been given to the
\&\s-1UI\s0 with \fBUI_add_user_data()\fR or UI_dup_user_data.
.PP
\&\fBUI_get0_result()\fR returns a pointer to the result buffer associated with
the information indexed by \fIi\fR.
.PP
\&\fBUI_get_result_length()\fR returns the length of the result buffer associated with
the information indexed by \fIi\fR.
.PP
\&\fBUI_process()\fR goes through the information given so far, does all the printing
and prompting and returns the final status, which is \-2 on out-of-band events
(Interrupt, Cancel, ...), \-1 on error and 0 on success.
.PP
\&\fBUI_ctrl()\fR adds extra control for the application author.  For now, it
understands two commands: \fB\s-1UI_CTRL_PRINT_ERRORS\s0\fR, which makes \fBUI_process()\fR
print the OpenSSL error stack as part of processing the \s-1UI,\s0 and
\&\fB\s-1UI_CTRL_IS_REDOABLE\s0\fR, which returns a flag saying if the used \s-1UI\s0 can
be used again or not.
.PP
\&\fBUI_set_default_method()\fR changes the default \s-1UI\s0 method to the one given.
This function is not thread-safe and should not be called at the same time
as other OpenSSL functions.
.PP
\&\fBUI_get_default_method()\fR returns a pointer to the current default \s-1UI\s0 method.
.PP
\&\fBUI_get_method()\fR returns the \s-1UI\s0 method associated with a given \s-1UI.\s0
.PP
\&\fBUI_set_method()\fR changes the \s-1UI\s0 method associated with a given \s-1UI.\s0
.SH "NOTES"
.IX Header "NOTES"
The resulting strings that the built in method \fBUI_OpenSSL()\fR generate
are assumed to be encoded according to the current locale or (for
Windows) code page.
For applications having different demands, these strings need to be
converted appropriately by the caller.
For Windows, if the \fB\s-1OPENSSL_WIN32_UTF8\s0\fR environment variable is set,
the built-in method \fBUI_OpenSSL()\fR will produce \s-1UTF\-8\s0 encoded strings
instead.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBUI_new()\fR and \fBUI_new_method()\fR return a valid \fB\s-1UI\s0\fR structure or \s-1NULL\s0 if an error
occurred.
.PP
\&\fBUI_add_input_string()\fR, \fBUI_dup_input_string()\fR, \fBUI_add_verify_string()\fR,
\&\fBUI_dup_verify_string()\fR, \fBUI_add_input_boolean()\fR, \fBUI_dup_input_boolean()\fR,
\&\fBUI_add_info_string()\fR, \fBUI_dup_info_string()\fR, \fBUI_add_error_string()\fR
and \fBUI_dup_error_string()\fR return a positive number on success or a value which
is less than or equal to 0 otherwise.
.PP
\&\fBUI_construct_prompt()\fR returns a string or \s-1NULL\s0 if an error occurred.
.PP
\&\fBUI_dup_user_data()\fR returns 0 on success or \-1 on error.
.PP
\&\fBUI_get0_result()\fR returns a string or \s-1NULL\s0 on error.
.PP
\&\fBUI_get_result_length()\fR returns a positive integer or 0 on success; otherwise it
returns \-1 on error.
.PP
\&\fBUI_process()\fR returns 0 on success or a negative value on error.
.PP
\&\fBUI_ctrl()\fR returns a mask on success or \-1 on error.
.PP
\&\fBUI_get_default_method()\fR, \fBUI_get_method()\fR, \fBUI_OpenSSL()\fR, \fBUI_null()\fR and
\&\fBUI_set_method()\fR return either a valid \fB\s-1UI_METHOD\s0\fR structure or \s-1NULL\s0
respectively.
.SH "HISTORY"
.IX Header "HISTORY"
The \fBUI_dup_user_data()\fR function was added in OpenSSL 1.1.1.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001\-2020 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
