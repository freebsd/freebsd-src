.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "OPENSSL_LOAD_U16_LE 3ossl"
.TH OPENSSL_LOAD_U16_LE 3ossl 2025-07-01 3.5.1 OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
OPENSSL_load_u16_le, OPENSSL_load_u16_be, OPENSSL_load_u32_le,
OPENSSL_load_u32_be, OPENSSL_load_u64_le, OPENSSL_load_u64_be,
OPENSSL_store_u16_le, OPENSSL_store_u16_be,
OPENSSL_store_u32_le, OPENSSL_store_u32_be,
OPENSSL_store_u64_le, OPENSSL_store_u64_be \-
Read and write unsigned 16, 32 and 64\-bit integers in a specific byte order
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    #include <openssl/byteorder.h>
\&
\&    static ossl_inline unsigned char *OPENSSL_store_u16_le(
\&        unsigned char *out, uint16_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u16_be(
\&        unsigned char *out, uint16_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u32_le(
\&        unsigned char *out, uint32_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u32_be(
\&        unsigned char *out, uint32_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u64_le(
\&        unsigned char *out, uint64_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u64_be(
\&        unsigned char *out, uint64_t val);
\&    static ossl_inline const unsigned char *OPENSSL_load_u16_le(
\&        uint16_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u16_be(
\&        uint16_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u32_le(
\&        uint32_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u32_be(
\&        uint32_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u64_le(
\&        uint64_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u64_be(
\&        uint64_t *val, const unsigned char *in);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
These functions read and write 16, 32 and 64 bit unsigned integers in a
specified byte order.
The \f(CW\*(C`_be\*(C'\fR functions use big-endian byte order, while the \f(CW\*(C`_le\*(C'\fR functions use
little-endian byte order.
They're implemented directly in the header file, and declared static.  When the
compiler supports inline functions, they're also declared inline.
An optimising compiler will often convert these to just one or two machine
instructions: a load or store with a possible byte swap.
.PP
The \f(CW\*(C`load\*(C'\fR functions write the decoded integer value at the address pointed to
by \fIval\fR, which must be a valid (possibly suitably aligned) address of an
object of the appropriate type.
The \f(CW\*(C`store\*(C'\fR functions write the encoding of \fIval\fR at the address pointed to
by \fIout\fR.
.PP
For convenience, these functions return the updated input or output pointer,
making it easy to continue reading or writing more data at the next memory
location.
.PP
No bounds checks are performed, the caller is responsible for making sure that
the input or output buffers are sufficiently large for the requested read or
write.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
All these functions return the next memory address following the last byte
written or read.
.SH HISTORY
.IX Header "HISTORY"
These functions were added in OpenSSL 3.5.
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2025 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
<https://www.openssl.org/source/license.html>.
