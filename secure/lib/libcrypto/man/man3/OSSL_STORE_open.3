.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OSSL_STORE_OPEN 3ossl"
.TH OSSL_STORE_OPEN 3ossl "2023-09-19" "3.0.11" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OSSL_STORE_CTX, OSSL_STORE_post_process_info_fn,
OSSL_STORE_open, OSSL_STORE_open_ex,
OSSL_STORE_ctrl, OSSL_STORE_load, OSSL_STORE_eof,
OSSL_STORE_error, OSSL_STORE_close
\&\- Types and functions to read objects from a URI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/store.h>
\&
\& typedef struct ossl_store_ctx_st OSSL_STORE_CTX;
\&
\& typedef OSSL_STORE_INFO *(*OSSL_STORE_post_process_info_fn)(OSSL_STORE_INFO *,
\&                                                             void *);
\&
\& OSSL_STORE_CTX *OSSL_STORE_open(const char *uri, const UI_METHOD *ui_method,
\&                                 void *ui_data,
\&                                 OSSL_STORE_post_process_info_fn post_process,
\&                                 void *post_process_data);
\& OSSL_STORE_CTX *
\& OSSL_STORE_open_ex(const char *uri, OSSL_LIB_CTX *libctx, const char *propq,
\&                    const UI_METHOD *ui_method, void *ui_data,
\&                    const OSSL_PARAM params[],
\&                    OSSL_STORE_post_process_info_fn post_process,
\&                    void *post_process_data);
\&
\& OSSL_STORE_INFO *OSSL_STORE_load(OSSL_STORE_CTX *ctx);
\& int OSSL_STORE_eof(OSSL_STORE_CTX *ctx);
\& int OSSL_STORE_error(OSSL_STORE_CTX *ctx);
\& int OSSL_STORE_close(OSSL_STORE_CTX *ctx);
.Ve
.PP
The following function has been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining \fB\s-1OPENSSL_API_COMPAT\s0\fR with a suitable version value,
see \fBopenssl_user_macros\fR\|(7):
.PP
.Vb 1
\& int OSSL_STORE_ctrl(OSSL_STORE_CTX *ctx, int cmd, ... /* args */);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions help the application to fetch supported objects (see
\&\*(L"\s-1SUPPORTED OBJECTS\*(R"\s0 in \s-1\fBOSSL_STORE_INFO\s0\fR\|(3) for information on which those are)
from a given \s-1URI.\s0
The general method to do so is to \*(L"open\*(R" the \s-1URI\s0 using \fBOSSL_STORE_open()\fR,
read each available and supported object using \fBOSSL_STORE_load()\fR as long as
\&\fBOSSL_STORE_eof()\fR hasn't been reached, and finish it off with \fBOSSL_STORE_close()\fR.
.PP
The retrieved information is stored in a \fB\s-1OSSL_STORE_INFO\s0\fR, which is further
described in \s-1\fBOSSL_STORE_INFO\s0\fR\|(3).
.SS "Types"
.IX Subsection "Types"
\&\fB\s-1OSSL_STORE_CTX\s0\fR is a context variable that holds all the internal
information for \fBOSSL_STORE_open()\fR, \fBOSSL_STORE_open_ex()\fR,
\&\fBOSSL_STORE_load()\fR, \fBOSSL_STORE_eof()\fR and \fBOSSL_STORE_close()\fR to work
together.
.SS "Functions"
.IX Subsection "Functions"
\&\fBOSSL_STORE_open_ex()\fR takes a uri or path \fIuri\fR, password \s-1UI\s0 method
\&\fIui_method\fR with associated data \fIui_data\fR, and post processing
callback \fIpost_process\fR with associated data \fIpost_process_data\fR,
a library context \fIlibctx\fR with an associated property query \fIpropq\fR,
and opens a channel to the data located at the \s-1URI\s0 and returns a
\&\fB\s-1OSSL_STORE_CTX\s0\fR with all necessary internal information.
The given \fIui_method\fR and \fIui_data\fR will be reused by all
functions that use \fB\s-1OSSL_STORE_CTX\s0\fR when interaction is needed,
for instance to provide a password.
The auxiliary \s-1\fBOSSL_PARAM\s0\fR\|(3) parameters in \fIparams\fR can be set to further
modify the store operation.
The given \fIpost_process\fR and \fIpost_process_data\fR will be reused by
\&\fBOSSL_STORE_load()\fR to manipulate or drop the value to be returned.
The \fIpost_process\fR function drops values by returning \s-1NULL,\s0 which
will cause \fBOSSL_STORE_load()\fR to start its process over with loading
the next object, until \fIpost_process\fR returns something other than
\&\s-1NULL,\s0 or the end of data is reached as indicated by \fBOSSL_STORE_eof()\fR.
.PP
\&\fBOSSL_STORE_open()\fR is similar to \fBOSSL_STORE_open_ex()\fR but uses \s-1NULL\s0 for
the \fIparams\fR, the library context \fIlibctx\fR and property query \fIpropq\fR.
.PP
\&\fBOSSL_STORE_ctrl()\fR takes a \fB\s-1OSSL_STORE_CTX\s0\fR, and command number \fIcmd\fR and
more arguments not specified here.
The available loader specific command numbers and arguments they each
take depends on the loader that's used and is documented together with
that loader.
.PP
There are also global controls available:
.IP "\fB\s-1OSSL_STORE_C_USE_SECMEM\s0\fR" 4
.IX Item "OSSL_STORE_C_USE_SECMEM"
Controls if the loader should attempt to use secure memory for any
allocated \fB\s-1OSSL_STORE_INFO\s0\fR and its contents.
This control expects one argument, a pointer to an \fIint\fR that is expected to
have the value 1 (yes) or 0 (no).
Any other value is an error.
.PP
\&\fBOSSL_STORE_load()\fR takes a \fB\s-1OSSL_STORE_CTX\s0\fR and tries to load the next
available object and return it wrapped with \fB\s-1OSSL_STORE_INFO\s0\fR.
.PP
\&\fBOSSL_STORE_eof()\fR takes a \fB\s-1OSSL_STORE_CTX\s0\fR and checks if we've reached the end
of data.
.PP
\&\fBOSSL_STORE_error()\fR takes a \fB\s-1OSSL_STORE_CTX\s0\fR and checks if an error occurred in
the last \fBOSSL_STORE_load()\fR call.
Note that it may still be meaningful to try and load more objects, unless
\&\fBOSSL_STORE_eof()\fR shows that the end of data has been reached.
.PP
\&\fBOSSL_STORE_close()\fR takes a \fB\s-1OSSL_STORE_CTX\s0\fR, closes the channel that was opened
by \fBOSSL_STORE_open()\fR and frees all other information that was stored in the
\&\fB\s-1OSSL_STORE_CTX\s0\fR, as well as the \fB\s-1OSSL_STORE_CTX\s0\fR itself.
If \fIctx\fR is \s-1NULL\s0 it does nothing.
.SH "NOTES"
.IX Header "NOTES"
A string without a scheme prefix (that is, a non-URI string) is
implicitly interpreted as using the \fIfile:\fR scheme.
.PP
There are some tools that can be used together with
\&\fBOSSL_STORE_open()\fR to determine if any failure is caused by an unparsable
\&\s-1URI,\s0 or if it's a different error (such as memory allocation
failures); if the \s-1URI\s0 was parsable but the scheme unregistered, the
top error will have the reason \f(CW\*(C`OSSL_STORE_R_UNREGISTERED_SCHEME\*(C'\fR.
.PP
These functions make no direct assumption regarding the pass phrase received
from the password callback.
The loaders may make assumptions, however.
For example, the \fBfile:\fR scheme loader inherits the assumptions made by
OpenSSL functionality that handles the different file types; this is mostly
relevant for PKCS#12 objects.
See \fBpassphrase\-encoding\fR\|(7) for further information.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBOSSL_STORE_open()\fR returns a pointer to a \fB\s-1OSSL_STORE_CTX\s0\fR on success, or
\&\s-1NULL\s0 on failure.
.PP
\&\fBOSSL_STORE_load()\fR returns a pointer to a \fB\s-1OSSL_STORE_INFO\s0\fR on success, or \s-1NULL\s0
on error or when end of data is reached.
Use \fBOSSL_STORE_error()\fR and \fBOSSL_STORE_eof()\fR to determine the meaning of a
returned \s-1NULL.\s0
.PP
\&\fBOSSL_STORE_eof()\fR returns 1 if the end of data has been reached
or an error occurred, 0 otherwise.
.PP
\&\fBOSSL_STORE_error()\fR returns 1 if an error occurred in an \fBOSSL_STORE_load()\fR call,
otherwise 0.
.PP
\&\fBOSSL_STORE_ctrl()\fR and \fBOSSL_STORE_close()\fR returns 1 on success, or 0 on failure.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBossl_store\fR\|(7), \s-1\fBOSSL_STORE_INFO\s0\fR\|(3), \fBOSSL_STORE_register_loader\fR\|(3),
\&\fBpassphrase\-encoding\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fBOSSL_STORE_open_ex()\fR was added in OpenSSL 3.0.
.PP
\&\fB\s-1OSSL_STORE_CTX\s0\fR, \fBOSSL_STORE_post_process_info_fn()\fR, \fBOSSL_STORE_open()\fR,
\&\fBOSSL_STORE_ctrl()\fR, \fBOSSL_STORE_load()\fR, \fBOSSL_STORE_eof()\fR and \fBOSSL_STORE_close()\fR
were added in OpenSSL 1.1.1.
.PP
Handling of \s-1NULL\s0 \fIctx\fR argument for \fBOSSL_STORE_close()\fR
was introduced in OpenSSL 1.1.1h.
.PP
\&\fBOSSL_STORE_open_ex()\fR was added in OpenSSL 3.0.
.PP
\&\fBOSSL_STORE_ctrl()\fR and \fBOSSL_STORE_vctrl()\fR were deprecated in OpenSSL 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2016\-2021 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
