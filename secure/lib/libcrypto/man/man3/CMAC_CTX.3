.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CMAC_CTX 3ossl"
.TH CMAC_CTX 3ossl 2025-09-30 3.5.4 OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
CMAC_CTX, CMAC_CTX_new, CMAC_CTX_cleanup, CMAC_CTX_free,
CMAC_CTX_get0_cipher_ctx, CMAC_CTX_copy, CMAC_Init, CMAC_Update, CMAC_Final,
CMAC_resume
\&\- create cipher\-based message authentication codes
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/cmac.h>
.Ve
.PP
The following functions have been deprecated since OpenSSL 3.0, and can be
disabled entirely by defining \fBOPENSSL_API_COMPAT\fR with a suitable version
value, see \fBopenssl_user_macros\fR\|(7).
.PP
.Vb 1
\& typedef struct CMAC_CTX_st CMAC_CTX;
\&
\& CMAC_CTX *CMAC_CTX_new(void);
\& void CMAC_CTX_cleanup(CMAC_CTX *ctx);
\& void CMAC_CTX_free(CMAC_CTX *ctx);
\& EVP_CIPHER_CTX *CMAC_CTX_get0_cipher_ctx(CMAC_CTX *ctx);
\& int CMAC_CTX_copy(CMAC_CTX *out, const CMAC_CTX *in);
\& int CMAC_Init(CMAC_CTX *ctx, const void *key, size_t keylen,
\&               const EVP_CIPHER *cipher, ENGINE *impl);
\& int CMAC_Update(CMAC_CTX *ctx, const void *data, size_t dlen);
\& int CMAC_Final(CMAC_CTX *ctx, unsigned char *out, size_t *poutlen);
\& int CMAC_resume(CMAC_CTX *ctx);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
The low-level MAC functions documented on this page are deprecated.
Applications should use the new \fBEVP_MAC\fR\|(3) interface.
Specifically, utilize the following functions for MAC operations:
.IP "\fBEVP_MAC_CTX_new\fR\|(3) to create a new MAC context." 4
.IX Item "EVP_MAC_CTX_new to create a new MAC context."
.PD 0
.IP "\fBEVP_MAC_CTX_free\fR\|(3) to free the MAC context." 4
.IX Item "EVP_MAC_CTX_free to free the MAC context."
.IP "\fBEVP_MAC_init\fR\|(3) to initialize the MAC context." 4
.IX Item "EVP_MAC_init to initialize the MAC context."
.IP "\fBEVP_MAC_update\fR\|(3) to update the MAC with data." 4
.IX Item "EVP_MAC_update to update the MAC with data."
.IP "\fBEVP_MAC_final\fR\|(3) to finalize the MAC and retrieve the output." 4
.IX Item "EVP_MAC_final to finalize the MAC and retrieve the output."
.PD
.PP
Alternatively, for a single-step MAC computation, use the \fBEVP_Q_mac\fR\|(3)
function.
.PP
The \fBCMAC_CTX\fR type is a structure used for the provision of CMAC
(Cipher-based Message Authentication Code) operations.
.PP
\&\fBCMAC_CTX_new()\fR creates a new \fBCMAC_CTX\fR structure and returns a pointer to it.
.PP
\&\fBCMAC_CTX_cleanup()\fR resets the \fBCMAC_CTX\fR structure, clearing any internal data
but not freeing the structure itself.
.PP
\&\fBCMAC_CTX_free()\fR frees the \fBCMAC_CTX\fR structure and any associated resources.
If the argument is NULL, no action is taken.
.PP
\&\fBCMAC_CTX_get0_cipher_ctx()\fR returns a pointer to the internal \fBEVP_CIPHER_CTX\fR
structure within the \fBCMAC_CTX\fR.
.PP
\&\fBCMAC_CTX_copy()\fR copies the state from one \fBCMAC_CTX\fR structure to another.
.PP
\&\fBCMAC_Init()\fR initializes the \fBCMAC_CTX\fR structure for a new CMAC calculation
with the specified key, key length, and cipher type.
Optionally, an \fBENGINE\fR can be provided.
.PP
\&\fBCMAC_Update()\fR processes data to be included in the CMAC calculation.
This function can be called multiple times to update the context with
additional data.
.PP
\&\fBCMAC_Final()\fR finalizes the CMAC calculation and retrieves the resulting
MAC value. The output is stored in the provided buffer, and the length is
stored in the variable pointed to by \fIpoutlen\fR. To determine the required
buffer size, call with \fIout\fR set to NULL, which stores only the length in
\&\fIpoutlen\fR. Allocate a buffer of this size and call \fBCMAC_Final()\fR again with
the allocated buffer to retrieve the MAC.
.PP
\&\fBCMAC_resume()\fR resumes a previously finalized CMAC calculation, allowing
additional data to be processed and a new MAC to be generated.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBCMAC_CTX_new()\fR returns a pointer to a new \fBCMAC_CTX\fR structure or NULL if
an error occurs.
.PP
\&\fBCMAC_CTX_get0_cipher_ctx()\fR returns a pointer to the internal
\&\fBEVP_CIPHER_CTX\fR structure, or NULL if an error occurs.
.PP
\&\fBCMAC_CTX_copy()\fR, \fBCMAC_Init()\fR, \fBCMAC_Update()\fR, \fBCMAC_Final()\fR and \fBCMAC_resume()\fR
return 1 for success or 0 if an error occurs.
.SH HISTORY
.IX Header "HISTORY"
All functions described here were deprecated in OpenSSL 3.0. For replacements,
see \fBEVP_MAC_CTX_new\fR\|(3), \fBEVP_MAC_CTX_free\fR\|(3), \fBEVP_MAC_init\fR\|(3),
\&\fBEVP_MAC_update\fR\|(3), and \fBEVP_MAC_final\fR\|(3).
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2024 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
<https://www.openssl.org/source/license.html>.
