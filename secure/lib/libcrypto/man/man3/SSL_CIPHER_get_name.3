.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CIPHER_GET_NAME 3ossl"
.TH SSL_CIPHER_GET_NAME 3ossl "2023-09-19" "3.0.11" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CIPHER_get_name,
SSL_CIPHER_standard_name,
OPENSSL_cipher_name,
SSL_CIPHER_get_bits,
SSL_CIPHER_get_version,
SSL_CIPHER_description,
SSL_CIPHER_get_cipher_nid,
SSL_CIPHER_get_digest_nid,
SSL_CIPHER_get_handshake_digest,
SSL_CIPHER_get_kx_nid,
SSL_CIPHER_get_auth_nid,
SSL_CIPHER_is_aead,
SSL_CIPHER_find,
SSL_CIPHER_get_id,
SSL_CIPHER_get_protocol_id
\&\- get SSL_CIPHER properties
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& const char *SSL_CIPHER_get_name(const SSL_CIPHER *cipher);
\& const char *SSL_CIPHER_standard_name(const SSL_CIPHER *cipher);
\& const char *OPENSSL_cipher_name(const char *stdname);
\& int SSL_CIPHER_get_bits(const SSL_CIPHER *cipher, int *alg_bits);
\& const char *SSL_CIPHER_get_version(const SSL_CIPHER *cipher);
\& char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int size);
\& int SSL_CIPHER_get_cipher_nid(const SSL_CIPHER *c);
\& int SSL_CIPHER_get_digest_nid(const SSL_CIPHER *c);
\& const EVP_MD *SSL_CIPHER_get_handshake_digest(const SSL_CIPHER *c);
\& int SSL_CIPHER_get_kx_nid(const SSL_CIPHER *c);
\& int SSL_CIPHER_get_auth_nid(const SSL_CIPHER *c);
\& int SSL_CIPHER_is_aead(const SSL_CIPHER *c);
\& const SSL_CIPHER *SSL_CIPHER_find(SSL *ssl, const unsigned char *ptr);
\& uint32_t SSL_CIPHER_get_id(const SSL_CIPHER *c);
\& uint32_t SSL_CIPHER_get_protocol_id(const SSL_CIPHER *c);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBSSL_CIPHER_get_name()\fR returns a pointer to the name of \fBcipher\fR. If the
\&\fBcipher\fR is \s-1NULL,\s0 it returns \*(L"(\s-1NONE\s0)\*(R".
.PP
\&\fBSSL_CIPHER_standard_name()\fR returns a pointer to the standard \s-1RFC\s0 name of
\&\fBcipher\fR. If the \fBcipher\fR is \s-1NULL,\s0 it returns \*(L"(\s-1NONE\s0)\*(R". If the \fBcipher\fR
has no standard name, it returns \fB\s-1NULL\s0\fR. If \fBcipher\fR was defined in both
SSLv3 and \s-1TLS,\s0 it returns the \s-1TLS\s0 name.
.PP
\&\fBOPENSSL_cipher_name()\fR returns a pointer to the OpenSSL name of \fBstdname\fR.
If the \fBstdname\fR is \s-1NULL,\s0 or \fBstdname\fR has no corresponding OpenSSL name,
it returns \*(L"(\s-1NONE\s0)\*(R". Where both exist, \fBstdname\fR should be the \s-1TLS\s0 name rather
than the SSLv3 name.
.PP
\&\fBSSL_CIPHER_get_bits()\fR returns the number of secret bits used for \fBcipher\fR.
If \fBcipher\fR is \s-1NULL, 0\s0 is returned.
.PP
\&\fBSSL_CIPHER_get_version()\fR returns string which indicates the \s-1SSL/TLS\s0 protocol
version that first defined the cipher.  It returns \*(L"(\s-1NONE\s0)\*(R" if \fBcipher\fR is \s-1NULL.\s0
.PP
\&\fBSSL_CIPHER_get_cipher_nid()\fR returns the cipher \s-1NID\s0 corresponding to \fBc\fR.
If there is no cipher (e.g. for cipher suites with no encryption) then
\&\fBNID_undef\fR is returned.
.PP
\&\fBSSL_CIPHER_get_digest_nid()\fR returns the digest \s-1NID\s0 corresponding to the \s-1MAC\s0
used by \fBc\fR during record encryption/decryption. If there is no digest (e.g.
for \s-1AEAD\s0 cipher suites) then \fBNID_undef\fR is returned.
.PP
\&\fBSSL_CIPHER_get_handshake_digest()\fR returns an \s-1EVP_MD\s0 for the digest used during
the \s-1SSL/TLS\s0 handshake when using the \s-1SSL_CIPHER\s0 \fBc\fR. Note that this may be
different to the digest used to calculate the \s-1MAC\s0 for encrypted records.
.PP
\&\fBSSL_CIPHER_get_kx_nid()\fR returns the key exchange \s-1NID\s0 corresponding to the method
used by \fBc\fR. If there is no key exchange, then \fBNID_undef\fR is returned.
If any appropriate key exchange algorithm can be used (as in the case of \s-1TLS 1.3\s0
cipher suites) \fBNID_kx_any\fR is returned. Examples (not comprehensive):
.PP
.Vb 4
\& NID_kx_rsa
\& NID_kx_ecdhe
\& NID_kx_dhe
\& NID_kx_psk
.Ve
.PP
\&\fBSSL_CIPHER_get_auth_nid()\fR returns the authentication \s-1NID\s0 corresponding to the method
used by \fBc\fR. If there is no authentication, then \fBNID_undef\fR is returned.
If any appropriate authentication algorithm can be used (as in the case of
\&\s-1TLS 1.3\s0 cipher suites) \fBNID_auth_any\fR is returned. Examples (not comprehensive):
.PP
.Vb 3
\& NID_auth_rsa
\& NID_auth_ecdsa
\& NID_auth_psk
.Ve
.PP
\&\fBSSL_CIPHER_is_aead()\fR returns 1 if the cipher \fBc\fR is \s-1AEAD\s0 (e.g. \s-1GCM\s0 or
ChaCha20/Poly1305), and 0 if it is not \s-1AEAD.\s0
.PP
\&\fBSSL_CIPHER_find()\fR returns a \fB\s-1SSL_CIPHER\s0\fR structure which has the cipher \s-1ID\s0 stored
in \fBptr\fR. The \fBptr\fR parameter is a two element array of \fBchar\fR, which stores the
two-byte \s-1TLS\s0 cipher \s-1ID\s0 (as allocated by \s-1IANA\s0) in network byte order. This parameter
is usually retrieved from a \s-1TLS\s0 packet by using functions like
\&\fBSSL_client_hello_get0_ciphers\fR\|(3).  \fBSSL_CIPHER_find()\fR returns \s-1NULL\s0 if an
error occurs or the indicated cipher is not found.
.PP
\&\fBSSL_CIPHER_get_id()\fR returns the OpenSSL-specific \s-1ID\s0 of the given cipher \fBc\fR. That \s-1ID\s0 is
not the same as the IANA-specific \s-1ID.\s0
.PP
\&\fBSSL_CIPHER_get_protocol_id()\fR returns the two-byte \s-1ID\s0 used in the \s-1TLS\s0 protocol of the given
cipher \fBc\fR.
.PP
\&\fBSSL_CIPHER_description()\fR returns a textual description of the cipher used
into the buffer \fBbuf\fR of length \fBlen\fR provided.  If \fBbuf\fR is provided, it
must be at least 128 bytes, otherwise a buffer will be allocated using
\&\fBOPENSSL_malloc()\fR.  If the provided buffer is too small, or the allocation fails,
\&\fB\s-1NULL\s0\fR is returned.
.PP
The string returned by \fBSSL_CIPHER_description()\fR consists of several fields
separated by whitespace:
.IP "<ciphername>" 4
.IX Item "<ciphername>"
Textual representation of the cipher name.
.IP "<protocol version>" 4
.IX Item "<protocol version>"
The minimum protocol version that the ciphersuite supports, such as \fBTLSv1.2\fR.
Note that this is not always the same as the protocol version in which the
ciphersuite was first defined because some ciphersuites are backwards compatible
with earlier protocol versions.
.IP "Kx=<key exchange>" 4
.IX Item "Kx=<key exchange>"
Key exchange method such as \fB\s-1RSA\s0\fR, \fB\s-1ECDHE\s0\fR, etc.
.IP "Au=<authentication>" 4
.IX Item "Au=<authentication>"
Authentication method such as \fB\s-1RSA\s0\fR, \fBNone\fR, etc.. None is the
representation of anonymous ciphers.
.IP "Enc=<symmetric encryption method>" 4
.IX Item "Enc=<symmetric encryption method>"
Encryption method, with number of secret bits, such as \fB\s-1AESGCM\s0(128)\fR.
.IP "Mac=<message authentication code>" 4
.IX Item "Mac=<message authentication code>"
Message digest, such as \fB\s-1SHA256\s0\fR.
.PP
Some examples for the output of \fBSSL_CIPHER_description()\fR:
.PP
.Vb 2
\& ECDHE\-RSA\-AES256\-GCM\-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(256) Mac=AEAD
\& RSA\-PSK\-AES256\-CBC\-SHA384 TLSv1.0 Kx=RSAPSK   Au=RSA  Enc=AES(256)  Mac=SHA384
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBSSL_CIPHER_get_name()\fR, \fBSSL_CIPHER_standard_name()\fR, \fBOPENSSL_cipher_name()\fR,
\&\fBSSL_CIPHER_get_version()\fR and \fBSSL_CIPHER_description()\fR return the corresponding
value in a NUL-terminated string for a specific cipher or \*(L"(\s-1NONE\s0)\*(R"
if the cipher is not found.
.PP
\&\fBSSL_CIPHER_get_bits()\fR returns a positive integer representing the number of
secret bits or 0 if an error occurred.
.PP
\&\fBSSL_CIPHER_get_cipher_nid()\fR, \fBSSL_CIPHER_get_digest_nid()\fR,
\&\fBSSL_CIPHER_get_kx_nid()\fR and \fBSSL_CIPHER_get_auth_nid()\fR return the \s-1NID\s0 value or
\&\fBNID_undef\fR if an error occurred.
.PP
\&\fBSSL_CIPHER_get_handshake_digest()\fR returns a valid \fB\s-1EVP_MD\s0\fR structure or \s-1NULL\s0
if an error occurred.
.PP
\&\fBSSL_CIPHER_is_aead()\fR returns 1 if the cipher is \s-1AEAD\s0 or 0 otherwise.
.PP
\&\fBSSL_CIPHER_find()\fR returns a valid \fB\s-1SSL_CIPHER\s0\fR structure or \s-1NULL\s0 if an error
occurred.
.PP
\&\fBSSL_CIPHER_get_id()\fR returns a 4\-byte integer representing the OpenSSL-specific \s-1ID.\s0
.PP
\&\fBSSL_CIPHER_get_protocol_id()\fR returns a 2\-byte integer representing the \s-1TLS\s0
protocol-specific \s-1ID.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBssl\fR\|(7), \fBSSL_get_current_cipher\fR\|(3),
\&\fBSSL_get_ciphers\fR\|(3), \fBopenssl\-ciphers\fR\|(1)
.SH "HISTORY"
.IX Header "HISTORY"
The \fBSSL_CIPHER_get_version()\fR function was updated to always return the
correct protocol string in OpenSSL 1.1.0.
.PP
The \fBSSL_CIPHER_description()\fR function was changed to return \fB\s-1NULL\s0\fR on error,
rather than a fixed string, in OpenSSL 1.1.0.
.PP
The \fBSSL_CIPHER_get_handshake_digest()\fR function was added in OpenSSL 1.1.1.
.PP
The \fBSSL_CIPHER_standard_name()\fR function was globally available in OpenSSL 1.1.1.
 Before OpenSSL 1.1.1, tracing (\fBenable-ssl-trace\fR argument to Configure) was
required to enable this function.
.PP
The \fBOPENSSL_cipher_name()\fR function was added in OpenSSL 1.1.1.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000\-2021 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
