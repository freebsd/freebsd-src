.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CRYPTO_THREAD_RUN_ONCE 3ossl"
.TH CRYPTO_THREAD_RUN_ONCE 3ossl 2025-07-01 3.5.1 OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
CRYPTO_THREAD_run_once,
CRYPTO_THREAD_lock_new, CRYPTO_THREAD_read_lock, CRYPTO_THREAD_write_lock,
CRYPTO_THREAD_unlock, CRYPTO_THREAD_lock_free,
CRYPTO_atomic_add, CRYPTO_atomic_add64, CRYPTO_atomic_and, CRYPTO_atomic_or,
CRYPTO_atomic_load, CRYPTO_atomic_store, CRYPTO_atomic_load_int,
OSSL_set_max_threads, OSSL_get_max_threads,
OSSL_get_thread_support_flags, OSSL_THREAD_SUPPORT_FLAG_THREAD_POOL,
OSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN \- OpenSSL thread support
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/crypto.h>
\&
\& CRYPTO_ONCE CRYPTO_ONCE_STATIC_INIT;
\& int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void));
\&
\& CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void);
\& int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock);
\& int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock);
\& int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock);
\& void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock);
\&
\& int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock);
\& int CRYPTO_atomic_add64(uint64_t *val, uint64_t op, uint64_t *ret,
\&                         CRYPTO_RWLOCK *lock);
\& int CRYPTO_atomic_and(uint64_t *val, uint64_t op, uint64_t *ret,
\&                       CRYPTO_RWLOCK *lock);
\& int CRYPTO_atomic_or(uint64_t *val, uint64_t op, uint64_t *ret,
\&                      CRYPTO_RWLOCK *lock);
\& int CRYPTO_atomic_load(uint64_t *val, uint64_t *ret, CRYPTO_RWLOCK *lock);
\& int CRYPTO_atomic_store(uint64_t *dst, uint64_t val, CRYPTO_RWLOCK *lock);
\& int CRYPTO_atomic_load_int(int *val, int *ret, CRYPTO_RWLOCK *lock);
\&
\& int OSSL_set_max_threads(OSSL_LIB_CTX *ctx, uint64_t max_threads);
\& uint64_t OSSL_get_max_threads(OSSL_LIB_CTX *ctx);
\& uint32_t OSSL_get_thread_support_flags(void);
\&
\& #define OSSL_THREAD_SUPPORT_FLAG_THREAD_POOL
\& #define OSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
OpenSSL can be safely used in multi-threaded applications provided that
support for the underlying OS threading API is built-in. Currently, OpenSSL
supports the pthread and Windows APIs. OpenSSL can also be built without
any multi-threading support, for example on platforms that don't provide
any threading support or that provide a threading API that is not yet
supported by OpenSSL.
.PP
The following multi-threading function are provided:
.IP \(bu 2
\&\fBCRYPTO_THREAD_run_once()\fR can be used to perform one-time initialization.
The \fIonce\fR argument must be a pointer to a static object of type
\&\fBCRYPTO_ONCE\fR that was statically initialized to the value
\&\fBCRYPTO_ONCE_STATIC_INIT\fR.
The \fIinit\fR argument is a pointer to a function that performs the desired
exactly once initialization.
In particular, this can be used to allocate locks in a thread-safe manner,
which can then be used with the locking functions below.
.IP \(bu 2
\&\fBCRYPTO_THREAD_lock_new()\fR allocates, initializes and returns a new read/write
lock.
.IP \(bu 2
\&\fBCRYPTO_THREAD_read_lock()\fR locks the provided \fIlock\fR for reading.
.IP \(bu 2
\&\fBCRYPTO_THREAD_write_lock()\fR locks the provided \fIlock\fR for writing.
.IP \(bu 2
\&\fBCRYPTO_THREAD_unlock()\fR unlocks the previously locked \fIlock\fR.
.IP \(bu 2
\&\fBCRYPTO_THREAD_lock_free()\fR frees the provided \fIlock\fR.
If the argument is NULL, nothing is done.
.IP \(bu 2
\&\fBCRYPTO_atomic_add()\fR atomically adds \fIamount\fR to \fI*val\fR and returns the
result of the operation in \fI*ret\fR. \fIlock\fR will be locked, unless atomic
operations are supported on the specific platform. Because of this, if a
variable is modified by \fBCRYPTO_atomic_add()\fR then \fBCRYPTO_atomic_add()\fR must
be the only way that the variable is modified. If atomic operations are not
supported and \fIlock\fR is NULL, then the function will fail.
.IP \(bu 2
\&\fBCRYPTO_atomic_add64()\fR atomically adds \fIop\fR to \fI*val\fR and returns the
result of the operation in \fI*ret\fR. \fIlock\fR will be locked, unless atomic
operations are supported on the specific platform. Because of this, if a
variable is modified by \fBCRYPTO_atomic_add64()\fR then \fBCRYPTO_atomic_add64()\fR must
be the only way that the variable is modified. If atomic operations are not
supported and \fIlock\fR is NULL, then the function will fail.
.IP \(bu 2
\&\fBCRYPTO_atomic_and()\fR performs an atomic bitwise and of \fIop\fR and \fI*val\fR and stores
the result back in \fI*val\fR. It also returns the result of the operation in
\&\fI*ret\fR. \fIlock\fR will be locked, unless atomic operations are supported on the
specific platform. Because of this, if a variable is modified by
\&\fBCRYPTO_atomic_and()\fR or read by \fBCRYPTO_atomic_load()\fR then \fBCRYPTO_atomic_and()\fR must
be the only way that the variable is modified. If atomic operations are not
supported and \fIlock\fR is NULL, then the function will fail.
.IP \(bu 2
\&\fBCRYPTO_atomic_or()\fR performs an atomic bitwise or of \fIop\fR and \fI*val\fR and stores
the result back in \fI*val\fR. It also returns the result of the operation in
\&\fI*ret\fR. \fIlock\fR will be locked, unless atomic operations are supported on the
specific platform. Because of this, if a variable is modified by
\&\fBCRYPTO_atomic_or()\fR or read by \fBCRYPTO_atomic_load()\fR then \fBCRYPTO_atomic_or()\fR must
be the only way that the variable is modified. If atomic operations are not
supported and \fIlock\fR is NULL, then the function will fail.
.IP \(bu 2
\&\fBCRYPTO_atomic_load()\fR atomically loads the contents of \fI*val\fR into \fI*ret\fR.
\&\fIlock\fR will be locked, unless atomic operations are supported on the specific
platform. Because of this, if a variable is modified by \fBCRYPTO_atomic_or()\fR or
read by \fBCRYPTO_atomic_load()\fR then \fBCRYPTO_atomic_load()\fR must be the only way that
the variable is read. If atomic operations are not supported and \fIlock\fR is
NULL, then the function will fail.
.IP \(bu 2
\&\fBCRYPTO_atomic_store()\fR atomically stores the contents of \fIval\fR into \fI*dst\fR.
\&\fIlock\fR will be locked, unless atomic operations are supported on the specific
platform.
.IP \(bu 2
\&\fBCRYPTO_atomic_load_int()\fR works identically to \fBCRYPTO_atomic_load()\fR but operates
on an \fIint\fR value instead of a \fIuint64_t\fR value.
.IP \(bu 2
\&\fBOSSL_set_max_threads()\fR sets the maximum number of threads to be used by the
thread pool. If the argument is 0, thread pooling is disabled. OpenSSL will
not create any threads and existing threads in the thread pool will be torn
down. The maximum thread count is a limit, not a target. Threads will not be
spawned unless (and until) there is demand. Thread polling is disabled by
default. To enable threading you must call \fBOSSL_set_max_threads()\fR explicitly.
Under no circumstances is this done for you.
.IP \(bu 2
\&\fBOSSL_get_thread_support_flags()\fR determines what thread pool functionality
OpenSSL is compiled with and is able to support in the current run time
environment. \fBOSSL_THREAD_SUPPORT_FLAG_THREAD_POOL\fR indicates that the base
thread pool functionality is available, and
\&\fBOSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN\fR indicates that the default thread pool
model is available. The default thread pool model is currently the only model
available, therefore both of these flags must be set for thread pool
functionality to be used.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBCRYPTO_THREAD_run_once()\fR returns 1 on success, or 0 on error.
.PP
\&\fBCRYPTO_THREAD_lock_new()\fR returns the allocated lock, or NULL on error.
.PP
\&\fBCRYPTO_THREAD_lock_free()\fR returns no value.
.PP
\&\fBOSSL_set_max_threads()\fR returns 1 on success and 0 on failure. Returns failure
if OpenSSL-managed thread pooling is not supported (for example, if it is not
supported on the current platform, or because OpenSSL is not built with the
necessary support).
.PP
\&\fBOSSL_get_max_threads()\fR returns the maximum number of threads currently allowed
to be used by the thread pool. If thread pooling is disabled or not available,
returns 0.
.PP
\&\fBOSSL_get_thread_support_flags()\fR returns zero or more \fBOSSL_THREAD_SUPPORT_FLAG\fR
values.
.PP
The other functions return 1 on success, or 0 on error.
.SH NOTES
.IX Header "NOTES"
On Windows platforms the CRYPTO_THREAD_* types and functions in the
\&\fI<openssl/crypto.h>\fR header are dependent on some of the types
customarily made available by including \fI<windows.h>\fR. The application
developer is likely to require control over when the latter is included,
commonly as one of the first included headers. Therefore, it is defined as an
application developer's responsibility to include \fI<windows.h>\fR prior to
\&\fI<openssl/crypto.h>\fR where use of CRYPTO_THREAD_* types and functions is
required.
.SH EXAMPLES
.IX Header "EXAMPLES"
You can find out if OpenSSL was configured with thread support:
.PP
.Vb 6
\& #include <openssl/opensslconf.h>
\& #if defined(OPENSSL_THREADS)
\&     /* thread support enabled */
\& #else
\&     /* no thread support */
\& #endif
.Ve
.PP
This example safely initializes and uses a lock.
.PP
.Vb 4
\& #ifdef _WIN32
\& # include <windows.h>
\& #endif
\& #include <openssl/crypto.h>
\&
\& static CRYPTO_ONCE once = CRYPTO_ONCE_STATIC_INIT;
\& static CRYPTO_RWLOCK *lock;
\&
\& static void myinit(void)
\& {
\&     lock = CRYPTO_THREAD_lock_new();
\& }
\&
\& static int mylock(void)
\& {
\&     if (!CRYPTO_THREAD_run_once(&once, void init) || lock == NULL)
\&         return 0;
\&     return CRYPTO_THREAD_write_lock(lock);
\& }
\&
\& static int myunlock(void)
\& {
\&     return CRYPTO_THREAD_unlock(lock);
\& }
\&
\& int serialized(void)
\& {
\&     int ret = 0;
\&
\&     if (!mylock()) {
\&        /* Do not unlock unless the lock was successfully acquired. */
\&        return 0;
\&     }
\&
\&     /* Your code here, do not return without releasing the lock! */
\&     ret = ... ;
\&     myunlock();
\&     return ret;
\& }
.Ve
.PP
Finalization of locks is an advanced topic, not covered in this example.
This can only be done at process exit or when a dynamically loaded library is
no longer in use and is unloaded.
The simplest solution is to just "leak" the lock in applications and not
repeatedly load/unload shared libraries that allocate locks.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBcrypto\fR\|(7), \fBopenssl\-threads\fR\|(7).
.SH HISTORY
.IX Header "HISTORY"
\&\fBCRYPTO_atomic_load_int()\fR, \fBOSSL_set_max_threads()\fR, \fBOSSL_get_max_threads()\fR,
\&\fBOSSL_get_thread_support_flags()\fR were added in OpenSSL 3.2.
.PP
\&\fBCRYPTO_atomic_store()\fR, \fBCRYPTO_atomic_add64()\fR, \fBCRYPTO_atomic_and()\fR
were added in OpenSSL 3.4.
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2000\-2024 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
<https://www.openssl.org/source/license.html>.
