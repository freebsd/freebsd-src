.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OSSL_ALGORITHM 3"
.TH OSSL_ALGORITHM 3 "2023-05-30" "3.0.9" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OSSL_ALGORITHM \- OpenSSL Core type to define a fetchable algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/core.h>
\&
\& typedef struct ossl_algorithm_st OSSL_ALGORITHM;
\& struct ossl_algorithm_st {
\&     const char *algorithm_names;     /* key */
\&     const char *property_definition; /* key */
\&     const OSSL_DISPATCH *implementation;
\&     const char *algorithm_description;
\& };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\s-1OSSL_ALGORITHM\s0\fR type is a \fIpublic structure\fR that describes an
algorithm that a \fBprovider\fR\|(7) provides.  Arrays of this type are returned
by providers on demand from the OpenSSL libraries to describe what
algorithms the providers provide implementations of, and with what
properties.
.PP
Arrays of this type must be terminated with a tuple where \fIalgorithm_names\fR
is \s-1NULL.\s0
.PP
This type of array is typically returned by the provider's operation querying
function, further described in \*(L"Provider Functions\*(R" in \fBprovider\-base\fR\|(7).
.SS "\fB\s-1OSSL_ALGORITHM\s0\fP fields"
.IX Subsection "OSSL_ALGORITHM fields"
.IP "\fIalgorithm_names\fR" 4
.IX Item "algorithm_names"
This string is a colon separated set of names / identities, and is used by
the appropriate fetching functionality (such as \fBEVP_CIPHER_fetch\fR\|(3),
\&\fBEVP_MD_fetch\fR\|(3), etc) to find the desired algorithm.
.Sp
Multiple names / identities allow a specific algorithm implementation to be
fetched multiple ways.  For example, the \s-1RSA\s0 algorithm has the following
known identities:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`RSA\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`rsaEncryption\*(C'\fR
.Sp
This is the name of the algorithm's \s-1OBJECT IDENTIFIER\s0 (\s-1OID\s0), as given by the
PKCS#1 \s-1RFC\s0's \s-1ASN.1\s0 module <https://www.rfc-editor.org/rfc/rfc8017#appendix-C>
.IP "\(bu" 4
\&\f(CW1.2.840.113549.1.1.1\fR
.Sp
This is the \s-1OID\s0 itself for \f(CW\*(C`rsaEncryption\*(C'\fR, in canonical decimal text form.
.RE
.RS 4
.Sp
The resulting \fIalgorithm_names\fR string would look like this:
.Sp
.Vb 1
\& "RSA:rsaEncryption:1.2.840.113549.1.1.1"
.Ve
.Sp
The OpenSSL libraries use the first of the algorithm names as the main
or canonical name, on a per algorithm implementation basis.
.Sp
See the notes \*(L"On the subject of algorithm names\*(R" below for a more in
depth discussion on \fIalgorithm_names\fR and how that may interact with
applications and libraries, including OpenSSL's.
.RE
.IP "\fIproperty_definition\fR" 4
.IX Item "property_definition"
This string defines a set of properties associated with a particular
algorithm implementation, and is used by the appropriate fetching
functionality (such as \fBEVP_CIPHER_fetch\fR\|(3), \fBEVP_MD_fetch\fR\|(3), etc) for
a finer grained lookup of an algorithm implementation, which is useful in
case multiple implementations of the same algorithm are available.
.Sp
See \fBproperty\fR\|(7) for a further description of the contents of this
string.
.IP "\fIimplementation\fR" 4
.IX Item "implementation"
Pointer to an \s-1\fBOSSL_DISPATCH\s0\fR\|(3) array, containing pointers to the
functions of a particular algorithm implementation.
.IP "\fIalgorithm_description\fR" 4
.IX Item "algorithm_description"
A string with a short human-readable description of the algorithm.
.SH "NOTES"
.IX Header "NOTES"
.SS "On the subject of algorithm names"
.IX Subsection "On the subject of algorithm names"
Providers may find the need to register \s-1ASN.1\s0 OIDs for algorithms using
\&\fBOBJ_create\fR\|(3) (via the \fBcore_obj_create\fR upcall described in
\&\fBprovider\-base\fR\|(7), because some application or library \*(-- possibly still
the OpenSSL libraries, even \*(-- use NIDs to look up algorithms.
.PP
In that scenario, you must make sure that the corresponding \fB\s-1OSSL_ALGORITHM\s0\fR's
\&\fIalgorithm_names\fR includes both the short and the long name.
.PP
Most of the time, registering \s-1ASN.1\s0 OIDs like this shouldn't be necessary,
and applications and libraries are encouraged to use \fBOBJ_obj2txt\fR\|(3) to
get a text representation of the \s-1OID,\s0 which may be a long or short name for
OIDs that are registered, or the \s-1OID\s0 itself in canonical decimal text form
if not (or if \fBOBJ_obj2txt\fR\|(3) is called with \fIno_name\fR = 1).
.PP
It's recommended to make sure that the corresponding \fB\s-1OSSL_ALGORITHM\s0\fR's
\&\fIalgorithm_names\fR include known names as well as the \s-1OID\s0 itself in
canonical decimal text form.  That should cover all scenarios.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBcrypto\fR\|(7), \fBprovider\-base\fR\|(7), \fBopenssl\-core.h\fR\|(7),
\&\fBopenssl\-core_dispatch.h\fR\|(7), \s-1\fBOSSL_DISPATCH\s0\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fB\s-1OSSL_ALGORITHM\s0\fR was added in OpenSSL 3.0
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2022 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
