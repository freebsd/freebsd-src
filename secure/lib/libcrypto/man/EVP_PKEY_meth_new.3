.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_PKEY_meth_new 3"
.TH EVP_PKEY_meth_new 3 "2018-08-14" "1.0.2p" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_PKEY_meth_new, EVP_PKEY_meth_free, EVP_PKEY_meth_copy, EVP_PKEY_meth_find,
EVP_PKEY_meth_add0, EVP_PKEY_METHOD,
EVP_PKEY_meth_set_init, EVP_PKEY_meth_set_copy, EVP_PKEY_meth_set_cleanup,
EVP_PKEY_meth_set_paramgen, EVP_PKEY_meth_set_keygen, EVP_PKEY_meth_set_sign,
EVP_PKEY_meth_set_verify, EVP_PKEY_meth_set_verify_recover, EVP_PKEY_meth_set_signctx,
EVP_PKEY_meth_set_verifyctx, EVP_PKEY_meth_set_encrypt, EVP_PKEY_meth_set_decrypt,
EVP_PKEY_meth_set_derive, EVP_PKEY_meth_set_ctrl,
EVP_PKEY_meth_get_init, EVP_PKEY_meth_get_copy, EVP_PKEY_meth_get_cleanup,
EVP_PKEY_meth_get_paramgen, EVP_PKEY_meth_get_keygen, EVP_PKEY_meth_get_sign,
EVP_PKEY_meth_get_verify, EVP_PKEY_meth_get_verify_recover, EVP_PKEY_meth_get_signctx,
EVP_PKEY_meth_get_verifyctx, EVP_PKEY_meth_get_encrypt, EVP_PKEY_meth_get_decrypt,
EVP_PKEY_meth_get_derive, EVP_PKEY_meth_get_ctrl
\&\- manipulating EVP_PKEY_METHOD structure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& typedef struct evp_pkey_method_st EVP_PKEY_METHOD;
\&
\& EVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags);
\& void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);
\& void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);
\& const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);
\& int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);
\&
\& void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,
\&                             int (*init) (EVP_PKEY_CTX *ctx));
\& void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,
\&                             int (*copy) (EVP_PKEY_CTX *dst,
\&                                          EVP_PKEY_CTX *src));
\& void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,
\&                                void (*cleanup) (EVP_PKEY_CTX *ctx));
\& void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,
\&                                 int (*paramgen_init) (EVP_PKEY_CTX *ctx),
\&                                 int (*paramgen) (EVP_PKEY_CTX *ctx,
\&                                                  EVP_PKEY *pkey));
\& void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,
\&                               int (*keygen_init) (EVP_PKEY_CTX *ctx),
\&                               int (*keygen) (EVP_PKEY_CTX *ctx,
\&                                              EVP_PKEY *pkey));
\& void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,
\&                             int (*sign_init) (EVP_PKEY_CTX *ctx),
\&                             int (*sign) (EVP_PKEY_CTX *ctx,
\&                                          unsigned char *sig, size_t *siglen,
\&                                          const unsigned char *tbs,
\&                                          size_t tbslen));
\& void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,
\&                               int (*verify_init) (EVP_PKEY_CTX *ctx),
\&                               int (*verify) (EVP_PKEY_CTX *ctx,
\&                                              const unsigned char *sig,
\&                                              size_t siglen,
\&                                              const unsigned char *tbs,
\&                                              size_t tbslen));
\& void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,
\&                                       int (*verify_recover_init) (EVP_PKEY_CTX
\&                                                                   *ctx),
\&                                       int (*verify_recover) (EVP_PKEY_CTX
\&                                                              *ctx,
\&                                                              unsigned char
\&                                                              *sig,
\&                                                              size_t *siglen,
\&                                                              const unsigned
\&                                                              char *tbs,
\&                                                              size_t tbslen));
\& void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,
\&                                int (*signctx_init) (EVP_PKEY_CTX *ctx,
\&                                                     EVP_MD_CTX *mctx),
\&                                int (*signctx) (EVP_PKEY_CTX *ctx,
\&                                                unsigned char *sig,
\&                                                size_t *siglen,
\&                                                EVP_MD_CTX *mctx));
\& void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
\&                                  int (*verifyctx_init) (EVP_PKEY_CTX *ctx,
\&                                                         EVP_MD_CTX *mctx),
\&                                  int (*verifyctx) (EVP_PKEY_CTX *ctx,
\&                                                    const unsigned char *sig,
\&                                                    int siglen,
\&                                                    EVP_MD_CTX *mctx));
\& void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,
\&                                int (*encrypt_init) (EVP_PKEY_CTX *ctx),
\&                                int (*encryptfn) (EVP_PKEY_CTX *ctx,
\&                                                  unsigned char *out,
\&                                                  size_t *outlen,
\&                                                  const unsigned char *in,
\&                                                  size_t inlen));
\& void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,
\&                                int (*decrypt_init) (EVP_PKEY_CTX *ctx),
\&                                int (*decrypt) (EVP_PKEY_CTX *ctx,
\&                                                unsigned char *out,
\&                                                size_t *outlen,
\&                                                const unsigned char *in,
\&                                                size_t inlen));
\& void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,
\&                               int (*derive_init) (EVP_PKEY_CTX *ctx),
\&                               int (*derive) (EVP_PKEY_CTX *ctx,
\&                                              unsigned char *key,
\&                                              size_t *keylen));
\& void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,
\&                             int (*ctrl) (EVP_PKEY_CTX *ctx, int type, int p1,
\&                                          void *p2),
\&                             int (*ctrl_str) (EVP_PKEY_CTX *ctx,
\&                                              const char *type,
\&                                              const char *value));
\&
\& void EVP_PKEY_meth_get_init(EVP_PKEY_METHOD *pmeth,
\&                             int (**pinit) (EVP_PKEY_CTX *ctx));
\& void EVP_PKEY_meth_get_copy(EVP_PKEY_METHOD *pmeth,
\&                             int (**pcopy) (EVP_PKEY_CTX *dst,
\&                                            EVP_PKEY_CTX *src));
\& void EVP_PKEY_meth_get_cleanup(EVP_PKEY_METHOD *pmeth,
\&                                void (**pcleanup) (EVP_PKEY_CTX *ctx));
\& void EVP_PKEY_meth_get_paramgen(EVP_PKEY_METHOD *pmeth,
\&                                 int (**pparamgen_init) (EVP_PKEY_CTX *ctx),
\&                                 int (**pparamgen) (EVP_PKEY_CTX *ctx,
\&                                                    EVP_PKEY *pkey));
\& void EVP_PKEY_meth_get_keygen(EVP_PKEY_METHOD *pmeth,
\&                               int (**pkeygen_init) (EVP_PKEY_CTX *ctx),
\&                               int (**pkeygen) (EVP_PKEY_CTX *ctx,
\&                                                EVP_PKEY *pkey));
\& void EVP_PKEY_meth_get_sign(EVP_PKEY_METHOD *pmeth,
\&                             int (**psign_init) (EVP_PKEY_CTX *ctx),
\&                             int (**psign) (EVP_PKEY_CTX *ctx,
\&                                            unsigned char *sig, size_t *siglen,
\&                                            const unsigned char *tbs,
\&                                            size_t tbslen));
\& void EVP_PKEY_meth_get_verify(EVP_PKEY_METHOD *pmeth,
\&                               int (**pverify_init) (EVP_PKEY_CTX *ctx),
\&                               int (**pverify) (EVP_PKEY_CTX *ctx,
\&                                                const unsigned char *sig,
\&                                                size_t siglen,
\&                                                const unsigned char *tbs,
\&                                                size_t tbslen));
\& void EVP_PKEY_meth_get_verify_recover(EVP_PKEY_METHOD *pmeth,
\&                                       int (**pverify_recover_init) (EVP_PKEY_CTX
\&                                                                     *ctx),
\&                                       int (**pverify_recover) (EVP_PKEY_CTX
\&                                                                *ctx,
\&                                                                unsigned char
\&                                                                *sig,
\&                                                                size_t *siglen,
\&                                                                const unsigned
\&                                                                char *tbs,
\&                                                                size_t tbslen));
\& void EVP_PKEY_meth_get_signctx(EVP_PKEY_METHOD *pmeth,
\&                                int (**psignctx_init) (EVP_PKEY_CTX *ctx,
\&                                                       EVP_MD_CTX *mctx),
\&                                int (**psignctx) (EVP_PKEY_CTX *ctx,
\&                                                  unsigned char *sig,
\&                                                  size_t *siglen,
\&                                                  EVP_MD_CTX *mctx));
\& void EVP_PKEY_meth_get_verifyctx(EVP_PKEY_METHOD *pmeth,
\&                                  int (**pverifyctx_init) (EVP_PKEY_CTX *ctx,
\&                                                           EVP_MD_CTX *mctx),
\&                                  int (**pverifyctx) (EVP_PKEY_CTX *ctx,
\&                                                      const unsigned char *sig,
\&                                                      int siglen,
\&                                                      EVP_MD_CTX *mctx));
\& void EVP_PKEY_meth_get_encrypt(EVP_PKEY_METHOD *pmeth,
\&                                int (**pencrypt_init) (EVP_PKEY_CTX *ctx),
\&                                int (**pencryptfn) (EVP_PKEY_CTX *ctx,
\&                                                    unsigned char *out,
\&                                                    size_t *outlen,
\&                                                    const unsigned char *in,
\&                                                    size_t inlen));
\& void EVP_PKEY_meth_get_decrypt(EVP_PKEY_METHOD *pmeth,
\&                                int (**pdecrypt_init) (EVP_PKEY_CTX *ctx),
\&                                int (**pdecrypt) (EVP_PKEY_CTX *ctx,
\&                                                  unsigned char *out,
\&                                                  size_t *outlen,
\&                                                  const unsigned char *in,
\&                                                  size_t inlen));
\& void EVP_PKEY_meth_get_derive(EVP_PKEY_METHOD *pmeth,
\&                               int (**pderive_init) (EVP_PKEY_CTX *ctx),
\&                               int (**pderive) (EVP_PKEY_CTX *ctx,
\&                                                unsigned char *key,
\&                                                size_t *keylen));
\& void EVP_PKEY_meth_get_ctrl(EVP_PKEY_METHOD *pmeth,
\&                             int (**pctrl) (EVP_PKEY_CTX *ctx, int type, int p1,
\&                                            void *p2),
\&                             int (**pctrl_str) (EVP_PKEY_CTX *ctx,
\&                                                const char *type,
\&                                                const char *value));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1EVP_PKEY_METHOD\s0\fR is a structure which holds a set of methods for a
specific public key cryptographic algorithm. Those methods are usually
used to perform different jobs, such as generating a key, signing or
verifying, encrypting or decrypting, etc.
.PP
There are two places where the \fB\s-1EVP_PKEY_METHOD\s0\fR objects are stored: one
is a built-in static array representing the standard methods for different
algorithms, and the other one is a stack of user-defined application-specific
methods, which can be manipulated by using \fIEVP_PKEY_meth_add0\fR\|(3).
.PP
The \fB\s-1EVP_PKEY_METHOD\s0\fR objects are usually referenced by \fB\s-1EVP_PKEY_CTX\s0\fR
objects.
.SS "Methods"
.IX Subsection "Methods"
The methods are the underlying implementations of a particular public key
algorithm present by the \fB\s-1EVP_PKEY_CTX\s0\fR object.
.PP
.Vb 3
\& int (*init) (EVP_PKEY_CTX *ctx);
\& int (*copy) (EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src);
\& void (*cleanup) (EVP_PKEY_CTX *ctx);
.Ve
.PP
The \fIinit()\fR method is called to initialize algorithm-specific data when a new
\&\fB\s-1EVP_PKEY_CTX\s0\fR is created. As opposed to \fIinit()\fR, the \fIcleanup()\fR method is called
when an \fB\s-1EVP_PKEY_CTX\s0\fR is freed. The \fIcopy()\fR method is called when an \fB\s-1EVP_PKEY_CTX\s0\fR
is being duplicated. Refer to \fIEVP_PKEY_CTX_new\fR\|(3), \fIEVP_PKEY_CTX_new_id\fR\|(3),
\&\fIEVP_PKEY_CTX_free\fR\|(3) and \fIEVP_PKEY_CTX_dup\fR\|(3).
.PP
.Vb 2
\& int (*paramgen_init) (EVP_PKEY_CTX *ctx);
\& int (*paramgen) (EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);
.Ve
.PP
The \fIparamgen_init()\fR and \fIparamgen()\fR methods deal with key parameter generation.
They are called by \fIEVP_PKEY_paramgen_init\fR\|(3) and \fIEVP_PKEY_paramgen\fR\|(3) to
handle the parameter generation process.
.PP
.Vb 2
\& int (*keygen_init) (EVP_PKEY_CTX *ctx);
\& int (*keygen) (EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);
.Ve
.PP
The \fIkeygen_init()\fR and \fIkeygen()\fR methods are used to generate the actual key for
the specified algorithm. They are called by \fIEVP_PKEY_keygen_init\fR\|(3) and
\&\fIEVP_PKEY_keygen\fR\|(3).
.PP
.Vb 3
\& int (*sign_init) (EVP_PKEY_CTX *ctx);
\& int (*sign) (EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
\&              const unsigned char *tbs, size_t tbslen);
.Ve
.PP
The \fIsign_init()\fR and \fIsign()\fR methods are used to generate the signature of a
piece of data using a private key. They are called by \fIEVP_PKEY_sign_init\fR\|(3)
and \fIEVP_PKEY_sign\fR\|(3).
.PP
.Vb 4
\& int (*verify_init) (EVP_PKEY_CTX *ctx);
\& int (*verify) (EVP_PKEY_CTX *ctx,
\&                const unsigned char *sig, size_t siglen,
\&                const unsigned char *tbs, size_t tbslen);
.Ve
.PP
The \fIverify_init()\fR and \fIverify()\fR methods are used to verify whether a signature is
valid. They are called by \fIEVP_PKEY_verify_init\fR\|(3) and \fIEVP_PKEY_verify\fR\|(3).
.PP
.Vb 4
\& int (*verify_recover_init) (EVP_PKEY_CTX *ctx);
\& int (*verify_recover) (EVP_PKEY_CTX *ctx,
\&                        unsigned char *rout, size_t *routlen,
\&                        const unsigned char *sig, size_t siglen);
.Ve
.PP
The \fIverify_recover_init()\fR and \fIverify_recover()\fR methods are used to verify a
signature and then recover the digest from the signature (for instance, a
signature that was generated by \s-1RSA\s0 signing algorithm). They are called by
\&\fIEVP_PKEY_verify_recover_init\fR\|(3) and \fIEVP_PKEY_verify_recover\fR\|(3).
.PP
.Vb 3
\& int (*signctx_init) (EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);
\& int (*signctx) (EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
\&                 EVP_MD_CTX *mctx);
.Ve
.PP
The \fIsignctx_init()\fR and \fIsignctx()\fR methods are used to sign a digest present by
a \fB\s-1EVP_MD_CTX\s0\fR object. They are called by the EVP_DigestSign functions. See
\&\fIEVP_DigestSignInit\fR\|(3) for detail.
.PP
.Vb 3
\& int (*verifyctx_init) (EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);
\& int (*verifyctx) (EVP_PKEY_CTX *ctx, const unsigned char *sig, int siglen,
\&                   EVP_MD_CTX *mctx);
.Ve
.PP
The \fIverifyctx_init()\fR and \fIverifyctx()\fR methods are used to verify a signature
against the data in a \fB\s-1EVP_MD_CTX\s0\fR object. They are called by the various
EVP_DigestVerify functions. See \fIEVP_DigestVerifyInit\fR\|(3) for detail.
.PP
.Vb 3
\& int (*encrypt_init) (EVP_PKEY_CTX *ctx);
\& int (*encrypt) (EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
\&                 const unsigned char *in, size_t inlen);
.Ve
.PP
The \fIencrypt_init()\fR and \fIencrypt()\fR methods are used to encrypt a piece of data.
They are called by \fIEVP_PKEY_encrypt_init\fR\|(3) and \fIEVP_PKEY_encrypt\fR\|(3).
.PP
.Vb 3
\& int (*decrypt_init) (EVP_PKEY_CTX *ctx);
\& int (*decrypt) (EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
\&                 const unsigned char *in, size_t inlen);
.Ve
.PP
The \fIdecrypt_init()\fR and \fIdecrypt()\fR methods are used to decrypt a piece of data.
They are called by \fIEVP_PKEY_decrypt_init\fR\|(3) and \fIEVP_PKEY_decrypt\fR\|(3).
.PP
.Vb 2
\& int (*derive_init) (EVP_PKEY_CTX *ctx);
\& int (*derive) (EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);
.Ve
.PP
The \fIderive_init()\fR and \fIderive()\fR methods are used to derive the shared secret
from a public key algorithm (for instance, the \s-1DH\s0 algorithm). They are called by
\&\fIEVP_PKEY_derive_init\fR\|(3) and \fIEVP_PKEY_derive\fR\|(3).
.PP
.Vb 2
\& int (*ctrl) (EVP_PKEY_CTX *ctx, int type, int p1, void *p2);
\& int (*ctrl_str) (EVP_PKEY_CTX *ctx, const char *type, const char *value);
.Ve
.PP
The \fIctrl()\fR and \fIctrl_str()\fR methods are used to adjust algorithm-specific
settings. See \fIEVP_PKEY_CTX_ctrl\fR\|(3) and related functions for detail.
.PP
.Vb 5
\& int (*digestsign) (EVP_MD_CTX *ctx, unsigned char *sig, size_t *siglen,
\&                    const unsigned char *tbs, size_t tbslen);
\& int (*digestverify) (EVP_MD_CTX *ctx, const unsigned char *sig,
\&                      size_t siglen, const unsigned char *tbs,
\&                      size_t tbslen);
.Ve
.PP
The \fIdigestsign()\fR and \fIdigestverify()\fR methods are used to generate or verify
a signature in a one-shot mode. They could be called by \fIEVP_DigetSign\fR\|(3)
and \fIEVP_DigestVerify\fR\|(3).
.SS "Functions"
.IX Subsection "Functions"
\&\fIEVP_PKEY_meth_new()\fR creates and returns a new \fB\s-1EVP_PKEY_METHOD\s0\fR object,
and associates the given \fBid\fR and \fBflags\fR. The following flags are
supported:
.PP
.Vb 2
\& EVP_PKEY_FLAG_AUTOARGLEN
\& EVP_PKEY_FLAG_SIGCTX_CUSTOM
.Ve
.PP
If an \fB\s-1EVP_PKEY_METHOD\s0\fR is set with the \fB\s-1EVP_PKEY_FLAG_AUTOARGLEN\s0\fR flag, the
maximum size of the output buffer will be automatically calculated or checked
in corresponding \s-1EVP\s0 methods by the \s-1EVP\s0 framework. Thus the implementations of
these methods don't need to care about handling the case of returning output
buffer size by themselves. For details on the output buffer size, refer to
\&\fIEVP_PKEY_sign\fR\|(3).
.PP
The \fB\s-1EVP_PKEY_FLAG_SIGCTX_CUSTOM\s0\fR is used to indicate the \fIsignctx()\fR method
of an \fB\s-1EVP_PKEY_METHOD\s0\fR is always called by the \s-1EVP\s0 framework while doing a
digest signing operation by calling \fIEVP_DigestSignFinal\fR\|(3).
.PP
\&\fIEVP_PKEY_meth_free()\fR frees an existing \fB\s-1EVP_PKEY_METHOD\s0\fR pointed by
\&\fBpmeth\fR.
.PP
\&\fIEVP_PKEY_meth_copy()\fR copies an \fB\s-1EVP_PKEY_METHOD\s0\fR object from \fBsrc\fR
to \fBdst\fR.
.PP
\&\fIEVP_PKEY_meth_find()\fR finds an \fB\s-1EVP_PKEY_METHOD\s0\fR object with the \fBid\fR.
This function first searches through the user-defined method objects and
then the built-in objects.
.PP
\&\fIEVP_PKEY_meth_add0()\fR adds \fBpmeth\fR to the user defined stack of methods.
.PP
The EVP_PKEY_meth_set functions set the corresponding fields of
\&\fB\s-1EVP_PKEY_METHOD\s0\fR structure with the arguments passed.
.PP
The EVP_PKEY_meth_get functions get the corresponding fields of
\&\fB\s-1EVP_PKEY_METHOD\s0\fR structure to the arguments provided.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIEVP_PKEY_meth_new()\fR returns a pointer to a new \fB\s-1EVP_PKEY_METHOD\s0\fR
object or returns \s-1NULL\s0 on error.
.PP
\&\fIEVP_PKEY_meth_free()\fR and \fIEVP_PKEY_meth_copy()\fR do not return values.
.PP
\&\fIEVP_PKEY_meth_find()\fR returns a pointer to the found \fB\s-1EVP_PKEY_METHOD\s0\fR
object or returns \s-1NULL\s0 if not found.
.PP
\&\fIEVP_PKEY_meth_add0()\fR returns 1 if method is added successfully or 0
if an error occurred.
.PP
All EVP_PKEY_meth_set and EVP_PKEY_meth_get functions have no return
values. For the 'get' functions, function pointers are returned by
arguments.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the OpenSSL license (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
