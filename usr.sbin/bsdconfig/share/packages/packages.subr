if [ ! "$_PACKAGES_PACKAGES_SUBR" ]; then _PACKAGES_PACKAGES_SUBR=1
#
# Copyright (c) 2013 Devin Teske
# All Rights Reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $FreeBSD$
#
############################################################ INCLUDES

BSDCFG_SHARE="/usr/share/bsdconfig"
. $BSDCFG_SHARE/common.subr || exit 1
f_dprintf "%s: loading includes..." "$0"
f_include $BSDCFG_SHARE/dialog.subr
f_include $BSDCFG_SHARE/strings.subr
f_include $BSDCFG_SHARE/packages/categories.subr
f_include $BSDCFG_SHARE/packages/index.subr

BSDCFG_LIBE="/usr/libexec/bsdconfig"
f_include_lang $BSDCFG_LIBE/include/messages.subr

############################################################ CONFIGURATION

#
# How many packages to display (maximum) per dialog menubox.
#
: ${PACKAGE_MENU_PAGESIZE:=2000}

############################################################ GLOBALS

PACKAGE_CATEGORIES=
SELECTED_PACKAGES=

#
# Options
#
[ "${SHOW_DESC+set}" ] || SHOW_DESC=1

############################################################ FUNCTIONS

# eval f_package_accent_category_menu $var_to_set $CATEGORY_MENU_LIST
#
# Accent the CATEGORY_MENU_LIST produced by f_index_read() (see
# packages/index.subr). Accented information includes adding an asterisk to the
# category name if its index has been cached, adding the number of installed
# packages for each category, and adding the number _selected_ packages for
# each category.
#
# NOTE: The reason `eval' is recommended/shown for the syntax above is because
# the $CATEGORY_MENU_LIST generated by f_index_read() is meant to be expanded
# prior to execution (it contains a series of pre-quoted strings which act as
# the interpolated command arguments).
#
f_package_accent_category_menu()
{
	local var_to_set="$1" cat desc help varcat menu_buf n
	shift 1 # var_to_set
	while [ $# -gt 0 ]; do
		cat="${1%\*}" desc="${2%%; *}" help="$3"
		shift 3 # cat/desc/help

		cat="${cat# }" # Trim leading space inserted by sort-method
		f_str2varname "$cat" varcat

		# Add number of installed packages for this category (if any)
		n=0
		case "$cat" in
		"$msg_all") debug= f_getvar "_All_ninstalled" n ;;
		         *) debug= f_getvar "_${varcat}_ninstalled" n ;;
		esac &&
			[ $n -ge 1 ] && desc="$desc; $n $msg_installed_lc"

		# Add number of selected packages for this category (if any)
		n=0
		case "$cat" in
		"$msg_all") debug= f_getvar "_All_nselected" n ;;
		         *) debug= f_getvar "_${varcat}_nselected" n ;;
		esac &&
			[ $n -ge 1 ] && desc="$desc; $n $msg_selected"

		# Add an asterisk to the category if its index has been cached
		f_isset _index_page_${varcat}_1 && cat="$cat*"

		# Update buffer with modified elements
		menu_buf="$menu_buf
		'$cat' '$desc' '$help'" # End-Quote
	done
	setvar "$var_to_set" "$menu_buf" # return our buffer
}

# f_package_select $package ...
#
# Add $package to the list of tracked/selected packages. If $package is already
# being tracked (already apears in $SELECTED_PACKAGES), this function amounts
# to having no effect.
#
f_package_select()
{
	local package pkgsel
	while [ $# -gt 0 ]; do
		package="$1"
		shift 1 # package
		for pkgsel in $SELECTED_PACKAGES; do
			[ "$package" = "$pkgsel" ] && return
		done
		SELECTED_PACKAGES="$SELECTED_PACKAGES $package"
	done
	SELECTED_PACKAGES="${SELECTED_PACKAGES# }" # Trim leading space
}

# f_package_deselect $package ...
#
# Remove $package from teh list of tracked/selected packages. If $package is
# not being tracked (doesn't appear in $SELECTED_PACKAGES), this function
# amounts to having no effet.
#
f_package_deselect()
{
	local package pkgsel
	while [ $# -gt 1 ]; do
		local new_list=""
		package="$1"
		shift 1 # package
		for pkgsel in $SELECTED_PACKAGES; do
			[ "$pkgsel" = "$package" ] && continue
			new_list="$new_list${new_list:+ }$pkgsel"
		done
		SELECTED_PACKAGES="$new_list"
	done
}

# f_package_detect_installed
#
# Detect installed packages. Currently this searches /var/db/pkg for directory
# entries and marks each entry as an installed/selected package.
#
f_package_detect_installed()
{
	local installed package varpkg
	installed=$( find -s /var/db/pkg -mindepth 1 -maxdepth 1 -type d |
			sed -e 's:/var/db/pkg/::' )
	for package in $installed; do
		f_str2varname $package varpkg
		export _mark_$varpkg=X # exported for awk(1) ENVIRON[]
		f_package_select $package
	done
}

# f_package_calculate_totals
#
# Calculate number of installed/selected packages for each category listed in
# $PACKAGE_CATEGORIES (the number of installed packages for $category is stored
# as $_${varcat}_ninstalled -- where $varcat is the product of `f_str2varname
# $category varcat' -- and number selected packages as $_${varcat}_nselected).
# Also calculates the total number of installed/selected packages stored as
# $_All_ninstalled and $_All_nselected.
#
# Calculations are peformed by checking "marks". A "mark" is stored as
# $_mark_$varpkg -- where $varpkg is the product of `f_str2varname $package
# varpkg'. A mark can be "X" for an installed package, `I' for a package that
# is marked for installation, "R" for a package that is marked for re-install,
# and "U" for a package that is marked for uninstallation. If a package mark is
# NULL or a single space (e.g., " "), the package is considered to be NOT
# selected (and therefore does not increment the counts calculated herein).
#
f_package_calculate_totals()
{
	local pkg varpkg mark cat varcat pkgcat n tselected=0 tinstalled=0
	for cat in $PACKAGE_CATEGORIES; do
		f_str2varname $cat varcat
		setvar _${varcat}_ninstalled=0
		setvar _${varcat}_nselected=0
	done
	for pkg in $SELECTED_PACKAGES; do
		f_str2varname $pkg varpkg
		mark=
		f_getvar _mark_$varpkg mark
		case "$mark" in
		""|" ") : ;;
		X) tinstalled=$(( $tinstalled + 1 ));;
		*) tselected=$(( $tselected + 1 ))
		esac
		f_getvar _categories_$varpkg pkgcat
		for cat in $pkgcat; do
			f_str2varname $cat varcat
			case "$mark" in
			""|" ") : ;;
			X) debug= f_getvar _${varcat}_ninstalled n
			   setvar _${varcat}_ninstalled $(( $n + 1 ));;
			*) debug= f_getvar _${varcat}_nselected n
			   setvar _${varcat}_nselected $(( $n + 1 ))
			esac
		done
	done
	_All_nselected=$tselected
	_All_ninstalled=$tinstalled
}

# f_package_calculate_rundeps
#
# Update package dependencies by first unmarking all dependencies and then
# re-marking all dependencies of packages marked for either install ("I") or
# re-install ("R").
#
f_package_calculate_rundeps()
{
	local pkg varpkg mark rundeps dep vardep

	#
	# First unmark all the existing run-dependencies
	#
	f_dprintf "Unselecting package run-dependencies..."
	for pkg in $SELECTED_PACKAGES; do
		f_str2varname $pkg varpkg
		mark=
		debug= f_getvar _mark_$varpkg mark
		# Only unmark if it's marked as a Dependency
		if [ "$mark" = "D" ]; then
			f_dprintf "%s unselected" $pkg
			unset _mark_$varpkg
			f_package_deselect $pkg
		fi
	done

	#
	# Processes selected packages, adding dependencies
	#
	f_dprintf "Re-selecting package run-dependencies..."
	for pkg in $SELECTED_PACKAGES; do
		f_str2varname $pkg varpkg
		mark=
		debug= f_getvar _mark_$varpkg mark
		# Skip pkg unless marked for [Re-]Install
		[ "$mark" = "I" -o "$mark" = "R" ] || continue
		f_getvar _rundeps_$varpkg rundeps
		for dep in $rundeps; do
			f_str2varname $dep vardep
			mark=
			debug= f_getvar _mark_$vardep mark
			# Skip dep if already marked
			[ "${mark:- }" = " " ] || continue
			export _mark_$vardep="D"
			f_package_select $dep
		done
	done

	f_dprintf "Finished recalculating dependencies."
}

# f_package_menu_categories $var_to_set $defaultitem
#
# Dislay the menu of package categories, complete with package counts for each
# category, accents, and other miscellany. If $defaultitem is non-NULL and
# matches one of the existing menu-items, it will be pre-highlighted in the
# menu dialog (HINT: Use f_dialog_menutag() to populate a local variable that
# is passed as $defaultitem to highlight the user's last selection by default).
#
f_package_menu_categories()
{
	local var_to_get="$1" defaultitem="$2" category_list menu_list

	f_package_calculate_rundeps
		# updates package mark variables and SELECTED_PACKAGES
	f_package_calculate_totals
		# creates _{varcat}_ninstalled and _{varcat}_nselected

	debug= f_getvar "$var_to_get" category_list || return $FAILURE

	# Accent the category menu list with ninstalled/nselected
	eval f_package_accent_category_menu category_list $category_list

	local prompt="$msg_please_select_a_category_to_display"
	local hline=""

	menu_list="
		'> $msg_review' '$msg_review_desc' '$msg_review_help'
		$category_list
	" # End-Quote

	local size dialog_menu
	size=$( eval f_dialog_menu_with_help_size \
	        	\"\$DIALOG_TITLE\"     \
	        	\"\$DIALOG_BACKTITLE\" \
	        	\"\$prompt\"           \
	        	\"\$hline\"            \
	        	$menu_list             )
	dialog_menu=$( eval $DIALOG \
			--title \"\$DIALOG_TITLE\"         \
			--backtitle \"\$DIALOG_BACKTITLE\" \
			--hline \"\$hline\"                \
			--item-help                        \
			--default-item \"\$defaultitem\"   \
			--ok-label \"$msg_select\"         \
			--cancel-label \"$msg_cancel\"     \
			--menu \"\$prompt\" $size          \
			$menu_list                         \
			2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
		)
	local retval=$?
	setvar DIALOG_MENU_$$ "$dialog_menu"
	return $retval
}

# f_package_index_get_page $category $page [$var_to_set [$var_to_get]]
#
# Obtain a [potentially cached] page of the INDEX file for a given $category.
# If $page is 1 and the cache has not yet been generated, the cache-generating
# function f_index_extract_pages() (above) is called to generate all pages
# (not just the requested page) in cache before returning the requested page.
# If $page is not 1 and there is no cached page, failure status is returned.
#
f_package_index_get_page()
{
	local category="$1" page="$2" var_to_set="$3" var_to_get="$4" varcat
	f_str2varname "$category" varcat
	if ! debug= f_getvar "_index_page_${varcat}_$page" $var_to_set &&
	   [ "$page" = "1" ]
	then
		f_show_info "$msg_building_package_menus"
		local pagesize="$PACKAGE_MENU_PAGESIZE"
		f_index_extract_pages "${var_to_get:-PACKAGE_INDEX}" \
			_index_page_${varcat} "$pagesize" "$category"
		debug= f_getvar _index_page_${varcat}_$page $var_to_set

		# Update category default-item because now we're cached
		[ $page -eq 1 ] &&
		    category_defaultitem="${category_defaultitem%\*}*"
	else
		return $FAILURE
	fi
}

# f_package_menu_select $category [ $page [ $defaultitem ] ]
#
# Display list of packages for $category, optionally $page N and with a default
# item selected. If $page is omitted, the first page is displayed (but this
# only matters if there are multiple pages; which is determined by the global
# maximum $PACKAGE_MENU_PAGESIZE).
#
# On success, if the user doesn't press ESC or choose Cancel, the environment
# variable $DIALOG_MENUITEM_$$ will hold the item associated with the chosen
# tag (accessible through f_dialog_menutag()).
#
f_package_menu_select()
{
	local category="$1" page="${2:-1}" defaultitem="$3"
	local varcat npkgs=0 npages menu_list

	f_isinteger "$page" || return $FAILURE

	f_str2varname "$category" varcat
	f_package_index_get_page "$category" $page index_page

	# Get number of packages for this category
	case "$category" in
	"$msg_all"|"") npkgs="${_npkgs:-0}";;
	*) f_getvar _npkgs_$varcat npkgs
	esac

	# Calculate number of pages
	npages=$(( ${npkgs:=0} / $PACKAGE_MENU_PAGESIZE ))

	# Add a page to the pagecount if not evenly divisible
	[ $(( $npages * $PACKAGE_MENU_PAGESIZE )) -lt $npkgs ] &&
		npages=$(( $npages + 1 ))

	# Print some debugging information
	f_dprintf "f_package_menu_select: category=[%s] npkgs=%u npages=%u" \
	          "$category" "$npkgs" "$npages"

	local add_prev="" add_next=""
	local previous_page="$msg_previous_page" next_page="$msg_next_page"
	if [ $page -gt 1 ]; then
		add_prev=1
		# Accent the `Previous Page' item with an asterisk
		# if the page-before-previous is loaded/cached
		f_isset _index_page_${varcat}_$(( $page - 1 )) &&
			previous_page="$previous_page*"
	fi
	if [ $page -lt $npages ]; then
		add_next=1
		# Accent the `Next Page' item with an asterisk
		# if the page-after-next is loaded/cached
		f_isset _index_page_${varcat}_$(( $page + 1 )) &&
			next_page="$next_page*"
	fi

	menu_list="
		${add_prev:+'> $previous_page' '' ${SHOW_DESC:+''}}
		${add_next:+'> $next_page' '' ${SHOW_DESC:+''}}
	$(
		export SHOW_DESC
		export VALID_VARNAME_CHARS
		echo "$index_page" | awk -F'|' -v view="port" '
		BEGIN {
			valid_chars = ENVIRON["VALID_VARNAME_CHARS"]
			prefix = ""
		}
		{
			cur_prefix = tolower(substr($1, 1, 1))
			printf "'\''"
			if ( prefix != cur_prefix )
				prefix = cur_prefix
			else
				printf " "
			package = $1
			if ( view == "port" )
				desc = $2
			varpkg = package
			gsub("[^" valid_chars "]", "_", varpkg)
			mark = ENVIRON["_mark_" varpkg]
			if ( ! mark ) mark = " "
			printf "%s'\'' '\''[%c] %s'\''",
			       package, mark, desc
			if ( ENVIRON["SHOW_DESC"] ) {
				help = $4
				gsub(/'\''/, "'\''\\'\'\''", help)
				printf " '\''%s'\''", help
			}
			printf "\n"
		}'
	)
		${add_prev:+'> $previous_page' '' ${SHOW_DESC:+''}}
		${add_next:+'> $next_page' '' ${SHOW_DESC:+''}}
	" # End-Quote

	local prompt=""
	# Accept/Translate i18n "All" but other category names must
	# match tree definitions from INDEX, ports, FTP, etc.
	case "$category" in
	"$msg_all"|"") f_category_desc_get "All" prompt ;;
	            *) f_category_desc_get "$category" prompt ;;
	esac
	prompt="$prompt $( printf "$msg_page_of_npages" \
	                          "$page" "$npages" )"

	local hline="$hline_arrows_tab_punc_enter"
	local size isize dialog_menu item
	size=$( eval f_dialog_menu${SHOW_DESC:+_with_help}_size \
	        	\"\$DIALOG_TITLE\"     \
	        	\"\$DIALOG_BACKTITLE\" \
	        	\"\$prompt\"           \
	        	\"\$hline\"            \
	        	$menu_list             )
	isize=$( f_dialog_infobox_size \
	         	"$DIALOG_TITLE"             \
	         	"$DIALOG_BACKTITLE"         \
	         	"$msg_processing_selection" )
	dialog_menu=$( eval $DIALOG \
		--title \"\$DIALOG_TITLE\"         \
		--backtitle \"\$DIALOG_BACKTITLE\" \
		--hline \"\$hline\"                \
		--keep-tite                        \
		--ok-label \"$msg_select\"         \
		--cancel-label \"$msg_back\"       \
		${SHOW_DESC:+--item-help}          \
		--default-item \"\$defaultitem\"   \
		--menu \"\$prompt\" $size          \
		$menu_list                         \
		--and-widget                       \
		${USE_XDIALOG:+--no-buttons}       \
		--infobox \"\$msg_processing_selection\" $isize \
		2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
	)
	local retval=$?
	setvar DIALOG_MENU_$$ "$dialog_menu"

	if [ $retval -eq $SUCCESS ]; then
		item=$( eval f_dialog_menutag2item${SHOW_DESC:+_with_help} \
		             	\"\$dialog_menu\" $menu_list )
		setvar DIALOG_MENUITEM_$$ "$item"
	fi

	return $retval
}

# f_package_menu_deselect $package
#
# Display a menu, asking the user what they would like to do with $package
# with regard to "deselecting" an already installed package. Choices include
# uninstall, re-install, or cancel (leave $package marked as installed).
# Returns success if the user does not press ESC or choose Cnacel. Use the
# f_dialog_menutag() function upon success to retrieve the user's choice.
#
f_package_menu_deselect()
{
	local package="$1" prompt menu_list size dialog_menu
	prompt=$( printf "$msg_what_would_you_like_to_do_with" "$package" )
	local hline="$hline_alnum_arrows_punc_tab_enter"
	menu_list="
		'X $msg_installed' '$msg_installed_desc'
		'R $msg_reinstall' '$msg_reinstall_desc'
		'U $msg_uninstall' '$msg_uninstall_desc'
	" # End-Quote
	size=$( eval f_dialog_menu_size \
	         	\"\$DIALOG_TITLE\"     \
	         	\"\$DIALOG_BACKTITLE\" \
	         	\"\$prompt\"           \
	         	\"\$hline\"            \
	         	$menu_list             )
	dialog_menu=$( eval $DIALOG \
		--title \"\$DIALOG_TITLE\"         \
		--backtitle \"\$DIALOG_BACKTITLE\" \
		--hline \"\$hline\"                \
		--ok-label \"$msg_select\"         \
		--cancel-label \"$msg_cancel\"     \
		--menu \"\$prompt\" $size          \
		$menu_list                         \
		2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
	)
	local retval=$?
	setvar DIALOG_MENU_$$ "$dialog_menu"
	return $retval
}

# f_package_review
#
# Display a review screen, showing selected packages and what they are marked
# for, before proceeding (if the user does not press ESC or choose Cancel) to
# operate on each selection. Returns error if no packages have been selected,
# or the user has pressed ESC, or if they have chosen Cancel.
#
f_package_review()
{
	local prompt size dialog_menu package varpkg mark menu_list=
	prompt=$( printf "$msg_reviewing_selected_packages" \
	                 "$_All_nselected" )
	local hline="$hline_alnum_arrows_punc_tab_enter"
	f_dprintf "f_package_review: SELECTED_PACKAGES=[%s]" \
	          "$SELECTED_PACKAGES"
	for package in $SELECTED_PACKAGES; do
		mark=
		f_str2varname "$package" varpkg
		f_getvar _mark_$varpkg mark
		[ "$mark" -a ! "${mark#[IRUD]}" ] || continue
		menu_list="$menu_list
			'$mark' '$package'
		" # End-Quote
	done
	if [ ! "$menu_list" ]; then
		f_show_msg "$msg_no_packages_were_selected_for_extraction"
		return $FAILURE # They might have selected this by accident
	fi
	menu_list=$( echo "$menu_list" | sort )
	size=$( eval f_dialog_menu_size \
			\"\$DIALOG_TITLE\"     \
			\"\$DIALOG_BACKTITLE\" \
			\"\$prompt\"           \
			\"\$hline\"            \
			$menu_list             )
	dialog_menu=$( eval $DIALOG \
		--title \"\$DIALOG_TITLE\"         \
		--backtitle \"\$DIALOG_BACKTITLE\" \
		--hline \"\$hline\"                \
		--ok-label \"\$msg_proceed\"       \
		--cancel-label \"\$msg_cancel\"    \
		--menu \"\$prompt\" $size          \
		$menu_list                         \
		2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
	)
	local retval=$?
	setvar DIALOG_MENU_$$ "$dialog_menu"

	#
	# XXX
	#
	f_show_msg "Coming soon..."
	#
	# XXX
	#

	return $retval
}

# f_package_config
#
# Allow the user to configure packages and install them. Initially, a list of
# package categories is loaded/displayed. When the user selects a category,
# the menus for that category are built (unlike sysinstall which built all
# category menus up-front -- which also took forever, despite the fact that
# few people visit more than a couple of categories each time).
#
f_package_config()
{
	# Did we get an INDEX?
	f_index_initialize packages/INDEX || return $FAILURE
		# Creates following variables (indirectly via f_index_read())
		#   CATEGORY_MENU_LIST _categories_{varpkg} _rundeps_{varpkg}
		#   PACKAGE_CATEGORIES _npkgs

	# Detect installed packages (updates marks/SELECTED_PACKAGES)
	f_package_detect_installed

	local retval category varcat defaultitem category_defaultitem=""
	while :; do
		# Display the list of package categories
		f_package_menu_categories \
			CATEGORY_MENU_LIST "$category_defaultitem"
		retval=$?
		category=$( f_dialog_menutag )
		f_dprintf "retval=%u mtag=[%s]" $retval "$category"
		category_defaultitem="$category"

		[ $retval -eq $SUCCESS ] || break

		# Maybe the user chose an action (like `Review')
		case "$category" in
		"> $msg_review")
			f_package_review && break
			continue ;;
		"> "*)
			continue
		esac

		# Anything else is a package category

		category=${category# } # Trim leading space if present
		category=${category%\*} # Trim trailing asterisk if present

		f_str2varname "$category" varcat

		local page package varpkg mark
		while :; do
			# Display the list of packages for selected category
			page=1 defaultitem=""
			f_getvar _defaultitem_$varcat defaultitem
			f_getvar _defaultpage_$varcat page
			f_package_menu_select \
				"$category" "${page:=1}" "$defaultitem"
			retval=$?
			dialog_menu=$( f_dialog_menutag )
			f_dprintf "retval=%u mtag=[%s]" $retval "$dialog_menu"

			# NOTE: When --and-widget is used only ESC will cause
			# dialog(1) to return without going to the next widget.
			# This is alright in our case as we can still detect
			# the Cancel button because stdout will be NULL.
			# Alternatively, Xdialog(1) will terminate with 1
			# if/when Cancel is chosen on any widget.
			if [ $retval -eq 255 -o ! "$dialog_menu" ]; then
				# User pressed ESC or chose Cancel
				break
			elif [ $retval -eq 1 ]; then
				# Using X11, Xdialog(1) returned 1 for Cancel
				f_show_msg "%s" "$dialog_menu"
				break
			elif [ $retval -ne $SUCCESS ]; then
				# X11-related error occurred using Xdialog(1)
				f_show_msg "%s" "$dialog_menu"
				break
			fi

			defaultitem="$dialog_menu"

			# NOTE: f_package_menu_select() does not show the
			# `Previous Page' or `Next Page' items unless needed
			case "$dialog_menu" in
			"> $msg_previous_page"|"> $msg_previous_page*")
				page=$(( $page - 1 ))
				setvar _defaultpage_$varcat $page
				# Update default-item to match accent that will
				# be applied by f_package_menu_select(); if the
				# page-before-prev is cached, add an asterisk.
				if f_isset \
					_index_page_${varcat}_$(( $page - 1 ))
				then
					defaultitem="${defaultitem%\*}*"
				else
					defaultitem="${defaultitem%\*}"
				fi
				setvar _defaultitem_$varcat "$defaultitem"
				continue ;;
			"> $msg_next_page"|"> $msg_next_page*")
				page=$(( $page + 1 ))
				setvar _defaultpage_$varcat $page
				# Update default-item to match accent that will
				# be applied by f_package_menu_select(); if the
				# page-after-next is cached, add an asterisk.
				if f_isset \
					_index_page_${varcat}_$(( $page + 1 ))
				then
					defaultitem="${defaultitem%\*}*"
				else
					defaultitem="${defaultitem%\*}"
				fi
				setvar _defaultitem_$varcat "$defaultitem"
				continue ;;
			"> "*) # Unknown navigation/action item
				setvar _defaultpage_$varcat $page
				continue ;; # Do not treat as a package
			*)
				setvar _defaultitem_$varcat "$defaultitem"
			esac

			# Treat any other selection as a package
			package="${dialog_menu# }" # Trim leading space
			f_str2varname $package varpkg
			f_getvar DIALOG_MENUITEM_$$ mark
			mark="${mark#?}"
			mark="${mark%%\] *}"
			case "$mark" in
			"I")
				mark=" "
				f_package_deselect $package
				;;
			" "|"D")
				mark="I"
				f_package_select $package
				;;
			"X"|"R"|"U")
				f_package_menu_deselect $package || continue
				dialog_menu=$( f_dialog_menutag )
				case "$dialog_menu" in
				"X $msg_installed")
					f_package_deselect "$package"
					mark="X"
					;;
				"R $msg_reinstall")
					f_package_select "$package"
					mark="R"
					;;
				"U $msg_uninstall")
					f_package_select "$package"
					mark="U"
					;;
				esac
				;;
			esac
			export _mark_$varpkg="$mark"
				# NOTE: exported for awk(1) ENVIRON[]
		done
	done
}

############################################################ MAIN

f_dprintf "%s: Successfully loaded." packages/packages.subr

fi # ! $_PACKAGES_PACKAGES_SUBR
