.\"
.\"	$Id$
.\"
.Dd December 21, 1993
.Dt NTPDATE 8
.Os
.Sh NAME
.Nm ntpdate
.Nd set the date and time via NTP
.Sh SYNOPSIS
.Nm
.Op Fl bds
.Op Fl o Ar version
.Op Fl a Ar key#
.Op Fl e Ar authdelay
.Op Fl k Ar keyfile
.Op Fl p Ar samples
.Op Fl t Ar timeout
.Ar server ...
.Sh DESCRIPTION
.Nm Ntpdate
sets the local date and time by polling the Network Time Protocol
server(s) on the host(s) given as arguments to determine
the correct time.  It must be run as root on the local host.  A number
of samples are obtained from each of the servers specified and the
standard NTP clock filter and selection algorithms are applied to select
the best of these.  Typically,
.Nm
can be inserted in the
.Pa /etc/rc.local
startup up script to set the time of day at boot time and/or can be run
from time\-to\-time via
.Xr cron 8 .
Note that
.Nm Ns 's
reliability and precision will improve dramatically with greater numbers
of servers.  While a single server may be used, better performance and
greater resistance to insanity on the part of any one server
will be obtained by providing at least three or four servers, if not more.
.Pp
Time adjustments are made by
.Nm
in one of two ways.  If
.Nm
determines your clock is off by more than 0.5 seconds it will simply
step the time by calling
.Xr settimeofday 2 .
If the error is less than 0.5 seconds, however, it will by default slew
the clock's time via a call to
.Xr adjtime 2
with the offset.  The latter technique is less disruptive and more
accurate when the offset is small, and works quite well when
.Nm
is run by
.Xr cron 8
every hour or two.  The adjustment made in the latter
case is actually 50% larger than the measured offset since this will
tend to keep a badly drifting clock more accurate (at some expense to
stability, though this tradeoff is usually advantageous).  At boot time,
however, it is usually better to always step the time.  This can be forced
in all cases by specifying the
.Fl b
switch on the command line.  The
.Fl s
switch tells
.Nm
to log its actions via the
.Xr syslog 3
facility rather than to the standard output, a useful option when
running the program from
.Xr cron 8 .
.Pp
The
.Fl d
flag may be used to determine what
.Nm
will do without it actually doing it.  Information useful for general
debugging will also be printed.  By default
.Nm
claims to be an NTP version 3 implementation in its outgoing packets.  As
some older software will decline to respond to version 3 queries, the
.Fl o Ar version
switch can be used to force the program to poll as a version 2 or 1
implementation instead.
.Pp
The number of samples
.Nm
acquires from each server can be set to between 1 and 8 inclusive
using the
.Fl p
switch.  The default is 4.  The time it will spend waiting for a
response can be set using the
.Fl t
switch, and will be rounded to a multiple of 0.2 seconds.  The default
is 1 second, a value suitable for polling across a LAN.
.Pp
.Nm Ntpdate
will authenticate its transactions if need be.  The
.Fl a
switch specifies that all packets should be authenticated using the
key number indicated.  The
.Fl k
switch allows the name of the file from which the keys may be read
to be modified from the default of
.Pa /etc/ntp.keys .
This file should be in the format described in
.Xr xntpd 8 .
The
.Fl e
option allows the specification of an authentication processing delay,
in seconds (see
.Xr xntpd  8
for details).  This number is usually small enough to be negligible for
.Nm Ns 's
purposes, though specifying a value may improve timekeeping on very slow
CPU's.
.Pp
.Nm Ntpdate
will decline to set the date if an NTP server daemon (e.g.
.Xr xntpd 8 )
is running on the same host.  When running
.Nm
on a regular basis from
.Xr cron 8
as an alternative to running a daemon, doing so once every hour or two
will result in precise enough timekeeping to avoid stepping the clock.
.Sh FILES
.Bl -tag -width /etc/ntp.keys -compact
.It Pa /etc/ntp.keys
contains the encryption keys used by
.Nm Ns .
.El
.Sh SEE ALSO
.Xr xntpd 8
.Sh HISTORY
Written by
.An Dennis Ferguson
at the University of Toronto
.Sh BUGS
The technique used for improving accuracy by compensating for clock
oscillator errors sucks, but doing better would require the program
to save state from previous runs.
