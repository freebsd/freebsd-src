<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>HeimdalGSS-APIlibrary: Heimdal GSS-API functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<p>
<a href="http://www.h5l.org/"><img src="http://www.h5l.org/keyhole-heimdal.png" alt="keyhole logo"/></a>
</p>
<!-- end of header marker -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Heimdal GSS-API functions</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g233373d4e0baa31615eb4d4f0ccb9683">gss_add_oid_set_member</a> (OM_uint32 *minor_status, const gss_OID member_oid, gss_OID_set *oid_set)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#gb02ec963066cc8e5e6682799457208e9">gss_wrap_iov</a> (OM_uint32 *minor_status, gss_ctx_id_t context_handle, int conf_req_flag, gss_qop_t qop_req, int *conf_state, gss_iov_buffer_desc *iov, int iov_count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g399bb326e47574aca7b28d6886d29fd0">gss_unwrap_iov</a> (OM_uint32 *minor_status, gss_ctx_id_t context_handle, int *conf_state, gss_qop_t *qop_state, gss_iov_buffer_desc *iov, int iov_count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g6216cfcb1ba8dc2d1a1d680d21752f26">gss_wrap_iov_length</a> (OM_uint32 *minor_status, gss_ctx_id_t context_handle, int conf_req_flag, gss_qop_t qop_req, int *conf_state, gss_iov_buffer_desc *iov, int iov_count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g2dbb20a4c9a3cf5072ef081cd37e54b4">gss_release_iov_buffer</a> (OM_uint32 *minor_status, gss_iov_buffer_desc *iov, int iov_count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g06e9814b830ed2fc4a756775a5bfd943">gss_canonicalize_name</a> (OM_uint32 *minor_status, const gss_name_t input_name, const gss_OID mech_type, gss_name_t *output_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g0afe06fd5264ebfb93ecca4bcc70895b">gss_import_name</a> (OM_uint32 *minor_status, const gss_buffer_t input_name_buffer, const gss_OID input_name_type, gss_name_t *output_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g8eb94eab14874226b748710f833474eb">gss_init_sec_context</a> (OM_uint32 *minor_status, const gss_cred_id_t initiator_cred_handle, gss_ctx_id_t *context_handle, const gss_name_t target_name, const gss_OID input_mech_type, OM_uint32 req_flags, OM_uint32 time_req, const gss_channel_bindings_t input_chan_bindings, const gss_buffer_t input_token, gss_OID *actual_mech_type, gss_buffer_t output_token, OM_uint32 *ret_flags, OM_uint32 *time_rec)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#gdc725eaf82322d8cf50812fc26442893">gss_inquire_saslname_for_mech</a> (OM_uint32 *minor_status, const gss_OID desired_mech, gss_buffer_t sasl_mech_name, gss_buffer_t mech_name, gss_buffer_t mech_description)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#gf472671a43512495de04ca0c69079e5d">gss_inquire_attrs_for_mech</a> (OM_uint32 *minor_status, gss_const_OID mech, gss_OID_set *mech_attr, gss_OID_set *known_mech_attrs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION int <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#gc98677df7ae9bbc387cd68002a97ad15">gss_oid_equal</a> (gss_const_OID a, gss_const_OID b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#gd2990721c56fe83e06d45648874680d7">gss_release_cred</a> (OM_uint32 *minor_status, gss_cred_id_t *cred_handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g0691190338f1f24170bd5f695ff1e721">gss_release_name</a> (OM_uint32 *minor_status, gss_name_t *input_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GSSAPI_LIB_FUNCTION OM_uint32 <br>
GSSAPI_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g89a6d98056b75a8a25152de268833f51">gss_wrap</a> (OM_uint32 *minor_status, const gss_ctx_id_t context_handle, int conf_req_flag, gss_qop_t qop_req, const gss_buffer_t input_message_buffer, int *conf_state, gss_buffer_t output_message_buffer)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gss_OID_desc GSSAPI_LIB_FUNCTION&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gssapi.html#g961f7a7f9f92e06b91c6d503e524a672">__gss_c_attr_stream_sizes_oid_desc</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g233373d4e0baa31615eb4d4f0ccb9683"></a><!-- doxytag: member="gss_add_oid_set_member.c::gss_add_oid_set_member" ref="g233373d4e0baa31615eb4d4f0ccb9683" args="(OM_uint32 *minor_status, const gss_OID member_oid, gss_OID_set *oid_set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_add_oid_set_member           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_OID&nbsp;</td>
          <td class="paramname"> <em>member_oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_OID_set *&nbsp;</td>
          <td class="paramname"> <em>oid_set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a oid to the oid set, function does not make a copy of the oid, so the pointer to member_oid needs to be stable for the whole time oid_set is used.<p>
If there is a duplicate member of the oid, the new member is not added to to the set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status code. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>member_oid</em>&nbsp;</td><td>member to add to the oid set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oid_set</em>&nbsp;</td><td>oid set to add the member too</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a gss_error code, see gss_display_status() about printing the error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g06e9814b830ed2fc4a756775a5bfd943"></a><!-- doxytag: member="gss_canonicalize_name.c::gss_canonicalize_name" ref="g06e9814b830ed2fc4a756775a5bfd943" args="(OM_uint32 *minor_status, const gss_name_t input_name, const gss_OID mech_type, gss_name_t *output_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_canonicalize_name           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_name_t&nbsp;</td>
          <td class="paramname"> <em>input_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_OID&nbsp;</td>
          <td class="paramname"> <em>mech_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_name_t *&nbsp;</td>
          <td class="paramname"> <em>output_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
gss_canonicalize_name takes a Internal Name (IN) and converts in into a mechanism specific Mechanism Name (MN).<p>
The input name may multiple name, or generic name types.<p>
If the input_name if of the GSS_C_NT_USER_NAME, and the Kerberos mechanism is specified, the resulting MN type is a GSS_KRB5_NT_PRINCIPAL_NAME.<p>
For more information about <a class="el" href="internalvsmechname.html">internalVSmechname</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status code. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_name</em>&nbsp;</td><td>name to covert, unchanged by <a class="el" href="group__gssapi.html#g06e9814b830ed2fc4a756775a5bfd943">gss_canonicalize_name()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mech_type</em>&nbsp;</td><td>the type to convert Name too. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output_name</em>&nbsp;</td><td>the resulting type, release with <a class="el" href="group__gssapi.html#g0691190338f1f24170bd5f695ff1e721">gss_release_name()</a>, independent of input_name.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a gss_error code, see gss_display_status() about printing the error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0afe06fd5264ebfb93ecca4bcc70895b"></a><!-- doxytag: member="gss_import_name.c::gss_import_name" ref="g0afe06fd5264ebfb93ecca4bcc70895b" args="(OM_uint32 *minor_status, const gss_buffer_t input_name_buffer, const gss_OID input_name_type, gss_name_t *output_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_import_name           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_buffer_t&nbsp;</td>
          <td class="paramname"> <em>input_name_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_OID&nbsp;</td>
          <td class="paramname"> <em>input_name_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_name_t *&nbsp;</td>
          <td class="paramname"> <em>output_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Import a name internal or mechanism name<p>
Type of name and their format:<ul>
<li>GSS_C_NO_OID</li><li>GSS_C_NT_USER_NAME</li><li>GSS_C_NT_HOSTBASED_SERVICE</li><li>GSS_C_NT_EXPORT_NAME</li><li>GSS_C_NT_ANONYMOUS</li><li>GSS_KRB5_NT_PRINCIPAL_NAME</li></ul>
<p>
For more information about <a class="el" href="internalvsmechname.html">internalVSmechname</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_name_buffer</em>&nbsp;</td><td>import name buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_name_type</em>&nbsp;</td><td>type of the import name buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output_name</em>&nbsp;</td><td>the resulting type, release with <a class="el" href="group__gssapi.html#g0691190338f1f24170bd5f695ff1e721">gss_release_name()</a>, independent of input_name</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a gss_error code, see gss_display_status() about printing the error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8eb94eab14874226b748710f833474eb"></a><!-- doxytag: member="gss_init_sec_context.c::gss_init_sec_context" ref="g8eb94eab14874226b748710f833474eb" args="(OM_uint32 *minor_status, const gss_cred_id_t initiator_cred_handle, gss_ctx_id_t *context_handle, const gss_name_t target_name, const gss_OID input_mech_type, OM_uint32 req_flags, OM_uint32 time_req, const gss_channel_bindings_t input_chan_bindings, const gss_buffer_t input_token, gss_OID *actual_mech_type, gss_buffer_t output_token, OM_uint32 *ret_flags, OM_uint32 *time_rec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_init_sec_context           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_cred_id_t&nbsp;</td>
          <td class="paramname"> <em>initiator_cred_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_ctx_id_t *&nbsp;</td>
          <td class="paramname"> <em>context_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_name_t&nbsp;</td>
          <td class="paramname"> <em>target_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_OID&nbsp;</td>
          <td class="paramname"> <em>input_mech_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OM_uint32&nbsp;</td>
          <td class="paramname"> <em>req_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OM_uint32&nbsp;</td>
          <td class="paramname"> <em>time_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_channel_bindings_t&nbsp;</td>
          <td class="paramname"> <em>input_chan_bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_buffer_t&nbsp;</td>
          <td class="paramname"> <em>input_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_OID *&nbsp;</td>
          <td class="paramname"> <em>actual_mech_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_buffer_t&nbsp;</td>
          <td class="paramname"> <em>output_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>ret_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>time_rec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
As the initiator build a context with an acceptor.<p>
Returns in the major<ul>
<li>GSS_S_COMPLETE - if the context if build</li><li>GSS_S_CONTINUE_NEEDED - if the caller needs to continue another round of gss_i nit_sec_context</li><li>error code - any other error code</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status code.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initiator_cred_handle</em>&nbsp;</td><td>the credential to use when building the context, if GSS_C_NO_CREDENTIAL is passed, the default credential for the mechanism will be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_handle</em>&nbsp;</td><td>a pointer to a context handle, will be returned as long as there is not an error.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target_name</em>&nbsp;</td><td>the target name of acceptor, created using <a class="el" href="group__gssapi.html#g0afe06fd5264ebfb93ecca4bcc70895b">gss_import_name()</a>. The name is can be of any name types the mechanism supports, check supported name types with gss_inquire_names_for_mech().</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_mech_type</em>&nbsp;</td><td>mechanism type to use, if GSS_C_NO_OID is used, Kerberos (GSS_KRB5_MECHANISM) will be tried. Other available mechanism are listed in the <a class="el" href="gssapi_mechs_intro.html">GSS-API mechanisms</a> section.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req_flags</em>&nbsp;</td><td>flags using when building the context, see <a class="el" href="gssapi_services_intro.html#gssapi_context_flags">Context creation flags</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time_req</em>&nbsp;</td><td>time requested this context should be valid in seconds, common used value is GSS_C_INDEFINITE</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_chan_bindings</em>&nbsp;</td><td>Channel bindings used, if not exepected otherwise, used GSS_C_NO_CHANNEL_BINDINGS</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_token</em>&nbsp;</td><td>input token sent from the acceptor, for the initial packet the buffer of { NULL, 0 } should be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>actual_mech_type</em>&nbsp;</td><td>the actual mech used, MUST NOT be freed since it pointing to static memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output_token</em>&nbsp;</td><td>if there is an output token, regardless of complete, continue_needed, or error it should be sent to the acceptor</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ret_flags</em>&nbsp;</td><td>return what flags was negotitated, caller should check if they are accetable. For example, if GSS_C_MUTUAL_FLAG was negotiated with the acceptor or not.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time_rec</em>&nbsp;</td><td>amount of time this context is valid for</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a gss_error code, see gss_display_status() about printing the error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf472671a43512495de04ca0c69079e5d"></a><!-- doxytag: member="gss_mo.c::gss_inquire_attrs_for_mech" ref="gf472671a43512495de04ca0c69079e5d" args="(OM_uint32 *minor_status, gss_const_OID mech, gss_OID_set *mech_attr, gss_OID_set *known_mech_attrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_inquire_attrs_for_mech           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_const_OID&nbsp;</td>
          <td class="paramname"> <em>mech</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_OID_set *&nbsp;</td>
          <td class="paramname"> <em>mech_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_OID_set *&nbsp;</td>
          <td class="paramname"> <em>known_mech_attrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List support attributes for a mech and/or all mechanisms.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mech</em>&nbsp;</td><td>given together with mech_attr will return the list of attributes for mechanism, can optionally be GSS_C_NO_OID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mech_attr</em>&nbsp;</td><td>see mech parameter, can optionally be NULL, release with gss_release_oid_set(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>known_mech_attrs</em>&nbsp;</td><td>all attributes for mechanisms supported, release with gss_release_oid_set(). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gdc725eaf82322d8cf50812fc26442893"></a><!-- doxytag: member="gss_mo.c::gss_inquire_saslname_for_mech" ref="gdc725eaf82322d8cf50812fc26442893" args="(OM_uint32 *minor_status, const gss_OID desired_mech, gss_buffer_t sasl_mech_name, gss_buffer_t mech_name, gss_buffer_t mech_description)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_inquire_saslname_for_mech           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_OID&nbsp;</td>
          <td class="paramname"> <em>desired_mech</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_buffer_t&nbsp;</td>
          <td class="paramname"> <em>sasl_mech_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_buffer_t&nbsp;</td>
          <td class="paramname"> <em>mech_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_buffer_t&nbsp;</td>
          <td class="paramname"> <em>mech_description</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns different protocol names and description of the mechanism.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>desired_mech</em>&nbsp;</td><td>mech list query </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sasl_mech_name</em>&nbsp;</td><td>SASL GS2 protocol name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mech_name</em>&nbsp;</td><td>gssapi protocol name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mech_description</em>&nbsp;</td><td>description of gssapi mech</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns GSS_S_COMPLETE or a error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc98677df7ae9bbc387cd68002a97ad15"></a><!-- doxytag: member="gss_oid_equal.c::gss_oid_equal" ref="gc98677df7ae9bbc387cd68002a97ad15" args="(gss_const_OID a, gss_const_OID b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION int GSSAPI_LIB_CALL gss_oid_equal           </td>
          <td>(</td>
          <td class="paramtype">gss_const_OID&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_const_OID&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two GSS-API OIDs with each other.<p>
GSS_C_NO_OID matches nothing, not even it-self.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>first oid to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>second oid to compare</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>non-zero when both oid are the same OID, zero when they are not the same. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd2990721c56fe83e06d45648874680d7"></a><!-- doxytag: member="gss_release_cred.c::gss_release_cred" ref="gd2990721c56fe83e06d45648874680d7" args="(OM_uint32 *minor_status, gss_cred_id_t *cred_handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_release_cred           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_cred_id_t *&nbsp;</td>
          <td class="paramname"> <em>cred_handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a credentials<p>
Its ok to release the GSS_C_NO_CREDENTIAL/NULL credential, it will return a GSS_S_COMPLETE error code. On return cred_handle is set ot GSS_C_NO_CREDENTIAL.<p>
Example:<p>
<div class="fragment"><pre class="fragment"> gss_cred_id_t cred = GSS_C_NO_CREDENTIAL;
 major = <a class="code" href="group__gssapi.html#gd2990721c56fe83e06d45648874680d7">gss_release_cred</a>(&amp;minor, &amp;cred);
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status return code, mech specific </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cred_handle</em>&nbsp;</td><td>a pointer to the credential too release</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an gssapi error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2dbb20a4c9a3cf5072ef081cd37e54b4"></a><!-- doxytag: member="gss_aeap.c::gss_release_iov_buffer" ref="g2dbb20a4c9a3cf5072ef081cd37e54b4" args="(OM_uint32 *minor_status, gss_iov_buffer_desc *iov, int iov_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_release_iov_buffer           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_iov_buffer_desc *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iov_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free all buffer allocated by <a class="el" href="group__gssapi.html#gb02ec963066cc8e5e6682799457208e9">gss_wrap_iov()</a> or <a class="el" href="group__gssapi.html#g399bb326e47574aca7b28d6886d29fd0">gss_unwrap_iov()</a> by looking at the GSS_IOV_BUFFER_FLAG_ALLOCATED flag. 
</div>
</div><p>
<a class="anchor" name="g0691190338f1f24170bd5f695ff1e721"></a><!-- doxytag: member="gss_release_name.c::gss_release_name" ref="g0691190338f1f24170bd5f695ff1e721" args="(OM_uint32 *minor_status, gss_name_t *input_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_release_name           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_name_t *&nbsp;</td>
          <td class="paramname"> <em>input_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a name<p>
import_name can point to NULL or be NULL, or a pointer to a gss_name_t structure. If it was a pointer to gss_name_t, the pointer will be set to NULL on success and failure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_name</em>&nbsp;</td><td>name to free</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a gss_error code, see gss_display_status() about printing the error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g399bb326e47574aca7b28d6886d29fd0"></a><!-- doxytag: member="gss_aeap.c::gss_unwrap_iov" ref="g399bb326e47574aca7b28d6886d29fd0" args="(OM_uint32 *minor_status, gss_ctx_id_t context_handle, int *conf_state, gss_qop_t *qop_state, gss_iov_buffer_desc *iov, int iov_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_unwrap_iov           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_ctx_id_t&nbsp;</td>
          <td class="paramname"> <em>context_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>conf_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_qop_t *&nbsp;</td>
          <td class="paramname"> <em>qop_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_iov_buffer_desc *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iov_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrypt or verifies the signature on the data. 
</div>
</div><p>
<a class="anchor" name="g89a6d98056b75a8a25152de268833f51"></a><!-- doxytag: member="gss_wrap.c::gss_wrap" ref="g89a6d98056b75a8a25152de268833f51" args="(OM_uint32 *minor_status, const gss_ctx_id_t context_handle, int conf_req_flag, gss_qop_t qop_req, const gss_buffer_t input_message_buffer, int *conf_state, gss_buffer_t output_message_buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_wrap           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_ctx_id_t&nbsp;</td>
          <td class="paramname"> <em>context_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>conf_req_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_qop_t&nbsp;</td>
          <td class="paramname"> <em>qop_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gss_buffer_t&nbsp;</td>
          <td class="paramname"> <em>input_message_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>conf_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_buffer_t&nbsp;</td>
          <td class="paramname"> <em>output_message_buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrap a message using either confidentiality (encryption + signature) or sealing (signature).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor_status</em>&nbsp;</td><td>minor status code. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_handle</em>&nbsp;</td><td>context handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf_req_flag</em>&nbsp;</td><td>if non zero, confidentiality is requestd. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qop_req</em>&nbsp;</td><td>type of protection needed, in most cases it GSS_C_QOP_DEFAULT should be passed in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_message_buffer</em>&nbsp;</td><td>messages to wrap </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf_state</em>&nbsp;</td><td>returns non zero if confidentiality was honoured. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output_message_buffer</em>&nbsp;</td><td>the resulting buffer, release with gss_release_buffer(). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb02ec963066cc8e5e6682799457208e9"></a><!-- doxytag: member="gss_aeap.c::gss_wrap_iov" ref="gb02ec963066cc8e5e6682799457208e9" args="(OM_uint32 *minor_status, gss_ctx_id_t context_handle, int conf_req_flag, gss_qop_t qop_req, int *conf_state, gss_iov_buffer_desc *iov, int iov_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_wrap_iov           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_ctx_id_t&nbsp;</td>
          <td class="paramname"> <em>context_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>conf_req_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_qop_t&nbsp;</td>
          <td class="paramname"> <em>qop_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>conf_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_iov_buffer_desc *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iov_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encrypts or sign the data.<p>
This is a more complicated version of <a class="el" href="group__gssapi.html#g89a6d98056b75a8a25152de268833f51">gss_wrap()</a>, it allows the caller to use AEAD data (signed header/trailer) and allow greater controll over where the encrypted data is placed.<p>
The maximum packet size is gss_context_stream_sizes.max_msg_size.<p>
The caller needs provide the folloing buffers when using in conf_req_flag=1 mode:<p>
<ul>
<li>HEADER (of size gss_context_stream_sizes.header) { DATA or SIGN_ONLY } (optional, zero or more) PADDING (of size gss_context_stream_sizes.blocksize, if zero padding is zero, can be omitted) TRAILER (of size gss_context_stream_sizes.trailer)</li></ul>
<p>
<ul>
<li>on DCE-RPC mode, the caller can skip PADDING and TRAILER if the DATA elements is padded to a block bountry and header is of at least size gss_context_stream_sizes.header + gss_context_stream_sizes.trailer.</li></ul>
<p>
HEADER, PADDING, TRAILER will be shrunken to the size required to transmit any of them too large.<p>
To generate <a class="el" href="group__gssapi.html#g89a6d98056b75a8a25152de268833f51">gss_wrap()</a> compatible packets, use: HEADER | DATA | PADDING | TRAILER<p>
When used in conf_req_flag=0,<p>
<ul>
<li>HEADER (of size gss_context_stream_sizes.header) { DATA or SIGN_ONLY } (optional, zero or more) PADDING (of size gss_context_stream_sizes.blocksize, if zero padding is zero, can be omitted) TRAILER (of size gss_context_stream_sizes.trailer)</li></ul>
<p>
The input sizes of HEADER, PADDING and TRAILER can be fetched using <a class="el" href="group__gssapi.html#g6216cfcb1ba8dc2d1a1d680d21752f26">gss_wrap_iov_length()</a> or gss_context_query_attributes(). 
</div>
</div><p>
<a class="anchor" name="g6216cfcb1ba8dc2d1a1d680d21752f26"></a><!-- doxytag: member="gss_aeap.c::gss_wrap_iov_length" ref="g6216cfcb1ba8dc2d1a1d680d21752f26" args="(OM_uint32 *minor_status, gss_ctx_id_t context_handle, int conf_req_flag, gss_qop_t qop_req, int *conf_state, gss_iov_buffer_desc *iov, int iov_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSSAPI_LIB_FUNCTION OM_uint32 GSSAPI_LIB_CALL gss_wrap_iov_length           </td>
          <td>(</td>
          <td class="paramtype">OM_uint32 *&nbsp;</td>
          <td class="paramname"> <em>minor_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_ctx_id_t&nbsp;</td>
          <td class="paramname"> <em>context_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>conf_req_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_qop_t&nbsp;</td>
          <td class="paramname"> <em>qop_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>conf_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gss_iov_buffer_desc *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iov_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the length fields in iov buffer for the types:<ul>
<li>GSS_IOV_BUFFER_TYPE_HEADER</li><li>GSS_IOV_BUFFER_TYPE_PADDING</li><li>GSS_IOV_BUFFER_TYPE_TRAILER</li></ul>
<p>
Consider using gss_context_query_attributes() to fetch the data instead. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g961f7a7f9f92e06b91c6d503e524a672"></a><!-- doxytag: member="gss_aeap.c::__gss_c_attr_stream_sizes_oid_desc" ref="g961f7a7f9f92e06b91c6d503e524a672" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gss_OID_desc GSSAPI_LIB_FUNCTION <a class="el" href="group__gssapi.html#g961f7a7f9f92e06b91c6d503e524a672">__gss_c_attr_stream_sizes_oid_desc</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    {10, rk_UNCONST(<span class="stringliteral">"\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x03"</span>)}
</pre></div>Query the context for parameters.<p>
SSPI equivalent if this function is QueryContextAttributes.<p>
<ul>
<li>GSS_C_ATTR_STREAM_SIZES data is a gss_context_stream_sizes. </li></ul>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Wed Jan 11 14:07:44 2012 for HeimdalGSS-APIlibrary by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6</small></address>
</body>
</html>
