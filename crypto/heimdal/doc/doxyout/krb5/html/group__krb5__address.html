<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>HeimdalKerberos5library: Heimdal Kerberos 5 address functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<p>
<a href="http://www.h5l.org/"><img src="http://www.h5l.org/keyhole-heimdal.png" alt="keyhole logo"/></a>
</p>
<!-- end of header marker -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Heimdal Kerberos 5 address functions</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#gec34704845bdaee3c08ebba2fa87d61e">krb5_sockaddr2address</a> (krb5_context context, const struct sockaddr *sa, krb5_address *addr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g76125115a2c040a3f70a4f66eada77aa">krb5_sockaddr2port</a> (krb5_context context, const struct sockaddr *sa, int16_t *port)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g88b9c3052f35dc5a44fdfe9747c36cc5">krb5_addr2sockaddr</a> (krb5_context context, const krb5_address *addr, struct sockaddr *sa, krb5_socklen_t *sa_size, int port)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION size_t <br>
KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g55bd20d9a185cf7963e2117c1c804c85">krb5_max_sockaddr_size</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION krb5_boolean <br>
KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#gc4c55c7ef3d078993b0177649593088c">krb5_sockaddr_uninteresting</a> (const struct sockaddr *sa)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g51cd06ac365188aa989256b99b706f80">krb5_h_addr2sockaddr</a> (krb5_context context, int af, const char *addr, struct sockaddr *sa, krb5_socklen_t *sa_size, int port)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#gb8901409302e9e7bb95187e4d5e6a179">krb5_h_addr2addr</a> (krb5_context context, int af, const char *haddr, krb5_address *addr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g9cfbb00b2bed85766f86b63541cc7752">krb5_anyaddr</a> (krb5_context context, int af, struct sockaddr *sa, krb5_socklen_t *sa_size, int port)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g6e9adff4c8738f92fa2637698c06ccb9">krb5_print_address</a> (const krb5_address *addr, char *str, size_t len, size_t *ret_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#gd7bc7e348e6d36c4cf09dcd2ee5a92a3">krb5_parse_address</a> (krb5_context context, const char *string, krb5_addresses *addresses)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION int KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#gc743b9d3c7e4a1f71659ffd28b1fd9fb">krb5_address_order</a> (krb5_context context, const krb5_address *addr1, const krb5_address *addr2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION krb5_boolean <br>
KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g7771724e9a25914395dabac15b705e33">krb5_address_compare</a> (krb5_context context, const krb5_address *addr1, const krb5_address *addr2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION krb5_boolean <br>
KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#ge2720bd07b737e73c8b6924403e5b7e1">krb5_address_search</a> (krb5_context context, const krb5_address *addr, const krb5_addresses *addrlist)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g705d91f9f2a2311b656371e553af66a3">krb5_free_address</a> (krb5_context context, krb5_address *address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g3b5f1c170a4af0de561bc30486983cc5">krb5_free_addresses</a> (krb5_context context, krb5_addresses *addresses)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#gf965da6155d3b086a6ca2e47b391f5df">krb5_copy_address</a> (krb5_context context, const krb5_address *inaddr, krb5_address *outaddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g8b73a9ee0e1259a7f10809b329483b85">krb5_copy_addresses</a> (krb5_context context, const krb5_addresses *inaddr, krb5_addresses *outaddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#gf56d02edcc81b3edd3c5a1e2e16e99e3">krb5_append_addresses</a> (krb5_context context, krb5_addresses *dest, const krb5_addresses *source)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#gc50ffb71832862424c35c1ace9bbe14d">krb5_make_addrport</a> (krb5_context context, krb5_address **res, const krb5_address *addr, int16_t port)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">KRB5_LIB_FUNCTION <br>
krb5_error_code KRB5_LIB_CALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__krb5__address.html#g3164f6fcff3b1029b93d316e14b017cf">krb5_address_prefixlen_boundary</a> (krb5_context context, const krb5_address *inaddr, unsigned long prefixlen, krb5_address *low, krb5_address *high)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g88b9c3052f35dc5a44fdfe9747c36cc5"></a><!-- doxytag: member="addr_families.c::krb5_addr2sockaddr" ref="g88b9c3052f35dc5a44fdfe9747c36cc5" args="(krb5_context context, const krb5_address *addr, struct sockaddr *sa, krb5_socklen_t *sa_size, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_addr2sockaddr           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_socklen_t *&nbsp;</td>
          <td class="paramname"> <em>sa_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_addr2sockaddr sets the "struct sockaddr sockaddr" from addr and port. The argument sa_size should initially contain the size of the sa and after the call, it will contain the actual length of the address. In case of the sa is too small to fit the whole address, the up to *sa_size will be stored, and then *sa_size will be set to the required length.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>the address to copy the from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sa</em>&nbsp;</td><td>the struct sockaddr that will be filled in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sa_size</em>&nbsp;</td><td>pointer to length of sa, and after the call, it will contain the actual length of the address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>set port in sa.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. Will return KRB5_PROG_ATYPE_NOSUPP in case address type is not supported. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7771724e9a25914395dabac15b705e33"></a><!-- doxytag: member="addr_families.c::krb5_address_compare" ref="g7771724e9a25914395dabac15b705e33" args="(krb5_context context, const krb5_address *addr1, const krb5_address *addr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL krb5_address_compare           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_address_compare compares the addresses addr1 and addr2. Returns TRUE if the two addresses are the same.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr1</em>&nbsp;</td><td>address to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr2</em>&nbsp;</td><td>address to compare</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an TRUE is the address are the same FALSE if not </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc743b9d3c7e4a1f71659ffd28b1fd9fb"></a><!-- doxytag: member="addr_families.c::krb5_address_order" ref="gc743b9d3c7e4a1f71659ffd28b1fd9fb" args="(krb5_context context, const krb5_address *addr1, const krb5_address *addr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION int KRB5_LIB_CALL krb5_address_order           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_address_order compares the addresses addr1 and addr2 so that it can be used for sorting addresses. If the addresses are the same address krb5_address_order will return 0. Behavies like memcmp(2).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr1</em>&nbsp;</td><td>krb5_address to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr2</em>&nbsp;</td><td>krb5_address to compare</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt; 0 if address addr1 in "less" then addr2. 0 if addr1 and addr2 is the same address, &gt; 0 if addr2 is "less" then addr1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3164f6fcff3b1029b93d316e14b017cf"></a><!-- doxytag: member="addr_families.c::krb5_address_prefixlen_boundary" ref="g3164f6fcff3b1029b93d316e14b017cf" args="(krb5_context context, const krb5_address *inaddr, unsigned long prefixlen, krb5_address *low, krb5_address *high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_address_prefixlen_boundary           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>inaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>prefixlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_address *&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_address *&nbsp;</td>
          <td class="paramname"> <em>high</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the boundary addresses of `inaddr'/`prefixlen' and store them in `low' and `high'.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inaddr</em>&nbsp;</td><td>address in prefixlen that the bondery searched </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefixlen</em>&nbsp;</td><td>width of boundery </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>low</em>&nbsp;</td><td>lowest address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>high</em>&nbsp;</td><td>highest address</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge2720bd07b737e73c8b6924403e5b7e1"></a><!-- doxytag: member="addr_families.c::krb5_address_search" ref="ge2720bd07b737e73c8b6924403e5b7e1" args="(krb5_context context, const krb5_address *addr, const krb5_addresses *addrlist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL krb5_address_search           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_addresses *&nbsp;</td>
          <td class="paramname"> <em>addrlist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_address_search checks if the address addr is a member of the address set list addrlist .<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>address to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrlist</em>&nbsp;</td><td>list of addresses to look in for addr.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9cfbb00b2bed85766f86b63541cc7752"></a><!-- doxytag: member="addr_families.c::krb5_anyaddr" ref="g9cfbb00b2bed85766f86b63541cc7752" args="(krb5_context context, int af, struct sockaddr *sa, krb5_socklen_t *sa_size, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_anyaddr           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_socklen_t *&nbsp;</td>
          <td class="paramname"> <em>sa_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_anyaddr fills in a "struct sockaddr sa" that can be used to bind(2) to. The argument sa_size should initially contain the size of the sa, and after the call, it will contain the actual length of the address.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>af</em>&nbsp;</td><td>address family </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sa</em>&nbsp;</td><td>sockaddr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sa_size</em>&nbsp;</td><td>lenght of sa. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>for to fill into sa.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf56d02edcc81b3edd3c5a1e2e16e99e3"></a><!-- doxytag: member="addr_families.c::krb5_append_addresses" ref="gf56d02edcc81b3edd3c5a1e2e16e99e3" args="(krb5_context context, krb5_addresses *dest, const krb5_addresses *source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_append_addresses           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_addresses *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_addresses *&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_append_addresses adds the set of addresses in source to dest. While copying the addresses, duplicates are also sorted out.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination of copy operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>adresses that are going to be added to dest</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf965da6155d3b086a6ca2e47b391f5df"></a><!-- doxytag: member="addr_families.c::krb5_copy_address" ref="gf965da6155d3b086a6ca2e47b391f5df" args="(krb5_context context, const krb5_address *inaddr, krb5_address *outaddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_copy_address           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>inaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_address *&nbsp;</td>
          <td class="paramname"> <em>outaddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_copy_address copies the content of address inaddr to outaddr.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inaddr</em>&nbsp;</td><td>pointer to source address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outaddr</em>&nbsp;</td><td>pointer to destination address</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8b73a9ee0e1259a7f10809b329483b85"></a><!-- doxytag: member="addr_families.c::krb5_copy_addresses" ref="g8b73a9ee0e1259a7f10809b329483b85" args="(krb5_context context, const krb5_addresses *inaddr, krb5_addresses *outaddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_copy_addresses           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_addresses *&nbsp;</td>
          <td class="paramname"> <em>inaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_addresses *&nbsp;</td>
          <td class="paramname"> <em>outaddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_copy_addresses copies the content of addresses inaddr to outaddr.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inaddr</em>&nbsp;</td><td>pointer to source addresses </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outaddr</em>&nbsp;</td><td>pointer to destination addresses</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g705d91f9f2a2311b656371e553af66a3"></a><!-- doxytag: member="addr_families.c::krb5_free_address" ref="g705d91f9f2a2311b656371e553af66a3" args="(krb5_context context, krb5_address *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_free_address           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_address *&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_free_address frees the data stored in the address that is alloced with any of the krb5_address functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>addresss to be freed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3b5f1c170a4af0de561bc30486983cc5"></a><!-- doxytag: member="addr_families.c::krb5_free_addresses" ref="g3b5f1c170a4af0de561bc30486983cc5" args="(krb5_context context, krb5_addresses *addresses)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_free_addresses           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_addresses *&nbsp;</td>
          <td class="paramname"> <em>addresses</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_free_addresses frees the data stored in the address that is alloced with any of the krb5_address functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addresses</em>&nbsp;</td><td>addressses to be freed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb8901409302e9e7bb95187e4d5e6a179"></a><!-- doxytag: member="addr_families.c::krb5_h_addr2addr" ref="gb8901409302e9e7bb95187e4d5e6a179" args="(krb5_context context, int af, const char *haddr, krb5_address *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_h_addr2addr           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>haddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_h_addr2addr works like krb5_h_addr2sockaddr with the exception that it operates on a krb5_address instead of a struct sockaddr.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>af</em>&nbsp;</td><td>address family </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>haddr</em>&nbsp;</td><td>host address from struct hostent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>returned krb5_address.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g51cd06ac365188aa989256b99b706f80"></a><!-- doxytag: member="addr_families.c::krb5_h_addr2sockaddr" ref="g51cd06ac365188aa989256b99b706f80" args="(krb5_context context, int af, const char *addr, struct sockaddr *sa, krb5_socklen_t *sa_size, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_h_addr2sockaddr           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_socklen_t *&nbsp;</td>
          <td class="paramname"> <em>sa_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_h_addr2sockaddr initializes a "struct sockaddr sa" from af and the "struct hostent" (see gethostbyname(3) ) h_addr_list component. The argument sa_size should initially contain the size of the sa, and after the call, it will contain the actual length of the address.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>af</em>&nbsp;</td><td>addresses </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sa</em>&nbsp;</td><td>returned struct sockaddr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sa_size</em>&nbsp;</td><td>size of sa </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>port to set in sa.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc50ffb71832862424c35c1ace9bbe14d"></a><!-- doxytag: member="addr_families.c::krb5_make_addrport" ref="gc50ffb71832862424c35c1ace9bbe14d" args="(krb5_context context, krb5_address **res, const krb5_address *addr, int16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_make_addrport           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_address **&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an address of type KRB5_ADDRESS_ADDRPORT from (addr, port)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>built address from addr/port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>address to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>port to use</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g55bd20d9a185cf7963e2117c1c804c85"></a><!-- doxytag: member="addr_families.c::krb5_max_sockaddr_size" ref="g55bd20d9a185cf7963e2117c1c804c85" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION size_t KRB5_LIB_CALL krb5_max_sockaddr_size           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_max_sockaddr_size returns the max size of the .Li struct sockaddr that the Kerberos library will return.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an size_t of the maximum struct sockaddr. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd7bc7e348e6d36c4cf09dcd2ee5a92a3"></a><!-- doxytag: member="addr_families.c::krb5_parse_address" ref="gd7bc7e348e6d36c4cf09dcd2ee5a92a3" args="(krb5_context context, const char *string, krb5_addresses *addresses)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_parse_address           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_addresses *&nbsp;</td>
          <td class="paramname"> <em>addresses</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_parse_address returns the resolved hostname in string to the krb5_addresses addresses .<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addresses</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6e9adff4c8738f92fa2637698c06ccb9"></a><!-- doxytag: member="addr_families.c::krb5_print_address" ref="g6e9adff4c8738f92fa2637698c06ccb9" args="(const krb5_address *addr, char *str, size_t len, size_t *ret_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_print_address           </td>
          <td>(</td>
          <td class="paramtype">const krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>ret_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_print_address prints the address in addr to the string string that have the length len. If ret_len is not NULL, it will be filled with the length of the string if size were unlimited (not including the final NUL) .<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>address to be printed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>pointer string to print the address into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length that will fit into area pointed to by "str". </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ret_len</em>&nbsp;</td><td>return length the str.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gec34704845bdaee3c08ebba2fa87d61e"></a><!-- doxytag: member="addr_families.c::krb5_sockaddr2address" ref="gec34704845bdaee3c08ebba2fa87d61e" args="(krb5_context context, const struct sockaddr *sa, krb5_address *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_sockaddr2address           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">krb5_address *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_sockaddr2address stores a address a "struct sockaddr" sa in the krb5_address addr.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sa</em>&nbsp;</td><td>a struct sockaddr to extract the address from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>an Kerberos 5 address to store the address in.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g76125115a2c040a3f70a4f66eada77aa"></a><!-- doxytag: member="addr_families.c::krb5_sockaddr2port" ref="g76125115a2c040a3f70a4f66eada77aa" args="(krb5_context context, const struct sockaddr *sa, int16_t *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_sockaddr2port           </td>
          <td>(</td>
          <td class="paramtype">krb5_context&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_sockaddr2port extracts a port (if possible) from a "struct sockaddr.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>a Keberos context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sa</em>&nbsp;</td><td>a struct sockaddr to extract the port from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>a pointer to an int16_t store the port in.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return an error code or 0. Will return KRB5_PROG_ATYPE_NOSUPP in case address type is not supported. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc4c55c7ef3d078993b0177649593088c"></a><!-- doxytag: member="addr_families.c::krb5_sockaddr_uninteresting" ref="gc4c55c7ef3d078993b0177649593088c" args="(const struct sockaddr *sa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL krb5_sockaddr_uninteresting           </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>sa</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
krb5_sockaddr_uninteresting returns TRUE for all .Fa sa that the kerberos library thinks are uninteresting. One example are link local addresses.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sa</em>&nbsp;</td><td>pointer to struct sockaddr that might be interesting.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return a non zero for uninteresting addresses. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Wed Jan 11 14:07:47 2012 for HeimdalKerberos5library by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6</small></address>
</body>
</html>
