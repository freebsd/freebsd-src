#
# This is the default initialization file for more(1).  To avoid any need to
# change the manpage or helpfile, almost all commands maintain their historical
# keymappings.  Some additional twoggles may be added that will be left for
# the intrepid user to discover.
#
# This file is compiled directly into more; changing this file will not change
# the actual defaults (unless it is changed in the source directory and more
# is recompiled).  The correct way to change the global defaults is by
# adding a /etc/dot.morerc global initialization file.
#
# In general, the average user is not expected have any interest in changing
# default keybindings.
# 
# If you use an ~/.morerc that is dependent on specific features of this
# default morerc, you should copy this default morerc to ~/.defmorerc so that
# possible future changes in this file do not cause problems for you.  The
# ~/.defmorerc file will cause the compiled-in default morerc to be ignored.
#
# The default initialization file is compiled into more(1) so that more(1)
# will work and be usable even if the filesystem (and the location
# /usr/share/misc/default.morerc, where this would be stored if it was not
# compiled into more(1)) is missing or away without leave (chroot directory,
# fs crash, badly written rescue floppy, or any other reason).
#
# BUGS: a) There is no documentation (this is arguably a feature).
#       b) There is no "map" command.
#
# $FreeBSD$
#

# The "deftog" is required to initialize more(1).
#
# Each of the toggle variables in the proceeding list will be initialized.
# A toggle variable "togvar" will be initialized into two variables:
# ${togvar_s} and ${togvar_n}.  The _s variant will hold a string representing
# the toggle state, and the _n variant will hold a number representing the
# toggle state.  The toggle states are numbered from 0 to n, in the order
# listed for the toggle.
#
# _ls_direction		forw back	direction of last search
# _ls_sense		noinvert invert	find match/non-matching to last search
# _wraplines		off on		currently wrapping lines?
# _statprompt		on off		currently displaying the long prompt?
#
# If the fact that "off on" is in a different order from "on off" bothers
# you, then you are probably abusing the variables.
#
# Additionally, the following variables are set,
#
# ${_curhscroll}	number of columns scrolled horizontally
# ${_ls_regexp}		regular expression from the last search
#

deftog


#
# basic internal initialization for things used inside this file
#
set lsthscr 1
# Add "set hkey_scroll true" to ~/.morerc to enable all the hjkl keys (but
# disabling h)elp).
set hkey_scroll false
set scr_scroll 0
# We have no way of resetting this on SIGWINCH as the old more A_H_SCROLL did
# It's probably just as well...  (since resetting would lose the old value!)
# (Actually, we could emulate it from here if we really wanted to).
set half_scroll (${_sc_height} / 2)
# magic number indicating the value is not initialized
set savedhscroll 87382

macro 1 j	'forw_scroll ${number}'
macro 1 k	'back_scroll ${number}'
macro 1 \e[B	'forw_scroll ${number}'
macro 1 \e[A	'back_scroll ${number}'
macro 1 \n	'forw_scroll ${number}'
macro 1 \e[G	'forw (${_sc_height} * ${number})'
macro 1 \e[I	'back (${_sc_height} * ${number})'
set com_getscr	'condition (${number} != 0);      \
             	   set scr_scroll ${number};      \
             	 condition (${number} == 0);      \
             	   set scr_scroll ${_sc_height};  \
             	 condition true;'
macro 0 " "	'eval ${com_getscr}; forw ${scr_scroll};'
macro 0 f	'eval ${com_getscr}; forw ${scr_scroll};'
macro 0 ""	'eval ${com_getscr}; forw ${scr_scroll};'
macro 0 b	'eval ${com_getscr}; back ${scr_scroll};'
macro 0 ""	'eval ${com_getscr}; back ${scr_scroll};'
set com_sethalfscroll	'condition (${number} != 0);   \
         		   set half_scroll ${number};  \
         		 condition true;'
macro 0 d	'eval ${com_sethalfscroll}; forw_scroll ${half_scroll}'
macro 0 ""	'eval ${com_sethalfscroll}; forw_scroll ${half_scroll}'
macro 0 u	'eval ${com_sethalfscroll}; back_scroll ${half_scroll}'
macro 0 ""	'eval ${com_sethalfscroll}; back_scroll ${half_scroll}'
# An argument can be made that we should move by whatever tab was set to
# using the -x argument to more(1)
macro 1 "\t"	'rscroll (${number} * 8)'
macro 1 '[Z'	'lscroll (${number} * 8)'
set com_rscroll	'condition (${number} != 0);  \
         	   set lsthscr ${number};     \
         	 condition true;              \
         	 rscroll ${lsthscr};'
set com_lscroll	'condition (${number} != 0);  \
         	   set lsthscr ${number};     \
         	 condition true;              \
         	 lscroll ${lsthscr};'
# this little trick lets the user simply set hkey_scroll=true in their own
# ~/.morerc file to enable the 'l' and 'h' keys the way Bill meant them
macro 0 h	'condition ${hkey_scroll};   eval ${com_lscroll};      \
         	 condition_! ${hkey_scroll}; help;                     \
          	 condition true;'
macro 0 l	'condition ${hkey_scroll};   eval ${com_rscroll};      \
         	 condition_! ${hkey_scroll}; error "key not enabled";  \
          	 condition true;'
macro 0 :help	'help'
macro 0 \e[C	'eval ${com_rscroll}'
macro 0 \e[D	'eval ${com_lscroll}'
macro 0 \e[H	'condition (${_wraplines_n} && (${savedhscroll} != 87382));  \
            	   rscroll 1;                                                \
            	   rscroll ${savedhscroll};                                  \
            	 condition_toggle;                                           \
            	   set savedhscroll ${_curhscroll};                          \
            	   lscroll ${_curhscroll};                                   \
             	   lscroll 1;                                                \
            	 condition true;'
macro 1 n	'research ${_ls_direction_n} ${number}'
macro 1 N	'research (${_ls_direction_n} + 1) ${number}'
macro 1 /	'magicasksearch forw ${number}'
macro 1 ?	'magicasksearch back ${number}'
macro 0 G	'condition (${number} == 0); goend;             \
         	 condition (${number} != 0); goline ${number};  \
         	 condition true;'
macro 1 g	'goline ${number}'
macro 0 p	'gopercent ${number}'
macro 0 %	'gopercent ${number}'
macro 0 \e[F	'goend'
# Quote  since it's technically an isspace() character
macro 0 ""	'repaint'
macro 0 r	'repaint'
macro 0 R	'flush'
macro 0 v	'edit'
macro 0 :e	'askfile'
macro 0 E	'askfile'
# The old keymaping for 'N'
#macro 1 N	'file next ${number}'
macro 1 :n	'file next ${number}'
macro 1 P	'file prev ${number}'
macro 1 :p	'file prev ${number}'
macro 0 :a	'file_list'
macro 0 m	'setmark ?'
macro 0 \'	'gomark ?'
macro 0 :t	'asktag'
macro 1 t	'nexttag ${number}'
macro 1 T	'prevtag ${number}'
macro 0 ""	'stat (${_statprompt_n} + 1)'
macro 0 =	'stat (${_statprompt_n} + 1)'
macro 0 q	'quit'
macro 0 :q	'quit'
macro 0 ZZ	'quit'
# This command intentionally disabled by default.  The command parser is
# too baroque to expose hapless users to.
#macro 0 ::	'usercom'
