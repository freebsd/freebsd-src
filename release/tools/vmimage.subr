#!/bin/sh
#
#
#
# Common functions for virtual machine image build scripts.
#

scriptdir=$(dirname $(realpath $0))
. ${scriptdir}/../scripts/tools.subr
. ${scriptdir}/../../tools/boot/install-boot.sh

export PATH="/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
trap "cleanup" INT QUIT TRAP ABRT TERM

# Platform-specific large-scale setup
# Most platforms use GPT, so put that as default, then special cases
PARTSCHEME=gpt
ROOTLABEL="gpt"
case "${TARGET}:${TARGET_ARCH}" in
	powerpc:powerpc*)
		PARTSCHEME=mbr
		ROOTLABEL="ufs"
		NOSWAP=yes # Can't label swap partition with MBR, so no swap
	;;
esac

err() {
	printf "${@}\n"
	cleanup
	return 1
}

cleanup() {
	if [ -c "${DESTDIR}/dev/null" ]; then
		umount_loop ${DESTDIR}/dev 2>/dev/null
	fi

	return 0
}

metalog_add_data() {
	local file mode type

	if [ -n "${NO_ROOT}" ]; then
		file=$1
		if [ -f ${DESTDIR}/${file} ]; then
			type=file
			mode=${2:-0644}
		elif [ -d ${DESTDIR}/${file} ]; then
			type=dir
			mode=${2:-0755}
		else
			echo "metalog_add_data: ${file} not found" >&2
			return 1
		fi
		echo "${file} type=${type} uname=root gname=wheel mode=${mode}" >> \
		    ${DESTDIR}/METALOG
	fi
}

vm_create_base() {

	mkdir -p ${DESTDIR}

	return 0
}

vm_copy_base() {
	# Defunct
	return 0
}

vm_base_packages_list() {
	# Output a list of package sets equivalent to what we get from
	# "installworld installkernel distribution", aka. the full base
	# system.
	for S in base kernels; do
		echo FreeBSD-set-$S
		echo FreeBSD-set-$S-dbg
	done
	case ${TARGET_ARCH} in
	amd64 | aarch64 | powerpc64)
		echo FreeBSD-set-lib32
		echo FreeBSD-set-lib32-dbg
	esac
	echo FreeBSD-set-tests
}

vm_extra_filter_base_packages() {
	# Prototype. When overridden, allows further filtering of base system
	# packages, reading package names from stdin and writing to stdout.
	cat
}

vm_install_base() {
	# Installs the FreeBSD userland/kernel to the virtual machine disk.

	if [ -z "${NOPKGBASE}" ]; then
		local pkg_cmd
		pkg_cmd="${PKG_CMD} --rootdir ${DESTDIR} --repo-conf-dir ${PKGBASE_REPO_DIR}
			-o ASSUME_ALWAYS_YES=yes -o IGNORE_OSVERSION=yes
			-o ABI=${PKG_ABI} -o INSTALL_AS_USER=yes "
		if [ -n "${NO_ROOT}" ]; then
			pkg_cmd="$pkg_cmd -o METALOG=METALOG"
		fi
		$pkg_cmd update
		selected=$(vm_base_packages_list | vm_extra_filter_base_packages)
		$pkg_cmd install -U -r FreeBSD-base $selected
		metalog_add_data ./var/db/pkg/local.sqlite
		mkdir -p ${DESTDIR}/usr/local/etc/pkg/repos
		echo 'FreeBSD-base: { enabled: yes }' > ${DESTDIR}/usr/local/etc/pkg/repos/FreeBSD.conf
		metalog_add_data ./usr/local/etc/pkg/repos
		metalog_add_data ./usr/local/etc/pkg/repos/FreeBSD.conf
	else
		cd ${WORLDDIR} && \
			make DESTDIR=${DESTDIR} ${INSTALLOPTS} \
			installworld installkernel distribution || \
			err "\n\nCannot install the base system to ${DESTDIR}."
	fi

	# Bootstrap etcupdate(8) database.
	mkdir -p ${DESTDIR}/var/db/etcupdate
	etcupdate extract -B \
		-M "TARGET=${TARGET} TARGET_ARCH=${TARGET_ARCH}" \
		-s ${WORLDDIR} -d ${DESTDIR}/var/db/etcupdate \
		-L /dev/stdout ${NO_ROOT:+-N}
	if [ -n "${NO_ROOT}" ]; then
		# Reroot etcupdate's internal METALOG to the whole tree
		sed -n 's,^\.,./var/db/etcupdate/current,p' \
		    ${DESTDIR}/var/db/etcupdate/current/METALOG | \
		    env -i LC_COLLATE=C sort >> ${DESTDIR}/METALOG
		rm ${DESTDIR}/var/db/etcupdate/current/METALOG
	fi

	echo '# Custom /etc/fstab for FreeBSD VM images' \
		> ${DESTDIR}/etc/fstab
	if [ "${VMFS}" != zfs ]; then
		echo "/dev/${ROOTLABEL}/rootfs   /       ${VMFS}   rw,noatime      1       1" \
			>> ${DESTDIR}/etc/fstab
	fi
	if [ -z "${NOSWAP}" ]; then
		echo '/dev/gpt/swapfs  none    swap    sw      0       0' \
			>> ${DESTDIR}/etc/fstab
	fi
	metalog_add_data ./etc/fstab

	local hostname
	hostname="$(echo $(uname -o) | tr '[:upper:]' '[:lower:]')"
	echo "hostname=\"${hostname}\"" >> ${DESTDIR}/etc/rc.conf
	metalog_add_data ./etc/rc.conf
	if [ "${VMFS}" = zfs ]; then
		echo "zfs_enable=\"YES\"" >> ${DESTDIR}/etc/rc.conf
		echo "zpool_reguid=\"zroot\"" >> ${DESTDIR}/etc/rc.conf
		echo "zpool_upgrade=\"zroot\"" >> ${DESTDIR}/etc/rc.conf
		echo "kern.geom.label.disk_ident.enable=0" >> ${DESTDIR}/boot/loader.conf
		echo "zfs_load=YES" >> ${DESTDIR}/boot/loader.conf
		metalog_add_data ./boot/loader.conf
	fi

	return 0
}

vm_emulation_setup() {
	if [ -n "${WITHOUT_QEMU}" ]; then
		return 0
	fi
	if [ -n "${QEMUSTATIC}" ]; then
		export EMULATOR=/qemu
		cp ${QEMUSTATIC} ${DESTDIR}/${EMULATOR}
	fi

	mkdir -p ${DESTDIR}/dev
	mount -t devfs devfs ${DESTDIR}/dev
	chroot ${DESTDIR} ${EMULATOR} /bin/sh /etc/rc.d/ldconfig forcestart
	cp /etc/resolv.conf ${DESTDIR}/etc/resolv.conf

	return 0
}

vm_extra_install_base() {
	# Prototype.  When overridden, runs extra post-installworld commands
	# as needed, based on the target virtual machine image or cloud
	# provider image target.

	return 0
}

vm_extra_enable_services() {
	if [ -n "${VM_RC_LIST}" ]; then
		for _rcvar in ${VM_RC_LIST}; do
			echo ${_rcvar}_enable="YES" >> ${DESTDIR}/etc/rc.conf
		done
	fi

	if [ -z "${VMCONFIG}" -o -c "${VMCONFIG}" ]; then
		echo 'ifconfig_DEFAULT="DHCP inet6 accept_rtadv"' >> \
			${DESTDIR}/etc/rc.conf
		# Expand the filesystem to fill the disk.
		echo 'growfs_enable="YES"' >> ${DESTDIR}/etc/rc.conf
	fi

	return 0
}

vm_extra_install_packages() {
	if [ -z "${VM_EXTRA_PACKAGES}" ]; then
		return 0
	fi
	if [ -n "${NO_ROOT}" ]; then
		for pkg in ${VM_EXTRA_PACKAGES}; do
			INSTALL_AS_USER=yes \
			${PKG_CMD} \
			    -o ABI=${PKG_ABI} \
			    -o METALOG=${DESTDIR}/METALOG.pkg \
			    -o REPOS_DIR=${PKG_REPOS_DIR} \
			    -o PKG_DBDIR=${DESTDIR}/var/db/pkg \
			    -r ${DESTDIR} \
			    install -y -r ${PKG_REPO_NAME} $pkg
		done
		INSTALL_AS_USER=yes \
		${PKG_CMD} \
		    -o ABI=${PKG_ABI} \
		    -o REPOS_DIR=${PKG_REPOS_DIR} \
		    -o PKG_DBDIR=${DESTDIR}/var/db/pkg \
		    -r ${DESTDIR} \
		    autoremove -y
		if [ -n "${NOPKGBASE}" ]; then
			metalog_add_data ./var/db/pkg/local.sqlite
		fi
	else
		if [ -n "${WITHOUT_QEMU}" ]; then
			return 0
		fi

		chroot ${DESTDIR} ${EMULATOR} env ASSUME_ALWAYS_YES=yes \
			/usr/sbin/pkg bootstrap -y
		for p in ${VM_EXTRA_PACKAGES}; do
			chroot ${DESTDIR} ${EMULATOR} env ASSUME_ALWAYS_YES=yes \
				/usr/sbin/pkg install -y ${p}
		done
		chroot ${DESTDIR} ${EMULATOR} env ASSUME_ALWAYS_YES=yes \
		    /usr/sbin/pkg autoremove -y
	fi

	return 0
}

vm_extra_install_ports() {
	# Prototype.  When overridden, installs additional ports within the
	# virtual machine environment.

	return 0
}

vm_extra_pre_umount() {
	# Prototype.  When overridden, performs additional tasks within the
	# virtual machine environment prior to unmounting the filesystem.

	return 0
}

vm_emulation_cleanup() {
	if [ -n "${WITHOUT_QEMU}" ]; then
		return 0
	fi

	if ! [ -z "${QEMUSTATIC}" ]; then
		rm -f ${DESTDIR}/${EMULATOR}
	fi
	rm -f ${DESTDIR}/etc/resolv.conf
	umount_loop ${DESTDIR}/dev
	return 0
}

vm_extra_pkg_rmcache() {
	if [ -n "${NO_ROOT}" ]; then
		${PKG_CMD} \
		    -o ASSUME_ALWAYS_YES=yes \
		    -o INSTALL_AS_USER=yes \
		    -r ${DESTDIR} \
		    clean -y -a
	else
		if [ -e ${DESTDIR}/usr/local/sbin/pkg ]; then
			chroot ${DESTDIR} ${EMULATOR} env ASSUME_ALWAYS_YES=yes \
			    /usr/local/sbin/pkg clean -y -a
		fi
	fi

	return 0
}

buildfs() {
	local md tmppool

	# Copy entries from METALOG.pkg into METALOG, but first check to
	# make sure that filesystem objects still exist; some things may
	# have been logged which no longer exist if a package was removed.
	if [ -f ${DESTDIR}/METALOG.pkg ]; then
		while read F REST; do
			if [ -e ${DESTDIR}/${F} ]; then
				echo "${F} ${REST}" >> ${DESTDIR}/METALOG
			fi
		done < ${DESTDIR}/METALOG.pkg
	fi

	if [ -n "${NO_ROOT}" ]; then
		# Check for any directories in the staging tree which weren't
		# recorded in METALOG, and record them now.  This is a quick hack
		# to avoid creating unusable VM images and should go away once
		# the bugs which produce such unlogged directories are gone.
		grep type=dir ${DESTDIR}/METALOG |
		    cut -f 1 -d ' ' |
		    sort -u > ${DESTDIR}/METALOG.dirs
		( cd ${DESTDIR} && find . -type d ) |
		    sort |
		    comm -23 - ${DESTDIR}/METALOG.dirs > ${DESTDIR}/METALOG.missingdirs
		if [ -s ${DESTDIR}/METALOG.missingdirs ]; then
			echo "WARNING: Directories exist but were not in METALOG"
			cat ${DESTDIR}/METALOG.missingdirs
		fi
		while read DIR; do
			metalog_add_data ${DIR}
		done < ${DESTDIR}/METALOG.missingdirs

		if [ -z "${NOPKGBASE}" ]; then
			# Add some database files which are created by pkg triggers;
			# at some point in the future the tools which create these
			# files should probably learn how to record them in METALOG
			# (which would simplify no-root installworld as well).
			metalog_add_data ./etc/login.conf.db
			metalog_add_data ./etc/passwd
			metalog_add_data ./etc/pwd.db
			metalog_add_data ./etc/spwd.db 600
			metalog_add_data ./var/db/services.db
		fi

		if [ -n "${MISSING_METALOGS}" ]; then
			# Hack to allow VM configurations to add files which
			# weren't being added to METALOG appropriately.  This
			# is mainly a workaround for the @sample bug and it
			# should go away before FreeBSD 15.1 ships.
			for P in ${MISSING_METALOGS}; do
				metalog_add_data ${P}
			done
		fi

		# Sort METALOG file; makefs produces directories with 000 permissions
		# if their contents are seen before the directories themselves.
		env -i LC_COLLATE=C sort -u ${DESTDIR}/METALOG > ${DESTDIR}/METALOG.sorted
		mv ${DESTDIR}/METALOG.sorted ${DESTDIR}/METALOG
	fi

	case "${VMFS}" in
	ufs)
		cd ${DESTDIR} && ${MAKEFS} ${MAKEFSARGS} -o label=rootfs -o version=2 -o softupdates=1 \
			${VMBASE} .${NO_ROOT:+/METALOG}
		;;
	zfs)
		cd ${DESTDIR} && ${MAKEFS} -t zfs ${MAKEFSARGS} \
			-o poolname=zroot -o bootfs=zroot/ROOT/default -o rootpath=/ \
			-o fs=zroot\;mountpoint=none \
			-o fs=zroot/ROOT\;mountpoint=none \
			-o fs=zroot/ROOT/default\;mountpoint=/\;canmount=noauto \
			-o fs=zroot/home\;mountpoint=/home \
			-o fs=zroot/tmp\;mountpoint=/tmp\;exec=on\;setuid=off \
			-o fs=zroot/usr\;mountpoint=/usr\;canmount=off \
			-o fs=zroot/usr/ports\;setuid=off \
			-o fs=zroot/usr/src \
			-o fs=zroot/usr/obj \
			-o fs=zroot/var\;mountpoint=/var\;canmount=off \
			-o fs=zroot/var/audit\;setuid=off\;exec=off \
			-o fs=zroot/var/crash\;setuid=off\;exec=off \
			-o fs=zroot/var/log\;setuid=off\;exec=off \
			-o fs=zroot/var/mail\;atime=on \
			-o fs=zroot/var/tmp\;setuid=off \
			${VMBASE} .${NO_ROOT:+/METALOG}
		;;
	*)
		echo "Unexpected VMFS value '${VMFS}'"
		exit 1
		;;
	esac
}

umount_loop() {
	DIR=$1
	i=0
	sync
	while ! umount ${DIR}; do
		i=$(( $i + 1 ))
		if [ $i -ge 10 ]; then
			# This should never happen.  But, it has happened.
			echo "Cannot umount(8) ${DIR}"
			echo "Something has gone horribly wrong."
			return 1
		fi
		sleep 1
	done

	return 0
}

vm_create_disk() {
	local BOOTFILES BOOTPARTSOFFSET FSPARTTYPE X86GPTBOOTFILE

	if [ -z "${NOSWAP}" ]; then
		SWAPOPT="-p freebsd-swap/swapfs::${SWAPSIZE}"
	fi

	if [ -n "${VM_BOOTPARTSOFFSET}" ]; then
		BOOTPARTSOFFSET=":${VM_BOOTPARTSOFFSET}"
	fi

	if [ -n "${CONFIG_DRIVE}" ]; then
		CONFIG_DRIVE="-p freebsd/config-drive::${CONFIG_DRIVE_SIZE}"
	fi

	case "${VMFS}" in
	ufs)
		FSPARTTYPE=freebsd-ufs
		X86GPTBOOTFILE=i386/gptboot/gptboot
		;;
	zfs)
		FSPARTTYPE=freebsd-zfs
		X86GPTBOOTFILE=i386/gptzfsboot/gptzfsboot
		;;
	*)
		echo "Unexpected VMFS value '${VMFS}'"
		return 1
		;;
	esac

	echo "Creating image...  Please wait."
	echo

	BOOTFILES="$(env TARGET=${TARGET} TARGET_ARCH=${TARGET_ARCH} \
		WITH_UNIFIED_OBJDIR=yes \
		make -C ${WORLDDIR}/stand -V .OBJDIR)"
	BOOTFILES="$(realpath ${BOOTFILES})"
	MAKEFSARGS="-s ${VMSIZE} -D"

	case "${TARGET}:${TARGET_ARCH}" in
		amd64:amd64 | i386:i386)
			ESP=yes
			BOOTPARTS="-b ${BOOTFILES}/i386/pmbr/pmbr \
				   -p freebsd-boot/bootfs:=${BOOTFILES}/${X86GPTBOOTFILE}${BOOTPARTSOFFSET}"
			ROOTFSPART="-p ${FSPARTTYPE}/rootfs:=${VMBASE}"
			MAKEFSARGS="$MAKEFSARGS -B little"
			;;
		arm:armv7 | arm64:aarch64 | riscv:riscv64*)
			ESP=yes
			BOOTPARTS=
			ROOTFSPART="-p ${FSPARTTYPE}/rootfs:=${VMBASE}"
			MAKEFSARGS="$MAKEFSARGS -B little"
			;;
		powerpc:powerpc*)
			ESP=no
			BOOTPARTS="-p prepboot:=${BOOTFILES}/powerpc/boot1.chrp/boot1.elf -a 1"
			ROOTFSPART="-p freebsd:=${VMBASE}"
			if [ ${TARGET_ARCH} = powerpc64le ]; then
				MAKEFSARGS="$MAKEFSARGS -B little"
			else
				MAKEFSARGS="$MAKEFSARGS -B big"
			fi
			;;
		*)
			echo "vmimage.subr: unsupported target '${TARGET}:${TARGET_ARCH}'" >&2
			exit 1
			;;
	esac

	if [ ${ESP} = "yes" ]; then
		# Create an ESP
		espfilename=$(mktemp /tmp/efiboot.XXXXXX)
		make_esp_file ${espfilename} ${fat32min} ${BOOTFILES}/efi/loader_lua/loader_lua.efi
		espsuffix=""
		if [ -z "${BOOTPARTS}" ]; then
			espsuffix="${BOOTPARTSOFFSET}"
		fi
		BOOTPARTS="${BOOTPARTS} -p efi/efiboot0:=${espfilename}${espsuffix}"

		# Add this to fstab
		mkdir -p ${DESTDIR}/boot/efi
		echo "/dev/${ROOTLABEL}/efiboot0	/boot/efi       msdosfs     rw      2       2" \
			>> ${DESTDIR}/etc/fstab
	fi

	# Add a marker file which indicates that this image has never
	# been booted.  Some services run only upon the first boot.
	touch ${DESTDIR}/firstboot
	metalog_add_data ./firstboot

	echo "Building filesystem...  Please wait."
	buildfs

	echo "Building final disk image...  Please wait."
	${MKIMG} -s ${PARTSCHEME} -f ${VMFORMAT} \
		${BOOTPARTS} \
		${SWAPOPT} \
		${CONFIG_DRIVE} \
		${ROOTFSPART} \
		-o ${VMIMAGE}

	echo "Disk image ${VMIMAGE} created."

	if [ ${ESP} = "yes" ]; then
		rm ${espfilename}
	fi

	return 0
}

vm_extra_create_disk() {

	return 0
}
