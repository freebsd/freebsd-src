#! /bin/sh -

# $FreeBSD$
#
# stage1 -- this script prepares the actual picobsd image

. ../Version

set -e	# abort in case of untested errors

# if you include the floppy tree in the mfs, you
# can boot from the image via diskless.
INCLUDE_FLOPPY_IN_MFS="yes"

# By default, /tmp should exist.
#
MFS_NAME=fs.PICOBSD
MFS_MOUNTPOINT=`mktemp -d "/tmp/picobsd.XXXXXXXXXX"`
export MFS_MOUNTPOINT

PICO_OBJ=${OBJ}/picobsd/${TYPE}
export PICO_OBJ

# Location of the boot blocks (in case you want them custom-built)
boot1=/boot/boot1
boot2=/boot/boot2

rm -f kernel.gz ${MFS_NAME}    # cleanup...

# find a suitable vnode
VNUM=`mount | awk "/vn/ { num++ } END { printf \"%d\", num }"`
export VNUM
echo "-> Using vn${VNUM}..."

trap fail 2	# catch user interrupt

# free as much as possible from the vnode
free_vnode() {
    umount ${MFS_MOUNTPOINT} 2> /dev/null || true
    umount /dev/vn${VNUM} 2> /dev/null || true
    vnconfig -u /dev/rvn${VNUM} 2> /dev/null || true
}

# fail errno errcode
# This function is used to trap errors and print msgs
#
fail() {
    errno=$1
    errcode=$2
    echo "--> Error $errno code $errcode"
    case $errcode in
    no_vnconfig)
	echo "Error while doing vnconfig of ${MFS_NAME} on /dev/rvn${VNUM}..."
	echo "   Most probably your running kernel doesn't have the vn(4) device."
	;;
    disklabel)
	echo "Error while labeling ${MFS_NAME} size ${MFS_SIZE}"
	;;
    no_mount)
	echo "Error while mounting ${MFS_NAME} (/dev/vn${VNUM}c) on ${MFS_MOUNTPOINT}"
	;;
    mtree)
	echo "Error while making hierarchy in ${MFS_MOUNTPOINT}"
	;;
    makedevs)
	echo "Error while making devices in ${MFS_MOUNTPOINT}"
	;;
    crunch)
	echo "Error while building ../${TYPE}/crunch1..."
	;;
    vnconfig2)
	echo "Error while doing vnconfig of floppy.img on /dev/rvn${VNUM}..."
	;;
    disklabel)
	echo "Error while doing disklabel on of floppy.img size $FLOPPY_SIZE"
	;;
    kernel_compress)
	echo "Error while copying compressed kernel to disk"
	;;
    mfs_compress)
	echo "Error while copying compressed mfs image to disk"
	;;
    missing_kernel)
	echo "-> ERROR: you must build PICOBSD${suffix} kernel first"
	;;
    *)
	echo "unknown error, maybe user break: $errno $errcode"
	;;
    esac
    echo "-> Aborting $0"
    # try to cleanup the vnode.
    free_vnode
    rm -rf ${MFS_MOUNTPOINT} 2> /dev/null || true
    exit 10
}

create_mfs() {
    echo "-> Preparing MFS filesystem..."

    free_vnode

    # zero-fill the MFS image
    dd of=${MFS_NAME} if=/dev/zero count=${MFS_SIZE} bs=1k 2> /dev/null

    vnconfig -s labels -c /dev/rvn${VNUM} ${MFS_NAME} 2>/dev/null || \
	    fail $? no_vnconfig

    dd if=/boot/boot1 of=${MFS_NAME} conv=notrunc 2> /dev/null

    # This command does weird things on 2.2.x systems.
    # For small image sizes, use std disktypes
    if [ ${MFS_SIZE} -lt 1024 ] ; then
	disklabel -rw /dev/rvn${VNUM} fd${MFS_SIZE} || fail $? disklabel
    else
	disklabel -rw vn${VNUM} auto || fail $? disklabel
    fi

    newfs -i ${MFS_INODES} -m 0 -p 0 -o space /dev/rvn${VNUM}c
    mount /dev/vn${VNUM}c ${MFS_MOUNTPOINT} || fail $? no_mount

    pwd=`pwd`
}

populate_mfs() {
    echo "-> Populating MFS tree..."
    cd ../${TYPE}
    make -f Makefile.mfs DESTDIR=${MFS_MOUNTPOINT} > /dev/null || \
	fail $? mtree
    if [ X"${NO_DEVFS}" != X"" ] ; then
	make -f Makefile.mfs DESTDIR=${MFS_MOUNTPOINT} devnodes \
		> /dev/null || fail $? makedevs
    fi

    echo "-> Making and installing crunch1..."
    cd crunch1
    make -f ../../build/Makefile.crunch "SRC=${SRC}" && \
	make -f ../../build/Makefile.crunch install 2>&1 >/dev/null || \
	fail $? crunch

    cd ${pwd}
    if [ -f ${MFS_MOUNTPOINT}/stand/sshd ] ; then
	echo "creating host key for sshd"
	ssh-keygen -f ${MFS_MOUNTPOINT}/etc/ssh_host_key -N "" -C "root@picobsd"
    fi

    # copy mfs tree
    if [ -d ${BUILDDIR}/../${TYPE}/mfs_tree ]; then
	# we have a type-specific mfs tree
	MFS_TREE=${BUILDDIR}/../${TYPE}/mfs_tree
    else # normal case, use the default mfs tree
	MFS_TREE=${BUILDDIR}/../mfs_tree
    fi
    (cd ${MFS_TREE} ; tar -cf - --exclude CVS . ) | \
	    (cd ${MFS_MOUNTPOINT} ; tar xvf - )

    if [ "${INCLUDE_FLOPPY_IN_MFS}" = "yes" ]; then
	cp -Rp ${BUILDDIR}/floppy.tree/* ${MFS_MOUNTPOINT}/fd
    fi
    (echo "-> Fixing permissions"; cd ${MFS_MOUNTPOINT}; chown -R root . )
    df -ik ${MFS_MOUNTPOINT}
    umount ${MFS_MOUNTPOINT}
    fsck -p /dev/rvn${VNUM}c
    vnconfig -u /dev/rvn${VNUM}
}

do_kernel() {
    echo "-> Preparing kernel..."
    (cd ../${TYPE}; make -v -f ${BUILDDIR}/Makefile.conf )
    cp -p ${SRC}/sys/compile/PICOBSD${suffix}/kernel kernel || \
	fail $? missing_kernel
    strip kernel
    strip --remove-section=.note --remove-section=.comment kernel
}

do_floppy() {
    # On entry we are in /usr/src/release/build.

    echo "==> Preparing ${FLOPPY_SIZE}kB floppy filesystem..."

    # correct block and number of sectors according to size.
    blocks=${FLOPPY_SIZE}
    sectors=18
    if [ "${blocks}" = "1720" ]; then
	blocks=1722
	sectors=21
    elif [ "${blocks}" = "1480" ]; then
	blocks=1476
    fi
    echo "${sectors} sectors per track"
    # create image
    dd of=picobsd.bin if=/dev/zero count=${blocks} bs=1k
    # put in boot sector so vnconfig and disklabel will not complain
    dd if=${boot1} of=picobsd.bin conv=notrunc 2> /dev/null
    vnconfig -c /dev/rvn${VNUM} picobsd.bin || fail $? vnconfig2

    disklabel -Brw -b ${boot1} -s ${boot2} /dev/vn${VNUM}c \
	fd${FLOPPY_SIZE} || \
	fail $?  disklabel

    newfs -i ${FLOPPY_INODES} -m 0 -p 0 -o space /dev/rvn${VNUM}c

    mount /dev/vn${VNUM}c ${MFS_MOUNTPOINT}

    # preload kernel, compress with kgzip and copy to floppy image
    cc -o ./wmk /usr/src/release/write_mfs_in_kernel.c
    ./wmk kernel ${MFS_NAME}
    rm wmk
    kgzip -o kernel.gz kernel
    cp -p kernel.gz ${MFS_MOUNTPOINT}/kernel

    # now transfer the floppy tree
    cp -Rp floppy.tree/* ${MFS_MOUNTPOINT}
    (echo "-> Fixing permissions"; cd ${MFS_MOUNTPOINT}; chown -R root *)
    rm -rf floppy.tree || true # cleanup

    df -ik ${MFS_MOUNTPOINT} | colrm 70 > .build.reply
    umount ${MFS_MOUNTPOINT}
    rm -rf ${MFS_MOUNTPOINT}
    vnconfig -u /dev/rvn${VNUM}
    rm kernel.gz ${MFS_NAME}
}

populate_floppy_fs() {
    echo "==> Populating floppy filesystem..."

    # Configuration files are first copied to a local tree, then
    # compressed, then transferred back to the floppy.
    rm -rf floppy.tree || true
    mkdir floppy.tree

    excl=${BUILDDIR}/../${TYPE}/floppy.tree.exclude
    if [ -f ${excl} ] ; then
	excl="--exclude-from ${excl}"
	echo "Exclude following files from ${excl}:\n==="
	cat ${excl}
	echo "==="
    else
	excl=""
    fi
    (cd ${BUILDDIR}/../floppy.tree ; tar -cf - --exclude CVS ${excl} . ) | \
		(cd floppy.tree ; tar xvf - )

    srcdir=${BUILDDIR}/../${TYPE}/floppy.tree
    if [ -d ${srcdir} ] ; then
	echo "-> update with private files:"
	(cd ${srcdir} ; tar -cf - --exclude CVS . ) | \
	    (cd floppy.tree ; tar xvf - )
    fi
    if [ -d ${srcdir}.${SITE} ] ; then
	echo "-> update with site-specific (${SITE}) files:"
	(cd ${srcdir}.${SITE} ; tar -cf - --exclude CVS . ) | \
	    (cd floppy.tree ; tar xvf - )
    fi
    files="motd"
    echo "-> Copying language dependent files: ${files} -> ${MFS_MOUNTPOINT}/etc ..."
    for i in ${files} ; do
	if [ -f ${BUILDDIR}/../${TYPE}/lang/${i}.${LANGUAGE} ] ; then
	    cat ${BUILDDIR}/../${TYPE}/lang/${i}.${LANGUAGE} | \
		sed -e "s/@VER@/${VER}/g" > floppy.tree/etc/${i}
	fi
    done

    # XXX check this! i am unsure how it is necessary.
    if [ "${TYPE}" = "dial" ] ; then
	cp -p floppy.tree/etc/master.passwd .
	pwd_mkdb -d . master.passwd
	mv spwd.db floppy.tree/etc/
	rm pwd.db master.passwd
    fi
    # gzip returns an error if it fails to compress some file
    gzip -9 floppy.tree/etc/* || true
}


do_kernel
create_mfs
populate_floppy_fs	# things which go into floppy
populate_mfs		# things which go into mfs
do_floppy # copies everything into the floppy
