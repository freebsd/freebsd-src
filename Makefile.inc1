#
# $FreeBSD$
#
# Make command line options:
#	-DNO_CLEANDIR run ${MAKE} clean, instead of ${MAKE} cleandir
#	-DNO_CLEAN do not clean at all
#	-DDB_FROM_SRC use the user/group databases in src/etc instead of
#	    the system database when installing.
#	-DNO_SHARE do not go into share subdir
#	-DKERNFAST define NO_KERNEL{CONFIG,CLEAN,DEPEND,OBJ}
#	-DNO_KERNELCONFIG do not run config in ${MAKE} buildkernel
#	-DNO_KERNELCLEAN do not run ${MAKE} clean in ${MAKE} buildkernel
#	-DNO_KERNELDEPEND do not run ${MAKE} depend in ${MAKE} buildkernel
#	-DNO_KERNELOBJ do not run ${MAKE} obj in ${MAKE} buildkernel
#	-DNO_PORTSUPDATE do not update ports in ${MAKE} update
#	-DNO_ROOT install without using root privilege
#	-DNO_DOCUPDATE do not update doc in ${MAKE} update
#	-DNO_CTF do not run the DTrace CTF conversion tools on built objects
#	LOCAL_DIRS="list of dirs" to add additional dirs to the SUBDIR list
#	LOCAL_LIB_DIRS="list of dirs" to add additional dirs to libraries target
#	LOCAL_MTREE="list of mtree files" to process to allow local directories
#	    to be created before files are installed
#	LOCAL_TOOL_DIRS="list of dirs" to add additional dirs to the build-tools
#	    list
#	METALOG="path to metadata log" to write permission and ownership
#	    when NO_ROOT is set.  (default: ${DESTDIR}/METALOG)
#	TARGET="machine" to crossbuild world for a different machine type
#	TARGET_ARCH= may be required when a TARGET supports multiple endians
#	BUILDENV_SHELL= shell to launch for the buildenv target (def:/bin/sh)
#	WORLD_FLAGS= additional flags to pass to make(1) during buildworld
#	KERNEL_FLAGS= additional flags to pass to make(1) during buildkernel

#
# The intended user-driven targets are:
# buildworld  - rebuild *everything*, including glue to help do upgrades
# installworld- install everything built by "buildworld"
# doxygen     - build API documentation of the kernel
# update      - convenient way to update your source tree (eg: cvsup/cvs)
#
# Standard targets (not defined here) are documented in the makefiles in
# /usr/share/mk.  These include:
#		obj depend all install clean cleandepend cleanobj

# You are supposed to define both of these when calling Makefile.inc1
# directly.  However, some old scripts don't.  Cope for the moment, but
# issue a new warning for a transition period.
.if defined(TARGET) && !defined(TARGET_ARCH)
.warning "You must pass both TARGET and TARGET_ARCH to Makefile.inc1.  Setting TARGET_ARCH=${TARGET}."
TARGET_ARCH=${TARGET}
.endif
.if !defined(TARGET) || !defined(TARGET_ARCH)
.error "Both TARGET and TARGET_ARCH must be defined."
.endif

.include <bsd.own.mk>
.include <bsd.arch.inc.mk>
.include <bsd.compiler.mk>

# We must do share/info early so that installation of info `dir'
# entries works correctly.  Do it first since it is less likely to
# grow dependencies on include and lib than vice versa.
#
# We must do lib/ and libexec/ before bin/, because if installworld
# installs a new /bin/sh, the 'make' command will *immediately*
# use that new version.  And the new (dynamically-linked) /bin/sh
# will expect to find appropriate libraries in /lib and /libexec.
#
SUBDIR=	share/info lib libexec
SUBDIR+=bin
.if ${MK_GAMES} != "no"
SUBDIR+=games
.endif
.if ${MK_CDDL} != "no"
SUBDIR+=cddl
.endif
SUBDIR+=gnu include
.if ${MK_KERBEROS} != "no"
SUBDIR+=kerberos5
.endif
.if ${MK_RESCUE} != "no"
SUBDIR+=rescue
.endif
SUBDIR+=sbin
.if ${MK_CRYPT} != "no"
SUBDIR+=secure
.endif
.if !defined(NO_SHARE)
SUBDIR+=share
.endif
SUBDIR+=sys usr.bin usr.sbin
.if ${MK_OFED} != "no"
SUBDIR+=contrib/ofed
.endif
#
# We must do etc/ last for install/distribute to work.
#
SUBDIR+=etc

# These are last, since it is nice to at least get the base system
# rebuilt before you do them.
.for _DIR in ${LOCAL_LIB_DIRS} ${LOCAL_DIRS}
.if exists(${.CURDIR}/${_DIR}/Makefile)
SUBDIR+= ${_DIR}
.endif
.endfor

.if defined(SUBDIR_OVERRIDE)
SUBDIR=		${SUBDIR_OVERRIDE}
.endif

.if defined(NOCLEAN)
NO_CLEAN=	${NOCLEAN}
.endif
.if defined(NO_CLEANDIR)
CLEANDIR=	clean cleandepend
.else
CLEANDIR=	cleandir
.endif

LOCAL_TOOL_DIRS?=

BUILDENV_SHELL?=/bin/sh

CVS?=		cvs
CVSFLAGS?=	-A -P -d -I!
SVN?=		svn
SVNFLAGS?=	-r HEAD
SUP?=		/usr/bin/csup
SUPFLAGS?=	-g -L 2
.if defined(SUPHOST)
SUPFLAGS+=	-h ${SUPHOST}
.endif

MAKEOBJDIRPREFIX?=	/usr/obj
.if !defined(OSRELDATE)
.if exists(/usr/include/osreldate.h)
OSRELDATE!=	awk '/^\#define[[:space:]]*__FreeBSD_version/ { print $$3 }' \
		/usr/include/osreldate.h
.else
OSRELDATE=	0
.endif
.endif

.if !defined(VERSION)
VERSION!=	uname -srp
VERSION+=	${OSRELDATE}
.endif

KNOWN_ARCHES?=	amd64 arm armeb/arm armv6/arm armv6eb/arm i386 i386/pc98 ia64 mips mipsel/mips mips64el/mips mips64/mips mipsn32el/mips mipsn32/mips powerpc powerpc64/powerpc sparc64
.if ${TARGET} == ${TARGET_ARCH}
_t=		${TARGET}
.else
_t=		${TARGET_ARCH}/${TARGET}
.endif
.for _t in ${_t}
.if empty(KNOWN_ARCHES:M${_t})
.error Unknown target ${TARGET_ARCH}:${TARGET}.
.endif
.endfor

.if ${TARGET} == ${MACHINE}
TARGET_CPUTYPE?=${CPUTYPE}
.else
TARGET_CPUTYPE?=
.endif

.if !empty(TARGET_CPUTYPE)
_TARGET_CPUTYPE=${TARGET_CPUTYPE}
.else
_TARGET_CPUTYPE=dummy
.endif
_CPUTYPE!=	MAKEFLAGS= CPUTYPE=${_TARGET_CPUTYPE} ${MAKE} \
		-f /dev/null -m ${.CURDIR}/share/mk -V CPUTYPE
.if ${_CPUTYPE} != ${_TARGET_CPUTYPE}
.error CPUTYPE global should be set with ?=.
.endif
.if make(buildworld)
BUILD_ARCH!=	uname -p
.if ${MACHINE_ARCH} != ${BUILD_ARCH}
.error To cross-build, set TARGET_ARCH.
.endif
.endif
.if ${MACHINE} == ${TARGET} && ${MACHINE_ARCH} == ${TARGET_ARCH} && !defined(CROSS_BUILD_TESTING)
OBJTREE=	${MAKEOBJDIRPREFIX}
.else
OBJTREE=	${MAKEOBJDIRPREFIX}/${TARGET}.${TARGET_ARCH}
.endif
WORLDTMP=	${OBJTREE}${.CURDIR}/tmp
# /usr/games added for fortune which depend on strfile
BPATH=		${WORLDTMP}/legacy/usr/sbin:${WORLDTMP}/legacy/usr/bin:${WORLDTMP}/legacy/usr/games:${WORLDTMP}/legacy/bin
XPATH=		${WORLDTMP}/usr/sbin:${WORLDTMP}/usr/bin:${WORLDTMP}/usr/games
STRICTTMPPATH=	${BPATH}:${XPATH}
TMPPATH=	${STRICTTMPPATH}:${PATH}

#
# Avoid running mktemp(1) unless actually needed.
# It may not be functional, e.g., due to new ABI
# when in the middle of installing over this system.
#
.if make(distributeworld) || make(installworld)
INSTALLTMP!=	/usr/bin/mktemp -d -u -t install
.endif

#
# Building a world goes through the following stages
#
# 1. legacy stage [BMAKE]
#	This stage is responsible for creating compatibility
#	shims that are needed by the bootstrap-tools,
#	build-tools and cross-tools stages.
# 1. bootstrap-tools stage [BMAKE]
#	This stage is responsible for creating programs that
#	are needed for backward compatibility reasons. They
#	are not built as cross-tools.
# 2. build-tools stage [TMAKE]
#	This stage is responsible for creating the object
#	tree and building any tools that are needed during
#	the build process.
# 3. cross-tools stage [XMAKE]
#	This stage is responsible for creating any tools that
#	are needed for cross-builds. A cross-compiler is one
#	of them.
# 4. world stage [WMAKE]
#	This stage actually builds the world.
# 5. install stage (optional) [IMAKE]
#	This stage installs a previously built world.
#

BOOTSTRAPPING?=	0

# Common environment for world related stages
CROSSENV=	MAKEOBJDIRPREFIX=${OBJTREE} \
		MACHINE_ARCH=${TARGET_ARCH} \
		MACHINE=${TARGET} \
		CPUTYPE=${TARGET_CPUTYPE}
.if ${MK_GROFF} != "no"
CROSSENV+=	GROFF_BIN_PATH=${WORLDTMP}/legacy/usr/bin \
		GROFF_FONT_PATH=${WORLDTMP}/legacy/usr/share/groff_font \
		GROFF_TMAC_PATH=${WORLDTMP}/legacy/usr/share/tmac
.endif

# bootstrap-tools stage
BMAKEENV=	INSTALL="sh ${.CURDIR}/tools/install.sh" \
		PATH=${BPATH}:${PATH} \
		WORLDTMP=${WORLDTMP} \
		VERSION="${VERSION}" \
		MAKEFLAGS="-m ${.CURDIR}/tools/build/mk ${.MAKEFLAGS}" \
		COMPILER_TYPE=${COMPILER_TYPE}
BMAKE=		MAKEOBJDIRPREFIX=${WORLDTMP} \
		${BMAKEENV} ${MAKE} ${WORLD_FLAGS} -f Makefile.inc1 \
		DESTDIR= \
		BOOTSTRAPPING=${OSRELDATE} \
		SSP_CFLAGS= \
		-DWITHOUT_HTML -DWITHOUT_INFO -DNO_LINT -DWITHOUT_MAN \
		-DNO_PIC -DNO_PROFILE -DNO_SHARED \
		-DNO_CPU_CFLAGS -DNO_WARNS -DNO_CTF -DEARLY_BUILD

# build-tools stage
TMAKE=		MAKEOBJDIRPREFIX=${OBJTREE} \
		${BMAKEENV} ${MAKE} ${WORLD_FLAGS} -f Makefile.inc1 \
		TARGET=${TARGET} TARGET_ARCH=${TARGET_ARCH} \
		DESTDIR= \
		BOOTSTRAPPING=${OSRELDATE} \
		SSP_CFLAGS= \
		-DNO_LINT \
		-DNO_CPU_CFLAGS -DNO_WARNS -DNO_CTF -DEARLY_BUILD

# cross-tools stage
XMAKE=		TOOLS_PREFIX=${WORLDTMP} ${BMAKE} \
		TARGET=${TARGET} TARGET_ARCH=${TARGET_ARCH} \
		-DWITHOUT_GDB

# world stage
WMAKEENV=	${CROSSENV} \
		_SHLIBDIRPREFIX=${WORLDTMP} \
		_LDSCRIPTROOT= \
		VERSION="${VERSION}" \
		INSTALL="sh ${.CURDIR}/tools/install.sh" \
		PATH=${TMPPATH}
.if ${MK_CDDL} == "no"
WMAKEENV+=	NO_CTF=1
.endif
.if ${CC:T:Mgcc} == "gcc"
WMAKE_COMPILER_TYPE=	gcc
.elif ${CC:T:Mclang} == "clang"
WMAKE_COMPILER_TYPE=	clang
.elif ${MK_CLANG_IS_CC} == "no"
WMAKE_COMPILER_TYPE=	gcc
.else
WMAKE_COMPILER_TYPE=	clang
.endif
WMAKEENV+=	COMPILER_TYPE=${WMAKE_COMPILER_TYPE}
WMAKE=		${WMAKEENV} ${MAKE} ${WORLD_FLAGS} -f Makefile.inc1 DESTDIR=${WORLDTMP}

.if ${TARGET_ARCH} == "amd64" || ${TARGET_ARCH} == "powerpc64"
# 32 bit world
LIB32TMP=	${OBJTREE}${.CURDIR}/lib32

.if ${TARGET_ARCH} == "amd64"
.if empty(TARGET_CPUTYPE)
LIB32CPUFLAGS=	-march=i686 -mmmx -msse -msse2
.else
LIB32CPUFLAGS=	-march=${TARGET_CPUTYPE}
.endif
LIB32WMAKEENV=	MACHINE=i386 MACHINE_ARCH=i386 \
		MACHINE_CPU="i686 mmx sse sse2"
LIB32WMAKEFLAGS=	\
		AS="${AS} --32" \
		LD="${LD} -m elf_i386_fbsd -Y P,${LIB32TMP}/usr/lib32"

.elif ${TARGET_ARCH} == "powerpc64"
.if empty(TARGET_CPUTYPE)
LIB32CPUFLAGS=	-mcpu=powerpc
.else
LIB32CPUFLAGS=	-mcpu=${TARGET_CPUTYPE}
.endif
LIB32WMAKEENV=	MACHINE=powerpc MACHINE_ARCH=powerpc
LIB32WMAKEFLAGS=	\
		LD="${LD} -m elf32ppc_fbsd"
.endif


LIB32FLAGS=	-m32 ${LIB32CPUFLAGS} -DCOMPAT_32BIT \
		-isystem ${LIB32TMP}/usr/include/ \
		-L${LIB32TMP}/usr/lib32 \
		-B${LIB32TMP}/usr/lib32

# Yes, the flags are redundant.
LIB32WMAKEENV+=	MAKEOBJDIRPREFIX=${OBJTREE}/lib32 \
		_SHLIBDIRPREFIX=${LIB32TMP} \
		_LDSCRIPTROOT=${LIB32TMP} \
		VERSION="${VERSION}" \
		INSTALL="sh ${.CURDIR}/tools/install.sh" \
		PATH=${TMPPATH} \
		LIBDIR=/usr/lib32 \
		SHLIBDIR=/usr/lib32 \
		COMPILER_TYPE=${WMAKE_COMPILER_TYPE}
LIB32WMAKEFLAGS+=	\
		CC="${CC} ${LIB32FLAGS}" \
		CXX="${CXX} ${LIB32FLAGS}" \
		DESTDIR=${LIB32TMP} \
		-DCOMPAT_32BIT \
		-DLIBRARIES_ONLY \
		-DNO_CPU_CFLAGS \
		-DNO_CTF \
		-DNO_LINT

LIB32WMAKE=	${LIB32WMAKEENV} ${MAKE} ${LIB32WMAKEFLAGS} \
		-DWITHOUT_BIND -DWITHOUT_MAN -DWITHOUT_INFO -DWITHOUT_HTML
LIB32IMAKE=	${LIB32WMAKE:NINSTALL=*:NDESTDIR=*:N_LDSCRIPTROOT=*} -DNO_INCS \
		${IMAKE_INSTALL}
.endif

IMAKEENV=	${CROSSENV:N_LDSCRIPTROOT=*}
IMAKE=		${IMAKEENV} ${MAKE} -f Makefile.inc1 \
		${IMAKE_INSTALL} ${IMAKE_MTREE}
.if empty(.MAKEFLAGS:M-n)
IMAKEENV+=	PATH=${STRICTTMPPATH}:${INSTALLTMP} \
		LD_LIBRARY_PATH=${INSTALLTMP} \
		PATH_LOCALE=${INSTALLTMP}/locale
IMAKE+=		__MAKE_SHELL=${INSTALLTMP}/sh
.else
IMAKEENV+=	PATH=${TMPPATH}:${INSTALLTMP}
.endif
.if defined(DB_FROM_SRC)
INSTALLFLAGS+=	-N ${.CURDIR}/etc
MTREEFLAGS+=	-N ${.CURDIR}/etc
.endif
.if defined(NO_ROOT)
METALOG?=	${DESTDIR}/${DISTDIR}/METALOG
IMAKE+=		-DNO_ROOT METALOG=${METALOG}
INSTALL_DDIR=	${DESTDIR}/${DISTDIR}
INSTALLFLAGS+=	-U -M ${METALOG} -D ${INSTALL_DDIR:S://:/:g:C:/$::}
MTREEFLAGS+=	-W
.endif
.if defined(DB_FROM_SRC) || defined(NO_ROOT)
IMAKE_INSTALL=	INSTALL="install ${INSTALLFLAGS}"
IMAKE_MTREE=	MTREE_CMD="nmtree ${MTREEFLAGS}"
.endif

# kernel stage
KMAKEENV=	${WMAKEENV}
KMAKE=		${KMAKEENV} ${MAKE} ${.MAKEFLAGS} ${KERNEL_FLAGS} KERNEL=${INSTKERNNAME}

#
# buildworld
#
# Attempt to rebuild the entire system, with reasonable chance of
# success, regardless of how old your existing system is.
#
_worldtmp:
.if ${.CURDIR:C/[^,]//g} != ""
#	The m4 build of sendmail files doesn't like it if ',' is used
#	anywhere in the path of it's files.
	@echo
	@echo "*** Error: path to source tree contains a comma ','"
	@echo
	false
.endif
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> Rebuilding the temporary build tree"
	@echo "--------------------------------------------------------------"
.if !defined(NO_CLEAN)
	rm -rf ${WORLDTMP}
.if defined(LIB32TMP)
	rm -rf ${LIB32TMP}
.endif
.else
	rm -rf ${WORLDTMP}/legacy/usr/include
#	XXX - These three can depend on any header file.
	rm -f ${OBJTREE}${.CURDIR}/usr.bin/kdump/ioctl.c
	rm -f ${OBJTREE}${.CURDIR}/usr.bin/kdump/kdump_subr.c
	rm -f ${OBJTREE}${.CURDIR}/usr.bin/truss/ioctl.c
.endif
.for _dir in \
    lib usr legacy/bin legacy/usr
	mkdir -p ${WORLDTMP}/${_dir}
.endfor
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.usr.dist \
	    -p ${WORLDTMP}/legacy/usr >/dev/null
.if ${MK_GROFF} != "no"
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.groff.dist \
	    -p ${WORLDTMP}/legacy/usr >/dev/null
.endif
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.usr.dist \
	    -p ${WORLDTMP}/usr >/dev/null
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.include.dist \
	    -p ${WORLDTMP}/usr/include >/dev/null
	ln -sf ${.CURDIR}/sys ${WORLDTMP}
.if ${MK_BIND_LIBS} != "no"
	mtree -deU -f ${.CURDIR}/etc/mtree/BIND.include.dist \
	    -p ${WORLDTMP}/usr/include >/dev/null
.endif
.for _mtree in ${LOCAL_MTREE}
	mtree -deU -f ${.CURDIR}/${_mtree} -p ${WORLDTMP} > /dev/null
.endfor
_legacy:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 1.1: legacy release compatibility shims"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${BMAKE} legacy
_bootstrap-tools:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 1.2: bootstrap tools"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${BMAKE} bootstrap-tools
_cleanobj:
.if !defined(NO_CLEAN)
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2.1: cleaning up the object tree"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${WMAKE} ${CLEANDIR:S/^/par-/}
.if defined(LIB32TMP)
	${_+_}cd ${.CURDIR}; ${LIB32WMAKE} -f Makefile.inc1 ${CLEANDIR:S/^/par-/}
.endif
.endif
_obj:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2.2: rebuilding the object tree"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${WMAKE} par-obj
_build-tools:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2.3: build tools"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${TMAKE} build-tools
_cross-tools:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 3: cross tools"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${XMAKE} cross-tools
_includes:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 4.1: building includes"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${WMAKE} SHARED=symlinks par-includes
_libraries:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 4.2: building libraries"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; \
	    ${WMAKE} -DNO_FSCHG -DWITHOUT_HTML -DWITHOUT_INFO -DNO_LINT \
	    -DWITHOUT_MAN -DNO_PROFILE libraries
_depend:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 4.3: make dependencies"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${WMAKE} par-depend
everything:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 4.4: building everything"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${WMAKE} par-all
.if defined(LIB32TMP)
build32:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 5.1: building 32 bit shim libraries"
	@echo "--------------------------------------------------------------"
	mkdir -p ${LIB32TMP}/usr/include
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.usr.dist \
	    -p ${LIB32TMP}/usr >/dev/null
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.include.dist \
	    -p ${LIB32TMP}/usr/include >/dev/null
	mkdir -p ${WORLDTMP}
	ln -sf ${.CURDIR}/sys ${WORLDTMP}
.for _t in obj includes
	cd ${.CURDIR}/include; ${LIB32WMAKE} DIRPRFX=include/ ${_t}
	cd ${.CURDIR}/lib; ${LIB32WMAKE} DIRPRFX=lib/ ${_t}
.if ${MK_CDDL} != "no"
	cd ${.CURDIR}/cddl/lib; ${LIB32WMAKE} DIRPRFX=cddl/lib/ ${_t}
.endif
	cd ${.CURDIR}/gnu/lib; ${LIB32WMAKE} DIRPRFX=gnu/lib/ ${_t}
.if ${MK_CRYPT} != "no"
	cd ${.CURDIR}/secure/lib; ${LIB32WMAKE} DIRPRFX=secure/lib/ ${_t}
.endif
.if ${MK_KERBEROS} != "no"
	cd ${.CURDIR}/kerberos5/lib; ${LIB32WMAKE} DIRPRFX=kerberos5/lib ${_t}
.endif
.endfor
.for _dir in usr.bin/lex/lib
	cd ${.CURDIR}/${_dir}; ${LIB32WMAKE} DIRPRFX=${_dir}/ obj
.endfor
.for _dir in lib/ncurses/ncurses lib/ncurses/ncursesw lib/libmagic
	cd ${.CURDIR}/${_dir}; \
	    WORLDTMP=${WORLDTMP} \
	    MAKEFLAGS="-m ${.CURDIR}/tools/build/mk ${.MAKEFLAGS}" \
	    MAKEOBJDIRPREFIX=${OBJTREE}/lib32 ${MAKE} SSP_CFLAGS= DESTDIR= \
	    DIRPRFX=${_dir}/ -DNO_LINT -DNO_CPU_CFLAGS -DNO_WARNS -DNO_CTF \
	    -DEARLY_BUILD build-tools
.endfor
	cd ${.CURDIR}; \
	    ${LIB32WMAKE} -f Makefile.inc1 libraries
.for _t in obj depend all
	cd ${.CURDIR}/libexec/rtld-elf; PROG=ld-elf32.so.1 ${LIB32WMAKE} \
	    DIRPRFX=libexec/rtld-elf/ ${_t}
	cd ${.CURDIR}/usr.bin/ldd; PROG=ldd32 ${LIB32WMAKE} \
	    DIRPRFX=usr.bin/ldd ${_t}
.endfor

distribute32 install32:
	cd ${.CURDIR}/lib; ${LIB32IMAKE} ${.TARGET:S/32$//}
.if ${MK_CDDL} != "no"
	cd ${.CURDIR}/cddl/lib; ${LIB32IMAKE} ${.TARGET:S/32$//}
.endif
	cd ${.CURDIR}/gnu/lib; ${LIB32IMAKE} ${.TARGET:S/32$//}
.if ${MK_CRYPT} != "no"
	cd ${.CURDIR}/secure/lib; ${LIB32IMAKE} ${.TARGET:S/32$//}
.endif
.if ${MK_KERBEROS} != "no"
	cd ${.CURDIR}/kerberos5/lib; ${LIB32IMAKE} ${.TARGET:S/32$//}
.endif
	cd ${.CURDIR}/libexec/rtld-elf; \
	    PROG=ld-elf32.so.1 ${LIB32IMAKE} ${.TARGET:S/32$//}
	cd ${.CURDIR}/usr.bin/ldd; PROG=ldd32 ${LIB32IMAKE} ${.TARGET:S/32$//}
.endif

WMAKE_TGTS=
.if !defined(SUBDIR_OVERRIDE)
WMAKE_TGTS+=	_worldtmp _legacy _bootstrap-tools
.endif
WMAKE_TGTS+=	_cleanobj _obj _build-tools
.if !defined(SUBDIR_OVERRIDE)
WMAKE_TGTS+=	_cross-tools
.endif
WMAKE_TGTS+=	_includes _libraries _depend everything
.if defined(LIB32TMP) && ${MK_LIB32} != "no"
WMAKE_TGTS+=	build32
.endif

buildworld: buildworld_prologue ${WMAKE_TGTS} buildworld_epilogue
.ORDER: buildworld_prologue ${WMAKE_TGTS} buildworld_epilogue

buildworld_prologue:
	@echo "--------------------------------------------------------------"
	@echo ">>> World build started on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"

buildworld_epilogue:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> World build completed on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"

#
# We need to have this as a target because the indirection between Makefile
# and Makefile.inc1 causes the correct PATH to be used, rather than a
# modification of the current environment's PATH.  In addition, we need
# to quote multiword values.
#
buildenvvars:
	@echo ${WMAKEENV:Q}

buildenv:
	@echo Entering world for ${TARGET_ARCH}:${TARGET}
	@cd ${.CURDIR} && env ${WMAKEENV} ${BUILDENV_SHELL} || true

TOOLCHAIN_TGTS=	${WMAKE_TGTS:N_depend:Neverything:Nbuild32}
toolchain: ${TOOLCHAIN_TGTS}
kernel-toolchain: ${TOOLCHAIN_TGTS:N_includes:N_libraries}

#
# installcheck
#
# Checks to be sure system is ready for installworld/installkernel.
#
installcheck:

#
# Require DESTDIR to be set if installing for a different architecture or
# using the user/group database in the source tree.
#
.if ${TARGET_ARCH} != ${MACHINE_ARCH} || ${TARGET} != ${MACHINE} || \
    defined(DB_FROM_SRC)
.if !make(distributeworld)
installcheck: installcheck_DESTDIR
installcheck_DESTDIR:
.if !defined(DESTDIR) || empty(DESTDIR)
	@echo "ERROR: Please set DESTDIR!"; \
	false
.endif
.endif
.endif

.if !defined(DB_FROM_SRC)
#
# Check for missing UIDs/GIDs.
#
CHECK_UIDS=	auditdistd
CHECK_GIDS=	audit
.if ${MK_SENDMAIL} != "no"
CHECK_UIDS+=	smmsp
CHECK_GIDS+=	smmsp
.endif
.if ${MK_PF} != "no"
CHECK_UIDS+=	proxy
CHECK_GIDS+=	proxy authpf
.endif
installcheck: installcheck_UGID
installcheck_UGID:
.for uid in ${CHECK_UIDS}
	@if ! `id -u ${uid} >/dev/null 2>&1`; then \
		echo "ERROR: Required ${uid} user is missing, see /usr/src/UPDATING."; \
		false; \
	fi
.endfor
.for gid in ${CHECK_GIDS}
	@if ! `find / -prune -group ${gid} >/dev/null 2>&1`; then \
		echo "ERROR: Required ${gid} group is missing, see /usr/src/UPDATING."; \
		false; \
	fi
.endfor
.endif

#
# Required install tools to be saved in a scratch dir for safety.
#
.if ${MK_INFO} != "no"
_install-info=	install-info
.endif
.if ${MK_ZONEINFO} != "no"
_zoneinfo=	zic tzsetup
.endif

.if exists(/usr/sbin/nmtree)
_nmtree_itools=	nmtree
.endif

ITOOLS=	[ awk cap_mkdb cat chflags chmod chown \
	date echo egrep find grep id install ${_install-info} \
	ln lockf make mkdir mtree ${_nmtree_itools} mv pwd_mkdb \
	rm sed sh sysctl test true uname wc ${_zoneinfo}

#
# distributeworld
#
# Distributes everything compiled by a `buildworld'.
#
# installworld
#
# Installs everything compiled by a 'buildworld'.
#

# Non-base distributions produced by the base system
EXTRA_DISTRIBUTIONS=	doc
.if ${MK_GAMES} != "no"
EXTRA_DISTRIBUTIONS+=	games
.endif
.if defined(LIB32TMP) && ${MK_LIB32} != "no"
EXTRA_DISTRIBUTIONS+=	lib32
.endif

MTREE_MAGIC?=	mtree 2.0

distributeworld installworld: installcheck
	mkdir -p ${INSTALLTMP}
	progs=$$(for prog in ${ITOOLS}; do \
		if progpath=`which $$prog`; then \
			echo $$progpath; \
		else \
			echo "Required tool $$prog not found in PATH." >&2; \
			exit 1; \
		fi; \
	    done); \
	libs=$$(ldd -f "%o %p\n" -f "%o %p\n" $$progs 2>/dev/null | sort -u | \
	    while read line; do \
		set -- $$line; \
		if [ "$$2 $$3" != "not found" ]; then \
			echo $$2; \
		else \
			echo "Required library $$1 not found." >&2; \
			exit 1; \
		fi; \
	    done); \
	cp $$libs $$progs ${INSTALLTMP}
	cp -R $${PATH_LOCALE:-"/usr/share/locale"} ${INSTALLTMP}/locale
.if defined(NO_ROOT)
	echo "#${MTREE_MAGIC}" > ${METALOG}
.endif
.if make(distributeworld)
.for dist in ${EXTRA_DISTRIBUTIONS}
	-mkdir ${DESTDIR}/${DISTDIR}/${dist}
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.root.dist \
	    -p ${DESTDIR}/${DISTDIR}/${dist} >/dev/null
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.usr.dist \
	    -p ${DESTDIR}/${DISTDIR}/${dist}/usr >/dev/null
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.include.dist \
	    -p ${DESTDIR}/${DISTDIR}/${dist}/usr/include >/dev/null
.if defined(NO_ROOT)
	${IMAKEENV} nmtree -C -f ${.CURDIR}/etc/mtree/BSD.root.dist | \
	    sed -e 's#^\./#./${dist}/#' >> ${METALOG}
	${IMAKEENV} nmtree -C -f ${.CURDIR}/etc/mtree/BSD.usr.dist | \
	    sed -e 's#^\./#./${dist}/usr/#' >> ${METALOG}
	${IMAKEENV} nmtree -C -f ${.CURDIR}/etc/mtree/BSD.include.dist | \
	    sed -e 's#^\./#./${dist}/usr/include/#' >> ${METALOG}
.endif
.endfor
	-mkdir ${DESTDIR}/${DISTDIR}/base
	cd ${.CURDIR}/etc; ${CROSSENV} PATH=${TMPPATH} ${MAKE} \
	    METALOG=${METALOG} ${IMAKE_INSTALL} ${IMAKE_MTREE} \
	    DISTBASE=/base DESTDIR=${DESTDIR}/${DISTDIR}/base \
	    LOCAL_MTREE=${LOCAL_MTREE} distrib-dirs
.endif
	${_+_}cd ${.CURDIR}; ${IMAKE} re${.TARGET:S/world$//}; \
	    ${IMAKEENV} rm -rf ${INSTALLTMP}
.if make(distributeworld)
.for dist in ${EXTRA_DISTRIBUTIONS}
	find ${DESTDIR}/${DISTDIR}/${dist} -empty -delete
.endfor
.if defined(NO_ROOT)
.for dist in base ${EXTRA_DISTRIBUTIONS}
	@# For each file that exists in this dist, print the corresponding
	@# line from the METALOG.  This relies on the fact that
	@# a line containing only the filename will sort immediatly before
	@# the relevant mtree line.
	cd ${DESTDIR}/${DISTDIR}; \
	find ./${dist} | sort -u ${METALOG} - | \
	awk 'BEGIN { print "#${MTREE_MAGIC}" } !/ type=/ { file = $$1 } / type=/ { if ($$1 == file) { sub(/^\.\/${dist}\//, "./"); print } }' > \
	${DESTDIR}/${DISTDIR}/${dist}.meta
.endfor
.endif
.endif

packageworld:
.for dist in base ${EXTRA_DISTRIBUTIONS}
.if defined(NO_ROOT)
	${_+_}cd ${DESTDIR}/${DISTDIR}/${dist}; \
	    tar cvJf ${DESTDIR}/${DISTDIR}/${dist}.txz \
	    @${DESTDIR}/${DISTDIR}/${dist}.meta
.else
	${_+_}cd ${DESTDIR}/${DISTDIR}/${dist}; \
	    tar cvJf ${DESTDIR}/${DISTDIR}/${dist}.txz .
.endif
.endfor

#
# reinstall
#
# If you have a build server, you can NFS mount the source and obj directories
# and do a 'make reinstall' on the *client* to install new binaries from the
# most recent server build.
#
reinstall:
	@echo "--------------------------------------------------------------"
	@echo ">>> Making hierarchy"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${MAKE} -f Makefile.inc1 \
	    LOCAL_MTREE=${LOCAL_MTREE} hierarchy
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> Installing everything"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${MAKE} -f Makefile.inc1 install
.if defined(LIB32TMP) && ${MK_LIB32} != "no"
	${_+_}cd ${.CURDIR}; ${MAKE} -f Makefile.inc1 install32
.endif

redistribute:
	@echo "--------------------------------------------------------------"
	@echo ">>> Distributing everything"
	@echo "--------------------------------------------------------------"
	${_+_}cd ${.CURDIR}; ${MAKE} -f Makefile.inc1 distribute
.if defined(LIB32TMP) && ${MK_LIB32} != "no"
	${_+_}cd ${.CURDIR}; ${MAKE} -f Makefile.inc1 distribute32 \
	    DISTRIBUTION=lib32
.endif

distrib-dirs distribution:
	cd ${.CURDIR}/etc; ${CROSSENV} PATH=${TMPPATH} ${MAKE} \
	    ${IMAKE_INSTALL} ${IMAKE_MTREE} METALOG=${METALOG} ${.TARGET}

#
# buildkernel and installkernel
#
# Which kernels to build and/or install is specified by setting
# KERNCONF. If not defined a GENERIC kernel is built/installed.
# Only the existing (depending TARGET) config files are used
# for building kernels and only the first of these is designated
# as the one being installed.
#
# Note that we have to use TARGET instead of TARGET_ARCH when
# we're in kernel-land. Since only TARGET_ARCH is (expected) to
# be set to cross-build, we have to make sure TARGET is set
# properly.

.if defined(KERNFAST)
NO_KERNELCLEAN=	t
NO_KERNELCONFIG=	t
NO_KERNELDEPEND=	t
NO_KERNELOBJ=		t
# Shortcut for KERNCONF=Blah -DKERNFAST is now KERNFAST=Blah
.if !defined(KERNCONF) && ${KERNFAST} != "1"
KERNCONF=${KERNFAST}
.endif
.endif
.if !defined(KERNCONF) && defined(KERNEL)
KERNCONF=	${KERNEL}
KERNWARN=
.else
.if ${TARGET_ARCH} == "powerpc64"
KERNCONF?=	GENERIC64
.else
KERNCONF?=	GENERIC
.endif
.endif
INSTKERNNAME?=	kernel

KERNSRCDIR?=	${.CURDIR}/sys
KRNLCONFDIR=	${KERNSRCDIR}/${TARGET}/conf
KRNLOBJDIR=	${OBJTREE}${KERNSRCDIR}
KERNCONFDIR?=	${KRNLCONFDIR}

BUILDKERNELS=
INSTALLKERNEL=
.for _kernel in ${KERNCONF}
.if exists(${KERNCONFDIR}/${_kernel})
BUILDKERNELS+=	${_kernel}
.if empty(INSTALLKERNEL)
INSTALLKERNEL= ${_kernel}
.endif
.endif
.endfor

#
# buildkernel
#
# Builds all kernels defined by BUILDKERNELS.
#
buildkernel:
.if empty(BUILDKERNELS)
	@echo "ERROR: Missing kernel configuration file(s) (${KERNCONF})."; \
	false
.endif
.if defined(KERNWARN)
	@echo "--------------------------------------------------------------"
	@echo ">>> WARNING: KERNEL= setting should be changed to KERNCONF="
	@echo "--------------------------------------------------------------"
	@sleep 3
.endif
	@echo
.for _kernel in ${BUILDKERNELS}
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel build for ${_kernel} started on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
	@echo "===> ${_kernel}"
	mkdir -p ${KRNLOBJDIR}
.if !defined(NO_KERNELCONFIG)
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 1: configuring the kernel"
	@echo "--------------------------------------------------------------"
	cd ${KRNLCONFDIR}; \
		PATH=${TMPPATH} \
		    config ${CONFIGARGS} -d ${KRNLOBJDIR}/${_kernel} \
			${KERNCONFDIR}/${_kernel}
.endif
.if !defined(NO_CLEAN) && !defined(NO_KERNELCLEAN)
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2.1: cleaning up the object tree"
	@echo "--------------------------------------------------------------"
	cd ${KRNLOBJDIR}/${_kernel}; ${KMAKE} ${CLEANDIR}
.endif
.if !defined(NO_KERNELOBJ)
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2.2: rebuilding the object tree"
	@echo "--------------------------------------------------------------"
	cd ${KRNLOBJDIR}/${_kernel}; ${KMAKE} obj
.endif
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2.3: build tools"
	@echo "--------------------------------------------------------------"
	cd ${KRNLOBJDIR}/${_kernel}; \
	    PATH=${BPATH}:${PATH} \
	    MAKESRCPATH=${KERNSRCDIR}/dev/aic7xxx/aicasm \
	    ${MAKE} SSP_CFLAGS= -DNO_CPU_CFLAGS -DNO_CTF -DEARLY_BUILD \
	    -f ${KERNSRCDIR}/dev/aic7xxx/aicasm/Makefile
# XXX - Gratuitously builds aicasm in the ``makeoptions NO_MODULES'' case.
.if !defined(MODULES_WITH_WORLD) && !defined(NO_MODULES) && exists(${KERNSRCDIR}/modules)
.for target in obj depend all
	cd ${KERNSRCDIR}/modules/aic7xxx/aicasm; \
	    PATH=${BPATH}:${PATH} \
	    MAKEOBJDIRPREFIX=${KRNLOBJDIR}/${_kernel}/modules \
	    ${MAKE} SSP_CFLAGS= -DNO_CPU_CFLAGS -DNO_CTF -DEARLY_BUILD ${target}
.endfor
.endif
.if !defined(NO_KERNELDEPEND)
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 3.1: making dependencies"
	@echo "--------------------------------------------------------------"
	cd ${KRNLOBJDIR}/${_kernel}; ${KMAKE} depend -DNO_MODULES_OBJ
.endif
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 3.2: building everything"
	@echo "--------------------------------------------------------------"
	cd ${KRNLOBJDIR}/${_kernel}; ${KMAKE} all -DNO_MODULES_OBJ
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel build for ${_kernel} completed on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
.endfor

#
# installkernel, etc.
#
# Install the kernel defined by INSTALLKERNEL
#
installkernel installkernel.debug \
reinstallkernel reinstallkernel.debug: installcheck
.if empty(INSTALLKERNEL)
	@echo "ERROR: No kernel \"${KERNCONF}\" to install."; \
	false
.endif
	@echo "--------------------------------------------------------------"
	@echo ">>> Installing kernel ${INSTALLKERNEL}"
	@echo "--------------------------------------------------------------"
	cd ${KRNLOBJDIR}/${INSTALLKERNEL}; \
	    ${CROSSENV} PATH=${TMPPATH} \
	    ${MAKE} ${IMAKE_INSTALL} KERNEL=${INSTKERNNAME} ${.TARGET:S/kernel//}

distributekernel distributekernel.debug:
.if empty(INSTALLKERNEL)
	@echo "ERROR: No kernel \"${KERNCONF}\" to install."; \
	false
.endif
	cd ${KRNLOBJDIR}/${INSTALLKERNEL}; \
	    ${CROSSENV} PATH=${TMPPATH} ${MAKE} KERNEL=${INSTKERNNAME} \
	    DESTDIR=${DESTDIR}/${DISTDIR}/kernel \
	    ${.TARGET:S/distributekernel/install/}
.for _kernel in ${BUILDKERNELS:S/${INSTALLKERNEL}//}
	cd ${KRNLOBJDIR}/${_kernel}; \
	    ${CROSSENV} PATH=${TMPPATH} ${MAKE} \
	    KERNEL=${INSTKERNNAME}.${_kernel} \
	    DESTDIR=${DESTDIR}/${DISTDIR}/kernel.${_kernel} \
	    ${.TARGET:S/distributekernel/install/}
.endfor

packagekernel:
	cd ${DESTDIR}/${DISTDIR}/kernel; \
	    tar cvJf ${DESTDIR}/${DISTDIR}/kernel.txz .
.for _kernel in ${BUILDKERNELS:S/${INSTALLKERNEL}//}
	cd ${DESTDIR}/${DISTDIR}/kernel.${_kernel}; \
	    tar cvJf ${DESTDIR}/${DISTDIR}/kernel.${_kernel}.txz .
.endfor

#
# doxygen
#
# Build the API documentation with doxygen
#
doxygen:
	@if [ ! -x `/usr/bin/which doxygen` ]; then \
		echo "You need doxygen (devel/doxygen) to generate the API documentation of the kernel." | /usr/bin/fmt; \
		exit 1; \
	fi
	cd ${.CURDIR}/tools/kerneldoc/subsys && ${MAKE} obj all

#
# update
#
# Update the source tree(s), by running cvsup/cvs/svn to update to the
# latest copy.
#
update:
.if defined(SUP_UPDATE)
	@echo "--------------------------------------------------------------"
	@echo ">>> Running ${SUP}"
	@echo "--------------------------------------------------------------"
	@echo "!! WARNING WARNING WARNING WARNING WARNING WARNING WARNING !!"
	@echo "!! Update methods with ${SUP} are deprecated."
	@echo "!! Please see http://www.freebsd.org/handbook/svn.html"
	@echo "!! and convert your update method to SVN_UPDATE or"
	@echo "!! freebsd-update(8)."
	@echo "!! WARNING WARNING WARNING WARNING WARNING WARNING WARNING !!"
	@sleep 5
.if defined(SUPFILE)
	@${SUP} ${SUPFLAGS} ${SUPFILE}
.endif
.if defined(SUPFILE1)
	@${SUP} ${SUPFLAGS} ${SUPFILE1}
.endif
.if defined(SUPFILE2)
	@${SUP} ${SUPFLAGS} ${SUPFILE2}
.endif
.if defined(PORTSSUPFILE) && !defined(NO_PORTSUPDATE)
	@${SUP} ${SUPFLAGS} ${PORTSSUPFILE}
.endif
.if defined(DOCSUPFILE) && !defined(NO_DOCUPDATE)
	@${SUP} ${SUPFLAGS} ${DOCSUPFILE}
.endif
.endif
.if defined(CVS_UPDATE)
	@cd ${.CURDIR} ; \
	if [ -d CVS ] ; then \
		echo "--------------------------------------------------------------" ; \
		echo ">>> Updating ${.CURDIR} from CVS repository" ${CVSROOT} ; \
		echo "--------------------------------------------------------------" ; \
		echo "!! WARNING WARNING WARNING WARNING WARNING WARNING WARNING !!" ; \
		echo "!! Update methods with CVS are deprecated." ; \
		echo "!! Please see http://www.freebsd.org/handbook/svn.html" ; \
		echo "!! and convert your update method to SVN_UPDATE or" ; \
		echo "!! freebsd-update(8)." ; \
		echo "!! WARNING WARNING WARNING WARNING WARNING WARNING WARNING !!" ; \
		sleep 5 ; \
		echo ${CVS} -R -q update ${CVSFLAGS} ; \
		${CVS} -R -q update ${CVSFLAGS} ; \
	fi
.endif
.if defined(SVN_UPDATE)
	@cd ${.CURDIR} ; \
	if [ -d .svn ] ; then \
		echo "--------------------------------------------------------------" ; \
		echo ">>> Updating ${.CURDIR} using Subversion" ; \
		echo "--------------------------------------------------------------" ; \
		echo ${SVN} update ${SVNFLAGS} ; \
		${SVN} update ${SVNFLAGS} ; \
	fi
.endif

#
# ------------------------------------------------------------------------
#
# From here onwards are utility targets used by the 'make world' and
# related targets.  If your 'world' breaks, you may like to try to fix
# the problem and manually run the following targets to attempt to
# complete the build.  Beware, this is *not* guaranteed to work, you
# need to have a pretty good grip on the current state of the system
# to attempt to manually finish it.  If in doubt, 'make world' again.
#

#
# legacy: Build compatibility shims for the next three targets
#
legacy:
.if ${BOOTSTRAPPING} < 700055 && ${BOOTSTRAPPING} != 0
	@echo "ERROR: Source upgrades from versions prior to 7.0 not supported."; \
	false
.endif
.for _tool in tools/build
	${_+_}@${ECHODIR} "===> ${_tool} (obj,includes,depend,all,install)"; \
	    cd ${.CURDIR}/${_tool}; \
	    ${MAKE} DIRPRFX=${_tool}/ obj; \
	    ${MAKE} DIRPRFX=${_tool}/ DESTDIR=${MAKEOBJDIRPREFIX}/legacy includes; \
	    ${MAKE} DIRPRFX=${_tool}/ depend; \
	    ${MAKE} DIRPRFX=${_tool}/ all; \
	    ${MAKE} DIRPRFX=${_tool}/ DESTDIR=${MAKEOBJDIRPREFIX}/legacy install
.endfor

#
# bootstrap-tools: Build tools needed for compatibility
#
.if ${MK_GAMES} != "no"
_strfile=	games/fortune/strfile
.endif

.if ${MK_CXX} != "no"
_gperf=		gnu/usr.bin/gperf
.endif

.if ${MK_GROFF} != "no"
_groff=		gnu/usr.bin/groff
.endif

.if ${BOOTSTRAPPING} < 800022
_ar=		usr.bin/ar
.endif

.if ${BOOTSTRAPPING} < 800013
_mklocale=	usr.bin/mklocale
.endif

.if ${BOOTSTRAPPING} < 900002
_sed=		usr.bin/sed
.endif

.if ${BOOTSTRAPPING} < 900006
_lex=		usr.bin/lex
.endif

.if ${BOOTSTRAPPING} < 1000013
_yacc=		lib/liby \
		usr.bin/yacc
.endif

.if ${BOOTSTRAPPING} < 1000026
_nmtree=	lib/libnetbsd \
		usr.sbin/nmtree
.endif

.if ${BOOTSTRAPPING} < 1000027
_cat=		bin/cat
.endif

.if ${BOOTSTRAPPING} >= 900040 && ${BOOTSTRAPPING} < 900041
_awk=		usr.bin/awk
.endif

.if ${MK_BSNMP} != "no" && !exists(/usr/sbin/gensnmptree)
_gensnmptree=	usr.sbin/bsnmpd/gensnmptree
.endif

.if ${MK_CLANG} != "no"
_clang_tblgen= \
	lib/clang/libllvmsupport \
	lib/clang/libllvmtablegen \
	usr.bin/clang/tblgen \
	usr.bin/clang/clang-tblgen
.endif

# dtrace tools are required for older bootstrap env and cross-build
.if ${MK_CDDL} != "no" && \
    ((${BOOTSTRAPPING} < 800038 && \
          !(${BOOTSTRAPPING} >= 700112 && ${BOOTSTRAPPING} < 799999)) \
      || (${MACHINE} != ${TARGET} || ${MACHINE_ARCH} != ${TARGET_ARCH}))
_dtrace_tools= cddl/usr.bin/sgsmsg cddl/lib/libctf lib/libelf \
    lib/libdwarf cddl/usr.bin/ctfconvert cddl/usr.bin/ctfmerge
.endif

# Default to building the BSDL DTC, but build the GPL one if users explicitly
# request it.
_dtc= usr.bin/dtc
.if ${MK_GPL_DTC} != "no"
_dtc= gnu/usr.bin/dtc
.endif

.if ${MK_KERBEROS} != "no"
_kerberos5_bootstrap_tools= \
	kerberos5/tools/make-roken \
	kerberos5/lib/libroken \
	kerberos5/lib/libvers \
	kerberos5/tools/asn1_compile \
	kerberos5/tools/slc
.endif

#	Please document (add comment) why something is in 'bootstrap-tools'.
#	Try to bound the building of the bootstrap-tool to just the
#	FreeBSD versions that need the tool built at this stage of the build.
bootstrap-tools:
.for _tool in \
    ${_clang_tblgen} \
    ${_kerberos5_bootstrap_tools} \
    ${_dtrace_tools} \
    ${_strfile} \
    ${_gperf} \
    ${_groff} \
    ${_ar} \
    ${_dtc} \
    ${_awk} \
    ${_cat} \
    usr.bin/lorder \
    usr.bin/makewhatis \
    ${_mklocale} \
    usr.bin/rpcgen \
    ${_sed} \
    ${_yacc} \
    ${_lex} \
    lib/libmd \
    usr.bin/xinstall \
    ${_gensnmptree} \
    usr.sbin/config \
    ${_nmtree}
	${_+_}@${ECHODIR} "===> ${_tool} (obj,depend,all,install)"; \
		cd ${.CURDIR}/${_tool}; \
		${MAKE} DIRPRFX=${_tool}/ obj; \
		${MAKE} DIRPRFX=${_tool}/ depend; \
		${MAKE} DIRPRFX=${_tool}/ all; \
		${MAKE} DIRPRFX=${_tool}/ DESTDIR=${MAKEOBJDIRPREFIX}/legacy install
.endfor

#
# build-tools: Build special purpose build tools
#
.if defined(MODULES_WITH_WORLD) && exists(${KERNSRCDIR}/modules)
_aicasm= sys/modules/aic7xxx/aicasm
.endif

.if !defined(NO_SHARE)
_share=	share/syscons/scrnmaps
.endif

.if ${MK_GCC} != "no"
_gcc_tools= gnu/usr.bin/cc/cc_tools
.endif

.if ${MK_RESCUE} != "no"
_rescue= rescue/rescue
.endif

build-tools:
.for _tool in \
    bin/csh \
    bin/sh \
    ${_rescue} \
    ${LOCAL_TOOL_DIRS} \
    lib/ncurses/ncurses \
    lib/ncurses/ncursesw \
    ${_share} \
    ${_aicasm} \
    usr.bin/awk \
    lib/libmagic \
    usr.bin/mkesdb_static \
    usr.bin/mkcsmapper_static
	${_+_}@${ECHODIR} "===> ${_tool} (obj,build-tools)"; \
		cd ${.CURDIR}/${_tool}; \
		${MAKE} DIRPRFX=${_tool}/ obj; \
		${MAKE} DIRPRFX=${_tool}/ build-tools
.endfor
.for _tool in \
    ${_gcc_tools}
	${_+_}@${ECHODIR} "===> ${_tool} (obj,depend,all)"; \
		cd ${.CURDIR}/${_tool}; \
		${MAKE} DIRPRFX=${_tool}/ obj; \
		${MAKE} DIRPRFX=${_tool}/ depend; \
		${MAKE} DIRPRFX=${_tool}/ all
.endfor

#
# cross-tools: Build cross-building tools
#
.if ${TARGET_ARCH} != ${MACHINE_ARCH} || ${BOOTSTRAPPING} < 800035
.if ${TARGET_ARCH} == "amd64" || ${TARGET_ARCH} == "i386"
_btxld=		usr.sbin/btxld
.endif
.endif
.if ${TARGET_ARCH} != ${MACHINE_ARCH}
.if ${MK_RESCUE} != "no" || defined(RELEASEDIR)
_crunchide=	usr.sbin/crunch/crunchide
.endif
.if ${TARGET_ARCH} == "i386" && defined(RELEASEDIR)
_kgzip=		usr.sbin/kgzip
.endif
.endif

.if ${MK_BINUTILS} != "no"
_binutils=	gnu/usr.bin/binutils
.endif

.if ${MK_CLANG} != "no" && (${MK_CLANG_IS_CC} != "no" || ${CC:T:Mclang} == "clang")
_clang=		usr.bin/clang
_clang_libs=	lib/clang
.endif

.if ${MK_GCC} != "no" && (${MK_CLANG_IS_CC} == "no" || ${TARGET} == "pc98")
_cc=		gnu/usr.bin/cc
.endif

cross-tools:
.for _tool in \
    ${_clang_libs} \
    ${_clang} \
    ${_binutils} \
    ${_cc} \
    usr.bin/xlint/lint1 usr.bin/xlint/lint2 usr.bin/xlint/xlint \
    ${_btxld} \
    ${_crunchide} \
    ${_kgzip}
	${_+_}@${ECHODIR} "===> ${_tool} (obj,depend,all,install)"; \
		cd ${.CURDIR}/${_tool}; \
		${MAKE} DIRPRFX=${_tool}/ obj; \
		${MAKE} DIRPRFX=${_tool}/ depend; \
		${MAKE} DIRPRFX=${_tool}/ all; \
		${MAKE} DIRPRFX=${_tool}/ DESTDIR=${MAKEOBJDIRPREFIX} install
.endfor

#
# hierarchy - ensure that all the needed directories are present
#
hierarchy hier:
.if defined(NO_ROOT)
	cd ${.CURDIR}/etc; ${MAKE} LOCAL_MTREE=${LOCAL_MTREE} \
	    -DNO_ROOT METALOG=${METALOG} distrib-dirs
.else
	cd ${.CURDIR}/etc; ${MAKE} LOCAL_MTREE=${LOCAL_MTREE} distrib-dirs
.endif

#
# libraries - build all libraries, and install them under ${DESTDIR}.
#
# The list of libraries with dependents (${_prebuild_libs}) and their
# interdependencies (__L) are built automatically by the
# ${.CURDIR}/tools/make_libdeps.sh script.
#
libraries:
	cd ${.CURDIR}; \
	    ${MAKE} -f Makefile.inc1 _prereq_libs; \
	    ${MAKE} -f Makefile.inc1 _startup_libs; \
	    ${MAKE} -f Makefile.inc1 _prebuild_libs; \
	    ${MAKE} -f Makefile.inc1 _generic_libs;

#
# static libgcc.a prerequisite for shared libc
#
_prereq_libs= gnu/lib/libssp/libssp_nonshared gnu/lib/libgcc lib/libcompiler_rt

# These dependencies are not automatically generated:
#
# gnu/lib/csu, gnu/lib/libgcc, lib/csu and lib/libc must be built before
# all shared libraries for ELF.
#
_startup_libs=	gnu/lib/csu
.if exists(${.CURDIR}/lib/csu/${MACHINE_ARCH}-elf)
_startup_libs+=	lib/csu/${MACHINE_ARCH}-elf
.elif exists(${.CURDIR}/lib/csu/${MACHINE_ARCH})
_startup_libs+=	lib/csu/${MACHINE_ARCH}
.else
_startup_libs+=	lib/csu/${MACHINE_CPUARCH}
.endif
_startup_libs+=	gnu/lib/libgcc
_startup_libs+=	lib/libcompiler_rt
_startup_libs+=	lib/libc
.if ${MK_LIBCPLUSPLUS} != "no"
_startup_libs+=	lib/libcxxrt
.endif

gnu/lib/libgcc__L: lib/libc__L
.if ${MK_LIBCPLUSPLUS} != "no"
lib/libcxxrt__L: gnu/lib/libgcc__L
.endif

_prebuild_libs=	${_kerberos5_lib_libasn1} \
		${_kerberos5_lib_libhdb} \
		${_kerberos5_lib_libheimbase} \
		${_kerberos5_lib_libheimntlm} \
		${_kerberos5_lib_libheimsqlite} \
		${_kerberos5_lib_libheimipcc} \
		${_kerberos5_lib_libhx509} ${_kerberos5_lib_libkrb5} \
		${_kerberos5_lib_libroken} \
		${_kerberos5_lib_libwind} \
		${_lib_atf_libatf_c} \
		lib/libbz2 ${_libcom_err} lib/libcrypt \
		lib/libexpat \
		${_lib_libgssapi} ${_lib_libipx} \
		lib/libkiconv lib/libkvm lib/liblzma lib/libmd \
		lib/ncurses/ncurses lib/ncurses/ncursesw \
		lib/libopie lib/libpam ${_lib_libthr} \
		lib/libradius lib/libsbuf lib/libtacplus \
		${_cddl_lib_libumem} ${_cddl_lib_libnvpair} \
		${_cddl_lib_libzfs_core} \
		lib/libutil ${_lib_libypclnt} lib/libz lib/msun \
		${_secure_lib_libcrypto} ${_secure_lib_libssh} \
		${_secure_lib_libssl}

.if ${MK_ATF} != "no"
_lib_atf_libatf_c=	lib/atf/libatf-c
.endif

.if ${MK_LIBTHR} != "no"
_lib_libthr=	lib/libthr
.endif

.if ${MK_OFED} != "no"
_ofed_lib=	contrib/ofed/usr.lib/
.endif

_generic_libs=	${_cddl_lib} gnu/lib ${_kerberos5_lib} lib ${_secure_lib} usr.bin/lex/lib ${_ofed_lib}
.for _DIR in ${LOCAL_LIB_DIRS}
.if exists(${.CURDIR}/${_DIR}/Makefile)
_generic_libs+= ${_DIR}
.endif
.endfor

lib/libopie__L lib/libtacplus__L: lib/libmd__L

.if ${MK_CDDL} != "no"
_cddl_lib_libumem= cddl/lib/libumem
_cddl_lib_libnvpair= cddl/lib/libnvpair
_cddl_lib_libzfs_core= cddl/lib/libzfs_core
_cddl_lib= cddl/lib
cddl/lib/libzfs_core__L: cddl/lib/libnvpair__L
.endif

.if ${MK_CRYPT} != "no"
.if ${MK_OPENSSL} != "no"
_secure_lib_libcrypto= secure/lib/libcrypto
_secure_lib_libssl= secure/lib/libssl
lib/libradius__L secure/lib/libssl__L: secure/lib/libcrypto__L
.if ${MK_OPENSSH} != "no"
_secure_lib_libssh= secure/lib/libssh
secure/lib/libssh__L: lib/libz__L secure/lib/libcrypto__L lib/libcrypt__L
.if ${MK_KERBEROS_SUPPORT} != "no"
secure/lib/libssh__L: lib/libgssapi__L kerberos5/lib/libkrb5__L \
    kerberos5/lib/libhx509__L kerberos5/lib/libasn1__L lib/libcom_err__L \
    lib/libmd__L kerberos5/lib/libroken__L
.endif
.endif
.endif
_secure_lib=	secure/lib
.endif

.if ${MK_KERBEROS} != "no"
kerberos5/lib/libasn1__L: lib/libcom_err__L kerberos5/lib/libroken__L
kerberos5/lib/libhdb__L: kerberos5/lib/libasn1__L lib/libcom_err__L \
    kerberos5/lib/libkrb5__L kerberos5/lib/libroken__L \
    kerberos5/lib/libwind__L kerberos5/lib/libheimsqlite__L 
kerberos5/lib/libheimntlm__L: secure/lib/libcrypto__L kerberos5/lib/libkrb5__L \
    kerberos5/lib/libroken__L lib/libcom_err__L
kerberos5/lib/libhx509__L: kerberos5/lib/libasn1__L lib/libcom_err__L \
    secure/lib/libcrypto__L kerberos5/lib/libroken__L kerberos5/lib/libwind__L
kerberos5/lib/libkrb5__L: kerberos5/lib/libasn1__L lib/libcom_err__L \
    lib/libcrypt__L secure/lib/libcrypto__L kerberos5/lib/libhx509__L \
    kerberos5/lib/libroken__L kerberos5/lib/libwind__L \
    kerberos5/lib/libheimbase__L kerberos5/lib/libheimipcc__L
kerberos5/lib/libroken__L: lib/libcrypt__L
kerberos5/lib/libwind__L: kerberos5/lib/libroken__L lib/libcom_err__L
kerberos5/lib/libheimbase__L: lib/libthr__L
kerberos5/lib/libheimipcc__L: kerberos5/lib/libroken__L kerberos5/lib/libheimbase__L lib/libthr__L
kerberos5/lib/libheimsqlite__L: lib/libthr__L
.endif

.if ${MK_GSSAPI} != "no"
_lib_libgssapi=	lib/libgssapi
.endif

.if ${MK_IPX} != "no"
_lib_libipx=	lib/libipx
.endif

.if ${MK_KERBEROS} != "no"
_kerberos5_lib=	kerberos5/lib
_kerberos5_lib_libasn1= kerberos5/lib/libasn1
_kerberos5_lib_libhdb= kerberos5/lib/libhdb
_kerberos5_lib_libheimbase= kerberos5/lib/libheimbase
_kerberos5_lib_libkrb5= kerberos5/lib/libkrb5
_kerberos5_lib_libhx509= kerberos5/lib/libhx509
_kerberos5_lib_libroken= kerberos5/lib/libroken
_kerberos5_lib_libheimntlm= kerberos5/lib/libheimntlm
_kerberos5_lib_libheimsqlite= kerberos5/lib/libheimsqlite
_kerberos5_lib_libheimipcc= kerberos5/lib/libheimipcc
_kerberos5_lib_libwind= kerberos5/lib/libwind
_libcom_err= lib/libcom_err
.endif

.if ${MK_NIS} != "no"
_lib_libypclnt=	lib/libypclnt
.endif

.if ${MK_OPENSSL} == "no"
lib/libradius__L: lib/libmd__L
.endif

.for _lib in ${_prereq_libs}
${_lib}__PL: .PHONY
.if exists(${.CURDIR}/${_lib})
	${_+_}@${ECHODIR} "===> ${_lib} (obj,depend,all,install)"; \
		cd ${.CURDIR}/${_lib}; \
		${MAKE} DIRPRFX=${_lib}/ obj; \
		${MAKE} DIRPRFX=${_lib}/ depend; \
		${MAKE} -DNO_PROFILE -DNO_PIC DIRPRFX=${_lib}/ all; \
		${MAKE} -DNO_PROFILE -DNO_PIC DIRPRFX=${_lib}/ install
.endif
.endfor

.for _lib in ${_startup_libs} ${_prebuild_libs:Nlib/libpam} ${_generic_libs}
${_lib}__L: .PHONY
.if exists(${.CURDIR}/${_lib})
	${_+_}@${ECHODIR} "===> ${_lib} (obj,depend,all,install)"; \
		cd ${.CURDIR}/${_lib}; \
		${MAKE} DIRPRFX=${_lib}/ obj; \
		${MAKE} DIRPRFX=${_lib}/ depend; \
		${MAKE} DIRPRFX=${_lib}/ all; \
		${MAKE} DIRPRFX=${_lib}/ install
.endif
.endfor

# libpam is special: we need to build static PAM modules before
# static PAM library, and dynamic PAM library before dynamic PAM
# modules.
lib/libpam__L: .PHONY
	${_+_}@${ECHODIR} "===> lib/libpam (obj,depend,all,install)"; \
		cd ${.CURDIR}/lib/libpam; \
		${MAKE} DIRPRFX=lib/libpam/ obj; \
		${MAKE} DIRPRFX=lib/libpam/ depend; \
		${MAKE} DIRPRFX=lib/libpam/ -D_NO_LIBPAM_SO_YET all; \
		${MAKE} DIRPRFX=lib/libpam/ -D_NO_LIBPAM_SO_YET install

_prereq_libs: ${_prereq_libs:S/$/__PL/}
_startup_libs: ${_startup_libs:S/$/__L/}
_prebuild_libs: ${_prebuild_libs:S/$/__L/}
_generic_libs: ${_generic_libs:S/$/__L/}

.for __target in all clean cleandepend cleandir depend includes obj
.for entry in ${SUBDIR}
${entry}.${__target}__D: .PHONY
	${_+_}@if test -d ${.CURDIR}/${entry}.${MACHINE_ARCH}; then \
		${ECHODIR} "===> ${DIRPRFX}${entry}.${MACHINE_ARCH} (${__target})"; \
		edir=${entry}.${MACHINE_ARCH}; \
		cd ${.CURDIR}/$${edir}; \
	else \
		${ECHODIR} "===> ${DIRPRFX}${entry} (${__target})"; \
		edir=${entry}; \
		cd ${.CURDIR}/$${edir}; \
	fi; \
	${MAKE} ${__target} DIRPRFX=${DIRPRFX}$${edir}/
.endfor
par-${__target}: ${SUBDIR:S/$/.${__target}__D/}
.endfor

.include <bsd.subdir.mk>

.if make(check-old) || make(check-old-dirs) || \
    make(check-old-files) || make(check-old-libs) || \
    make(delete-old) || make(delete-old-dirs) || \
    make(delete-old-files) || make(delete-old-libs)

#
# check for / delete old files section
#

.include "ObsoleteFiles.inc"

OLD_LIBS_MESSAGE="Please be sure no application still uses those libraries, \
else you can not start such an application. Consult UPDATING for more \
information regarding how to cope with the removal/revision bump of a \
specific library."

.if !defined(BATCH_DELETE_OLD_FILES)
RM_I=-i
.else
RM_I=-v
.endif

delete-old-files:
	@echo ">>> Removing old files (only deletes safe to delete libs)"
# Ask for every old file if the user really wants to remove it.
# It's annoying, but better safe than sorry.
# NB: We cannot pass the list of OLD_FILES as a parameter because the
# argument list will get too long. Using .for/.endfor make "loops" will make
# the Makefile parser segfault.
	@exec 3<&0; \
	${MAKE} -f ${.CURDIR}/Makefile.inc1 ${.MAKEFLAGS} ${.TARGET} \
	    -V OLD_FILES -V "OLD_FILES:Musr/share/*.gz:R" | xargs -n1 | \
	while read file; do \
		if [ -f "${DESTDIR}/$${file}" -o -L "${DESTDIR}/$${file}" ]; then \
			chflags noschg "${DESTDIR}/$${file}" 2>/dev/null || true; \
			rm ${RM_I} "${DESTDIR}/$${file}" <&3; \
		fi; \
	done
# Remove catpages without corresponding manpages.
	@exec 3<&0; \
	find ${DESTDIR}/usr/share/man/cat* ! -type d | \
	sed -ep -e's:${DESTDIR}/usr/share/man/cat:${DESTDIR}/usr/share/man/man:' | \
	while read catpage; do \
		read manpage; \
		if [ ! -e "$${manpage}" ]; then \
			rm ${RM_I} $${catpage} <&3; \
	        fi; \
	done
	@echo ">>> Old files removed"

check-old-files:
	@echo ">>> Checking for old files"
	@${MAKE} -f ${.CURDIR}/Makefile.inc1 ${.MAKEFLAGS} ${.TARGET} \
	    -V OLD_FILES -V "OLD_FILES:Musr/share/*.gz:R" | xargs -n1 | \
	while read file; do \
		if [ -f "${DESTDIR}/$${file}" -o -L "${DESTDIR}/$${file}" ]; then \
		 	echo "${DESTDIR}/$${file}"; \
		fi; \
	done
# Check for catpages without corresponding manpages.
	@find ${DESTDIR}/usr/share/man/cat* ! -type d | \
	sed -ep -e's:${DESTDIR}/usr/share/man/cat:${DESTDIR}/usr/share/man/man:' | \
	while read catpage; do \
		read manpage; \
		if [ ! -e "$${manpage}" ]; then \
			echo $${catpage}; \
	        fi; \
	done

delete-old-libs:
	@echo ">>> Removing old libraries"
	@echo "${OLD_LIBS_MESSAGE}" | fmt
	@exec 3<&0; \
	${MAKE} -f ${.CURDIR}/Makefile.inc1 ${.MAKEFLAGS} ${.TARGET} \
	    -V OLD_LIBS | xargs -n1 | \
	while read file; do \
		if [ -f "${DESTDIR}/$${file}" -o -L "${DESTDIR}/$${file}" ]; then \
			chflags noschg "${DESTDIR}/$${file}" 2>/dev/null || true; \
			rm ${RM_I} "${DESTDIR}/$${file}" <&3; \
		fi; \
	done
	@echo ">>> Old libraries removed"

check-old-libs:
	@echo ">>> Checking for old libraries"
	@${MAKE} -f ${.CURDIR}/Makefile.inc1 ${.MAKEFLAGS} ${.TARGET} \
	    -V OLD_LIBS | xargs -n1 | \
	while read file; do \
		if [ -f "${DESTDIR}/$${file}" -o -L "${DESTDIR}/$${file}" ]; then \
			echo "${DESTDIR}/$${file}"; \
		fi; \
	done

delete-old-dirs:
	@echo ">>> Removing old directories"
	@${MAKE} -f ${.CURDIR}/Makefile.inc1 ${.MAKEFLAGS} ${.TARGET} \
	    -V OLD_DIRS | xargs -n1 | \
	while read dir; do \
		if [ -d "${DESTDIR}/$${dir}" ]; then \
			rmdir -v "${DESTDIR}/$${dir}" || true; \
		elif [ -L "${DESTDIR}/$${dir}" ]; then \
			echo "${DESTDIR}/$${dir} is a link, please remove everything manually."; \
		fi; \
	done
	@echo ">>> Old directories removed"

check-old-dirs:
	@echo ">>> Checking for old directories"
	@${MAKE} -f ${.CURDIR}/Makefile.inc1 ${.MAKEFLAGS} ${.TARGET} \
	    -V OLD_DIRS | xargs -n1 | \
	while read dir; do \
		if [ -d "${DESTDIR}/$${dir}" ]; then \
			echo "${DESTDIR}/$${dir}"; \
		elif [ -L "${DESTDIR}/$${dir}" ]; then \
			echo "${DESTDIR}/$${dir} is a link, please remove everything manually."; \
		fi; \
	done

delete-old: delete-old-files delete-old-dirs
	@echo "To remove old libraries run '${MAKE} delete-old-libs'."

check-old: check-old-files check-old-libs check-old-dirs
	@echo "To remove old files and directories run '${MAKE} delete-old'."
	@echo "To remove old libraries run '${MAKE} delete-old-libs'."

.endif

#
# showconfig - show build configuration.
#
showconfig:
	@${MAKE} -n -f bsd.own.mk -V dummy -dg1 2>&1 | grep ^MK_ | sort

.if !empty(KRNLOBJDIR) && !empty(KERNCONF)
DTBOUTPUTPATH= ${KRNLOBJDIR}/${KERNCONF}/

.if !defined(FDT_DTS_FILE) || empty(FDT_DTS_FILE)
.if exists(${KERNCONFDIR}/${KERNCONF})
FDT_DTS_FILE!= awk 'BEGIN {FS="="} /^makeoptions[[:space:]]+FDT_DTS_FILE/ {print $$2}' \
	${KERNCONFDIR}/${KERNCONF} ; echo
.endif
.endif

.endif

.if !defined(DTBOUTPUTPATH) || !exists(${DTBOUTPUTPATH})
DTBOUTPUTPATH= ${.CURDIR}
.endif

#
# Build 'standalone' Device Tree Blob
#
builddtb:
	@if [ "${FDT_DTS_FILE}" = "" ]; then \
		echo "ERROR: FDT_DTS_FILE must be specified!"; \
		exit 1; \
	fi;	\
	if [ ! -f ${.CURDIR}/sys/boot/fdt/dts/${FDT_DTS_FILE} ]; then \
		echo "ERROR: Specified DTS file (${FDT_DTS_FILE}) does not \
			exist!"; \
		exit 1;	\
	fi;	\
	if [ "${DTBOUTPUTPATH}" = "${.CURDIR}" ]; then	\
		echo "WARNING: DTB will be placed in the current working \
			directory"; \
	fi
	@PATH=${TMPPATH} \
	dtc -O dtb -o \
	    ${DTBOUTPUTPATH}/`echo ${FDT_DTS_FILE} | cut -d. -f1`.dtb -b 0 \
	    -p 1024 ${.CURDIR}/sys/boot/fdt/dts/${FDT_DTS_FILE}

###############

.if defined(XDEV) && defined(XDEV_ARCH)

.if ${XDEV} == ${MACHINE} && ${XDEV_ARCH} == ${MACHINE_ARCH}
XDEV_CPUTYPE?=${CPUTYPE}
.else
XDEV_CPUTYPE?=${TARGET_CPUTYPE}
.endif

NOFUN=-DNO_FSCHG -DWITHOUT_HTML -DWITHOUT_INFO -DNO_LINT \
	-DWITHOUT_MAN -DWITHOUT_NLS -DNO_PROFILE \
	-DWITHOUT_KERBEROS -DWITHOUT_RESCUE -DNO_WARNS \
	TARGET=${XDEV} TARGET_ARCH=${XDEV_ARCH} \
	CPUTYPE=${XDEV_CPUTYPE}

XDDIR=${XDEV_ARCH}-freebsd
XDTP=/usr/${XDDIR}
CDBENV=MAKEOBJDIRPREFIX=${MAKEOBJDIRPREFIX}/${XDDIR} \
	INSTALL="sh ${.CURDIR}/tools/install.sh"
CDENV= ${CDBENV} \
	_SHLIBDIRPREFIX=${XDDESTDIR} \
	TOOLS_PREFIX=${XDDESTDIR}
CD2CFLAGS=-isystem ${XDDESTDIR}/usr/include -L${XDDESTDIR}/usr/lib \
	-B${XDDESTDIR}/usr/lib
CD2ENV=${CDENV} CC="${CC} ${CD2CFLAGS}" \
	MACHINE=${XDEV} MACHINE_ARCH=${XDEV_ARCH}

CDTMP=	${MAKEOBJDIRPREFIX}/${XDDIR}/${.CURDIR}/tmp
CDMAKE=${CDENV} PATH=${CDTMP}/usr/bin:${PATH} ${MAKE} ${NOFUN}
CD2MAKE=${CD2ENV} PATH=${CDTMP}/usr/bin:${XDTP}/usr/bin:${PATH} ${MAKE} ${NOFUN}
XDDESTDIR=${DESTDIR}${XDTP}
.if !defined(OSREL)
OSREL!= uname -r | sed -e 's/[-(].*//'
.endif

.ORDER: xdev-build xdev-install
xdev: xdev-build xdev-install

.ORDER: _xb-worldtmp _xb-bootstrap-tools _xb-build-tools _xb-cross-tools
xdev-build: _xb-worldtmp _xb-bootstrap-tools _xb-build-tools _xb-cross-tools

_xb-worldtmp:
	mkdir -p ${CDTMP}/usr
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.usr.dist \
	    -p ${CDTMP}/usr >/dev/null

_xb-bootstrap-tools:
.for _tool in \
    ${_clang_tblgen}
	${_+_}@${ECHODIR} "===> ${_tool} (obj,depend,all,install)"; \
	cd ${.CURDIR}/${_tool}; \
	${CDMAKE} DIRPRFX=${_tool}/ obj; \
	${CDMAKE} DIRPRFX=${_tool}/ depend; \
	${CDMAKE} DIRPRFX=${_tool}/ all; \
	${CDMAKE} DIRPRFX=${_tool}/ DESTDIR=${CDTMP} install
.endfor

_xb-build-tools:
	${_+_}@cd ${.CURDIR}; \
	${CDBENV} ${MAKE} -f Makefile.inc1 ${NOFUN} build-tools

_xb-cross-tools:
.for _tool in \
    gnu/usr.bin/binutils \
    gnu/usr.bin/cc \
    usr.bin/ar \
    ${_clang_libs} \
    ${_clang}
	${_+_}@${ECHODIR} "===> xdev ${_tool} (obj,depend,all)"; \
	cd ${.CURDIR}/${_tool}; \
	${CDMAKE} DIRPRFX=${_tool}/ obj; \
	${CDMAKE} DIRPRFX=${_tool}/ depend; \
	${CDMAKE} DIRPRFX=${_tool}/ all
.endfor

_xi-mtree:
	${_+_}@${ECHODIR} "mtree populating ${XDDESTDIR}"
	mkdir -p ${XDDESTDIR}
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.root.dist \
	    -p ${XDDESTDIR} >/dev/null
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.usr.dist \
	    -p ${XDDESTDIR}/usr >/dev/null
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.include.dist \
	    -p ${XDDESTDIR}/usr/include >/dev/null

.ORDER: xdev-build _xi-mtree _xi-cross-tools _xi-includes _xi-libraries _xi-links
xdev-install: xdev-build _xi-mtree _xi-cross-tools _xi-includes _xi-libraries _xi-links

_xi-cross-tools:
	@echo "_xi-cross-tools"
.for _tool in \
    gnu/usr.bin/binutils \
    gnu/usr.bin/cc \
    usr.bin/ar \
    ${_clang}
	${_+_}@${ECHODIR} "===> xdev ${_tool} (install)"; \
	cd ${.CURDIR}/${_tool}; \
	${CDMAKE} DIRPRFX=${_tool}/ install DESTDIR=${XDDESTDIR}
.endfor

_xi-includes:
	${_+_}cd ${.CURDIR}; ${CD2MAKE} -f Makefile.inc1 par-includes \
		DESTDIR=${XDDESTDIR}

_xi-libraries:
	${_+_}cd ${.CURDIR}; ${CD2MAKE} -f Makefile.inc1 libraries \
		DESTDIR=${XDDESTDIR}

_xi-links:
	${_+_}cd ${XDDESTDIR}/usr/bin; \
		for i in *; do \
			ln -sf ../../${XDTP}/usr/bin/$$i \
			    ../../../../usr/bin/${XDDIR}-$$i; \
			ln -sf ../../${XDTP}/usr/bin/$$i \
			    ../../../../usr/bin/${XDDIR}${OSREL}-$$i; \
		done
.else
xdev xdev-build xdev-install:
	@echo "*** Error: Both XDEV and XDEV_ARCH must be defined for \"${.TARGET}\" target"
.endif
